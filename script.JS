// åŠ¨æ€ç”Ÿæˆ Manifest ä»¥æ”¯æŒå•æ–‡ä»¶ PWA
const manifest = {
    "name": "èŠ½èŠ½æœº",
    "short_name": "èŠ½èŠ½æœº",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#ffffff",
    "theme_color": "#ffffff",
    "orientation": "portrait",
    "icons": [
        {
            "src": "https://img.heliar.top/file/1770541813634_æ— æ ‡é¢˜434_20260208170943.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "https://img.heliar.top/file/1770541813634_æ— æ ‡é¢˜434_20260208170943.png",
            "sizes": "512x512",
            "type": "image/png"
        }
    ]
};
const stringManifest = JSON.stringify(manifest);
const blob = new Blob([stringManifest], {type: 'application/manifest+json'});
const manifestURL = URL.createObjectURL(blob);
// ç­‰å¾… DOM åŠ è½½å®Œæˆåå†è®¾ç½® manifest
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function() {
        const manifestLink = document.querySelector('#manifest-link');
        if (manifestLink) {
            manifestLink.setAttribute('href', manifestURL);
        }
    });
} else {
    const manifestLink = document.querySelector('#manifest-link');
    if (manifestLink) {
        manifestLink.setAttribute('href', manifestURL);
    }
}

// iOS 100vh ä¿®å¤ï¼šåŠ¨æ€è®¡ç®—è§†å£é«˜åº¦
function setVh() {
    // è·å–è§†å£é«˜åº¦ï¼Œä¸åŒ…å«æµè§ˆå™¨ UIï¼ˆå¦‚ Safari åº•éƒ¨æ ï¼‰
    let vh = window.innerHeight + 'px';
    document.documentElement.style.setProperty('--vh', vh);
}
// åˆå§‹åŒ–å¹¶ç›‘å¬ resize
setVh();
window.addEventListener('resize', setVh);

// åˆå§‹åŒ–DEXieæ•°æ®åº“
const db = new Dexie('DesktopDB');
// ç‰ˆæœ¬å‡çº§ï¼šå¢åŠ  lorebooks è¡¨
db.version(1).stores({
    dexiData: 'key, value'
});
db.version(2).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name' // æ–°å¢ä¸–ç•Œä¹¦è¡¨ï¼šidè‡ªå¢ï¼Œnameç´¢å¼•
});
db.version(3).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type' // æ–°å¢è§’è‰²è¡¨ï¼štype ç”¨äºåŒºåˆ† Char/NPC/User
});
db.version(4).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type',
    sticker_categories: '++id, name'
});
db.version(5).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type',
    sticker_categories: '++id, name',
    moments: '++id, userId, time, ownerUserId' // æ–°å¢æœ‹å‹åœˆè¡¨ (ownerUserId ç”¨äºè´¦å·éš”ç¦»)
});
db.version(6).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type',
    sticker_categories: '++id, name',
    moments: '++id, userId, time, ownerUserId',
    friend_requests: '++id, fromCharId, toAccountId, status, time' // æ–°å¢å¥½å‹ç”³è¯·è¡¨
});
// ç‰ˆæœ¬71ï¼šå…¼å®¹å·²å­˜åœ¨çš„é«˜ç‰ˆæœ¬æ•°æ®åº“
db.version(71).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type',
    sticker_categories: '++id, name',
    moments: '++id, userId, time, ownerUserId',
    friend_requests: '++id, fromCharId, toAccountId, status, time'
});
// ç‰ˆæœ¬72ï¼šæ·»åŠ ç¾¤èŠè¡¨
db.version(72).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type',
    sticker_categories: '++id, name',
    moments: '++id, userId, time, ownerUserId',
    friend_requests: '++id, fromCharId, toAccountId, status, time',
    group_chats: '++id, name, ownerAccountId, created_at' // ç¾¤èŠè¡¨ï¼šidè‡ªå¢ï¼Œåç§°ï¼Œåˆ›å»ºè€…è´¦å·IDï¼Œåˆ›å»ºæ—¶é—´
});
// ç‰ˆæœ¬73ï¼šæ·»åŠ ç”µè¯è®°å½•å’ŒçŸ­ä¿¡è®°å½•è¡¨ï¼ˆä»localStorageè¿ç§»åˆ°IndexedDBï¼‰
db.version(73).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type',
    sticker_categories: '++id, name',
    moments: '++id, userId, time, ownerUserId',
    friend_requests: '++id, fromCharId, toAccountId, status, time',
    group_chats: '++id, name, ownerAccountId, created_at',
    phone_recents: '++id, accountId, charId, time, type', // ç”µè¯è®°å½•ï¼šaccountIdè´¦å·éš”ç¦»ï¼ŒcharIdè§’è‰²IDï¼Œtimeæ—¶é—´ï¼Œtypeç±»å‹(missed/incoming/outgoing)
    sms_messages: '++id, accountId, charId, time, read'   // çŸ­ä¿¡è®°å½•ï¼šaccountIdè´¦å·éš”ç¦»ï¼ŒcharIdè§’è‰²IDï¼Œtimeæ—¶é—´ï¼Œreadæ˜¯å¦å·²è¯»
});
// ç‰ˆæœ¬74ï¼šæ·»åŠ èŠå¤©æ€»ç»“è¡¨ï¼ˆç”¨äºAIè‡ªåŠ¨æ€»ç»“åŠŸèƒ½ï¼‰
db.version(74).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type',
    sticker_categories: '++id, name',
    moments: '++id, userId, time, ownerUserId',
    friend_requests: '++id, fromCharId, toAccountId, status, time',
    group_chats: '++id, name, ownerAccountId, created_at',
    phone_recents: '++id, accountId, charId, time, type',
    sms_messages: '++id, accountId, charId, time, read',
    chat_summaries: '++id, accountId, chatType, chatId, time' // èŠå¤©æ€»ç»“è¡¨ï¼šaccountIdè´¦å·éš”ç¦»ï¼ŒchatType(private/group)ï¼ŒchatIdè§’è‰²/ç¾¤èŠIDï¼Œtimeæ€»ç»“æ—¶é—´
});

// ç‰ˆæœ¬75ï¼šæ·»åŠ å¤´åƒåº“è¡¨
db.version(75).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type',
    sticker_categories: '++id, name',
    moments: '++id, userId, time, ownerUserId',
    friend_requests: '++id, fromCharId, toAccountId, status, time',
    group_chats: '++id, name, ownerAccountId, created_at',
    phone_recents: '++id, accountId, charId, time, type',
    sms_messages: '++id, accountId, charId, time, read',
    chat_summaries: '++id, accountId, chatType, chatId, time',
    avatar_library: '++id, category, time' // å¤´åƒåº“è¡¨ï¼šcategoryä¸ºåˆ†ç±»åï¼Œtimeæ·»åŠ æ—¶é—´
});

// ç‰ˆæœ¬76ï¼šæ·»åŠ å¤´åƒåˆ†ç±»è¡¨
db.version(76).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type',
    sticker_categories: '++id, name',
    moments: '++id, userId, time, ownerUserId',
    friend_requests: '++id, fromCharId, toAccountId, status, time',
    group_chats: '++id, name, ownerAccountId, created_at',
    phone_recents: '++id, accountId, charId, time, type',
    sms_messages: '++id, accountId, charId, time, read',
    chat_summaries: '++id, accountId, chatType, chatId, time',
    avatar_library: '++id, category, time',
    avatar_categories: '++id, name, order, time'
});

// ç‰ˆæœ¬77ï¼šå¤´åƒåº“å¢åŠ tagå­—æ®µï¼Œå­åˆ†ç±»å¢åŠ parentCategoryå­—æ®µ
db.version(77).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type',
    sticker_categories: '++id, name',
    moments: '++id, userId, time, ownerUserId',
    friend_requests: '++id, fromCharId, toAccountId, status, time',
    group_chats: '++id, name, ownerAccountId, created_at',
    phone_recents: '++id, accountId, charId, time, type',
    sms_messages: '++id, accountId, charId, time, read',
    chat_summaries: '++id, accountId, chatType, chatId, time',
    avatar_library: '++id, category, tag, time', // category=single/couple, tag=å­åˆ†ç±»å
    avatar_categories: '++id, name, parentCategory, order, time' // å­åˆ†ç±»æ ‡ç­¾ï¼šparentCategory=single/couple
});

// ç‰ˆæœ¬78ï¼šä¿®å¤chat_summariesè¡¨çš„å¤åˆç´¢å¼•
db.version(78).stores({
    dexiData: 'key, value',
    lorebooks: '++id, name',
    characters: '++id, name, type',
    sticker_categories: '++id, name',
    moments: '++id, userId, time, ownerUserId',
    friend_requests: '++id, fromCharId, toAccountId, status, time',
    group_chats: '++id, name, ownerAccountId, created_at',
    phone_recents: '++id, accountId, charId, time, type',
    sms_messages: '++id, accountId, charId, time, read',
    chat_summaries: '++id, [accountId+chatType+chatId], accountId, chatType, chatId, time', // æ·»åŠ å¤åˆç´¢å¼•ç”¨äºå¿«é€ŸæŸ¥è¯¢
    avatar_library: '++id, category, tag, time',
    avatar_categories: '++id, name, parentCategory, order, time'
});

// ğŸ“¦ æ•°æ®è¿ç§»ï¼šå°† localStorage ä¸­çš„ç”µè¯å’ŒçŸ­ä¿¡è®°å½•è¿ç§»åˆ° IndexedDB
async function migratePhoneAndSmsToIndexedDB() {
    const migrationKey = 'phone_sms_migrated_to_indexeddb';
    if (localStorage.getItem(migrationKey) === 'true') {
        return; // å·²ç»è¿ç§»è¿‡
    }
    
    console.log('[Migration] å¼€å§‹è¿ç§»ç”µè¯å’ŒçŸ­ä¿¡è®°å½•åˆ° IndexedDB...');
    
    // è·å–é»˜è®¤è´¦å·ID
    const currentAccountId = localStorage.getItem('current_my_char_id') || '1';
    
    // è¿ç§»ç”µè¯è®°å½•
    try {
        const phoneRecents = JSON.parse(localStorage.getItem('phone_recents') || '[]');
        if (phoneRecents.length > 0) {
            console.log(`[Migration] è¿ç§» ${phoneRecents.length} æ¡ç”µè¯è®°å½•...`);
            for (const record of phoneRecents) {
                await db.phone_recents.add({
                    accountId: currentAccountId,
                    charId: null, // æ—§æ•°æ®æ²¡æœ‰ charId
                    name: record.name,
                    number: record.number,
                    time: record.time || Date.now(),
                    type: record.type || 'missed',
                    isBlocked: record.isBlocked || false
                });
            }
            // æ¸…ç†æ—§æ•°æ®
            localStorage.removeItem('phone_recents');
            console.log('[Migration] âœ… ç”µè¯è®°å½•è¿ç§»å®Œæˆ');
        }
    } catch (e) {
        console.error('[Migration] âŒ ç”µè¯è®°å½•è¿ç§»å¤±è´¥:', e);
    }
    
    // è¿ç§»çŸ­ä¿¡è®°å½•
    try {
        const smsMessages = JSON.parse(localStorage.getItem('sms_messages') || '[]');
        if (smsMessages.length > 0) {
            console.log(`[Migration] è¿ç§» ${smsMessages.length} æ¡çŸ­ä¿¡è®°å½•...`);
            for (const msg of smsMessages) {
                await db.sms_messages.add({
                    accountId: currentAccountId,
                    charId: null, // æ—§æ•°æ®æ²¡æœ‰ charId
                    sender: msg.sender,
                    number: msg.number,
                    content: msg.content || msg.message,
                    time: msg.time || msg.timestamp || Date.now(),
                    read: msg.read !== false,
                    type: msg.type || 'received',
                    isBlocked: msg.isBlocked || false,
                    receiverName: msg.receiverName,
                    receiverId: msg.receiverId
                });
            }
            // æ¸…ç†æ—§æ•°æ®
            localStorage.removeItem('sms_messages');
            console.log('[Migration] âœ… çŸ­ä¿¡è®°å½•è¿ç§»å®Œæˆ');
        }
    } catch (e) {
        console.error('[Migration] âŒ çŸ­ä¿¡è®°å½•è¿ç§»å¤±è´¥:', e);
    }
    
    // æ ‡è®°è¿ç§»å®Œæˆ
    localStorage.setItem(migrationKey, 'true');
    console.log('[Migration] ğŸ‰ ç”µè¯å’ŒçŸ­ä¿¡æ•°æ®è¿ç§»å®Œæˆ');
}

        let currentSelectIcon = '';
        let currentCharacterType = 'char'; // é»˜è®¤ä¸º char
        let editingCharId = null; // å½“å‰ç¼–è¾‘çš„è§’è‰²ID
        let currentChatCharId = null; // å½“å‰èŠå¤©å¯¹è±¡ID
        let currentChatUserId = null; // å½“å‰èŠå¤©ä½¿ç”¨çš„ User ID (ä¸´æ—¶ç¼“å­˜)
        let currentMyCharId = localStorage.getItem('current_my_char_id'); // å½“å‰ç™»å½•çš„â€œæˆ‘â€çš„è§’è‰²ID

        // æ¨¡æ‹Ÿç”¨æˆ·IDï¼Œå®é™…é¡¹ç›®ä¸­å¯èƒ½æ¥è‡ªç™»å½•
        let currentUserId = localStorage.getItem('user_id');
        if (!currentUserId) {
            currentUserId = 'user_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('user_id', currentUserId);
        }
        
        // å…¨å±€å®šæ—¶å™¨å˜é‡
        let notifTimer = null;
        let autoChatTimer = null; // ä¸»åŠ¨èŠå¤©å®šæ—¶å™¨
        const autoChatLocks = new Set(); // å­˜å‚¨æ­£åœ¨è¿›è¡Œä¸»åŠ¨èŠå¤©çš„ charIdï¼Œé˜²æ­¢å¹¶å‘è§¦å‘
        const autoMomentsLocks = new Set(); // å­˜å‚¨æ­£åœ¨ç”Ÿæˆæœ‹å‹åœˆçš„ charIdï¼Œé˜²æ­¢å¹¶å‘
        const lastMomentsPostTime = new Map(); // è®°å½•æ¯ä¸ªè§’è‰²ä¸Šæ¬¡å‘æœ‹å‹åœˆçš„æ—¶é—´
        let deviceBatteryLevel = null; // ç”¨æˆ·è®¾å¤‡çœŸå®ç”µé‡ (0-100)
        let deviceBatteryCharging = false; // æ˜¯å¦æ­£åœ¨å……ç”µ
        let lowBatteryShownThisSession = new Set(); // è®°å½•æœ¬æ¬¡ä¼šè¯å·²æé†’è¿‡çš„èŠå¤©ï¼Œé¿å…é‡å¤å¼¹
        // è®°å½•å·²çŸ¥çš„é€šçŸ¥IDï¼Œç”¨äºåˆ¤æ–­æ–°æ¶ˆæ¯
        let knownNotifIds = new Set();
        let isFirstLoad = true;
        // ç¼“å­˜æœ€æ–°ä¸€æ¡é€šçŸ¥ï¼Œç”¨äºå®šæ—¶å¼¹çª—æ–‡æ¡ˆ
        let latestNotification = null;

        // --- èŠå¤©äº¤äº’å…¨å±€å˜é‡ ---
        let longPressTimer = null;
        let isLongPress = false;
        let activeMsgIndex = -1; // å½“å‰æ“ä½œçš„æ¶ˆæ¯ç´¢å¼•
        let isSelectionMode = false;
        let selectedIndices = new Set(); // é€‰ä¸­çš„æ¶ˆæ¯ç´¢å¼•é›†åˆ

        // å…¨å±€å˜é‡ï¼šè¡¨æƒ…åŒ…ç®¡ç†
        let currentStickerCategoryId = null;

        // æ‰‹åŠ¨è§¦å‘æ¨é€è®¢é˜…ï¼ˆæ–°å¢å‡½æ•°ï¼‰
        async function manualSubscribePush() {
            console.log('[Manual] æ‰‹åŠ¨è§¦å‘æ¨é€è®¢é˜…...');
            showDebugToast('æ­£åœ¨æ³¨å†Œæ¨é€...', true);
            
            try {
                await registerServiceWorkerAndSubscribe();
                alert('âœ… æ¨é€è®¢é˜…æˆåŠŸï¼è¯·æŸ¥çœ‹è¯Šæ–­é¢æ¿ç¡®è®¤çŠ¶æ€ã€‚');
            } catch (err) {
                console.error('[Manual] è®¢é˜…å¤±è´¥:', err);
                alert('âŒ è®¢é˜…å¤±è´¥: ' + err.message);
            }
        }

        // é¡µé¢åŠ è½½åˆå§‹åŒ–
        window.onload = async function() {
            checkFirstVisitDisclaimer(); // é¦–æ¬¡è®¿é—®å¼¹å‡ºå…è´£å£°æ˜
            checkUpdateNotice(); // æ›´æ–°å…¬å‘Šï¼ˆæ¯ä¸ªç‰ˆæœ¬åªå¼¹ä¸€æ¬¡ï¼‰
            await restoreDesktopOrder(); // ä¼˜å…ˆæ¢å¤æ¡Œé¢å›¾æ ‡é¡ºåº
            await restoreSetting(); // å¼‚æ­¥æ¢å¤DEXieæ•°æ®
            await migrateAccountData(); // è¿ç§»è´¦å·éš”ç¦»æ•°æ®
            await migratePhoneAndSmsToIndexedDB(); // è¿ç§»ç”µè¯å’ŒçŸ­ä¿¡è®°å½•åˆ°IndexedDB
            await loadWardrobeCharacter(); // åŠ è½½è¡£æŸœäººç‰©å½¢è±¡
            initDesktopDrag(); // åˆå§‹åŒ–æ¡Œé¢æ‹–æ‹½
            syncPreview();
            
            // ğŸ”§ é¢„åŠ è½½APIé…ç½®åˆ°å†…å­˜ç¼“å­˜ï¼Œé˜²æ­¢åç»­è¯»å–æ—¶DBå¶å‘è¿”å›ç©º
            try {
                const [urlItem, keyItem, modelItem, tempItem] = await Promise.all([
                    db.dexiData.get('aiBaseUrl'),
                    db.dexiData.get('aiApiKey'),
                    db.dexiData.get('aiCurrentModel'),
                    db.dexiData.get('aiTemperature')
                ]);
                if (urlItem?.value || keyItem?.value || modelItem?.value) {
                    _apiConfigCache = {
                        url: urlItem?.value || '',
                        key: keyItem?.value || '',
                        model: modelItem?.value || '',
                        temp: tempItem?.value || '0.7'
                    };
                    console.log('[APIç¼“å­˜] âœ… å·²é¢„åŠ è½½APIé…ç½®åˆ°å†…å­˜');
                }
            } catch (e) {
                console.warn('[APIç¼“å­˜] é¢„åŠ è½½å¤±è´¥:', e.message);
            }
            
            // è¯·æ±‚é€šçŸ¥æƒé™ï¼ˆå°±åƒä½ ä¹‹å‰çš„ç‰ˆæœ¬ï¼‰
            if ('Notification' in window && Notification.permission === 'default') {
                console.log('[é€šçŸ¥] è¯·æ±‚é€šçŸ¥æƒé™...');
                Notification.requestPermission().then(permission => {
                    console.log('[é€šçŸ¥] æƒé™ç»“æœ:', permission);
                    if (permission === 'granted') {
                        showDebugToast('âœ“ é€šçŸ¥æƒé™å·²æˆäºˆ', true);
                    }
                });
            }
            
            // åˆå§‹åŒ–é€šçŸ¥è®¾ç½®
            const notifEnabled = localStorage.getItem('notification_enabled') === 'true';
            document.getElementById('notif-switch').checked = notifEnabled;
            
            // åˆå§‹åŒ–è°ƒè¯•æ¨¡å¼è®¾ç½®
            const debugEnabled = localStorage.getItem('debug_mode_enabled') === 'true';
            document.getElementById('debug-switch').checked = debugEnabled;
            
            // åˆå§‹åŒ–å¼ºåŠ›ä¿æ´»è®¾ç½®
            const keepaliveEnabled = localStorage.getItem('keepalive_enabled') === 'true';
            document.getElementById('keepalive-switch').checked = keepaliveEnabled;
            
            // å¦‚æœä¿æ´»å·²å¼€å¯ï¼Œç­‰å¾…ç”¨æˆ·äº¤äº’åå¯åŠ¨
            if (keepaliveEnabled) {
                console.log('[Init] ä¿æ´»å·²å¯ç”¨ï¼Œç­‰å¾…ç”¨æˆ·äº¤äº’...');
                document.addEventListener('click', function initKeepAlive() {
                    startKeepAlive();
                    document.removeEventListener('click', initKeepAlive);
                }, { once: true });
            }
            
            // åˆå§‹åŒ–é€šçŸ¥è½®è¯¢ (15ç§’æ£€æŸ¥ï¼Œæ›´å¿«å“åº”åç«¯è§¦å‘)
            if (notifEnabled) {
                startNotificationLoop(15);
            }
            
            // âœ… ä¿®å¤ï¼šé¡µé¢åŠ è½½æ—¶ç«‹å³æ³¨å†Œ Service Worker å’Œè®¢é˜…æ¨é€
            // ä¸å†ç­‰å¾… startAutoChatLoopï¼Œè€Œæ˜¯ç«‹å³æ‰§è¡Œ
            if (location.protocol === 'https:' || location.hostname === 'localhost') {
                console.log('[Init] ç«‹å³æ³¨å†Œ Service Worker å’Œè®¢é˜…æ¨é€...');
                await registerServiceWorkerAndSubscribe();
            } else {
                console.warn('[Init] å½“å‰ç¯å¢ƒä¸æ”¯æŒ Service Worker (éœ€è¦ HTTPS æˆ– localhost)');
            }
            
            // å¯åŠ¨ä¸»åŠ¨èŠå¤©æ£€æµ‹ (æ¯åˆ†é’Ÿä¸€æ¬¡)
            startAutoChatLoop();
            
            // åˆå§‹åŒ–ç”µé‡ç›‘æµ‹
            initBatteryMonitor();
            
            // âœ… è‡ªåŠ¨åˆå§‹åŒ–è”æœºç³»ç»Ÿï¼ˆä¸éœ€è¦æ‰‹åŠ¨æ‰“å¼€è®¾ç½®ï¼‰
            initOnlineSystem();
        }

        // --- çº¯å‰ç«¯æ¨¡å¼ï¼šæ‰€æœ‰æ•°æ®å­˜å‚¨åœ¨æœ¬åœ° ---
        // å·²ç§»é™¤åç«¯ä¾èµ–ï¼Œé€šçŸ¥ã€è§’è‰²ã€èŠå¤©è®°å½•å…¨éƒ¨ä½¿ç”¨ IndexedDB å­˜å‚¨
        console.log('[Config] çº¯å‰ç«¯æ¨¡å¼ï¼šæ— éœ€åç«¯æœåŠ¡');
        console.log('[Config] æ‰€æœ‰æ•°æ®å­˜å‚¨åœ¨æœ¬åœ° IndexedDB');

        // å¯åŠ¨è½®è¯¢
        function startNotificationLoop(seconds) {
            if (notifTimer) clearInterval(notifTimer);

            const loopTask = () => {
                fetchNotifications();
            };
            
            console.log(`[Notification] Polling started, checking every ${seconds}s`);
            showDebugToast(`é€šçŸ¥è½®è¯¢: æ¯${seconds}ç§’æ£€æŸ¥`, true);
            
            loopTask(); // ç«‹å³æ‰§è¡Œä¸€æ¬¡
            notifTimer = setInterval(loopTask, seconds * 1000);
        }

        // åˆ‡æ¢é€šçŸ¥æƒé™
        function toggleNotification(checkbox) {
            const enabled = checkbox.checked;
            localStorage.setItem('notification_enabled', enabled);
            if (enabled) {
                // è¯·æ±‚æµè§ˆå™¨ç³»ç»Ÿé€šçŸ¥æƒé™
                if ("Notification" in window) {
                    Notification.requestPermission().then(permission => {
                        if (permission === "granted") {
                            new Notification("ç³»ç»Ÿé€šçŸ¥å·²å¼€å¯", { body: "å³ä½¿åœ¨åå°ï¼Œæ‚¨ä¹Ÿèƒ½æ”¶åˆ°æ–°æ¶ˆæ¯æé†’äº†~" });
                        } else {
                            alert("è¯·åœ¨æµè§ˆå™¨å¼¹çª—ä¸­ç‚¹å‡»ã€å…è®¸ã€‘ï¼Œå¦åˆ™æ— æ³•æ”¶åˆ°ç³»ç»Ÿé€šçŸ¥å“¦ï¼");
                        }
                    });
                }
                startNotificationLoop(15); // 15ç§’æ£€æŸ¥
            } else {
                if (notifTimer) clearInterval(notifTimer);
                document.getElementById('notif-badge').style.display = 'none';
            }
        }

        // æµ‹è¯•é€šçŸ¥åŠŸèƒ½
        function testNotification() {
            console.log('[Test] Testing notification system...');
            console.log('[Test] Browser supports Notification:', "Notification" in window);
            console.log('[Test] Current permission:', Notification.permission);
            console.log('[Test] Page visibility:', document.visibilityState);
            console.log('[Test] Page hidden:', document.hidden);
            
            if (!("Notification" in window)) {
                alert("ä½ çš„æµè§ˆå™¨ä¸æ”¯æŒç³»ç»Ÿé€šçŸ¥åŠŸèƒ½");
                return;
            }
            
            if (Notification.permission === "denied") {
                alert("é€šçŸ¥æƒé™å·²è¢«æ‹’ç»ï¼Œè¯·åœ¨æµè§ˆå™¨è®¾ç½®ä¸­å…è®¸é€šçŸ¥æƒé™ååˆ·æ–°é¡µé¢");
                return;
            }
            
            if (Notification.permission === "granted") {
                // ç«‹å³å‘é€ç¬¬ä¸€æ¡é€šçŸ¥
                new Notification("æµ‹è¯•é€šçŸ¥", {
                    body: "å¦‚æœä½ èƒ½çœ‹åˆ°è¿™æ¡é€šçŸ¥ï¼Œè¯´æ˜ç³»ç»Ÿé€šçŸ¥åŠŸèƒ½æ­£å¸¸ï¼",
                    icon: 'https://img.heliar.top/file/1770541813634_æ— æ ‡é¢˜434_20260208170943.png'
                });
                showDebugToast("âœ“ ç«‹å³å‘é€é€šçŸ¥ï¼5ç§’åå†å‘ä¸€æ¡", true);
                
                // 5ç§’åå‘é€ç¬¬äºŒæ¡é€šçŸ¥
                setTimeout(() => {
                    new Notification("å»¶è¿Ÿæµ‹è¯•é€šçŸ¥", {
                        body: "è¿™æ˜¯5ç§’åå‘é€çš„é€šçŸ¥ï¼Œå¦‚æœåœ¨åå°ä¹Ÿèƒ½æ”¶åˆ°ï¼Œè¯´æ˜åå°æ¨é€æ­£å¸¸ï¼",
                        icon: 'https://img.heliar.top/file/1770541813634_æ— æ ‡é¢˜434_20260208170943.png',
                        tag: 'delayed-test'
                    });
                    showDebugToast("âœ“ 5ç§’å»¶è¿Ÿé€šçŸ¥å·²å‘é€ï¼", true);
                    console.log('[Test] 5ç§’å»¶è¿Ÿé€šçŸ¥å·²å‘é€');
                }, 5000);
                
            } else {
                Notification.requestPermission().then(permission => {
                    console.log('[Test] Permission request result:', permission);
                    if (permission === "granted") {
                        new Notification("æµ‹è¯•é€šçŸ¥", {
                            body: "æƒé™å·²æˆäºˆï¼ç³»ç»Ÿé€šçŸ¥åŠŸèƒ½æ­£å¸¸å·¥ä½œ",
                            icon: 'https://img.heliar.top/file/1770541813634_æ— æ ‡é¢˜434_20260208170943.png'
                        });
                        showDebugToast("âœ“ æƒé™å·²æˆäºˆï¼é€šçŸ¥å·²å‘é€", true);
                    } else {
                        alert("é€šçŸ¥æƒé™è¢«æ‹’ç»ï¼Œæ— æ³•å‘é€é€šçŸ¥");
                    }
                });
            }
        }

        // åˆ‡æ¢è°ƒè¯•æ¨¡å¼
        function toggleDebugMode(checkbox) {
            const enabled = checkbox.checked;
            localStorage.setItem('debug_mode_enabled', enabled);
            if (enabled) {
                showDebugToast('è°ƒè¯•æ¨¡å¼å·²å¼€å¯');
            }
        }

        // --- å¼ºåŠ›ä¿æ´»åŠŸèƒ½ ---
        let keepAliveAudio = null;

        // åˆ‡æ¢ä¿æ´»åŠŸèƒ½
        function toggleKeepAlive(checkbox) {
            const enabled = checkbox.checked;
            localStorage.setItem('keepalive_enabled', enabled);
            
            if (enabled) {
                startKeepAlive();
            } else {
                stopKeepAlive();
            }
        }

        // å¯åŠ¨ä¿æ´»
        async function startKeepAlive() {
            if (!keepAliveAudio) {
                keepAliveAudio = document.getElementById('keepalive-audio');
            }
            
            try {
                // è®¾ç½®éŸ³é‡ä¸º0ï¼ˆé™éŸ³ï¼‰
                keepAliveAudio.volume = 0;
                
                // å°è¯•æ’­æ”¾
                await keepAliveAudio.play();
                console.log('[KeepAlive] âœ“ ä¿æ´»éŸ³é¢‘å·²å¯åŠ¨');
                showDebugToast('âœ“ å¼ºåŠ›ä¿æ´»å·²å¯åŠ¨', true);
                addLog('success', 'å¼ºåŠ›ä¿æ´»å·²å¯åŠ¨');
                
                // ç›‘å¬æ’­æ”¾é”™è¯¯
                keepAliveAudio.onerror = (e) => {
                    console.error('[KeepAlive] éŸ³é¢‘æ’­æ”¾é”™è¯¯:', e);
                    showDebugToast('âœ— ä¿æ´»éŸ³é¢‘åŠ è½½å¤±è´¥');
                    addLog('error', 'ä¿æ´»éŸ³é¢‘åŠ è½½å¤±è´¥', e);
                };
                
            } catch (err) {
                console.error('[KeepAlive] å¯åŠ¨å¤±è´¥:', err);
                showDebugToast('âš ï¸ éœ€è¦ç”¨æˆ·äº¤äº’æ‰èƒ½å¯åŠ¨');
                addLog('warning', 'ä¿æ´»å¯åŠ¨å¤±è´¥ï¼Œéœ€è¦ç”¨æˆ·äº¤äº’', err);
                
                // ç­‰å¾…ç”¨æˆ·ç‚¹å‡»åé‡è¯•
                document.addEventListener('click', function retryKeepAlive() {
                    startKeepAlive();
                    document.removeEventListener('click', retryKeepAlive);
                }, { once: true });
            }
        }

        // åœæ­¢ä¿æ´»
        function stopKeepAlive() {
            if (keepAliveAudio) {
                keepAliveAudio.pause();
                keepAliveAudio.currentTime = 0;
                console.log('[KeepAlive] âœ“ ä¿æ´»å·²åœæ­¢');
                showDebugToast('âœ“ ä¿æ´»å·²åœæ­¢');
                addLog('info', 'å¼ºåŠ›ä¿æ´»å·²åœæ­¢');
            }
        }

        // æ˜¾ç¤ºè°ƒè¯•Toastï¼ˆåœ¨æ‰‹æœºä¸Šå¯è§ï¼‰
        let toastTimer = null;
        function showDebugToast(message, forceShow = false) {
            // æ£€æŸ¥æ˜¯å¦å¼€å¯è°ƒè¯•æ¨¡å¼ï¼ˆæµ‹è¯•é€šçŸ¥æ—¶å¼ºåˆ¶æ˜¾ç¤ºï¼‰
            const debugEnabled = localStorage.getItem('debug_mode_enabled') === 'true';
            if (!debugEnabled && !forceShow) {
                return;
            }
            
            // åˆ›å»ºæˆ–è·å–toastå…ƒç´ 
            let toast = document.getElementById('debug-toast');
            if (!toast) {
                toast = document.createElement('div');
                toast.id = 'debug-toast';
                toast.className = 'debug-toast';
                document.body.appendChild(toast);
            }
            
            // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
            if (toastTimer) clearTimeout(toastTimer);
            
            // æ˜¾ç¤ºæ¶ˆæ¯
            toast.innerText = message;
            toast.classList.add('show');
            
            // 3ç§’åéšè—
            toastTimer = setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        // API é”™è¯¯æç¤ºå¼¹çª—
        let apiErrorTimer = null;
        function showApiErrorToast(errorMessage) {
            // åˆ›å»ºæˆ–è·å–å¼¹çª—å…ƒç´ 
            let toast = document.getElementById('api-error-toast');
            if (!toast) {
                toast = document.createElement('div');
                toast.id = 'api-error-toast';
                toast.className = 'api-error-toast';
                document.body.appendChild(toast);
            }
            
            // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
            if (apiErrorTimer) clearTimeout(apiErrorTimer);
            
            // æ„å»ºé”™è¯¯æç¤ºå†…å®¹
            toast.innerHTML = `
                <div class="error-icon">âš ï¸</div>
                <div class="error-title">è¯·æ±‚å¤±è´¥</div>
                <div class="error-msg">${errorMessage}</div>
            `;
            toast.classList.add('show');
            
            // 4ç§’åè‡ªåŠ¨éšè—
            apiErrorTimer = setTimeout(() => {
                toast.classList.remove('show');
            }, 4000);
            
            // ç‚¹å‡»å…³é—­
            toast.style.pointerEvents = 'auto';
            toast.onclick = () => {
                toast.classList.remove('show');
                if (apiErrorTimer) clearTimeout(apiErrorTimer);
            };
        }

        // å…¨å±€æ—¥å¿—ç³»ç»Ÿ
        const systemLogs = [];
        const MAX_LOGS = 100;
        
        function addLog(type, message, data = null) {
            const log = {
                time: new Date().toLocaleTimeString(),
                type: type, // 'info', 'success', 'warning', 'error'
                message: message,
                data: data
            };
            systemLogs.unshift(log);
            if (systemLogs.length > MAX_LOGS) systemLogs.pop();
            
            // å¦‚æœè¯Šæ–­é¢æ¿æ‰“å¼€ï¼Œå®æ—¶æ›´æ–°
            const logContainer = document.getElementById('diagnostic-logs');
            if (logContainer) {
                renderLogs();
            }
        }
        
        function renderLogs() {
            const container = document.getElementById('diagnostic-logs');
            if (!container) return;
            
            container.innerHTML = systemLogs.map(log => {
                const colors = {
                    info: '#007aff',
                    success: '#34c759',
                    warning: '#ff9500',
                    error: '#ff3b30'
                };
                const icons = {
                    info: 'â„¹ï¸',
                    success: 'âœ…',
                    warning: 'âš ï¸',
                    error: 'âŒ'
                };
                
                return `
                    <div style="padding:8px; border-bottom:1px solid #eee; font-size:12px;">
                        <div style="display:flex; justify-content:space-between; margin-bottom:4px;">
                            <span style="color:${colors[log.type]}; font-weight:bold;">${icons[log.type]} ${log.type.toUpperCase()}</span>
                            <span style="color:#999;">${log.time}</span>
                        </div>
                        <div style="color:#333;">${log.message}</div>
                        ${log.data ? `<pre style="background:#f5f5f5; padding:4px; border-radius:4px; margin-top:4px; font-size:10px; overflow-x:auto;">${JSON.stringify(log.data, null, 2)}</pre>` : ''}
                    </div>
                `;
            }).join('');
        }
        
        // æ˜¾ç¤ºè¯Šæ–­é¢æ¿
        async function showDiagnosticPanel() {
            const panel = document.createElement('div');
            panel.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                z-index: 9999;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 20px;
            `;
            
            const content = document.createElement('div');
            content.style.cssText = `
                background: white;
                border-radius: 12px;
                padding: 20px;
                max-width: 500px;
                width: 100%;
                max-height: 80vh;
                overflow-y: auto;
            `;
            
            // è·å–è¯Šæ–­ä¿¡æ¯
            let diagnosticInfo = `<h2 style="margin-top:0; color:#333;">ğŸ” è¯Šæ–­ä¿¡æ¯</h2>`;
            
            // 1. User ID
            diagnosticInfo += `<div style="margin-bottom:20px; padding:10px; background:#f5f5f5; border-radius:8px;">
                <strong style="color:#007aff;">User ID:</strong><br>
                <code style="background:#fff; padding:5px; border-radius:4px; display:block; margin-top:5px; word-break:break-all;">${currentUserId}</code>
            </div>`;
            
            // 2. æ£€æŸ¥ Service Worker
            let swStatus = 'âŒ æœªæ³¨å†Œ';
            if ('serviceWorker' in navigator) {
                const registration = await navigator.serviceWorker.getRegistration();
                if (registration) {
                    swStatus = 'âœ… å·²æ³¨å†Œ';
                    if (registration.active) {
                        swStatus += ' (æ¿€æ´»)';
                    }
                }
            }
            diagnosticInfo += `<div style="margin-bottom:20px; padding:10px; background:#f5f5f5; border-radius:8px;">
                <strong style="color:#007aff;">Service Worker:</strong><br>
                <span style="margin-top:5px; display:block;">${swStatus}</span>
            </div>`;
            
            // 3. æ¨é€è®¢é˜…çŠ¶æ€
            let subStatus = 'âŒ æœªè®¢é˜…';
            let subEndpoint = 'æ— ';
            if ('serviceWorker' in navigator && 'PushManager' in window) {
                const registration = await navigator.serviceWorker.getRegistration();
                if (registration) {
                    const subscription = await registration.pushManager.getSubscription();
                    if (subscription) {
                        subStatus = 'âœ… å·²è®¢é˜…';
                        subEndpoint = subscription.endpoint.substring(0, 50) + '...';
                    }
                }
            }
            diagnosticInfo += `<div style="margin-bottom:20px; padding:10px; background:#f5f5f5; border-radius:8px;">
                <strong style="color:#007aff;">æ¨é€è®¢é˜…:</strong><br>
                <span style="margin-top:5px; display:block;">${subStatus}</span>
                <code style="background:#fff; padding:5px; border-radius:4px; display:block; margin-top:5px; font-size:10px; word-break:break-all;">${subEndpoint}</code>
            </div>`;
            
            // 4. é€šçŸ¥æƒé™
            const notifPerm = Notification.permission;
            const permIcon = notifPerm === 'granted' ? 'âœ…' : notifPerm === 'denied' ? 'âŒ' : 'âš ï¸';
            diagnosticInfo += `<div style="margin-bottom:20px; padding:10px; background:#f5f5f5; border-radius:8px;">
                <strong style="color:#007aff;">é€šçŸ¥æƒé™:</strong><br>
                <span style="margin-top:5px; display:block;">${permIcon} ${notifPerm}</span>
            </div>`;
            
            // 5. ç¯å¢ƒä¿¡æ¯
            diagnosticInfo += `<div style="margin-bottom:20px; padding:10px; background:#f5f5f5; border-radius:8px;">
                <strong style="color:#007aff;">ç¯å¢ƒä¿¡æ¯:</strong><br>
                <span style="margin-top:5px; display:block;">åè®®: ${location.protocol}</span>
                <span style="display:block;">åŸŸå: ${location.hostname}</span>
                <span style="display:block;">æ¨¡å¼: çº¯å‰ç«¯ï¼ˆæ— éœ€åç«¯ï¼‰</span>
            </div>`;
            
            // 6. å¼€å¯ä¸»åŠ¨èŠå¤©çš„è§’è‰²
            const autoChars = await db.characters
                .filter(c => c.auto_reply_enabled === true && c.auto_reply_interval > 0)
                .toArray();
            diagnosticInfo += `<div style="margin-bottom:20px; padding:10px; background:#f5f5f5; border-radius:8px;">
                <strong style="color:#007aff;">ä¸»åŠ¨èŠå¤©è§’è‰²:</strong><br>
                <span style="margin-top:5px; display:block;">${autoChars.length} ä¸ªè§’è‰²å·²å¯ç”¨</span>
                ${autoChars.map(c => `<div style="margin-top:5px; padding:5px; background:#fff; border-radius:4px;">
                    ${c.name} (${c.auto_reply_interval}åˆ†é’Ÿ)
                </div>`).join('')}
            </div>`;
            
            // 7. å®æ—¶æ—¥å¿—åŒºåŸŸ
            diagnosticInfo += `<div style="margin-bottom:20px;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                    <strong style="color:#007aff;">ğŸ“‹ å®æ—¶æ—¥å¿— (æœ€è¿‘${systemLogs.length}æ¡)</strong>
                    <button onclick="systemLogs.length=0; renderLogs();" style="padding:4px 8px; background:#ff3b30; color:#fff; border:none; border-radius:4px; font-size:11px;">æ¸…ç©º</button>
                </div>
                <div id="diagnostic-logs" style="max-height:300px; overflow-y:auto; background:#f9f9f9; border-radius:8px; padding:10px;">
                    ${systemLogs.length === 0 ? '<div style="text-align:center; color:#999; padding:20px;">æš‚æ— æ—¥å¿—</div>' : ''}
                </div>
            </div>`;
            
            content.innerHTML = diagnosticInfo;
            
            // æ¸²æŸ“æ—¥å¿—
            renderLogs();
            
            // å…³é—­æŒ‰é’®
            const closeBtn = document.createElement('button');
            closeBtn.innerText = 'å…³é—­';
            closeBtn.style.cssText = `
                width: 100%;
                padding: 12px;
                background: var(--ins-pink);
                color: white;
                border: none;
                border-radius: 8px;
                font-size: 16px;
                cursor: pointer;
                margin-top: 10px;
            `;
            closeBtn.onclick = () => document.body.removeChild(panel);
            content.appendChild(closeBtn);
            
            panel.appendChild(content);
            document.body.appendChild(panel);
            
            // ç‚¹å‡»èƒŒæ™¯å…³é—­
            panel.onclick = (e) => {
                if (e.target === panel) {
                    document.body.removeChild(panel);
                }
            };
        }

        // æ˜¾ç¤ºè®¾ç½®é¡µé¢
        function showSettingPage() {
            document.getElementById('setting-page').style.display = 'flex';
        }
        function hideSettingPage() {
            document.getElementById('setting-page').style.display = 'none';
        }

        // å…è´£å£°æ˜å¼¹çª—
        function showDisclaimerModal(isFirstVisit) {
            const overlay = document.createElement('div');
            overlay.id = 'disclaimer-modal';
            overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.3);display:flex;align-items:center;justify-content:center;z-index:999999;';
            if (!isFirstVisit) {
                overlay.onclick = (e) => { if (e.target === overlay) overlay.remove(); };
            }
            
            overlay.innerHTML = `
                <div style="background:#fff;border-radius:14px;width:300px;max-height:80vh;overflow-y:auto;box-shadow:0 8px 30px rgba(0,0,0,0.08);font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;">
                    <div style="padding:24px 20px 0;text-align:center;">
                        <div style="font-size:16px;font-weight:600;color:#262626;letter-spacing:0.3px;">å…è´£å£°æ˜</div>
                        <div style="font-size:11px;color:#c7c7c7;margin-top:2px;">Disclaimer</div>
                    </div>
                    <div style="padding:16px 20px;font-size:12px;color:#666;line-height:1.8;letter-spacing:0.2px;">
                        <p style="margin:0 0 10px;">1. æœ¬ç½‘é¡µä»…ä½œä¸ºå·¥å…·å¹³å°æä¾›ï¼Œä¸æä¾›ä»»ä½• AI æ¨¡å‹æœåŠ¡ã€‚æ‰€æœ‰ AI ç”Ÿæˆçš„å†…å®¹ï¼ˆåŒ…æ‹¬ä½†ä¸é™äºæ–‡å­—ã€å¯¹è¯ã€è§’è‰²è¡Œä¸ºç­‰ï¼‰å‡ç”±ç¬¬ä¸‰æ–¹ AI æœåŠ¡æä¾›å•†ç”Ÿæˆï¼Œä¸æœ¬å¹³å°åŠä½œè€…æ— å…³ã€‚</p>
                        <p style="margin:0 0 10px;">2. ç”¨æˆ·å¯¼å…¥çš„è§’è‰²å¡ã€ä¸–ç•Œä¹¦ç­‰å†…å®¹ç”±ç”¨æˆ·è‡ªè¡Œæä¾›ï¼Œæœ¬å¹³å°ä¸å¯¹å…¶åˆæ³•æ€§ã€å‡†ç¡®æ€§æˆ–é€‚å½“æ€§æ‰¿æ‹…ä»»ä½•è´£ä»»ã€‚</p>
                        <p style="margin:0 0 10px;">3. AI ç”Ÿæˆçš„æ‰€æœ‰å†…å®¹ä¸ä»£è¡¨æœ¬å¹³å°åŠä½œè€…çš„è§‚ç‚¹ä¸ç«‹åœºã€‚ç”¨æˆ·åº”è‡ªè¡Œåˆ¤æ–­å†…å®¹é€‚å½“æ€§ï¼Œå¹¶å¯¹ä½¿ç”¨åæœæ‰¿æ‹…å…¨éƒ¨è´£ä»»ã€‚</p>
                        <p style="margin:0 0 10px;">4. æœ¬å¹³å°ä¸å­˜å‚¨ã€ä¸ä¼ è¾“ç”¨æˆ·æ•°æ®è‡³å¤–éƒ¨æœåŠ¡å™¨ï¼ˆè”æœºåŠŸèƒ½é™¤å¤–ï¼‰ï¼Œæ‰€æœ‰æ•°æ®å­˜å‚¨åœ¨ç”¨æˆ·æœ¬åœ°æµè§ˆå™¨ä¸­ã€‚</p>
                        <p style="margin:0 0 10px;">5. ç”¨æˆ·åº”éµå®ˆæ‰€åœ¨åœ°åŒºæ³•å¾‹æ³•è§„ï¼Œä¸å¾—åˆ©ç”¨æœ¬å¹³å°ä»äº‹è¿æ³•è¿è§„æ´»åŠ¨ï¼Œå› ä¸å½“ä½¿ç”¨äº§ç”Ÿçš„æ³•å¾‹è´£ä»»ç”±ç”¨æˆ·è‡ªè¡Œæ‰¿æ‹…ã€‚</p>
                        <p style="margin:0;">6. ä½œè€…ä¿ç•™éšæ—¶ä¿®æ”¹ã€æš‚åœæˆ–ç»ˆæ­¢æœåŠ¡çš„æƒåˆ©ï¼Œä¸”æ— éœ€å¦è¡Œé€šçŸ¥ã€‚</p>
                    </div>
                    <div style="padding:0 20px 8px;text-align:center;">
                        <div style="width:30px;height:1px;background:#efefef;margin:0 auto 8px;"></div>
                        <div style="font-size:11px;color:#c7c7c7;">ä½œè€…ï¼šç†èŠ½ ï½œ ç‰¹åˆ«æ„Ÿè°¢ï¼šå°é‡çŒ«</div>
                    </div>
                    <div style="padding:12px 20px 20px;">
                        <div onclick="acceptDisclaimer()" style="width:100%;text-align:center;padding:12px;border-radius:10px;font-size:14px;color:#fff;background:#262626;cursor:pointer;font-weight:500;box-sizing:border-box;">
                            ${isFirstVisit ? 'æˆ‘å·²é˜…è¯»å¹¶åŒæ„' : 'å…³é—­'}
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
        }
        
        function acceptDisclaimer() {
            localStorage.setItem('disclaimer_accepted', '1');
            const modal = document.getElementById('disclaimer-modal');
            if (modal) modal.remove();
        }
        
        // é¦–æ¬¡è®¿é—®æ£€æŸ¥
        function checkFirstVisitDisclaimer() {
            if (!localStorage.getItem('disclaimer_accepted')) {
                showDisclaimerModal(true);
            }
        }

        // ===== æ›´æ–°å…¬å‘Šå¼¹çª— =====
        const UPDATE_VERSION = 'v2026-02-09'; // æ¯æ¬¡æ›´æ–°æ”¹è¿™ä¸ªç‰ˆæœ¬å·ï¼Œå°±ä¼šé‡æ–°å¼¹å‡º
        
        function checkUpdateNotice() {
            const readKey = 'update_notice_read_' + UPDATE_VERSION;
            if (localStorage.getItem(readKey)) return; // å·²è¯»è¿‡æ­¤ç‰ˆæœ¬ï¼Œä¸å†å¼¹å‡º
            showUpdateNotice();
        }
        
        function showUpdateNotice() {
            const readKey = 'update_notice_read_' + UPDATE_VERSION;
            const overlay = document.createElement('div');
            overlay.id = 'update-notice-modal';
            overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.45);display:flex;align-items:center;justify-content:center;z-index:999999;animation:fadeIn 0.25s ease-out;';
            
            overlay.innerHTML = `
                <div style="background:#fff;border-radius:16px;width:310px;max-height:80vh;overflow:hidden;box-shadow:0 12px 40px rgba(0,0,0,0.15);font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;display:flex;flex-direction:column;">
                    <div style="padding:22px 20px 0;text-align:center;">
                        <div style="font-size:28px;margin-bottom:6px;">ğŸ‰</div>
                        <div style="font-size:17px;font-weight:700;color:#262626;letter-spacing:0.3px;">æ›´æ–°å…¬å‘Š</div>
                        <div style="font-size:11px;color:#c7c7c7;margin-top:3px;">Update Notes Â· ${UPDATE_VERSION}</div>
                    </div>
                    <div style="padding:16px 20px;font-size:13px;color:#444;line-height:1.9;letter-spacing:0.2px;overflow-y:auto;flex:1;">
                        <div style="font-size:14px;font-weight:600;color:#333;margin-bottom:8px;">ğŸ”§ ä¿®å¤äº†Bug</div>
                        <div style="padding-left:4px;">
                            <p style="margin:0 0 4px;">1. è§„èŒƒè§’è‰²å‘é€è¡¨æƒ…åŒ…</p>
                            <p style="margin:0 0 4px;">2. å›å¤æ¡æ•°æœ€å¤§è®¾ç½®50</p>
                            <p style="margin:0 0 4px;">3. ä¿®å¤äº†ç¼–è¾‘æ¶ˆæ¯æ²¡ååº”</p>
                            <p style="margin:0 0 4px;">4. ä¿®å¤äº†é•¿æŒ‰æ¶ˆæ¯</p>
                            <p style="margin:0 0 4px;">5. ä¿®å¤äº†ç¾¤èŠæ— æ³•å‘é€è¡¨æƒ…åŒ…çº¢åŒ…</p>
                            <p style="margin:0 0 4px;">6. ä¿®å¤äº†å¿«è¿›æ—¶é—´æˆ³</p>
                            <p style="margin:0 0 4px;">7. ä¿®å¤äº†è§†é¢‘ä¸è¯»äººè®¾</p>
                            <p style="margin:0 0 4px;">8. ä¿®å¤äº†çº¿ä¸‹ä¸è¯»äººè®¾</p>
                            <p style="margin:0 0 4px;">9. æ”¹è¿›äº†ä¸€ä¸‹ç¿»è¯‘</p>
                            <p style="margin:0 0 4px;">10. ä¿®äº†ç‚¹æœ‹å‹åœˆ</p>
                        </div>
                        <div style="margin-top:12px;padding-top:10px;border-top:1px solid #f0f0f0;font-size:12px;color:#888;line-height:1.7;">
                            è°¢è°¢å¤§å®¶åé¦ˆ å¦‚æœè¿˜æœ‰bugæ¬¢è¿å†å‘ŠçŸ¥ â¤ï¸
                        </div>
                    </div>
                    <div style="padding:12px 20px 20px;text-align:center;">
                        <button id="update-notice-btn" disabled onclick="dismissUpdateNotice()" style="
                            width:100%;
                            padding:12px;
                            border:none;
                            border-radius:10px;
                            font-size:15px;
                            font-weight:600;
                            cursor:not-allowed;
                            background:#e0e0e0;
                            color:#aaa;
                            transition:all 0.3s ease;
                            letter-spacing:0.5px;
                        ">è¯·é˜…è¯» (5s)</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // 5ç§’å€’è®¡æ—¶
            let countdown = 5;
            const btn = document.getElementById('update-notice-btn');
            const timer = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    btn.textContent = `è¯·é˜…è¯» (${countdown}s)`;
                } else {
                    clearInterval(timer);
                    btn.disabled = false;
                    btn.style.cursor = 'pointer';
                    btn.style.background = 'var(--ins-pink, #ff6b9d)';
                    btn.style.color = '#fff';
                    btn.textContent = 'æˆ‘å·²é˜…è¯»';
                }
            }, 1000);
        }
        
        function dismissUpdateNotice() {
            const readKey = 'update_notice_read_' + UPDATE_VERSION;
            localStorage.setItem(readKey, '1');
            const modal = document.getElementById('update-notice-modal');
            if (modal) {
                modal.style.transition = 'opacity 0.25s ease';
                modal.style.opacity = '0';
                setTimeout(() => modal.remove(), 250);
            }
        }

        // ===== æ•°æ®å¯¼å…¥å¯¼å‡ºåŠŸèƒ½ =====
        
        // æ˜¾ç¤ºå¯¼å‡ºé€‰é¡¹å¼¹çª—
        function showExportOptions() {
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 100000;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white;
                border-radius: 12px;
                padding: 24px;
                max-width: 400px;
                width: 90%;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            `;
            
            dialog.innerHTML = `
                <h3 style="margin: 0 0 16px 0; font-size: 18px;">å¯¼å‡ºæ•°æ®é€‰é¡¹</h3>
                <p style="margin: 0 0 20px 0; font-size: 14px; color: #666;">
                    é€‰æ‹©è¦å¯¼å‡ºçš„æ•°æ®ç±»å‹ï¼š
                </p>
                <div style="margin-bottom: 20px;">
                    <label style="display: flex; align-items: center; margin-bottom: 12px; cursor: pointer;">
                        <input type="checkbox" id="export-local-data" checked style="margin-right: 8px; width: 18px; height: 18px;">
                        <div>
                            <div style="font-weight: 500;">æœ¬åœ°æ•°æ®</div>
                            <div style="font-size: 12px; color: #999;">
                                åŒ…æ‹¬ï¼šè§’è‰²ã€èŠå¤©è®°å½•ã€ä¸–ç•Œä¹¦ã€è¡¨æƒ…åŒ…ã€æœ‹å‹åœˆã€ç¾¤èŠã€ç”µè¯/çŸ­ä¿¡è®°å½•ç­‰
                            </div>
                        </div>
                    </label>
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="export-online-data" checked style="margin-right: 8px; width: 18px; height: 18px;">
                        <div>
                            <div style="font-weight: 500;">è”æœºè´¦å·æ•°æ®</div>
                            <div style="font-size: 12px; color: #999;">
                                åŒ…æ‹¬ï¼šè”æœºæœåŠ¡å™¨åœ°å€ã€ç™»å½•Tokenã€ç”¨æˆ·ä¿¡æ¯
                            </div>
                        </div>
                    </label>
                </div>
                <div style="display: flex; gap: 12px; justify-content: flex-end;">
                    <button id="export-cancel-btn" style="padding: 8px 16px; border: 1px solid #ddd; background: white; border-radius: 6px; cursor: pointer;">
                        å–æ¶ˆ
                    </button>
                    <button id="export-confirm-btn" style="padding: 8px 16px; border: none; background: #07c160; color: white; border-radius: 6px; cursor: pointer;">
                        ç¡®å®šå¯¼å‡º
                    </button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // ç»‘å®šäº‹ä»¶
            document.getElementById('export-cancel-btn').onclick = () => {
                document.body.removeChild(overlay);
            };
            
            document.getElementById('export-confirm-btn').onclick = async () => {
                const includeLocal = document.getElementById('export-local-data').checked;
                const includeOnline = document.getElementById('export-online-data').checked;
                
                if (!includeLocal && !includeOnline) {
                    alert('è¯·è‡³å°‘é€‰æ‹©ä¸€ç§æ•°æ®ç±»å‹');
                    return;
                }
                
                document.body.removeChild(overlay);
                await exportAllDataWithOptions(includeLocal, includeOnline);
            };
            
            // ç‚¹å‡»èƒŒæ™¯å…³é—­
            overlay.onclick = (e) => {
                if (e.target === overlay) {
                    document.body.removeChild(overlay);
                }
            };
        }
        
        // å¯¼å‡ºæ‰€æœ‰æ•°æ®ï¼ˆå¸¦é€‰é¡¹ï¼‰
        async function exportAllDataWithOptions(includeLocal = true, includeOnline = true) {
            try {
                const exportData = {
                    version: '2.0', // ç‰ˆæœ¬å‡çº§åˆ°2.0
                    exportTime: new Date().toISOString(),
                    dataTypes: {
                        local: includeLocal,
                        online: includeOnline
                    },
                    data: {}
                };
                
                if (includeLocal) {
                    // å¯¼å‡ºæ‰€æœ‰æ•°æ®åº“è¡¨
                    exportData.data.dexiData = await db.dexiData.toArray();
                    exportData.data.lorebooks = await db.lorebooks.toArray();
                    exportData.data.characters = await db.characters.toArray();
                    exportData.data.sticker_categories = await db.sticker_categories.toArray();
                    exportData.data.moments = await db.moments.toArray();
                    exportData.data.friend_requests = await db.friend_requests.toArray();
                    
                    // æ–°å¢ï¼šå¯¼å‡ºç¾¤èŠæ•°æ®
                    exportData.data.group_chats = await db.group_chats.toArray();
                    
                    // æ–°å¢ï¼šå¯¼å‡ºç”µè¯å’ŒçŸ­ä¿¡è®°å½•
                    exportData.data.phone_recents = await db.phone_recents.toArray();
                    exportData.data.sms_messages = await db.sms_messages.toArray();
                    
                    // æ–°å¢ï¼šå¯¼å‡ºèŠå¤©æ€»ç»“
                    exportData.data.chat_summaries = await db.chat_summaries.toArray();
                    
                    // æ–°å¢ï¼šå¯¼å‡ºå¤´åƒåº“
                    exportData.data.avatar_library = await db.avatar_library.toArray();
                    exportData.data.avatar_categories = await db.avatar_categories.toArray();
                    
                    // å¯¼å‡ºæœ¬åœ° localStorage æ•°æ®
                    exportData.localStorage = {
                        user_id: localStorage.getItem('user_id'),
                        current_my_char_id: localStorage.getItem('current_my_char_id'),
                        notification_enabled: localStorage.getItem('notification_enabled'),
                        debug_mode: localStorage.getItem('debug_mode'),
                        keepalive_enabled: localStorage.getItem('keepalive_enabled')
                    };
                }
                
                if (includeOnline) {
                    // å¯¼å‡ºè”æœºç›¸å…³æ•°æ®
                    exportData.onlineData = {
                        server_url: localStorage.getItem('online_server_url'),
                        token: localStorage.getItem('online_token'),
                        user_data: localStorage.getItem('online_user_data')
                    };
                }
                
                // è½¬æ¢ä¸ºJSONå­—ç¬¦ä¸²
                const jsonString = JSON.stringify(exportData, null, 2);
                
                // åˆ›å»ºä¸‹è½½é“¾æ¥
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                
                // æ ¹æ®å¯¼å‡ºçš„æ•°æ®ç±»å‹è®¾ç½®æ–‡ä»¶å
                let filename = 'wechat_backup_';
                if (includeLocal && includeOnline) {
                    filename += 'full_';
                } else if (includeLocal) {
                    filename += 'local_';
                } else if (includeOnline) {
                    filename += 'online_';
                }
                filename += new Date().getTime() + '.json';
                
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // æ˜¾ç¤ºå¯¼å‡ºçš„æ•°æ®ç»Ÿè®¡
                let stats = [];
                if (includeLocal) {
                    const charCount = exportData.data.characters?.length || 0;
                    const groupCount = exportData.data.group_chats?.length || 0;
                    const momentCount = exportData.data.moments?.length || 0;
                    stats.push(`è§’è‰²: ${charCount}ä¸ª`);
                    stats.push(`ç¾¤èŠ: ${groupCount}ä¸ª`);
                    stats.push(`æœ‹å‹åœˆ: ${momentCount}æ¡`);
                }
                if (includeOnline) {
                    stats.push('è”æœºè´¦å·ä¿¡æ¯å·²åŒ…å«');
                }
                
                alert('æ•°æ®å¯¼å‡ºæˆåŠŸï¼\n\n' + stats.join('\n'));
            } catch (error) {
                console.error('å¯¼å‡ºæ•°æ®å¤±è´¥:', error);
                alert('å¯¼å‡ºæ•°æ®å¤±è´¥: ' + error.message);
            }
        }
        
        // å…¼å®¹æ—§ç‰ˆæœ¬ï¼šç›´æ¥è°ƒç”¨æ—¶æ˜¾ç¤ºé€‰é¡¹
        async function exportAllData() {
            showExportOptions();
        }
        
        // å¯¼å…¥æ‰€æœ‰æ•°æ®
        async function importAllData(input) {
            const file = input.files[0];
            if (!file) return;
            
            try {
                const text = await file.text();
                const importData = JSON.parse(text);
                
                // éªŒè¯æ•°æ®æ ¼å¼
                if (!importData.version || !importData.data) {
                    throw new Error('æ•°æ®æ ¼å¼ä¸æ­£ç¡®');
                }
                
                // æ£€æµ‹æ•°æ®ç±»å‹
                const hasLocalData = importData.dataTypes?.local !== false;
                const hasOnlineData = importData.onlineData || (importData.dataTypes?.online === true);
                
                // æ˜¾ç¤ºå¯¼å…¥å†…å®¹é¢„è§ˆ
                let previewMsg = 'å³å°†å¯¼å…¥ä»¥ä¸‹æ•°æ®ï¼š\n\n';
                if (hasLocalData) {
                    const charCount = importData.data.characters?.length || 0;
                    const groupCount = importData.data.group_chats?.length || 0;
                    const momentCount = importData.data.moments?.length || 0;
                    previewMsg += `ğŸ“± æœ¬åœ°æ•°æ®ï¼š\n`;
                    previewMsg += `  - è§’è‰²: ${charCount}ä¸ª\n`;
                    previewMsg += `  - ç¾¤èŠ: ${groupCount}ä¸ª\n`;
                    previewMsg += `  - æœ‹å‹åœˆ: ${momentCount}æ¡\n`;
                    previewMsg += `  - ä»¥åŠä¸–ç•Œä¹¦ã€è¡¨æƒ…åŒ…ã€ç”µè¯/çŸ­ä¿¡è®°å½•ç­‰\n\n`;
                }
                if (hasOnlineData) {
                    const userData = importData.onlineData?.user_data;
                    if (userData) {
                        try {
                            const userObj = JSON.parse(userData);
                            previewMsg += `ğŸŒ è”æœºè´¦å·ï¼š${userObj.username || 'æœªçŸ¥'}\n\n`;
                        } catch {
                            previewMsg += `ğŸŒ è”æœºè´¦å·æ•°æ®\n\n`;
                        }
                    } else {
                        previewMsg += `ğŸŒ è”æœºè´¦å·æ•°æ®\n\n`;
                    }
                }
                
                previewMsg += 'âš ï¸ å¯¼å…¥å°†è¦†ç›–ç°æœ‰æ•°æ®ï¼\nå»ºè®®å…ˆå¯¼å‡ºå½“å‰æ•°æ®ä½œä¸ºå¤‡ä»½ã€‚\n\næ˜¯å¦ç»§ç»­ï¼Ÿ';
                
                // ç¡®è®¤å¯¹è¯æ¡†
                if (!confirm(previewMsg)) {
                    input.value = ''; // æ¸…ç©ºæ–‡ä»¶é€‰æ‹©
                    return;
                }
                
                // æ¸…ç©ºç°æœ‰æ•°æ®
                if (hasLocalData) {
                    await db.dexiData.clear();
                    await db.lorebooks.clear();
                    await db.characters.clear();
                    await db.sticker_categories.clear();
                    await db.moments.clear();
                    await db.friend_requests.clear();
                    
                    // æ¸…ç©ºæ–°å¢çš„è¡¨
                    if (db.group_chats) await db.group_chats.clear();
                    if (db.phone_recents) await db.phone_recents.clear();
                    if (db.sms_messages) await db.sms_messages.clear();
                    if (db.chat_summaries) await db.chat_summaries.clear();
                }
                
                // å¯¼å…¥æ•°æ®åº“è¡¨æ•°æ®
                if (hasLocalData && importData.data) {
                    if (importData.data.dexiData) {
                        await db.dexiData.bulkAdd(importData.data.dexiData);
                    }
                    if (importData.data.lorebooks) {
                        await db.lorebooks.bulkAdd(importData.data.lorebooks);
                    }
                    if (importData.data.characters) {
                        await db.characters.bulkAdd(importData.data.characters);
                    }
                    if (importData.data.sticker_categories) {
                        await db.sticker_categories.bulkAdd(importData.data.sticker_categories);
                    }
                    if (importData.data.moments) {
                        await db.moments.bulkAdd(importData.data.moments);
                    }
                    if (importData.data.friend_requests) {
                        await db.friend_requests.bulkAdd(importData.data.friend_requests);
                    }
                    
                    // å¯¼å…¥æ–°å¢çš„è¡¨
                    if (importData.data.group_chats && db.group_chats) {
                        await db.group_chats.bulkAdd(importData.data.group_chats);
                    }
                    if (importData.data.phone_recents && db.phone_recents) {
                        await db.phone_recents.bulkAdd(importData.data.phone_recents);
                    }
                    if (importData.data.sms_messages && db.sms_messages) {
                        await db.sms_messages.bulkAdd(importData.data.sms_messages);
                    }
                    if (importData.data.chat_summaries && db.chat_summaries) {
                        await db.chat_summaries.bulkAdd(importData.data.chat_summaries);
                    }
                    if (importData.data.avatar_library && db.avatar_library) {
                        await db.avatar_library.bulkAdd(importData.data.avatar_library);
                    }
                    if (importData.data.avatar_categories && db.avatar_categories) {
                        await db.avatar_categories.bulkAdd(importData.data.avatar_categories);
                    }
                    
                    // å¯¼å…¥ localStorage æ•°æ®
                    if (importData.localStorage) {
                        Object.keys(importData.localStorage).forEach(key => {
                            const value = importData.localStorage[key];
                            if (value !== null && value !== undefined) {
                                localStorage.setItem(key, value);
                            }
                        });
                    }
                }
                
                // å¯¼å…¥è”æœºæ•°æ®
                if (hasOnlineData && importData.onlineData) {
                    if (importData.onlineData.server_url) {
                        localStorage.setItem('online_server_url', importData.onlineData.server_url);
                    }
                    if (importData.onlineData.token) {
                        localStorage.setItem('online_token', importData.onlineData.token);
                    }
                    if (importData.onlineData.user_data) {
                        localStorage.setItem('online_user_data', importData.onlineData.user_data);
                    }
                }
                
                input.value = ''; // æ¸…ç©ºæ–‡ä»¶é€‰æ‹©
                
                let successMsg = 'æ•°æ®å¯¼å…¥æˆåŠŸï¼\n\n';
                if (hasLocalData) successMsg += 'âœ… æœ¬åœ°æ•°æ®å·²å¯¼å…¥\n';
                if (hasOnlineData) successMsg += 'âœ… è”æœºè´¦å·å·²å¯¼å…¥\n';
                successMsg += '\né¡µé¢å³å°†åˆ·æ–°...';
                
                alert(successMsg);
                
                // åˆ·æ–°é¡µé¢ä»¥åº”ç”¨å¯¼å…¥çš„æ•°æ®
                setTimeout(() => {
                    window.location.reload();
                }, 500);
                
            } catch (error) {
                console.error('å¯¼å…¥æ•°æ®å¤±è´¥:', error);
                alert('å¯¼å…¥æ•°æ®å¤±è´¥: ' + error.message);
                input.value = '';
            }
        }
        
        // æ¸…ç©ºæ‰€æœ‰æ•°æ®
        async function clearAllDataConfirm() {
            const confirm1 = confirm('âš ï¸ è­¦å‘Šï¼šæ­¤æ“ä½œå°†åˆ é™¤æ‰€æœ‰æ•°æ®ï¼\n\nåŒ…æ‹¬ï¼š\n- æ‰€æœ‰è§’è‰²å’ŒèŠå¤©è®°å½•\n- æ‰€æœ‰ä¸–ç•Œä¹¦\n- æ‰€æœ‰è¡¨æƒ…åŒ…\n- æ‰€æœ‰æœ‹å‹åœˆ\n- æ‰€æœ‰ç¾¤èŠ\n- ç”µè¯å’ŒçŸ­ä¿¡è®°å½•\n- è”æœºè´¦å·ä¿¡æ¯\n- APIè®¾ç½®\n\næ­¤æ“ä½œä¸å¯æ¢å¤ï¼Œç¡®å®šè¦ç»§ç»­å—ï¼Ÿ');
            if (!confirm1) return;
            
            const confirm2 = prompt('è¯·è¾“å…¥"ç¡®è®¤åˆ é™¤"ä»¥ç»§ç»­ï¼š');
            if (confirm2 !== 'ç¡®è®¤åˆ é™¤') {
                alert('å·²å–æ¶ˆæ“ä½œ');
                return;
            }
            
            try {
                // æ¸…ç©ºæ‰€æœ‰æ•°æ®åº“è¡¨
                await db.dexiData.clear();
                await db.lorebooks.clear();
                await db.characters.clear();
                await db.sticker_categories.clear();
                await db.moments.clear();
                await db.friend_requests.clear();
                
                // æ¸…ç©ºæ–°å¢çš„è¡¨
                if (db.group_chats) await db.group_chats.clear();
                if (db.phone_recents) await db.phone_recents.clear();
                if (db.sms_messages) await db.sms_messages.clear();
                if (db.chat_summaries) await db.chat_summaries.clear();
                
                // æ¸…ç©º localStorage
                localStorage.clear();
                
                alert('æ‰€æœ‰æ•°æ®å·²æ¸…ç©ºï¼é¡µé¢å³å°†åˆ·æ–°...');
                
                setTimeout(() => {
                    window.location.reload();
                }, 500);
                
            } catch (error) {
                console.error('æ¸…ç©ºæ•°æ®å¤±è´¥:', error);
                alert('æ¸…ç©ºæ•°æ®å¤±è´¥: ' + error.message);
            }
        }

        // æ˜¾ç¤ºé€šçŸ¥ä¸­å¿ƒ
        function showNotificationCenter() {
            const enabled = localStorage.getItem('notification_enabled') === 'true';
            if (!enabled) return; // æœªå¼€å¯ä¸æ˜¾ç¤º

            document.getElementById('notification-center').style.display = 'block';
            fetchNotifications(); // æ‰“å¼€æ—¶åˆ·æ–°ä¸€ä¸‹
        }
        function hideNotificationCenter() {
            document.getElementById('notification-center').style.display = 'none';
        }

        // è·å–é€šçŸ¥ï¼ˆçº¯å‰ç«¯ï¼šä»æœ¬åœ° IndexedDB è¯»å–ï¼‰
        async function fetchNotifications() {
            const enabled = localStorage.getItem('notification_enabled') === 'true';
            if (!enabled) return;

            try {
                // ä»æœ¬åœ°å­˜å‚¨è¯»å–é€šçŸ¥
                const notificationsJson = localStorage.getItem(`notifications_${currentUserId}`);
                const list = notificationsJson ? JSON.parse(notificationsJson) : [];
                renderNotifications(list);
            } catch (err) {
                console.error('è·å–é€šçŸ¥å¤±è´¥:', err);
            }
        }
        
        // æ·»åŠ æœ¬åœ°é€šçŸ¥ï¼ˆçº¯å‰ç«¯ç‰ˆæœ¬ï¼‰
        function addLocalNotification(title, content, type = 'single') {
            try {
                const notificationsJson = localStorage.getItem(`notifications_${currentUserId}`);
                const list = notificationsJson ? JSON.parse(notificationsJson) : [];
                
                const newNotif = {
                    id: Date.now(),
                    title: title,
                    content: content,
                    type: type,
                    timestamp: Date.now() / 1000,
                    is_read: false
                };
                
                list.unshift(newNotif);
                
                // æœ€å¤šä¿ç•™100æ¡é€šçŸ¥
                if (list.length > 100) list.pop();
                
                localStorage.setItem(`notifications_${currentUserId}`, JSON.stringify(list));
                return newNotif;
            } catch (err) {
                console.error('æ·»åŠ é€šçŸ¥å¤±è´¥:', err);
                return null;
            }
        }

        // æ¸²æŸ“é€šçŸ¥åˆ—è¡¨
        function renderNotifications(list) {
            const container = document.getElementById('notif-list');
            container.innerHTML = '';
            
            let unreadCount = 0;

            if (list.length === 0) {
                container.innerHTML = '<div class="empty-tip">æš‚æ— æ–°é€šçŸ¥</div>';
                latestNotification = null;
            } else {
                // ç¡®ä¿åˆ—è¡¨æ˜¯æŒ‰æ—¶é—´å€’åºçš„
                list.sort((a, b) => b.timestamp - a.timestamp);
                
                // æ›´æ–°æœ€æ–°çš„ä¸€æ¡é€šçŸ¥ç¼“å­˜
                latestNotification = list[0];

                list.forEach(item => {
                    // 1. ç»Ÿè®¡æœªè¯»
                    if (!item.is_read) unreadCount++;

                    // 2. æ£€æŸ¥æ˜¯å¦æœ‰æ–°æ¶ˆæ¯ (ä¸åœ¨å·²çŸ¥åˆ—è¡¨ä¸­ï¼Œä¸”éé¦–æ¬¡åŠ è½½)
                    if (!knownNotifIds.has(item.id)) {
                        knownNotifIds.add(item.id);
                        
                        // ä»…å½“éé¦–æ¬¡åŠ è½½æ—¶å¼¹çª—ï¼Œé¿å…åˆ·æ–°é¡µé¢æ—¶ç‹‚å¼¹
                        if (!isFirstLoad) {
                            sendSystemNotification(item.title, item.content);
                        }
                    }

                    // 3. æ¸²æŸ“DOM
                    const div = document.createElement('div');
                    div.className = `notif-item ${!item.is_read ? 'unread' : ''}`;
                    // æ ¼å¼åŒ–æ—¶é—´æˆ³
                    const date = new Date(item.timestamp * 1000);
                    const timeStr = `${date.getMonth()+1}-${date.getDate()} ${date.getHours()}:${date.getMinutes().toString().padStart(2, '0')}`;
                    
                    div.innerHTML = `
                        <div class="notif-time">${timeStr}</div>
                        <div class="notif-content-title">${item.title}</div>
                        <div class="notif-desc">${item.content}</div>
                    `;
                    div.onclick = () => markRead(item.id, item.is_read);
                    container.appendChild(div);
                });
            }
            
            // é¦–æ¬¡åŠ è½½æ ‡è®°ç½®ä¸ºfalse
            isFirstLoad = false;

            // æ›´æ–°çº¢ç‚¹
            const badge = document.getElementById('notif-badge');
            badge.style.display = unreadCount > 0 ? 'block' : 'none';
        }

        // å‘é€ç³»ç»Ÿé€šçŸ¥
        function sendSystemNotification(title, body) {
            console.log(`[Notification] ========================================`);
            console.log(`[Notification] ğŸ”” å°è¯•å‘é€é€šçŸ¥: "${title}" - "${body}"`);
            addLog('info', `å°è¯•å‘é€é€šçŸ¥: ${title}`, { body, caller: new Error().stack.split('\n')[2] });
            
            // æ£€æŸ¥æµè§ˆå™¨æ˜¯å¦æ”¯æŒé€šçŸ¥
            if (!("Notification" in window)) {
                console.error('[Notification] âœ— æµè§ˆå™¨ä¸æ”¯æŒé€šçŸ¥');
                addLog('error', 'æµè§ˆå™¨ä¸æ”¯æŒé€šçŸ¥');
                showDebugToast('æµè§ˆå™¨ä¸æ”¯æŒé€šçŸ¥');
                return;
            }
            
            // æ£€æŸ¥æƒé™çŠ¶æ€
            const permission = Notification.permission;
            console.log(`[Notification] æƒé™çŠ¶æ€: ${permission}`);
            addLog('info', `é€šçŸ¥æƒé™çŠ¶æ€: ${permission}`);
            
            if (permission === "granted") {
                try {
                    console.log(`[Notification] âœ“ æƒé™å·²æˆäºˆï¼Œç«‹å³å‘é€é€šçŸ¥...`);
                    const notification = new Notification(title, { 
                        body: body,
                        icon: 'https://img.heliar.top/file/1770541813634_æ— æ ‡é¢˜434_20260208170943.png',
                        badge: 'https://img.heliar.top/file/1770541813634_æ— æ ‡é¢˜434_20260208170943.png',
                        tag: 'chat-message-' + Date.now(), // æ¯æ¬¡éƒ½ç”¨æ–°tagï¼Œé¿å…è¢«æ›¿æ¢
                        requireInteraction: false,
                        silent: false
                    });
                    
                    notification.onclick = function() {
                        window.focus();
                        this.close();
                    };
                    
                    console.log('[Notification] âœ“âœ“âœ“ é€šçŸ¥å·²æˆåŠŸå‘é€ï¼');
                    showDebugToast(`âœ“ é€šçŸ¥: ${title}`);
                } catch (error) {
                    console.error('[Notification] âœ—âœ—âœ— å‘é€å¤±è´¥:', error);
                    showDebugToast(`âœ— é€šçŸ¥å¤±è´¥: ${error.message}`);
                }
            } else if (permission === "default") {
                console.log('[Notification] æƒé™æœªè®¾ç½®ï¼Œè¯·æ±‚æƒé™...');
                Notification.requestPermission().then(permission => {
                    console.log(`[Notification] æƒé™è¯·æ±‚ç»“æœ: ${permission}`);
                    if (permission === "granted") {
                        try {
                            new Notification(title, { 
                                body: body,
                                icon: 'https://img.heliar.top/file/1770541813634_æ— æ ‡é¢˜434_20260208170943.png'
                            });
                            console.log('[Notification] âœ“ é€šçŸ¥å·²å‘é€ï¼ˆæƒé™æˆäºˆåï¼‰');
                        } catch (error) {
                            console.error('[Notification] âœ— å‘é€å¤±è´¥:', error);
                        }
                    } else {
                        console.warn('[Notification] âœ— æƒé™è¢«æ‹’ç»');
                    }
                });
            } else {
                console.error('[Notification] âœ—âœ—âœ— æƒé™å·²è¢«æ‹’ç»ï¼Œæ— æ³•å‘é€é€šçŸ¥');
                console.error('[Notification] è¯·åœ¨æµè§ˆå™¨è®¾ç½®ä¸­å…è®¸é€šçŸ¥æƒé™');
                showDebugToast('âœ— é€šçŸ¥æƒé™è¢«æ‹’ç»ï¼Œè¯·åœ¨è®¾ç½®ä¸­å…è®¸');
            }
            
            console.log(`[Notification] ========================================`);
        }

        // æ ‡è®°å·²è¯»ï¼ˆçº¯å‰ç«¯ï¼šæ›´æ–°æœ¬åœ°å­˜å‚¨ï¼‰
        async function markRead(id, isRead) {
            if (isRead) return; // å·²ç»æ˜¯å·²è¯»

            try {
                const notificationsJson = localStorage.getItem(`notifications_${currentUserId}`);
                const list = notificationsJson ? JSON.parse(notificationsJson) : [];
                
                const notif = list.find(n => n.id === id);
                if (notif) {
                    notif.is_read = true;
                    localStorage.setItem(`notifications_${currentUserId}`, JSON.stringify(list));
                }
                
                // é‡æ–°è·å–åˆ·æ–°åˆ—è¡¨
                fetchNotifications();
            } catch (err) {
                console.error('æ ‡è®°å·²è¯»å¤±è´¥:', err);
            }
        }

        // æ ¸å¿ƒï¼šæŠ˜å å±•å¼€åˆ‡æ¢
        function toggleExpand(id) {
            const expand = document.getElementById(id);
            const arrow = document.getElementById(`arrow${id.replace('expand','')}`);
            if (expand.style.display === 'flex') {
                expand.style.display = 'none';
                arrow.classList.remove('active');
                // arrow.innerText = 'â†’'; // SVGæ—‹è½¬
            } else {
                expand.style.display = 'flex';
                arrow.classList.add('active');
                // arrow.innerText = 'â†‘'; // SVGæ—‹è½¬
            }
        }

        // å…¨å±€å­—ä½“è®¾ç½®ç›¸å…³å‡½æ•°
        let customFontStyleElement = null;
        
        // é¢„è§ˆè‡ªå®šä¹‰å­—ä½“
        function previewCustomFont() {
            const fontUrl = document.getElementById('custom-font-input').value.trim();
            const fontName = document.getElementById('custom-font-name-input').value.trim();
            
            if (!fontUrl || !fontName) {
                alert('è¯·å¡«å†™å­—ä½“é“¾æ¥å’Œå­—ä½“åç§°');
                return;
            }
            
            // åŠ¨æ€åŠ è½½å­—ä½“æ ·å¼
            loadCustomFont(fontUrl, fontName, true);
        }
        
        // åŠ è½½å¹¶åº”ç”¨è‡ªå®šä¹‰å­—ä½“ï¼ˆæ”¯æŒ Google Fonts CSS é“¾æ¥ å’Œ TTF/WOFF/WOFF2/OTF ç›´é“¾ï¼‰
        function loadCustomFont(fontUrl, fontName, previewOnly = false) {
            // ç§»é™¤æ—§çš„å­—ä½“æ ·å¼
            const oldLink = document.getElementById('custom-font-link');
            if (oldLink) oldLink.remove();
            const oldFontFace = document.getElementById('custom-font-face');
            if (oldFontFace) oldFontFace.remove();
            
            // åˆ¤æ–­æ˜¯å¦ä¸ºå­—ä½“æ–‡ä»¶ç›´é“¾ï¼ˆTTFã€WOFFã€WOFF2ã€OTFï¼‰
            const fontFileMatch = fontUrl.match(/\.(ttf|woff2?|otf)(\?.*)?$/i);
            
            if (fontFileMatch) {
                // === å­—ä½“æ–‡ä»¶ç›´é“¾æ¨¡å¼ï¼šä½¿ç”¨ @font-face åŠ è½½ ===
                const ext = fontFileMatch[1].toLowerCase();
                let format = 'truetype';
                if (ext === 'woff') format = 'woff';
                else if (ext === 'woff2') format = 'woff2';
                else if (ext === 'otf') format = 'opentype';
                
                const fontFaceStyle = document.createElement('style');
                fontFaceStyle.id = 'custom-font-face';
                fontFaceStyle.textContent = `
                    @font-face {
                        font-family: "${fontName}";
                        src: url("${fontUrl}") format("${format}");
                        font-weight: normal;
                        font-style: normal;
                        font-display: swap;
                    }
                `;
                document.head.appendChild(fontFaceStyle);
                
                // ä½¿ç”¨ FontFace API æ£€æµ‹å­—ä½“æ˜¯å¦åŠ è½½æˆåŠŸ
                if (window.FontFace) {
                    const font = new FontFace(fontName, `url(${fontUrl})`);
                    font.load().then(() => {
                        document.fonts.add(font);
                        console.log(`[Font] âœ“ å­—ä½“ "${fontName}" åŠ è½½æˆåŠŸ (${ext}ç›´é“¾)`);
                        if (previewOnly) {
                            const previewText = document.getElementById('font-preview-text');
                            previewText.style.fontFamily = `"${fontName}", sans-serif`;
                            previewText.innerText = `è¿™æ˜¯å­—ä½“é¢„è§ˆæ•ˆæœ ABC 123\n${fontName}`;
                        } else {
                            applyFontGlobal(fontName);
                        }
                    }).catch(err => {
                        console.error(`[Font] âœ— å­—ä½“åŠ è½½å¤±è´¥:`, err);
                        showToast('âŒ å­—ä½“åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥é“¾æ¥æ˜¯å¦æ­£ç¡®');
                    });
                } else {
                    // é™çº§ï¼šç­‰å¾…ä¸€å°æ®µæ—¶é—´åå°è¯•åº”ç”¨
                    setTimeout(() => {
                        if (previewOnly) {
                            const previewText = document.getElementById('font-preview-text');
                            previewText.style.fontFamily = `"${fontName}", sans-serif`;
                            previewText.innerText = `è¿™æ˜¯å­—ä½“é¢„è§ˆæ•ˆæœ ABC 123\n${fontName}`;
                        } else {
                            applyFontGlobal(fontName);
                        }
                    }, 2000);
                }
            } else {
                // === CSS é“¾æ¥æ¨¡å¼ï¼ˆGoogle Fonts ç­‰ï¼‰===
                const link = document.createElement('link');
                link.id = 'custom-font-link';
                link.rel = 'stylesheet';
                link.href = fontUrl;
                document.head.appendChild(link);
                
                link.onload = function() {
                    console.log(`[Font] âœ“ å­—ä½“æ ·å¼è¡¨åŠ è½½æˆåŠŸ: ${fontUrl}`);
                    if (previewOnly) {
                        const previewText = document.getElementById('font-preview-text');
                        previewText.style.fontFamily = `"${fontName}", sans-serif`;
                        previewText.innerText = `è¿™æ˜¯å­—ä½“é¢„è§ˆæ•ˆæœ ABC 123\n${fontName}`;
                    } else {
                        applyFontGlobal(fontName);
                    }
                };
                
                link.onerror = function() {
                    showToast('âŒ å­—ä½“åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥é“¾æ¥æ˜¯å¦æ­£ç¡®');
                };
            }
        }
        
        // åº”ç”¨å­—ä½“åˆ°å…¨å±€ï¼ˆæ’é™¤å›¾æ ‡/ç­‰å®½/SVGç­‰ç‰¹æ®Šå…ƒç´ ï¼Œé¿å…å½±å“å¸ƒå±€ï¼‰
        function applyFontGlobal(fontName) {
            // ç§»é™¤æ—§çš„å…¨å±€å­—ä½“æ ·å¼
            if (customFontStyleElement) {
                customFontStyleElement.remove();
            }
            
            // åˆ›å»ºæ–°çš„æ ·å¼å…ƒç´  â€”â€” é€šè¿‡ body ç»§æ‰¿ï¼Œè€Œé * å¼ºåˆ¶è¦†ç›–
            customFontStyleElement = document.createElement('style');
            customFontStyleElement.id = 'custom-font-global';
            customFontStyleElement.textContent = `
                /* å…¨å±€è¦†ç›–ï¼šåº”ç”¨è‡ªå®šä¹‰å­—ä½“åˆ°æ‰€æœ‰æ–‡æœ¬å…ƒç´  */
                * {
                    font-family: "${fontName}", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif !important;
                }
                /* ä¿æŒç­‰å®½å­—ä½“ä¸å—å½±å“ */
                code, pre, .monospace,
                #json-preview-content,
                #summary-detail-content-edit {
                    font-family: "${fontName}", 'Courier New', 'Consolas', 'Monaco', monospace !important;
                }
                /* æ—¥å†ç‰¹æ®Šå­—ä½“ä¿æŒ */
                .current-date-btn,
                .sel-year-item,
                .time-input {
                    font-family: "${fontName}", 'Playfair Display', serif !important;
                }
            `;
            document.head.appendChild(customFontStyleElement);
        }
        
        // ä¿å­˜å¹¶åº”ç”¨è‡ªå®šä¹‰å­—ä½“ï¼ˆç«‹å³ç”Ÿæ•ˆ+æŒä¹…åŒ–ï¼‰
        async function saveAndApplyFont() {
            const fontUrl = document.getElementById('custom-font-input').value.trim();
            const fontName = document.getElementById('custom-font-name-input').value.trim();
            
            if (!fontUrl || !fontName) {
                showToast('è¯·å…ˆå¡«å†™å­—ä½“é“¾æ¥å’Œå­—ä½“åç§°');
                return;
            }
            
            // åº”ç”¨å­—ä½“
            loadCustomFont(fontUrl, fontName, false);
            
            // æŒä¹…åŒ–åˆ°æ•°æ®åº“
            try {
                await db.dexiData.put({ key: 'customFontUrl', value: fontUrl });
                await db.dexiData.put({ key: 'customFontName', value: fontName });
                showToast('âœ… å­—ä½“å·²ä¿å­˜å¹¶åº”ç”¨');
            } catch (e) {
                console.error('[Font] ä¿å­˜å­—ä½“å¤±è´¥:', e);
                showToast('âš ï¸ å­—ä½“å·²åº”ç”¨ä½†ä¿å­˜å¤±è´¥');
            }
        }

        // æ¸…é™¤è‡ªå®šä¹‰å­—ä½“ï¼Œæ¢å¤é»˜è®¤
        async function clearCustomFont() {
            // æ¸…é™¤è¾“å…¥æ¡†
            document.getElementById('custom-font-input').value = '';
            document.getElementById('custom-font-name-input').value = '';
            
            // ç§»é™¤å­—ä½“é“¾æ¥å’Œå…¨å±€æ ·å¼
            const fontLink = document.getElementById('custom-font-link');
            if (fontLink) fontLink.remove();
            
            // ç§»é™¤ @font-face æ ·å¼ï¼ˆTTFç›´é“¾æ¨¡å¼ï¼‰
            const fontFace = document.getElementById('custom-font-face');
            if (fontFace) fontFace.remove();
            
            if (customFontStyleElement) {
                customFontStyleElement.remove();
                customFontStyleElement = null;
            }
            
            // é‡ç½®é¢„è§ˆåŒºåŸŸ
            const previewText = document.getElementById('font-preview-text');
            previewText.style.fontFamily = '';
            previewText.innerText = 'è¿™æ˜¯å­—ä½“é¢„è§ˆæ•ˆæœ ABC 123';
            
            // æ¸…é™¤æ•°æ®åº“ä¸­çš„å­—ä½“è®¾ç½®
            try {
                await db.dexiData.put({ key: 'customFontUrl', value: '' });
                await db.dexiData.put({ key: 'customFontName', value: '' });
            } catch (e) {
                console.error('[Font] æ¸…é™¤å­—ä½“è®¾ç½®å¤±è´¥:', e);
            }
            
            showToast('âœ… å·²æ¢å¤é»˜è®¤å­—ä½“');
        }
        
        // æ¡Œé¢æ–‡å­—é¢œè‰²ç›¸å…³
        let desktopTextColorStyleElement = null;
        
        function applyDesktopTextColor(color) {
            if (!color) return;
            
            // ç§»é™¤æ—§æ ·å¼
            if (desktopTextColorStyleElement) {
                desktopTextColorStyleElement.remove();
            }
            
            // åˆ›å»ºæ–°çš„æ ·å¼è¦†ç›–
            desktopTextColorStyleElement = document.createElement('style');
            desktopTextColorStyleElement.id = 'desktop-text-color-style';
            desktopTextColorStyleElement.textContent = `
                .app-icon .name,
                .dock-icon .name,
                .top-widget .text .title,
                .top-widget .text .subtext,
                .circle-photo .name,
                .circle-photo .bubble,
                .days-capsule .capsule {
                    color: ${color} !important;
                }
            `;
            document.head.appendChild(desktopTextColorStyleElement);
        }

        // åŒæ­¥é¢„è§ˆåŒºå’Œè¾“å…¥æ¡†
        function syncPreview() {
            // å£çº¸é¢„è§ˆ
            const bg = document.getElementById('desktop-body').style.backgroundImage;
            if (bg) {
                document.getElementById('wallpaper-preview').style.backgroundImage = bg;
                document.getElementById('wallpaper-preview').innerText = '';
            }
            // å°ç»„ä»¶
            document.getElementById('widget-icon-preview').style.backgroundImage = document.getElementById('widget-icon').style.backgroundImage;
            document.getElementById('widget-title-input').value = document.getElementById('widget-title').innerText.replace(/\{|\}/g, '').trim();
            document.getElementById('widget-subtext-input').value = document.getElementById('widget-subtext').innerText.trim();
            // æ‹ç«‹å¾—
            document.getElementById('photo-left-preview').style.backgroundImage = document.getElementById('img-left').style.backgroundImage;
            document.getElementById('photo-right-preview').style.backgroundImage = document.getElementById('img-right').style.backgroundImage;
            // å¤´åƒ
            document.getElementById('avatar1-preview').style.backgroundImage = document.getElementById('avatar-img-1').style.backgroundImage;
            document.getElementById('avatar2-preview').style.backgroundImage = document.getElementById('avatar-img-2').style.backgroundImage;
            document.getElementById('avatar1-bubble-input').value = document.getElementById('avatar-bubble1').innerText.trim();
            document.getElementById('avatar1-name-input').value = document.getElementById('avatar-name1').innerText.trim();
            document.getElementById('avatar2-bubble-input').value = document.getElementById('avatar-bubble2').innerText.trim();
            document.getElementById('avatar2-name-input').value = document.getElementById('avatar-name2').innerText.trim();
            // å€’æ•°æ—¥
            document.getElementById('days-input').value = document.getElementById('days-text').innerText.trim();
            // æ¤­åœ†å½¢é¢œè‰²
            const heartColor = getComputedStyle(document.documentElement).getPropertyValue('--heart-color').trim() || '#ffb6c1';
            const capsuleColor = getComputedStyle(document.documentElement).getPropertyValue('--capsule-bg').trim() || '#FFF7FA';
            const bubbleColor = getComputedStyle(document.documentElement).getPropertyValue('--bubble-bg').trim() || '#FFF7FA';
            document.getElementById('heart-color-input').value = heartColor;
            document.getElementById('capsule-color-input').value = capsuleColor;
            document.getElementById('bubble-color-input').value = bubbleColor;
            // æ¡Œé¢æ–‡å­—é¢œè‰²åŒæ­¥
            const dtcEl = document.getElementById('desktop-text-color-input');
            if (dtcEl) {
                // ä»å·²æœ‰çš„æ ·å¼ä¸­è¯»å–å½“å‰é¢œè‰²ï¼Œæˆ–ä¿ç•™è¾“å…¥æ¡†å½“å‰å€¼
                const existingStyle = document.getElementById('desktop-text-color-style');
                if (!existingStyle && dtcEl.value === '#999999') {
                    // é»˜è®¤å€¼ï¼Œä¸åšä»»ä½•äº‹
                }
            }
            // åŒæ­¥åº”ç”¨/Dockå›¾æ ‡é¢„è§ˆ
            document.querySelectorAll('.icon-select-item[data-icon-id]').forEach(item => {
                const iconId = item.getAttribute('data-icon-id');
                const desktopIcon = document.getElementById(`icon-${iconId}`)?.querySelector('.icon') || document.getElementById(`dock-${iconId}`)?.querySelector('.icon');
                const previewIcon = item.querySelector('.icon');
                if (desktopIcon && previewIcon) {
                    previewIcon.style.backgroundImage = desktopIcon.style.backgroundImage;
                    previewIcon.style.backgroundSize = 'cover';
                    previewIcon.style.backgroundPosition = 'center';
                }
            });
            // å­—ä½“é¢„è§ˆåŒæ­¥
            const fontName = document.getElementById('custom-font-name-input').value.trim();
            const previewText = document.getElementById('font-preview-text');
            if (fontName && previewText) {
                previewText.style.fontFamily = `"${fontName}", sans-serif`;
                previewText.innerText = `è¿™æ˜¯å­—ä½“é¢„è§ˆæ•ˆæœ ABC 123\n${fontName}`;
            }
        }

        // é¡µé¢åˆ‡æ¢
        function showCustomPage() {
            document.getElementById('home-page').style.display = 'none';
            document.getElementById('custom-main-page').style.display = 'flex';
            syncPreview();
        }
        function backHomePage() {
            document.getElementById('custom-main-page').style.display = 'none';
            document.getElementById('home-page').style.display = 'block';
        }

        // å„é¡¹è‡ªå®šä¹‰æ–¹æ³•ï¼ˆä¿®æ”¹åè‡ªåŠ¨ä¿å­˜åˆ°Dexieï¼‰
        function setWallpaper(input) {
            const file = input.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = e => {
                    applyWallpaper(e.target.result);
                };
                reader.readAsDataURL(file);
            }
            input.value = '';
        }
        function selectIcon(iconId) {
            currentSelectIcon = iconId;
            document.getElementById('custom-icon-input').click();
        }
        function setCustomIcon(input) {
            const file = input.files[0];
            if (file && currentSelectIcon) {
                const reader = new FileReader();
                reader.onload = e => {
                    applyIcon(currentSelectIcon, e.target.result);
                };
                reader.readAsDataURL(file);
            }
            input.value = '';
        }
        function setWidgetIcon(input) {
            const file = input.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = e => {
                    applyWidgetIcon(e.target.result);
                };
                reader.readAsDataURL(file);
            }
            input.value = '';
        }
        function setPhoto(pos, input) {
            const file = input.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = e => {
                    applyPhoto(pos, e.target.result);
                };
                reader.readAsDataURL(file);
            }
            input.value = '';
        }
        function setAvatar(id, input) {
            const file = input.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = e => {
                    applyAvatar(id, e.target.result);
                };
                reader.readAsDataURL(file);
            }
            input.value = '';
        }

        // ===== ç»Ÿä¸€ apply å‡½æ•°ï¼ˆåŒæ—¶æ›´æ–°æ¡Œé¢ + è®¾ç½®é¡µé¢„è§ˆï¼‰ =====
        function applyWallpaper(url) {
            document.getElementById('desktop-body').style.backgroundImage = `url(${url})`;
            const preview = document.getElementById('wallpaper-preview');
            if (preview) { preview.style.backgroundImage = `url(${url})`; preview.innerText = ''; }
            autoSaveCustomization();
        }
        function applyIcon(iconId, url, triggerEl) {
            let iconDom = document.getElementById(`icon-${iconId}`)?.querySelector('.icon') || document.getElementById(`dock-${iconId}`)?.querySelector('.icon');
            if (iconDom) iconDom.style.backgroundImage = `url(${url})`;
            // åŒæ­¥è®¾ç½®é¡µå›¾æ ‡é¢„è§ˆ
            const settingsItem = document.querySelector(`.icon-select-item[data-icon-id="${iconId}"] .icon`);
            if (settingsItem) settingsItem.style.backgroundImage = `url(${url})`;
            if (triggerEl) {
                const previewIcon = triggerEl.querySelector('.icon');
                if (previewIcon) previewIcon.style.backgroundImage = `url(${url})`;
            }
            autoSaveCustomization();
        }
        function applyWidgetIcon(url) {
            document.getElementById('widget-icon').style.backgroundImage = `url(${url})`;
            const preview = document.getElementById('widget-icon-preview');
            if (preview) preview.style.backgroundImage = `url(${url})`;
            autoSaveCustomization();
        }
        function applyPhoto(pos, url) {
            document.getElementById(`img-${pos}`).style.backgroundImage = `url(${url})`;
            const preview = document.getElementById(`photo-${pos}-preview`);
            if (preview) preview.style.backgroundImage = `url(${url})`;
            autoSaveCustomization();
        }
        function applyAvatar(id, url) {
            const img = document.getElementById(`avatar-img-${id}`);
            if (img) { img.style.backgroundImage = `url(${url})`; img.classList.add('has-image'); }
            const preview = document.getElementById(`avatar${id}-preview`);
            if (preview) preview.style.backgroundImage = `url(${url})`;
            autoSaveCustomization();
        }

        // ===== ç»Ÿä¸€å›¾ç‰‡é€‰æ‹©å¼¹çª— =====
        let _imgPickerCallback = null;
        function showImagePicker(config) {
            // config: { onApply: function(url) }
            const existing = document.getElementById('image-picker-modal');
            if (existing) existing.remove();
            _imgPickerCallback = config.onApply;

            const overlay = document.createElement('div');
            overlay.id = 'image-picker-modal';
            overlay.className = 'image-picker-overlay';
            overlay.innerHTML = `
                <div class="image-picker-card">
                    <div class="image-picker-title">é€‰æ‹©å›¾ç‰‡æ¥æº</div>
                    <div class="image-picker-option" onclick="imagePickerFromGallery()">
                        <span style="font-size:20px;">ğŸ“·</span>
                        <span>ä»ç›¸å†Œé€‰æ‹©</span>
                    </div>
                    <div class="image-picker-option" onclick="imagePickerShowUrlInput()">
                        <span style="font-size:20px;">ğŸ”—</span>
                        <span>ç²˜è´´å›¾ç‰‡é“¾æ¥</span>
                    </div>
                    <div class="image-picker-url-area" id="image-picker-url-area" style="display:none;">
                        <input type="text" class="image-picker-url-input" id="image-picker-url-input" placeholder="ç²˜è´´å›¾ç‰‡é“¾æ¥åœ°å€" oninput="imagePickerPreviewUrl(this.value)">
                        <div class="image-picker-preview-box" id="image-picker-preview-box">å›¾ç‰‡é¢„è§ˆ</div>
                        <div class="image-picker-confirm" onclick="imagePickerConfirmUrl()">ç¡®è®¤ä½¿ç”¨</div>
                    </div>
                    <div class="image-picker-cancel" onclick="closeImagePicker()">å–æ¶ˆ</div>
                </div>
            `;
            overlay.onclick = (e) => { if (e.target === overlay) closeImagePicker(); };
            document.body.appendChild(overlay);
        }
        function imagePickerFromGallery() {
            let input = document.getElementById('image-picker-file-input');
            if (!input) {
                input = document.createElement('input');
                input.type = 'file';
                input.id = 'image-picker-file-input';
                input.accept = 'image/*';
                input.style.display = 'none';
                document.body.appendChild(input);
            }
            input.onchange = function() {
                const file = this.files[0];
                if (file && _imgPickerCallback) {
                    const reader = new FileReader();
                    reader.onload = e => {
                        _imgPickerCallback(e.target.result);
                        closeImagePicker();
                    };
                    reader.readAsDataURL(file);
                }
                this.value = '';
            };
            input.click();
        }
        function imagePickerShowUrlInput() {
            const area = document.getElementById('image-picker-url-area');
            if (area) area.style.display = 'flex';
        }
        function imagePickerPreviewUrl(url) {
            url = url.trim();
            const box = document.getElementById('image-picker-preview-box');
            if (!box) return;
            if (url) {
                box.style.backgroundImage = `url(${url})`;
                box.style.backgroundSize = 'cover';
                box.style.backgroundPosition = 'center';
                box.innerText = '';
            } else {
                box.style.backgroundImage = '';
                box.innerText = 'å›¾ç‰‡é¢„è§ˆ';
            }
        }
        function imagePickerConfirmUrl() {
            const url = document.getElementById('image-picker-url-input')?.value?.trim();
            if (url && _imgPickerCallback) {
                _imgPickerCallback(url);
            }
            closeImagePicker();
        }
        function closeImagePicker() {
            const modal = document.getElementById('image-picker-modal');
            if (modal) modal.remove();
            _imgPickerCallback = null;
        }
        // è®¾ç½®é¡µå›¾æ ‡ç‚¹å‡» â€”â€” å¼¹å‡ºå›¾ç‰‡é€‰æ‹©å™¨
        function selectIconPicker(el, iconId) {
            showImagePicker({
                onApply: (url) => applyIcon(iconId, url, el)
            });
        }
        
        // è‡ªåŠ¨ä¿å­˜ä¸ªæ€§åŒ–è®¾ç½®ï¼ˆé˜²æŠ–ï¼Œé¿å…é¢‘ç¹å†™å…¥ï¼‰
        let _autoSaveTimer = null;
        function autoSaveCustomization() {
            if (_autoSaveTimer) clearTimeout(_autoSaveTimer);
            _autoSaveTimer = setTimeout(async () => {
                try {
                    // ä¿å­˜æ‰€æœ‰å›¾ç‰‡ç›¸å…³çš„æ•°æ®åˆ°Dexie
                    const saveItems = {};
                    
                    // å£çº¸
                    const wallpaper = document.getElementById('desktop-body')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '';
                    if (wallpaper) saveItems.wallpaper = wallpaper;
                    
                    // å°ç»„ä»¶å›¾æ ‡
                    const widgetIcon = document.getElementById('widget-icon')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '';
                    if (widgetIcon) saveItems.widgetIcon = widgetIcon;
                    
                    // æ‹ç«‹å¾—
                    const photoLeft = document.getElementById('img-left')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '';
                    const photoRight = document.getElementById('img-right')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '';
                    if (photoLeft) saveItems.photoLeft = photoLeft;
                    if (photoRight) saveItems.photoRight = photoRight;
                    
                    // å¤´åƒ
                    const avatar1 = document.getElementById('avatar-img-1')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '';
                    const avatar2 = document.getElementById('avatar-img-2')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '';
                    if (avatar1) saveItems.avatar1 = avatar1;
                    if (avatar2) saveItems.avatar2 = avatar2;
                    
                    // åº”ç”¨å›¾æ ‡
                    const iconIds = ['appstore','notes','remind','facetime','photo','xianyu','cabin','icity'];
                    iconIds.forEach(id => {
                        const el = document.getElementById(`icon-${id}`)?.querySelector('.icon');
                        if (el?.style.backgroundImage) {
                            const val = el.style.backgroundImage.replace(/url\(|\)|"/g, '');
                            if (val) saveItems[`icon${id.charAt(0).toUpperCase() + id.slice(1)}`] = val;
                        }
                    });
                    
                    // Dockå›¾æ ‡
                    const dockIds = ['setting','custom','message','phone'];
                    dockIds.forEach(id => {
                        const el = document.getElementById(`dock-${id}`)?.querySelector('.icon');
                        if (el?.style.backgroundImage) {
                            const val = el.style.backgroundImage.replace(/url\(|\)|"/g, '');
                            if (val) saveItems[`dock${id.charAt(0).toUpperCase() + id.slice(1)}`] = val;
                        }
                    });
                    
                    // å†™å…¥Dexie
                    for (const [key, value] of Object.entries(saveItems)) {
                        await db.dexiData.put({ key, value });
                    }
                    
                    console.log('[AutoSave] âœ“ å›¾æ ‡/å£çº¸è‡ªåŠ¨ä¿å­˜æˆåŠŸ');
                } catch (err) {
                    console.error('[AutoSave] âœ— è‡ªåŠ¨ä¿å­˜å¤±è´¥:', err);
                }
            }, 500); // 500ms é˜²æŠ–
        }

        // --- API è®¾ç½®é€»è¾‘ (æŠ˜å ç‰ˆ) ---
        function toggleApiSetting() {
            const body = document.getElementById('api-setting-body');
            const arrow = document.getElementById('api-setting-arrow');
            if (body.style.display === 'block') {
                body.style.display = 'none';
                arrow.classList.remove('expanded');
            } else {
                body.style.display = 'block';
                arrow.classList.add('expanded');
                loadAiConfig(); // å±•å¼€æ—¶åŠ è½½
            }
        }

        function toggleKeyVis() {
            const input = document.getElementById('ai-key-input');
            // æ‰¾åˆ°å¯¹åº”çš„eye-iconï¼ˆåœ¨åŒä¸€ä¸ªapi-input-groupä¸­ï¼‰
            const inputGroup = input.closest('.api-input-group');
            const icon = inputGroup ? inputGroup.querySelector('.eye-icon') : null;
            if (input && icon) {
                if (input.type === 'password') {
                    input.type = 'text';
                    icon.textContent = 'éšè—';
                } else {
                    input.type = 'password';
                    icon.textContent = 'æ˜¾ç¤º';
                }
            }
        }

        function updateTempDisplay(val) {
            document.getElementById('temp-val-display').innerText = val;
        }
        
        // åŠ è½½ API é…ç½®
        async function loadAiConfig() {
            try {
                const urlItem = await db.dexiData.get('aiBaseUrl');
                const keyItem = await db.dexiData.get('aiApiKey');
                const modelItem = await db.dexiData.get('aiCurrentModel');
                const listItem = await db.dexiData.get('aiModelList');
                const tempItem = await db.dexiData.get('aiTemperature');

                if (urlItem) document.getElementById('ai-url-input').value = urlItem.value;
                if (keyItem) document.getElementById('ai-key-input').value = keyItem.value;
                if (tempItem) {
                    document.getElementById('ai-temp-slider').value = tempItem.value;
                    updateTempDisplay(tempItem.value);
                }
                
                // æ¢å¤ä¸‹æ‹‰æ¡†
                const select = document.getElementById('ai-model-select');
                if (listItem && listItem.value) {
                    const models = JSON.parse(listItem.value);
                    select.innerHTML = '<option value="" disabled>è¯·é€‰æ‹©æ¨¡å‹</option>';
                    models.forEach(m => {
                        const opt = document.createElement('option');
                        opt.value = m.id;
                        opt.text = m.id;
                        select.appendChild(opt);
                    });
                }
                
                if (modelItem) {
                    select.value = modelItem.value;
                }
                
                // ğŸ”§ åŒæ­¥å†…å­˜ç¼“å­˜
                _apiConfigCache = {
                    url: urlItem?.value || _apiConfigCache.url,
                    key: keyItem?.value || _apiConfigCache.key,
                    model: modelItem?.value || _apiConfigCache.model,
                    temp: tempItem?.value || _apiConfigCache.temp
                };
                
                // åŠ è½½é¢„è®¾åˆ—è¡¨
                await loadApiPresetList();
            } catch (e) {
                console.error("åŠ è½½ API é…ç½®å¤±è´¥", e);
            }
        }
        
        // ğŸ”§ APIé…ç½®å†…å­˜ç¼“å­˜ï¼ˆé˜²æ­¢IndexedDBå¶å‘è¯»å–å¤±è´¥å¯¼è‡´é…ç½®ä¸¢å¤±ï¼‰
        let _apiConfigCache = { url: '', key: '', model: '', temp: '0.7' };
        
        // è‡ªåŠ¨ä¿å­˜ API é…ç½® (æ¯æ¬¡è¾“å…¥å˜æ›´æ—¶)
        async function autoSaveApi() {
            const url = document.getElementById('ai-url-input').value.trim();
            const key = document.getElementById('ai-key-input').value.trim();
            const model = document.getElementById('ai-model-select').value;
            const temp = document.getElementById('ai-temp-slider').value;
            
            // ğŸ”§ é˜²å¾¡ï¼šå¦‚æœURLå’ŒKeyéƒ½ä¸ºç©ºï¼Œå¯èƒ½æ˜¯DOMè¿˜æ²¡åŠ è½½å¥½ï¼Œä¸è¦è¦†ç›–æ•°æ®åº“
            if (!url && !key) {
                console.warn('[autoSaveApi] URLå’ŒKeyå‡ä¸ºç©ºï¼Œè·³è¿‡ä¿å­˜ï¼ˆé˜²æ­¢è¦†ç›–æœ‰æ•ˆé…ç½®ï¼‰');
                return;
            }
            
            await db.dexiData.put({ key: 'aiBaseUrl', value: url });
            await db.dexiData.put({ key: 'aiApiKey', value: key });
            await db.dexiData.put({ key: 'aiCurrentModel', value: model });
            await db.dexiData.put({ key: 'aiTemperature', value: temp });
            
            // åŒæ­¥æ›´æ–°å†…å­˜ç¼“å­˜
            _apiConfigCache = { url, key, model, temp };
        }
        
        // ========== API é¢„è®¾ç®¡ç† ==========
        
        // åŠ è½½é¢„è®¾åˆ—è¡¨åˆ°ä¸‹æ‹‰æ¡†
        async function loadApiPresetList() {
            const select = document.getElementById('api-preset-select');
            if (!select) return;
            
            try {
                const presetsData = await db.dexiData.get('apiPresets');
                const presets = presetsData?.value ? JSON.parse(presetsData.value) : [];
                const currentPresetData = await db.dexiData.get('currentApiPreset');
                const currentPresetName = currentPresetData?.value || '';
                
                select.innerHTML = '<option value="">-- é€‰æ‹©é¢„è®¾ --</option>';
                presets.forEach(preset => {
                    const opt = document.createElement('option');
                    opt.value = preset.name;
                    opt.textContent = preset.name;
                    if (preset.name === currentPresetName) {
                        opt.selected = true;
                    }
                    select.appendChild(opt);
                });
            } catch (e) {
                console.error('åŠ è½½APIé¢„è®¾åˆ—è¡¨å¤±è´¥:', e);
            }
        }
        
        // ä¿å­˜å½“å‰é…ç½®ä¸ºé¢„è®¾
        async function saveApiPreset() {
            const name = prompt('è¯·è¾“å…¥é¢„è®¾åç§°ï¼š');
            if (!name || !name.trim()) return;
            
            const presetName = name.trim();
            const url = document.getElementById('ai-url-input').value.trim();
            const key = document.getElementById('ai-key-input').value.trim();
            const model = document.getElementById('ai-model-select').value;
            const temp = document.getElementById('ai-temp-slider').value;
            const modelListData = await db.dexiData.get('aiModelList');
            const modelList = modelListData?.value || '[]';
            
            const newPreset = {
                name: presetName,
                url: url,
                key: key,
                model: model,
                temperature: temp,
                modelList: modelList
            };
            
            try {
                const presetsData = await db.dexiData.get('apiPresets');
                let presets = presetsData?.value ? JSON.parse(presetsData.value) : [];
                
                // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨åŒåé¢„è®¾
                const existingIndex = presets.findIndex(p => p.name === presetName);
                if (existingIndex >= 0) {
                    if (!confirm(`é¢„è®¾"${presetName}"å·²å­˜åœ¨ï¼Œæ˜¯å¦è¦†ç›–ï¼Ÿ`)) return;
                    presets[existingIndex] = newPreset;
                } else {
                    presets.push(newPreset);
                }
                
                await db.dexiData.put({ key: 'apiPresets', value: JSON.stringify(presets) });
                await db.dexiData.put({ key: 'currentApiPreset', value: presetName });
                
                await loadApiPresetList();
                alert(`é¢„è®¾"${presetName}"å·²ä¿å­˜ï¼`);
            } catch (e) {
                console.error('ä¿å­˜APIé¢„è®¾å¤±è´¥:', e);
                alert('ä¿å­˜é¢„è®¾å¤±è´¥ï¼š' + e.message);
            }
        }
        
        // åŠ è½½é€‰ä¸­çš„é¢„è®¾
        async function loadApiPreset(presetName) {
            if (!presetName) return;
            
            try {
                const presetsData = await db.dexiData.get('apiPresets');
                const presets = presetsData?.value ? JSON.parse(presetsData.value) : [];
                const preset = presets.find(p => p.name === presetName);
                
                if (!preset) {
                    alert('é¢„è®¾ä¸å­˜åœ¨');
                    return;
                }
                
                // åº”ç”¨é¢„è®¾åˆ°è¾“å…¥æ¡†
                document.getElementById('ai-url-input').value = preset.url || '';
                document.getElementById('ai-key-input').value = preset.key || '';
                document.getElementById('ai-temp-slider').value = preset.temperature || '0.7';
                updateTempDisplay(preset.temperature || '0.7');
                
                // æ¢å¤æ¨¡å‹åˆ—è¡¨å’Œé€‰æ‹©
                const select = document.getElementById('ai-model-select');
                if (preset.modelList) {
                    try {
                        const models = JSON.parse(preset.modelList);
                        select.innerHTML = '<option value="" disabled>è¯·é€‰æ‹©æ¨¡å‹</option>';
                        models.forEach(m => {
                            const opt = document.createElement('option');
                            opt.value = m.id;
                            opt.text = m.id;
                            select.appendChild(opt);
                        });
                    } catch (e) {
                        select.innerHTML = '<option value="" disabled>è¯·æ‹‰å–</option>';
                    }
                }
                if (preset.model) {
                    select.value = preset.model;
                }
                
                // ä¿å­˜åˆ°æ•°æ®åº“
                await db.dexiData.put({ key: 'aiBaseUrl', value: preset.url || '' });
                await db.dexiData.put({ key: 'aiApiKey', value: preset.key || '' });
                await db.dexiData.put({ key: 'aiCurrentModel', value: preset.model || '' });
                await db.dexiData.put({ key: 'aiTemperature', value: preset.temperature || '0.7' });
                await db.dexiData.put({ key: 'aiModelList', value: preset.modelList || '[]' });
                await db.dexiData.put({ key: 'currentApiPreset', value: presetName });
                
                // ğŸ”§ åŒæ­¥æ›´æ–°å†…å­˜ç¼“å­˜
                _apiConfigCache = {
                    url: preset.url || '',
                    key: preset.key || '',
                    model: preset.model || '',
                    temp: preset.temperature || '0.7'
                };
                
            } catch (e) {
                console.error('åŠ è½½APIé¢„è®¾å¤±è´¥:', e);
                alert('åŠ è½½é¢„è®¾å¤±è´¥ï¼š' + e.message);
            }
        }
        
        // åˆ é™¤å½“å‰é€‰ä¸­çš„é¢„è®¾
        async function deleteApiPreset() {
            const select = document.getElementById('api-preset-select');
            const presetName = select.value;
            
            if (!presetName) {
                alert('è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„é¢„è®¾');
                return;
            }
            
            if (!confirm(`ç¡®å®šè¦åˆ é™¤é¢„è®¾"${presetName}"å—ï¼Ÿ`)) return;
            
            try {
                const presetsData = await db.dexiData.get('apiPresets');
                let presets = presetsData?.value ? JSON.parse(presetsData.value) : [];
                
                presets = presets.filter(p => p.name !== presetName);
                await db.dexiData.put({ key: 'apiPresets', value: JSON.stringify(presets) });
                
                // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰é¢„è®¾ï¼Œæ¸…ç©ºå½“å‰é¢„è®¾æ ‡è®°
                const currentPresetData = await db.dexiData.get('currentApiPreset');
                if (currentPresetData?.value === presetName) {
                    await db.dexiData.put({ key: 'currentApiPreset', value: '' });
                }
                
                await loadApiPresetList();
                alert(`é¢„è®¾"${presetName}"å·²åˆ é™¤`);
            } catch (e) {
                console.error('åˆ é™¤APIé¢„è®¾å¤±è´¥:', e);
                alert('åˆ é™¤é¢„è®¾å¤±è´¥ï¼š' + e.message);
            }
        }

        // NovelAI è®¾ç½®ç›¸å…³å‡½æ•°
        function toggleNovelAISettings() {
            const body = document.getElementById('novelai-setting-body');
            const arrow = document.getElementById('novelai-setting-arrow');
            if (body.style.display === 'none') {
                body.style.display = 'block';
                arrow.textContent = 'â–²';
                loadNovelAIConfig(); // å±•å¼€æ—¶åŠ è½½
            } else {
                body.style.display = 'none';
                arrow.textContent = 'â–¼';
            }
        }

        // åˆ‡æ¢NovelAIå¯†é’¥æ˜¾ç¤º
        function toggleNovelAIKeyVis() {
            const input = document.getElementById('novelai-api-key');
            const inputGroup = input.closest('.api-input-group');
            const icon = inputGroup ? inputGroup.querySelector('.eye-icon') : null;
            if (input && icon) {
                if (input.type === 'password') {
                    input.type = 'text';
                    icon.textContent = 'éšè—';
                } else {
                    input.type = 'password';
                    icon.textContent = 'æ˜¾ç¤º';
                }
            }
        }

        // æ›´æ–°NovelAIé‡‡æ ·æ­¥æ•°æ˜¾ç¤º
        function updateNovelAIStepsDisplay(val) {
            const display = document.getElementById('novelai-steps-value');
            if (display) display.textContent = val;
        }

        // æ›´æ–°NovelAIå¼•å¯¼å¼ºåº¦æ˜¾ç¤º
        function updateNovelAIScaleDisplay(val) {
            const display = document.getElementById('novelai-scale-value');
            if (display) display.textContent = val;
        }

        // åŠ è½½ NovelAI é…ç½®
        async function loadNovelAIConfig() {
            try {
                const apiKeyItem = await db.dexiData.get('novelaiApiKey');
                const proxyUrlItem = await db.dexiData.get('novelaiProxyUrl');
                const modelItem = await db.dexiData.get('novelaiModel');
                const stepsItem = await db.dexiData.get('novelaiSteps');
                const scaleItem = await db.dexiData.get('novelaiScale');
                const samplerItem = await db.dexiData.get('novelaiSampler');
                const sizeItem = await db.dexiData.get('novelaiSize');
                const systemPromptItem = await db.dexiData.get('novelaiSystemPrompt');
                const negativePromptItem = await db.dexiData.get('novelaiNegativePrompt');

                if (apiKeyItem) document.getElementById('novelai-api-key').value = apiKeyItem.value;
                if (proxyUrlItem) document.getElementById('novelai-proxy-url').value = proxyUrlItem.value;
                if (modelItem) document.getElementById('novelai-model').value = modelItem.value;
                if (stepsItem) {
                    document.getElementById('novelai-steps').value = stepsItem.value;
                    updateNovelAIStepsDisplay(stepsItem.value);
                }
                if (scaleItem) {
                    document.getElementById('novelai-scale').value = scaleItem.value;
                    updateNovelAIScaleDisplay(scaleItem.value);
                }
                if (samplerItem) document.getElementById('novelai-sampler').value = samplerItem.value;
                if (sizeItem) document.getElementById('novelai-size').value = sizeItem.value;
                if (systemPromptItem) document.getElementById('novelai-system-prompt').value = systemPromptItem.value;
                if (negativePromptItem) document.getElementById('novelai-negative-prompt').value = negativePromptItem.value;
            } catch (e) {
                console.error("åŠ è½½ NovelAI é…ç½®å¤±è´¥", e);
            }
        }

        // è‡ªåŠ¨ä¿å­˜ NovelAI é…ç½®
        async function autoSaveNovelAI() {
            const apiKey = document.getElementById('novelai-api-key').value.trim();
            const proxyUrl = document.getElementById('novelai-proxy-url').value.trim();
            const model = document.getElementById('novelai-model').value;
            const steps = document.getElementById('novelai-steps').value;
            const scale = document.getElementById('novelai-scale').value;
            const sampler = document.getElementById('novelai-sampler').value;
            const size = document.getElementById('novelai-size').value;
            const systemPrompt = document.getElementById('novelai-system-prompt').value.trim();
            const negativePrompt = document.getElementById('novelai-negative-prompt').value.trim();

            await db.dexiData.put({ key: 'novelaiApiKey', value: apiKey });
            await db.dexiData.put({ key: 'novelaiProxyUrl', value: proxyUrl });
            await db.dexiData.put({ key: 'novelaiModel', value: model });
            await db.dexiData.put({ key: 'novelaiSteps', value: steps });
            await db.dexiData.put({ key: 'novelaiScale', value: scale });
            await db.dexiData.put({ key: 'novelaiSampler', value: sampler });
            await db.dexiData.put({ key: 'novelaiSize', value: size });
            await db.dexiData.put({ key: 'novelaiSystemPrompt', value: systemPrompt });
            await db.dexiData.put({ key: 'novelaiNegativePrompt', value: negativePrompt });
        }

        // æµ‹è¯• NovelAI è¿æ¥
        async function testNovelAIConnection() {
            const apiKey = document.getElementById('novelai-api-key').value.trim();
            const proxyUrl = document.getElementById('novelai-proxy-url').value.trim();
            const resultDiv = document.getElementById('novelai-test-result');
            const btnText = document.getElementById('test-novelai-btn-text');

            if (!apiKey) {
                resultDiv.textContent = 'âŒ è¯·å…ˆè¾“å…¥ NovelAI API Key';
                resultDiv.style.color = '#ff3b30';
                return;
            }

            btnText.textContent = 'æµ‹è¯•ä¸­...';
            resultDiv.textContent = 'â³ æ­£åœ¨æµ‹è¯•è¿æ¥...';
            resultDiv.style.color = '#999';

            try {
                const testUrl = proxyUrl || 'https://image.novelai.net/ai/generate-image';
                
                // æ„é€ æµ‹è¯•è¯·æ±‚ï¼ˆä½¿ç”¨æœ€å°å‚æ•°ï¼‰
                const testPayload = {
                    input: 'test',
                    model: 'nai-diffusion-3',
                    action: 'generate',
                    parameters: {
                        width: 512,
                        height: 512,
                        scale: 7,
                        sampler: 'k_euler_ancestral',
                        steps: 1,
                        n_samples: 1,
                        seed: 0
                    }
                };

                const response = await fetch(testUrl, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(testPayload)
                });

                if (response.ok) {
                    resultDiv.textContent = 'âœ… NovelAI è¿æ¥æˆåŠŸï¼';
                    resultDiv.style.color = '#34C759';
                } else {
                    const errorText = await response.text();
                    resultDiv.textContent = `âŒ è¿æ¥å¤±è´¥ (${response.status}): ${errorText.substring(0, 100)}`;
                    resultDiv.style.color = '#ff3b30';
                }
            } catch (err) {
                resultDiv.textContent = `âŒ è¿æ¥é”™è¯¯: ${err.message}`;
                resultDiv.style.color = '#ff3b30';
            } finally {
                btnText.textContent = 'æµ‹è¯• NovelAI è¿æ¥';
            }
        }

        // æ„é€ æ™ºèƒ½ URL (è‡ªåŠ¨è¡¥å…¨ /v1)
        function getSmartUrl(baseUrl, endpoint) {
            let url = baseUrl;
            if (url.endsWith('/')) url = url.slice(0, -1);
            // å¦‚æœç”¨æˆ·æ²¡æœ‰å†™ /v1ï¼Œä¸”ä¸æ˜¯ç›´æ¥è¯·æ±‚å®Œæ•´è·¯å¾„ï¼Œè‡ªåŠ¨è¡¥å…¨ /v1
            if (!url.includes('/v1')) {
                url += '/v1';
            }
            return url + endpoint;
        }

        // æ‹‰å–æ¨¡å‹åˆ—è¡¨
        async function fetchModels() {
            const url = document.getElementById('ai-url-input').value.trim();
            const key = document.getElementById('ai-key-input').value.trim();
            
            if (!url) {
                alert("è¯·å…ˆå¡«å†™APIåœ°å€");
                return;
            }

            const spinner = document.getElementById('fetch-spinner');
            const btnText = document.getElementById('fetch-text');
            spinner.style.display = 'inline-block';
            btnText.style.display = 'none';
            
            // æ„é€ è¯·æ±‚ URL: è‡ªåŠ¨è¡¥å…¨ /v1/models
            const requestUrl = getSmartUrl(url, '/models');

            try {
                const res = await fetch(requestUrl, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${key}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!res.ok) {
                    throw new Error(`HTTP Error ${res.status}`);
                }
                
                const data = await res.json();
                let models = [];
                if (Array.isArray(data)) {
                    models = data;
                } else if (data.data && Array.isArray(data.data)) {
                    models = data.data;
                }
                
                const select = document.getElementById('ai-model-select');
                select.innerHTML = '<option value="" disabled selected>è¯·é€‰æ‹©æ¨¡å‹</option>';
                models.forEach(m => {
                    const opt = document.createElement('option');
                    opt.value = m.id;
                    opt.text = m.id;
                    select.appendChild(opt);
                });
                
                await db.dexiData.put({ key: 'aiModelList', value: JSON.stringify(models) });
                alert(`æˆåŠŸè·å– ${models.length} ä¸ªæ¨¡å‹ï¼`);
                
            } catch (err) {
                console.error(err);
                alert(`æ‹‰å–å¤±è´¥: ${err.message}\nå°è¯•è¯·æ±‚: ${requestUrl}`);
            } finally {
                spinner.style.display = 'none';
                btnText.style.display = 'inline';
            }
        }

        // æµ‹è¯•è¿æ¥
        async function testConnection() {
            const url = document.getElementById('ai-url-input').value.trim();
            const key = document.getElementById('ai-key-input').value.trim();
            const model = document.getElementById('ai-model-select').value;
            
            if (!url || !model) {
                alert("è¯·å…ˆå®Œå–„é…ç½®å¹¶é€‰æ‹©æ¨¡å‹");
                return;
            }

            const btn = document.querySelector('.test-btn');
            const originalText = document.getElementById('test-btn-text').innerText;
            document.getElementById('test-btn-text').innerText = "æµ‹è¯•ä¸­...";
            btn.style.opacity = "0.7";

            // æ„é€ ç®€å•çš„ Chat è¯·æ±‚
            const requestUrl = getSmartUrl(url, '/chat/completions');
            
            try {
                const res = await fetch(requestUrl, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${key}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: model,
                        messages: [{ role: "user", content: "Hi" }],
                        max_tokens: 5
                    })
                });

                if (res.ok) {
                    alert("âœ… è¿æ¥æˆåŠŸï¼API é…ç½®æœ‰æ•ˆã€‚");
                } else {
                    const errText = await res.text();
                    alert(`âŒ è¿æ¥å¤±è´¥ (${res.status}):\n${errText}`);
                }
            } catch (e) {
                alert(`âŒ ç½‘ç»œé”™è¯¯: ${e.message}`);
            } finally {
                document.getElementById('test-btn-text').innerText = originalText;
                btn.style.opacity = "1";
            }
        }

        // æ ¸å¿ƒï¼šä¿å­˜æ‰€æœ‰è®¾ç½®åˆ°DEXie (ä¿ç•™åŸæœ‰é€»è¾‘ï¼Œä»…æ’é™¤ AI ç›¸å…³ key é˜²æ­¢è¦†ç›–)
        async function saveAllSetting() {
            try {
                // è¯»å–æ‰€æœ‰è¾“å…¥å€¼
                const saveData = {
                    wallpaper: document.getElementById('desktop-body')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '',
                    widgetIcon: document.getElementById('widget-icon')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '',
                    widgetTitle: document.getElementById('widget-title-input')?.value?.trim() || document.getElementById('widget-title')?.innerText?.trim() || 'lovely Day',
                    widgetSubtext: document.getElementById('widget-subtext-input')?.value?.trim() || document.getElementById('widget-subtext')?.innerText?.trim() || 'ä¸–ç•Œç ´ç ´çƒ‚çƒ‚å°çŒ«ç¼ç¼è¡¥è¡¥ ğŸ¾',
                    photoLeft: document.getElementById('img-left')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '',
                    photoRight: document.getElementById('img-right')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '',
                    avatar1: document.getElementById('avatar-img-1')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '',
                    avatar2: document.getElementById('avatar-img-2')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '',
                    avatar1Bubble: document.getElementById('avatar1-bubble-input')?.value?.trim() || '> .. <',
                    avatar1Name: document.getElementById('avatar1-name-input')?.value?.trim() || '> .. <',
                    avatar2Bubble: document.getElementById('avatar2-bubble-input')?.value?.trim() || 'gw..â™¡',
                    avatar2Name: document.getElementById('avatar2-name-input')?.value?.trim() || 'gw..â™¡',
                    daysText: document.getElementById('days-input')?.value?.trim() || '446 days'
                };
                
                // å­˜å‚¨åº”ç”¨å›¾æ ‡
                const iconIds = ['appstore','notes','remind','facetime','photo','xianyu','cabin','icity'];
                iconIds.forEach(id => {
                    const el = document.getElementById(`icon-${id}`)?.querySelector('.icon');
                    if (el) saveData[`icon${id.charAt(0).toUpperCase() + id.slice(1)}`] = el.style.backgroundImage.replace(/url\(|\)|"/g, '');
                });
                // å­˜å‚¨Dockå›¾æ ‡
                const dockIds = ['setting','custom','message','phone'];
                dockIds.forEach(id => {
                    const el = document.getElementById(`dock-${id}`)?.querySelector('.icon');
                    if (el) saveData[`dock${id.charAt(0).toUpperCase() + id.slice(1)}`] = el.style.backgroundImage.replace(/url\(|\)|"/g, '');
                });

                // ä¿å­˜æ¤­åœ†å½¢é¢œè‰²
                const heartColor = document.getElementById('heart-color-input')?.value || '#ffb6c1';
                const capsuleColor = document.getElementById('capsule-color-input')?.value || '#FFF7FA';
                const bubbleColor = document.getElementById('bubble-color-input')?.value || '#FFF7FA';
                saveData.heartColor = heartColor;
                saveData.capsuleColor = capsuleColor;
                saveData.bubbleColor = bubbleColor;

                // ä¿å­˜æ¡Œé¢æ–‡å­—é¢œè‰²
                const desktopTextColor = document.getElementById('desktop-text-color-input')?.value || '#999999';
                saveData.desktopTextColor = desktopTextColor;

                // ä¿å­˜è‡ªå®šä¹‰å­—ä½“
                const customFontUrl = document.getElementById('custom-font-input')?.value?.trim() || '';
                const customFontName = document.getElementById('custom-font-name-input')?.value?.trim() || '';
                saveData.customFontUrl = customFontUrl;
                saveData.customFontName = customFontName;

                // ä¿å­˜è‡ªå®šä¹‰CSS
                const customCssCode = document.getElementById('custom-css-input')?.value || '';
                saveData.customCssCode = customCssCode;

                // å¾ªç¯ä¿å­˜åˆ°æ•°æ®åº“
                for (const [key, value] of Object.entries(saveData)) {
                    await db.dexiData.put({ key, value });
                }

                // å®æ—¶æ›´æ–°é¡µé¢æ˜¾ç¤º
                const widgetTitle = document.getElementById('widget-title');
                const widgetSubtext = document.getElementById('widget-subtext');
                const bubble1 = document.getElementById('avatar-bubble1');
                const name1 = document.getElementById('avatar-name1');
                const bubble2 = document.getElementById('avatar-bubble2');
                const name2 = document.getElementById('avatar-name2');
                const daysText = document.getElementById('days-text');
                
                if (widgetTitle) widgetTitle.innerText = saveData.widgetTitle;
                if (widgetSubtext) widgetSubtext.innerText = saveData.widgetSubtext;
                if (bubble1) bubble1.innerText = saveData.avatar1Bubble;
                if (name1) name1.innerText = saveData.avatar1Name;
                if (bubble2) bubble2.innerText = saveData.avatar2Bubble;
                if (name2) name2.innerText = saveData.avatar2Name;
                if (daysText) daysText.innerText = saveData.daysText;
                
                // åº”ç”¨æ¤­åœ†å½¢é¢œè‰²
                document.documentElement.style.setProperty('--heart-color', heartColor);
                document.documentElement.style.setProperty('--capsule-bg', capsuleColor);
                document.documentElement.style.setProperty('--bubble-bg', bubbleColor);

                // åº”ç”¨æ¡Œé¢æ–‡å­—é¢œè‰²
                if (desktopTextColor && desktopTextColor !== '#999999') {
                    applyDesktopTextColor(desktopTextColor);
                }

                // åº”ç”¨è‡ªå®šä¹‰å­—ä½“åˆ°å…¨å±€
                if (customFontUrl && customFontName) {
                    loadCustomFont(customFontUrl, customFontName, false);
                }

                // åº”ç”¨è‡ªå®šä¹‰CSS
                applyCustomCSS();

                // ä¿å­˜æç¤º
                showToast('âœ… ä¿å­˜æˆåŠŸ');
                console.log('[SaveSetting] âœ“ ä¸ªæ€§åŒ–è®¾ç½®ä¿å­˜æˆåŠŸ', saveData);
            } catch (error) {
                console.error('[SaveSetting] âœ— ä¿å­˜å¤±è´¥:', error);
                showToast('âŒ ä¿å­˜å¤±è´¥: ' + error.message);
            }
        }

        // ===== å¯¼å‡º/å¯¼å…¥æ¡Œé¢è£…ä¿®åŒ… =====
        async function exportDesktopTheme() {
            try {
                const theme = {};
                // å£çº¸
                theme.wallpaper = document.getElementById('desktop-body')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '';
                // å°ç»„ä»¶
                theme.widgetIcon = document.getElementById('widget-icon')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '';
                theme.widgetTitle = document.getElementById('widget-title')?.innerText?.trim() || '';
                theme.widgetSubtext = document.getElementById('widget-subtext')?.innerText?.trim() || '';
                // æ‹ç«‹å¾—
                theme.photoLeft = document.getElementById('img-left')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '';
                theme.photoRight = document.getElementById('img-right')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '';
                // å¤´åƒ
                theme.avatar1 = document.getElementById('avatar-img-1')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '';
                theme.avatar2 = document.getElementById('avatar-img-2')?.style.backgroundImage?.replace(/url\(|\)|"/g, '') || '';
                theme.avatar1Bubble = document.getElementById('avatar-bubble1')?.innerText?.trim() || '';
                theme.avatar1Name = document.getElementById('avatar-name1')?.innerText?.trim() || '';
                theme.avatar2Bubble = document.getElementById('avatar-bubble2')?.innerText?.trim() || '';
                theme.avatar2Name = document.getElementById('avatar-name2')?.innerText?.trim() || '';
                // å€’æ•°æ—¥
                theme.daysText = document.getElementById('days-text')?.innerText?.trim() || '';
                // åº”ç”¨å›¾æ ‡
                const iconIds = ['appstore','notes','remind','facetime','photo','xianyu','cabin','icity'];
                iconIds.forEach(id => {
                    const el = document.getElementById(`icon-${id}`)?.querySelector('.icon');
                    if (el && el.style.backgroundImage) theme[`icon_${id}`] = el.style.backgroundImage.replace(/url\(|\)|"/g, '');
                });
                // Dockå›¾æ ‡
                const dockIds = ['setting','custom','message','phone'];
                dockIds.forEach(id => {
                    const el = document.getElementById(`dock-${id}`)?.querySelector('.icon');
                    if (el && el.style.backgroundImage) theme[`dock_${id}`] = el.style.backgroundImage.replace(/url\(|\)|"/g, '');
                });
                // é¢œè‰²
                theme.heartColor = getComputedStyle(document.documentElement).getPropertyValue('--heart-color').trim() || '';
                theme.capsuleColor = getComputedStyle(document.documentElement).getPropertyValue('--capsule-bg').trim() || '';
                theme.bubbleColor = getComputedStyle(document.documentElement).getPropertyValue('--bubble-bg').trim() || '';
                // æ¡Œé¢æ–‡å­—é¢œè‰²
                theme.desktopTextColor = document.getElementById('desktop-text-color-input')?.value || '#999999';
                // å­—ä½“
                theme.customFontUrl = document.getElementById('custom-font-input')?.value?.trim() || '';
                theme.customFontName = document.getElementById('custom-font-name-input')?.value?.trim() || '';
                // è‡ªå®šä¹‰CSS
                theme.customCssCode = document.getElementById('custom-css-input')?.value || '';

                // ç”Ÿæˆæ–‡ä»¶
                const jsonStr = JSON.stringify(theme, null, 2);
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `æ¡Œé¢è£…ä¿®åŒ…_${new Date().toLocaleDateString('zh-CN').replace(/\//g, '-')}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showToast('âœ… è£…ä¿®åŒ…å·²å¯¼å‡º');
            } catch (err) {
                console.error('[ExportTheme] å¯¼å‡ºå¤±è´¥:', err);
                showToast('âŒ å¯¼å‡ºå¤±è´¥: ' + err.message);
            }
        }

        async function importDesktopTheme(input) {
            const file = input.files[0];
            if (!file) return;
            input.value = '';
            try {
                const text = await file.text();
                const theme = JSON.parse(text);
                if (typeof theme !== 'object' || theme === null) throw new Error('æ–‡ä»¶æ ¼å¼æ— æ•ˆ');

                // å£çº¸
                if (theme.wallpaper) {
                    document.getElementById('desktop-body').style.backgroundImage = `url(${theme.wallpaper})`;
                    const wp = document.getElementById('wallpaper-preview');
                    if (wp) { wp.style.backgroundImage = `url(${theme.wallpaper})`; wp.innerText = ''; }
                }
                // å°ç»„ä»¶
                if (theme.widgetIcon) {
                    document.getElementById('widget-icon').style.backgroundImage = `url(${theme.widgetIcon})`;
                    const wip = document.getElementById('widget-icon-preview');
                    if (wip) wip.style.backgroundImage = `url(${theme.widgetIcon})`;
                }
                if (theme.widgetTitle) {
                    document.getElementById('widget-title').innerText = theme.widgetTitle;
                    const wti = document.getElementById('widget-title-input');
                    if (wti) wti.value = theme.widgetTitle;
                }
                if (theme.widgetSubtext) {
                    document.getElementById('widget-subtext').innerText = theme.widgetSubtext;
                    const wsi = document.getElementById('widget-subtext-input');
                    if (wsi) wsi.value = theme.widgetSubtext;
                }
                // æ‹ç«‹å¾—
                if (theme.photoLeft) {
                    document.getElementById('img-left').style.backgroundImage = `url(${theme.photoLeft})`;
                    const plp = document.getElementById('photo-left-preview');
                    if (plp) plp.style.backgroundImage = `url(${theme.photoLeft})`;
                }
                if (theme.photoRight) {
                    document.getElementById('img-right').style.backgroundImage = `url(${theme.photoRight})`;
                    const prp = document.getElementById('photo-right-preview');
                    if (prp) prp.style.backgroundImage = `url(${theme.photoRight})`;
                }
                // å¤´åƒ
                if (theme.avatar1) {
                    const img1 = document.getElementById('avatar-img-1');
                    if (img1) { img1.style.backgroundImage = `url(${theme.avatar1})`; img1.classList.add('has-image'); }
                    const ap1 = document.getElementById('avatar1-preview');
                    if (ap1) ap1.style.backgroundImage = `url(${theme.avatar1})`;
                }
                if (theme.avatar2) {
                    const img2 = document.getElementById('avatar-img-2');
                    if (img2) { img2.style.backgroundImage = `url(${theme.avatar2})`; img2.classList.add('has-image'); }
                    const ap2 = document.getElementById('avatar2-preview');
                    if (ap2) ap2.style.backgroundImage = `url(${theme.avatar2})`;
                }
                if (theme.avatar1Bubble) {
                    const b1 = document.getElementById('avatar-bubble1');
                    if (b1) b1.innerText = theme.avatar1Bubble;
                    const ib1 = document.getElementById('avatar1-bubble-input');
                    if (ib1) ib1.value = theme.avatar1Bubble;
                }
                if (theme.avatar1Name) {
                    const n1 = document.getElementById('avatar-name1');
                    if (n1) n1.innerText = theme.avatar1Name;
                    const in1 = document.getElementById('avatar1-name-input');
                    if (in1) in1.value = theme.avatar1Name;
                }
                if (theme.avatar2Bubble) {
                    const b2 = document.getElementById('avatar-bubble2');
                    if (b2) b2.innerText = theme.avatar2Bubble;
                    const ib2 = document.getElementById('avatar2-bubble-input');
                    if (ib2) ib2.value = theme.avatar2Bubble;
                }
                if (theme.avatar2Name) {
                    const n2 = document.getElementById('avatar-name2');
                    if (n2) n2.innerText = theme.avatar2Name;
                    const in2 = document.getElementById('avatar2-name-input');
                    if (in2) in2.value = theme.avatar2Name;
                }
                // å€’æ•°æ—¥
                if (theme.daysText) {
                    document.getElementById('days-text').innerText = theme.daysText;
                    const di = document.getElementById('days-input');
                    if (di) di.value = theme.daysText;
                }
                // åº”ç”¨å›¾æ ‡
                const iconIds = ['appstore','notes','remind','facetime','photo','xianyu','cabin','icity'];
                iconIds.forEach(id => {
                    const val = theme[`icon_${id}`];
                    if (val) {
                        const el = document.getElementById(`icon-${id}`)?.querySelector('.icon');
                        if (el) el.style.backgroundImage = `url(${val})`;
                        const si = document.querySelector(`.icon-select-item[data-icon-id="${id}"] .icon`);
                        if (si) { si.style.backgroundImage = `url(${val})`; si.style.backgroundSize = 'cover'; si.style.backgroundPosition = 'center'; }
                    }
                });
                // Dockå›¾æ ‡
                const dockIds = ['setting','custom','message','phone'];
                dockIds.forEach(id => {
                    const val = theme[`dock_${id}`];
                    if (val) {
                        const el = document.getElementById(`dock-${id}`)?.querySelector('.icon');
                        if (el) el.style.backgroundImage = `url(${val})`;
                        const si = document.querySelector(`.icon-select-item[data-icon-id="${id}"] .icon`);
                        if (si) { si.style.backgroundImage = `url(${val})`; si.style.backgroundSize = 'cover'; si.style.backgroundPosition = 'center'; }
                    }
                });
                // é¢œè‰²
                if (theme.heartColor) {
                    document.documentElement.style.setProperty('--heart-color', theme.heartColor);
                    const hci = document.getElementById('heart-color-input');
                    if (hci) hci.value = theme.heartColor;
                }
                if (theme.capsuleColor) {
                    document.documentElement.style.setProperty('--capsule-bg', theme.capsuleColor);
                    const cci = document.getElementById('capsule-color-input');
                    if (cci) cci.value = theme.capsuleColor;
                }
                if (theme.bubbleColor) {
                    document.documentElement.style.setProperty('--bubble-bg', theme.bubbleColor);
                    const bci = document.getElementById('bubble-color-input');
                    if (bci) bci.value = theme.bubbleColor;
                }
                // æ¡Œé¢æ–‡å­—é¢œè‰²
                if (theme.desktopTextColor) {
                    applyDesktopTextColor(theme.desktopTextColor);
                    const dtci = document.getElementById('desktop-text-color-input');
                    if (dtci) dtci.value = theme.desktopTextColor;
                }
                // å­—ä½“
                if (theme.customFontUrl && theme.customFontName) {
                    const cfi = document.getElementById('custom-font-input');
                    if (cfi) cfi.value = theme.customFontUrl;
                    const cfni = document.getElementById('custom-font-name-input');
                    if (cfni) cfni.value = theme.customFontName;
                    loadCustomFont(theme.customFontUrl, theme.customFontName, false);
                }
                // è‡ªå®šä¹‰CSS
                if (theme.customCssCode !== undefined) {
                    const cssi = document.getElementById('custom-css-input');
                    if (cssi) cssi.value = theme.customCssCode;
                    applyCustomCSS();
                }

                // è‡ªåŠ¨ä¿å­˜åˆ°æ•°æ®åº“
                await saveAllSetting();
                showToast('âœ… è£…ä¿®åŒ…å¯¼å…¥æˆåŠŸ');
                console.log('[ImportTheme] âœ“ è£…ä¿®åŒ…å¯¼å…¥æˆåŠŸ', theme);
            } catch (err) {
                console.error('[ImportTheme] å¯¼å…¥å¤±è´¥:', err);
                showToast('âŒ å¯¼å…¥å¤±è´¥: ' + err.message);
            }
        }

// --- æ—¥å†æ—¶é—´è®¾å®šé€»è¾‘ (Premium Pink Pro) ---

const calendar = {
    date: new Date(),        // å½“å‰æµè§ˆçš„æ—¥æœŸï¼ˆç”¨äºç¿»é¡µï¼‰
    selectedDate: new Date(), // ç”¨æˆ·é€‰ä¸­çš„æ—¥æœŸ
    isSelectorOpen: false,   // çŠ¶æ€æ ‡è¯†
    isInitialized: false,    // æ˜¯å¦å·²åˆå§‹åŒ–

    elements: {},

    months: ["1æœˆ Â· January", "2æœˆ Â· February", "3æœˆ Â· March", "4æœˆ Â· April", "5æœˆ Â· May", "6æœˆ Â· June", "7æœˆ Â· July", "8æœˆ Â· August", "9æœˆ Â· September", "10æœˆ Â· October", "11æœˆ Â· November", "12æœˆ Â· December"],
    monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],

    init() {
        if (this.isInitialized) return;
        
        this.elements = {
            // Containers
            calendarLayer: document.getElementById('cal-calendarLayer'),
            selectorLayer: document.getElementById('cal-selectorLayer'),
            
            // Display/Inputs
            headerBtn: document.getElementById('cal-headerTitleBtn'),
            headerText: document.getElementById('cal-monthYearText'),
            daysContainer: document.getElementById('cal-daysContainer'),
            monthGrid: document.getElementById('cal-monthGrid'),
            yearList: document.getElementById('cal-yearList'),
            
            // Buttons
            prevBtn: document.getElementById('cal-prevBtn'),
            nextBtn: document.getElementById('cal-nextBtn'),
            
            // Time
            hourInput: document.getElementById('cal-hourInput'),
            minuteInput: document.getElementById('cal-minuteInput'),
            confirmBtn: document.getElementById('cal-confirmBtn')
        };

        this.bindEvents();
        this.renderSelectorItems();
        this.isInitialized = true;
    },

    // æ¸²æŸ“æ—¥å†ç½‘æ ¼
    render() {
        // è®¾ç½®æ ‡é¢˜
        this.elements.headerText.innerHTML = `${this.months[this.date.getMonth()].split(' Â· ')[0]} <span style="font-weight:300; opacity:0.6; font-size:0.9em">${this.date.getFullYear()}</span>`;

        this.date.setDate(1);
        const lastDay = new Date(this.date.getFullYear(), this.date.getMonth() + 1, 0).getDate();
        const firstDayIndex = this.date.getDay(); // 0 is Sunday
        
        let daysHTML = "";

        // ç©ºç™½å ä½
        for (let x = 0; x < firstDayIndex; x++) {
            daysHTML += `<div class="day fade"></div>`;
        }

        // æ—¥æœŸ
        for (let i = 1; i <= lastDay; i++) {
            const isToday = i === new Date().getDate() && 
                          this.date.getMonth() === new Date().getMonth() && 
                          this.date.getFullYear() === new Date().getFullYear();
            
            const isSelected = i === this.selectedDate.getDate() &&
                             this.date.getMonth() === this.selectedDate.getMonth() &&
                             this.date.getFullYear() === this.selectedDate.getFullYear();

            let classes = "day";
            if (isToday) classes += " today";
            if (isSelected) classes += " selected";

            // ä½¿ç”¨ onclick å­—ç¬¦ä¸²ç»‘å®šå¯èƒ½ä¼šæœ‰é—®é¢˜ï¼Œè¿™é‡Œæ”¹ç”¨äº‹ä»¶å§”æ‰˜æˆ–ç›´æ¥ç”ŸæˆHTMLåç»‘å®š
            // ä¸ºäº†ç®€å•ï¼Œæˆ‘ä»¬ä½¿ç”¨å…¨å±€å‡½æ•° calendarSelectDay
            daysHTML += `<div class="${classes}" onclick="calendarSelectDay(${i})">${i}</div>`;
        }

        this.elements.daysContainer.innerHTML = daysHTML;
        
        // æ›´æ–°é€‰æ‹©å™¨çš„é«˜äº®çŠ¶æ€
        this.updateSelectorHighlights();
    },

    // æ¸²æŸ“é€‰æ‹©å™¨çš„å†…å®¹ï¼ˆæœˆä»½å’Œå¹´ä»½åˆ—è¡¨ï¼‰
    renderSelectorItems() {
        // 1. æ¸²æŸ“æœˆä»½
        let mHtml = '';
        this.months.forEach((m, index) => {
            const ch = m.split(' Â· ')[0];
            const en = this.monthsShort[index];
            mHtml += `<div class="sel-month-item" onclick="calendarSetMonth(${index})">
                <span style="font-weight:700">${ch}</span> 
                <span style="font-size:0.8em; opacity:0.7">${en}</span>
            </div>`;
        });
        this.elements.monthGrid.innerHTML = mHtml;

        // 2. æ¸²æŸ“å¹´ä»½ (å‰å50å¹´)
        const currentYear = new Date().getFullYear();
        let yHtml = '';
        for(let y = currentYear - 50; y <= currentYear + 50; y++) {
            yHtml += `<div class="sel-year-item" id="year-${y}" onclick="calendarSetYear(${y})">${y}</div>`;
        }
        this.elements.yearList.innerHTML = yHtml;
    },

    updateSelectorHighlights() {
        // é«˜äº®æœˆä»½
        const monthItems = this.elements.monthGrid.children;
        for(let item of monthItems) item.classList.remove('selected');
        if(monthItems[this.date.getMonth()]) monthItems[this.date.getMonth()].classList.add('selected');

        // é«˜äº®å¹´ä»½å¹¶æ»šåŠ¨
        const yearItems = this.elements.yearList.children;
        for(let item of yearItems) item.classList.remove('selected');
        
        const activeYearEl = document.getElementById(`year-${this.date.getFullYear()}`);
        if(activeYearEl) {
            activeYearEl.classList.add('selected');
            // å¦‚æœé¢æ¿å¼€ç€ï¼Œæ‰æ»šåŠ¨ï¼Œå¦åˆ™ä¼šåœ¨åå°ä¹±æ»š
            if(this.isSelectorOpen) {
                activeYearEl.scrollIntoView({block: "center", behavior: "smooth"});
            }
        }
    },

    toggleSelector() {
        this.isSelectorOpen = !this.isSelectorOpen;
        
        if(this.isSelectorOpen) {
            this.elements.calendarLayer.classList.remove('active');
            this.elements.selectorLayer.classList.add('active');
            this.elements.headerBtn.classList.add('active');
            
            this.elements.prevBtn.style.opacity = '0';
            this.elements.prevBtn.style.pointerEvents = 'none';
            this.elements.nextBtn.style.opacity = '0';
            this.elements.nextBtn.style.pointerEvents = 'none';

            setTimeout(() => {
                const activeYear = document.getElementById(`year-${this.date.getFullYear()}`);
                if(activeYear) activeYear.scrollIntoView({block: "center"});
            }, 100);

        } else {
            this.elements.selectorLayer.classList.remove('active');
            this.elements.calendarLayer.classList.add('active');
            this.elements.headerBtn.classList.remove('active');

            this.elements.prevBtn.style.opacity = '1';
            this.elements.prevBtn.style.pointerEvents = 'auto';
            this.elements.nextBtn.style.opacity = '1';
            this.elements.nextBtn.style.pointerEvents = 'auto';
        }
    },

    setMonth(index) {
        this.date.setMonth(index);
        this.render();
    },

    setYear(year) {
        this.date.setFullYear(year);
        this.render();
    },
    
    selectDay(day) {
        this.selectedDate = new Date(this.date.getFullYear(), this.date.getMonth(), day);
        // ä¿ç•™å½“å‰çš„å°æ—¶åˆ†é’Ÿ
        const h = parseInt(this.elements.hourInput.value) || 0;
        const m = parseInt(this.elements.minuteInput.value) || 0;
        this.selectedDate.setHours(h);
        this.selectedDate.setMinutes(m);
        
        this.render();
    },

    updateTimeInputs() {
        const h = this.selectedDate.getHours().toString().padStart(2, '0');
        const m = this.selectedDate.getMinutes().toString().padStart(2, '0');
        this.elements.hourInput.value = h;
        this.elements.minuteInput.value = m;
    },

    bindEvents() {
        // å¤´éƒ¨ç‚¹å‡» -> æ‰“å¼€é€‰æ‹©å™¨
        this.elements.headerBtn.addEventListener('click', () => this.toggleSelector());

        // å·¦å³å¯¼èˆª
        this.elements.prevBtn.addEventListener('click', () => {
            this.date.setMonth(this.date.getMonth() - 1);
            this.render();
        });
        this.elements.nextBtn.addEventListener('click', () => {
            this.date.setMonth(this.date.getMonth() + 1);
            this.render();
        });

        // æ—¶é—´è¾“å…¥åŠç¡®è®¤
        const formatTime = (e) => {
            let val = parseInt(e.target.value);
            const max = e.target.id === 'cal-hourInput' ? 23 : 59;
            if(isNaN(val) || val < 0) val = 0; if(val > max) val = max;
            e.target.value = val.toString().padStart(2, '0');
            
            // æ›´æ–° selectedDate
            if (e.target.id === 'cal-hourInput') this.selectedDate.setHours(val);
            else this.selectedDate.setMinutes(val);
        };

        this.elements.hourInput.addEventListener('change', formatTime);
        this.elements.minuteInput.addEventListener('change', formatTime);
        
        // ç¡®è®¤æŒ‰é’®é€»è¾‘
        this.elements.confirmBtn.addEventListener('click', () => {
            if (this.isSelectorOpen) {
                this.toggleSelector(); // å…³é—­é€‰æ‹©å™¨ï¼Œå›åˆ°æ—¥å†è§†å›¾
            } else {
                saveCalendarTime(); // è°ƒç”¨å…¨å±€ä¿å­˜å‡½æ•°
            }
        });
    }
};

// å…¨å±€è¾…åŠ©å‡½æ•°ä¾› onclick è°ƒç”¨
function calendarSelectDay(day) {
    calendar.selectDay(day);
}
function calendarSetMonth(index) {
    calendar.setMonth(index);
}
function calendarSetYear(year) {
    calendar.setYear(year);
}

// ä¸»å…¥å£
// æ˜¾ç¤ºè¡£æŸœé¡µé¢
function showWardrobePage() {
    closeChatPanel();
    const wardrobePage = document.getElementById('wardrobe-page');
    if (wardrobePage) {
        wardrobePage.style.display = 'flex';
        // åŠ è½½ä¿å­˜çš„äººç‰©å½¢è±¡
        loadWardrobeCharacter();
    }
}

// éšè—è¡£æŸœé¡µé¢
function hideWardrobePage() {
    const wardrobePage = document.getElementById('wardrobe-page');
    if (wardrobePage) {
        wardrobePage.style.display = 'none';
    }
}

// è¡£æŸœç”Ÿæˆå›¾ç‰‡ç›¸å…³å‡½æ•°
let wardrobeGenerateType = 'character';
let wardrobeGender = 'female'; // é»˜è®¤å¥³ç”Ÿ

function openWardrobeGenerateModal() {
    const modal = document.getElementById('wardrobe-generate-modal');
    if (modal) {
        modal.style.display = 'flex';
        wardrobeGenerateType = 'character';
        wardrobeGender = 'female';
        selectWardrobeGenerateType('character', document.getElementById('wardrobe-btn-character'));
        selectWardrobeGender('female', document.getElementById('wardrobe-gender-female'));
        document.getElementById('wardrobe-generate-prompt').value = '';
    }
}

function closeWardrobeGenerateModal() {
    const modal = document.getElementById('wardrobe-generate-modal');
    if (modal) {
        modal.style.display = 'none';
        document.getElementById('wardrobe-generate-loading').style.display = 'none';
    }
}

function selectWardrobeGenerateType(type, element) {
    wardrobeGenerateType = type;
    // æ›´æ–°æŒ‰é’®æ ·å¼
    const allBtns = document.querySelectorAll('#wardrobe-btn-character, #wardrobe-btn-clothes');
    allBtns.forEach(btn => {
        btn.style.border = '2px solid #eee';
        btn.style.background = '#fff';
        btn.style.color = '#666';
    });
    element.style.border = '2px solid var(--ins-pink)';
    element.style.background = '#fff0f5';
    element.style.color = 'var(--ins-pink)';
    
    // æ§åˆ¶æ€§åˆ«é€‰æ‹©çš„æ˜¾ç¤ºï¼ˆåªåœ¨äººç‰©å½¢è±¡æ—¶æ˜¾ç¤ºï¼‰
    const genderSelect = document.getElementById('wardrobe-gender-select');
    if (genderSelect) {
        genderSelect.style.display = type === 'character' ? 'block' : 'none';
    }
}

// æ€§åˆ«é€‰æ‹©å‡½æ•°
function selectWardrobeGender(gender, element) {
    wardrobeGender = gender;
    // æ›´æ–°æŒ‰é’®æ ·å¼
    const allBtns = document.querySelectorAll('.wardrobe-gender-btn');
    allBtns.forEach(btn => {
        btn.style.border = '2px solid #eee';
        btn.style.background = '#fff';
        btn.style.color = '#666';
    });
    
    if (gender === 'female') {
        element.style.border = '2px solid #ff69b4';
        element.style.background = '#fff0f5';
        element.style.color = '#ff69b4';
    } else {
        element.style.border = '2px solid #4a90e2';
        element.style.background = '#f0f7ff';
        element.style.color = '#4a90e2';
    }
}

async function generateWardrobeImage() {
    const prompt = document.getElementById('wardrobe-generate-prompt').value.trim();
    if (!prompt) {
        alert('è¯·è¾“å…¥ç”Ÿæˆè¦æ±‚');
        return;
    }

    // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
    const loadingDiv = document.getElementById('wardrobe-generate-loading');
    const confirmBtn = document.querySelector('.generate-confirm-btn');
    loadingDiv.style.display = 'block';
    confirmBtn.disabled = true;
    confirmBtn.textContent = 'ç”Ÿæˆä¸­...';

    try {
        // è·å–NovelAIé…ç½®
        const apiKeyItem = await db.dexiData.get('novelaiApiKey');
        const proxyUrlItem = await db.dexiData.get('novelaiProxyUrl');
        const modelItem = await db.dexiData.get('novelaiModel');
        const stepsItem = await db.dexiData.get('novelaiSteps');
        const scaleItem = await db.dexiData.get('novelaiScale');
        const samplerItem = await db.dexiData.get('novelaiSampler');
        const sizeItem = await db.dexiData.get('novelaiSize');

        if (!apiKeyItem || !apiKeyItem.value) {
            throw new Error('è¯·å…ˆåœ¨è®¾ç½®ä¸­é…ç½® NovelAI API Key');
        }

        const apiKey = apiKeyItem.value;
        const proxyUrl = proxyUrlItem ? proxyUrlItem.value : 'https://image.novelai.net/ai/generate-image';
        const model = modelItem ? modelItem.value : 'nai-diffusion-4-5-full';
        const steps = stepsItem ? parseInt(stepsItem.value) : 28;
        const scale = scaleItem ? parseFloat(scaleItem.value) : 11;
        const sampler = samplerItem ? samplerItem.value : 'k_euler_ancestral';
        const size = sizeItem ? sizeItem.value : '832x1216';
        // è§£æå°ºå¯¸
        const [width, height] = size.split('x').map(Number);

        // è·å–å‚è€ƒå›¾ï¼ˆç”¨äºå›¾ç”Ÿå›¾ï¼‰
        let referenceImageBase64 = null;
        let cleanImage = null; // å»é™¤å‰ç¼€åçš„çº¯ base64 æ•°æ®
        
        if (wardrobeGenerateType === 'clothes') {
            // ç”Ÿæˆè¡£æœæ—¶ï¼Œè·å–å½“å‰äººç‰©å½¢è±¡ä½œä¸ºå‚è€ƒå›¾
            const charImg = document.getElementById('wardrobe-char-base');
            if (charImg && charImg.src && !charImg.src.includes('character.png')) {
                try {
                    // å°†å›¾ç‰‡è½¬æ¢ä¸º base64
                    referenceImageBase64 = await imageToBase64(charImg.src);
                    // å…³é”®ä¿®å¤ï¼šå»é™¤ base64 çš„å¤´ (data:image/png;base64,)
                    cleanImage = referenceImageBase64.replace(/^data:image\/\w+;base64,/, "");
                    console.log('å·²è·å–å‚è€ƒå›¾ï¼Œå‡†å¤‡è¿›è¡Œå›¾ç”Ÿå›¾ï¼Œçº¯ base64 é•¿åº¦:', cleanImage.length);
                } catch (e) {
                    console.warn('è·å–å‚è€ƒå›¾å¤±è´¥ï¼Œå°†ä½¿ç”¨çº¯æ–‡ç”Ÿå›¾:', e);
                }
            }
            
            // å¦‚æœæ²¡æœ‰å‚è€ƒå›¾ï¼Œæç¤ºç”¨æˆ·
            if (!cleanImage) {
                alert('è¯·å…ˆç”Ÿæˆäººç‰©å½¢è±¡åå†æ¢è£…');
                loadingDiv.style.display = 'none';
                confirmBtn.disabled = false;
                confirmBtn.textContent = 'ç”Ÿæˆ';
                return;
            }
        }
        
        // æ„å»ºå®Œæ•´çš„prompt
        let fullPrompt = '';
        let wardrobeNegativePrompt = '';
        
        if (wardrobeGenerateType === 'character') {
            // äººç‰©å½¢è±¡ï¼šæ ¹æ®é€‰æ‹©çš„æ€§åˆ«æ·»åŠ å¯¹åº”æ ‡ç­¾
            if (wardrobeGender === 'male') {
                // ç”·ç”Ÿï¼šå°† prompt (ä½ çš„è¾“å…¥) æ”¾åœ¨æœ€æœ€å‰é¢ï¼
                fullPrompt = prompt + ', 1boy, male, full body, standing, solo, masterpiece, best quality, highly detailed';
                wardrobeNegativePrompt = 'girl, female, woman, 1girl, feminine, worst quality, low quality, blurry, watermark, signature, cropped, cut off, half body, upper body, close-up, portrait, multiple views, background scenery, complex background, landscape, text, logo';
            } else {
                // å¥³ç”Ÿï¼šå°† prompt (ä½ çš„è¾“å…¥) æ”¾åœ¨æœ€æœ€å‰é¢ï¼
                fullPrompt = prompt + ', 1girl, female, full body, standing, solo, masterpiece, best quality, highly detailed';
                wardrobeNegativePrompt = 'boy, male, man, 1boy, masculine, worst quality, low quality, blurry, watermark, signature, cropped, cut off, half body, upper body, close-up, portrait, multiple views, background scenery, complex background, landscape, text, logo';
            }
        } else {
            // æ¢è£…æ¨¡å¼ï¼šå¿…é¡»å¸¦ä¸Šæ€§åˆ«å’ŒåŸºç¡€è´¨é‡è¯ï¼ŒæŠŠç”¨æˆ·çš„è¡£æœæè¿°(prompt)æ”¾åœ¨æœ€å‰é¢
            const genderTags = wardrobeGender === 'male' ? '1boy, male' : '1girl, female';
            fullPrompt = prompt + ', ' + genderTags + ', full body, standing, solo, masterpiece, best quality, highly detailed';
            wardrobeNegativePrompt = 'worst quality, low quality, blurry, watermark, text, logo, nsfw';
        }

        // åˆ¤æ–­æ¨¡å‹ç‰ˆæœ¬
        const isV4 = model.includes('nai-diffusion-4');
        
        // æ ¹æ®æ¨¡å‹ç‰ˆæœ¬é€‰æ‹©æ­£ç¡®çš„ç«¯ç‚¹
        const isCustomProxy = proxyUrl && proxyUrl !== 'https://image.novelai.net/ai/generate-image' && proxyUrl !== 'https://image.novelai.net/ai/generate-image-stream';
        let apiUrl;
        if (isCustomProxy) {
            apiUrl = proxyUrl;
        } else {
            apiUrl = isV4 ? 'https://image.novelai.net/ai/generate-image-stream' : 'https://image.novelai.net/ai/generate-image';
        }

        // æ„å»ºè¯·æ±‚ä½“
        let requestBody;
        if (isV4) {
            // V4/V4.5 ä½¿ç”¨æ–°æ ¼å¼
            requestBody = {
                input: fullPrompt, // V4 éœ€è¦ input å­—æ®µ
                model: model,
                action: 'generate',
                parameters: {
                    width: width,
                    height: height,
                    scale: scale,
                    sampler: sampler,
                    steps: steps,
                    seed: Math.floor(Math.random() * 9999999999),
                    n_samples: 1,
                    ucPreset: 0,
                    qualityToggle: true,
                    sm: false,
                    sm_dyn: false,
                    dynamic_thresholding: false,
                    controlnet_strength: 1,
                    legacy: false,
                    add_original_image: false,
                    cfg_rescale: 0,
                    noise_schedule: 'native',
                    negative_prompt: wardrobeNegativePrompt
                }
            };
            
            // å¦‚æœæ˜¯æ¢è£…æ¨¡å¼ï¼Œæ·»åŠ å›¾ç”Ÿå›¾å‚æ•°
            if (cleanImage) {
                console.log('å¯ç”¨å›¾ç”Ÿå›¾æ¨¡å¼ (V4 img2img)');
                // æ˜ç¡®å‘Šè¯‰ API è¿™æ˜¯å›¾ç”Ÿå›¾
                requestBody.action = 'img2img';
                // ä½¿ç”¨å»é™¤äº†å‰ç¼€çš„å›¾ç‰‡æ•°æ®
                requestBody.parameters.image = cleanImage;
                // é‡ç»˜å¹…åº¦ï¼š0.7 å·¦å³èƒ½åœ¨ä¿æŒå§¿åŠ¿çš„åŒæ—¶æ¢è¡£æœ
                requestBody.parameters.strength = 0.7;
                // ç¨å¾®åŠ ä¸€ç‚¹å™ªç‚¹å¢åŠ ç»†èŠ‚
                requestBody.parameters.noise = 0.1;
                requestBody.parameters.extra_noise_seed = requestBody.parameters.seed;
                
                console.log('å‚è€ƒå›¾ base64 é•¿åº¦:', cleanImage.length);
            }
        } else {
            // V3 ä½¿ç”¨æ—§æ ¼å¼
            requestBody = {
                input: fullPrompt,
                model: model,
                action: 'generate',
                parameters: {
                    width: width,
                    height: height,
                    scale: scale,
                    sampler: sampler,
                    steps: steps,
                    seed: Math.floor(Math.random() * 9999999999),
                    n_samples: 1,
                    ucPreset: 0,
                    qualityToggle: true,
                    negative_prompt: wardrobeNegativePrompt
                }
            };
            
            // å¦‚æœæ˜¯æ¢è£…æ¨¡å¼ï¼Œæ·»åŠ å›¾ç”Ÿå›¾å‚æ•°ï¼ˆV3ï¼‰
            if (cleanImage) {
                console.log('å¯ç”¨å›¾ç”Ÿå›¾æ¨¡å¼ (V3 img2img)');
                requestBody.action = 'img2img';
                requestBody.parameters.image = cleanImage;
                requestBody.parameters.strength = 0.7;
                requestBody.parameters.noise = 0.1;
                requestBody.parameters.extra_noise_seed = requestBody.parameters.seed;
                
                console.log('å‚è€ƒå›¾ base64 é•¿åº¦:', cleanImage.length);
            }
        }

        // å‘é€è¯·æ±‚
        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${apiKey}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`ç”Ÿæˆå¤±è´¥: ${response.status} ${errorText.substring(0, 200)}`);
        }

        // å¤„ç†å“åº”
        const contentType = response.headers.get('content-type');
        let imageUrl;
        
        if (contentType && contentType.includes('text/event-stream')) {
            // SSE æµå¼å“åº”ï¼ˆV4ï¼‰
            const text = await response.text();
            console.log('SSE å“åº”å‰ 500 å­—ç¬¦:', text.substring(0, 500));
            const lines = text.trim().split('\n');
            let base64Data = null;
            
            // ä»åå¾€å‰æŸ¥æ‰¾æœ€åä¸€ä¸ªåŒ…å«å›¾ç‰‡æ•°æ®çš„è¡Œ
            for (let i = lines.length - 1; i >= 0; i--) {
                const line = lines[i].trim();
                if (line.startsWith('data: ') && line !== 'data: [DONE]') {
                    const dataContent = line.substring(6);
                    try {
                        const jsonData = JSON.parse(dataContent);
                        console.log('è§£æåˆ° JSON æ•°æ®:', jsonData);
                        
                        // æ£€æŸ¥æ˜¯å¦æ˜¯é”™è¯¯äº‹ä»¶
                        if (jsonData.event_type === 'error' || jsonData.event === 'error') {
                            const errorMsg = jsonData.message || jsonData.error || 'NovelAI ç”Ÿæˆå¤±è´¥';
                            console.error('NovelAI é”™è¯¯:', jsonData);
                            throw new Error(`NovelAI API é”™è¯¯: ${errorMsg}`);
                        }
                        
                        // å°è¯•å„ç§å¯èƒ½çš„å­—æ®µ
                        if (jsonData.event_type === 'final' && jsonData.image) {
                            base64Data = jsonData.image;
                            console.log('æ‰¾åˆ°å›¾ç‰‡æ•°æ® (final.image)');
                            break;
                        }
                        if (jsonData.final && jsonData.final.image) {
                            base64Data = jsonData.final.image;
                            console.log('æ‰¾åˆ°å›¾ç‰‡æ•°æ® (final.image nested)');
                            break;
                        }
                        if (jsonData.data && typeof jsonData.data === 'string') {
                            base64Data = jsonData.data;
                            console.log('æ‰¾åˆ°å›¾ç‰‡æ•°æ® (data)');
                            break;
                        }
                        if (jsonData.image) {
                            base64Data = jsonData.image;
                            console.log('æ‰¾åˆ°å›¾ç‰‡æ•°æ® (image)');
                            break;
                        }
                        // NovelAI V4.5 å¯èƒ½ç›´æ¥è¿”å› base64
                        if (typeof jsonData === 'string' && jsonData.length > 100) {
                            base64Data = jsonData;
                            console.log('æ‰¾åˆ°å›¾ç‰‡æ•°æ® (ç›´æ¥å­—ç¬¦ä¸²)');
                            break;
                        }
                    } catch (e) {
                        // å¦‚æœä¸æ˜¯ JSONï¼Œå¯èƒ½ç›´æ¥æ˜¯ base64
                        if (dataContent.length > 100) {
                            base64Data = dataContent;
                            console.log('æ‰¾åˆ°å›¾ç‰‡æ•°æ® (é JSON å­—ç¬¦ä¸²)');
                            break;
                        }
                    }
                }
            }
            
            if (!base64Data) {
                console.error('æ— æ³•æå–å›¾ç‰‡æ•°æ®ï¼Œå“åº”å†…å®¹:', text.substring(0, 1000));
                throw new Error('æ— æ³•ä» SSE å“åº”ä¸­æå–å›¾ç‰‡æ•°æ®ã€‚è¯·æ£€æŸ¥æ§åˆ¶å°æ—¥å¿—ã€‚');
            }
            
            console.log('æå–åˆ°çš„ base64 æ•°æ®é•¿åº¦:', base64Data.length);
            
            // æ£€æŸ¥æ˜¯å¦ä¸ºå›¾ç‰‡çš„base64
            const isPNG = base64Data.startsWith('iVBORw0KGgo');
            const isJPEG = base64Data.startsWith('/9j/');
            
            if (isPNG || isJPEG) {
                imageUrl = `data:${isPNG ? 'image/png' : 'image/jpeg'};base64,${base64Data}`;
            } else {
                // å¯èƒ½æ˜¯ZIPçš„base64ï¼Œéœ€è¦è§£å‹
                const binaryString = atob(base64Data);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                const zipBlob = new Blob([bytes]);
                imageUrl = await extractImageFromZip(zipBlob);
            }
        } else {
            // ZIP æ–‡ä»¶å“åº”ï¼ˆV3ï¼‰
            const zipBlob = await response.blob();
            imageUrl = await extractImageFromZip(zipBlob);
        }

        if (!imageUrl) {
            throw new Error('æ— æ³•è§£æå›¾åƒæ•°æ®');
        }

        // æ˜¾ç¤ºç”Ÿæˆçš„å›¾ç‰‡
        if (wardrobeGenerateType === 'character') {
            // ç”Ÿæˆäººç‰©å½¢è±¡ï¼šç›´æ¥æ›´æ–°
            const charImg = document.getElementById('wardrobe-char-base');
            if (charImg) {
                charImg.src = imageUrl;
                // ä¿å­˜åˆ° Dexie
                await saveWardrobeCharacter(imageUrl);
            }
        } else {
            // ç”Ÿæˆè¡£æœ - å›¾ç”Ÿå›¾æ¢è£…
            // å›¾ç”Ÿå›¾æ¨¡å¼ï¼šæ›´æ–°å½“å‰äººç‰©å½¢è±¡ï¼ˆæ¢è£…æ•ˆæœï¼‰
            const charImg = document.getElementById('wardrobe-char-base');
            if (charImg) {
                charImg.src = imageUrl;
                // ä¿å­˜æ›´æ–°åçš„äººç‰©å½¢è±¡åˆ° Dexie
                await saveWardrobeCharacter(imageUrl);
            }
            alert('æ¢è£…æˆåŠŸï¼äººç‰©è¡£æœå·²æ›´æ–°');
        }

        // æ˜¾ç¤ºæˆåŠŸæç¤ºï¼ˆå›¾ç”Ÿå›¾æ¨¡å¼å·²ç»æœ‰ä¸“é—¨æç¤ºï¼Œè¿™é‡Œåªæç¤ºå…¶ä»–æƒ…å†µï¼‰
        if (wardrobeGenerateType === 'character' || !referenceImageBase64) {
            alert('å›¾ç‰‡ç”ŸæˆæˆåŠŸï¼');
        }
        closeWardrobeGenerateModal();

    } catch (error) {
        console.error('ç”Ÿæˆå›¾ç‰‡å¤±è´¥:', error);
        alert('ç”Ÿæˆå¤±è´¥: ' + error.message);
    } finally {
        loadingDiv.style.display = 'none';
        confirmBtn.disabled = false;
        confirmBtn.textContent = 'ç”Ÿæˆ';
    }
}

// è¡£æŸœTabåˆ‡æ¢å‡½æ•°
function switchWardrobeTab(category, element) {
    // æ›´æ–°Tabæ ·å¼
    document.querySelectorAll('.wardrobe-tab-item').forEach(tab => {
        tab.classList.remove('active');
        tab.style.color = '#999';
        tab.style.fontWeight = 'normal';
        const span = tab.querySelector('span');
        if (span) span.remove();
    });
    element.classList.add('active');
    element.style.color = '#333';
    element.style.fontWeight = 'bold';
    const indicator = document.createElement('span');
    indicator.style.cssText = 'position:absolute; bottom:0; left:50%; transform:translateX(-50%); width:20px; height:3px; background:#d4a5ff; border-radius:3px;';
    element.appendChild(indicator);

    // æ›´æ–°åˆ—è¡¨æ˜¾ç¤º
    document.querySelectorAll('.wardrobe-list').forEach(list => {
        list.style.display = 'none';
    });
    const targetList = document.getElementById('wardrobe-list-' + category);
    if (targetList) {
        targetList.style.display = 'flex';
    }
}

// å°†å›¾ç‰‡URLè½¬æ¢ä¸ºbase64
async function imageToBase64(imageUrl) {
    return new Promise((resolve, reject) => {
        // å¦‚æœå·²ç»æ˜¯ base64ï¼Œç›´æ¥è¿”å›
        if (imageUrl.startsWith('data:')) {
            resolve(imageUrl);
            return;
        }
        
        // å¦‚æœæ˜¯ blob URLï¼Œéœ€è¦å…ˆè½¬æ¢
        if (imageUrl.startsWith('blob:')) {
            fetch(imageUrl)
                .then(response => response.blob())
                .then(blob => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                })
                .catch(reject);
            return;
        }
        
        // æ™®é€š URLï¼Œä½¿ç”¨ canvas è½¬æ¢
        const img = new Image();
        img.crossOrigin = 'anonymous'; // è§£å†³è·¨åŸŸé—®é¢˜
        img.onload = () => {
            try {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                const base64 = canvas.toDataURL('image/png');
                resolve(base64);
            } catch (e) {
                reject(e);
            }
        };
        img.onerror = reject;
        img.src = imageUrl;
    });
}

// ğŸ”§ å°†å›¾ç‰‡è½¬æ¢ä¸º AI API å…¼å®¹æ ¼å¼ï¼ˆJPEGï¼‰
// è§£å†³ Gemini ç­‰ API ä¸æ”¯æŒ image/avifã€image/webp ç­‰æ ¼å¼çš„é—®é¢˜
function convertImageForAI(dataUrl) {
    return new Promise((resolve, reject) => {
        // å¦‚æœä¸æ˜¯ data URLï¼Œç›´æ¥è¿”å›
        if (!dataUrl || !dataUrl.startsWith('data:image')) {
            resolve(dataUrl);
            return;
        }
        
        // æ£€æŸ¥ MIME ç±»å‹ï¼Œåªæœ‰ JPEG å’Œ PNG æ˜¯æ‰€æœ‰ API éƒ½å¯é æ”¯æŒçš„
        const mimeMatch = dataUrl.match(/^data:(image\/[^;]+);/);
        if (mimeMatch) {
            const mime = mimeMatch[1].toLowerCase();
            // åªæ”¾è¡Œ JPEG å’Œ PNGï¼Œå…¶ä»–æ‰€æœ‰æ ¼å¼éƒ½è½¬æ¢ï¼ˆåŒ…æ‹¬ GIFã€AVIFã€WEBPã€BMP ç­‰ï¼‰
            if (mime === 'image/jpeg' || mime === 'image/png') {
                resolve(dataUrl);
                return;
            }
        }
        
        // éœ€è¦è½¬æ¢ï¼šgifã€avifã€webpã€bmp ç­‰æ ¼å¼ â†’ JPEG
        console.log('[convertImageForAI] æ£€æµ‹åˆ°éœ€è¦è½¬æ¢çš„å›¾ç‰‡æ ¼å¼:', mimeMatch?.[1] || 'æœªçŸ¥', 'â†’ JPEG');
        const img = new Image();
        img.onload = () => {
            try {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                // å¡«å……ç™½è‰²èƒŒæ™¯ï¼ˆé˜²æ­¢é€æ˜é€šé“åœ¨ JPEG ä¸­å˜é»‘ï¼‰
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);
                const jpegDataUrl = canvas.toDataURL('image/jpeg', 0.85);
                console.log('[convertImageForAI] âœ… å›¾ç‰‡å·²è½¬æ¢ä¸º JPEGï¼Œå¤§å°:', (jpegDataUrl.length / 1024).toFixed(1), 'KB');
                resolve(jpegDataUrl);
            } catch (e) {
                console.error('[convertImageForAI] âŒ è½¬æ¢å¤±è´¥ï¼Œä½¿ç”¨åŸå§‹æ ¼å¼:', e);
                resolve(dataUrl); // è½¬æ¢å¤±è´¥æ—¶å›é€€åˆ°åŸå§‹æ•°æ®
            }
        };
        img.onerror = () => {
            console.error('[convertImageForAI] âŒ å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨åŸå§‹æ ¼å¼');
            resolve(dataUrl); // åŠ è½½å¤±è´¥æ—¶å›é€€
        };
        img.src = dataUrl;
    });
}

// ğŸ”§ å°† HTTP å›¾ç‰‡ URL è½¬æ¢ä¸º base64 data URLï¼ˆç”¨äº AI API å…¼å®¹ï¼‰
// Gemini ç­‰ API ä¸æ”¯æŒç›´æ¥ä¼ é€’å¤–éƒ¨ HTTP å›¾ç‰‡é“¾æ¥ï¼Œéœ€è¦è½¬æˆ base64
function convertHttpImageToBase64(httpUrl) {
    return new Promise((resolve, reject) => {
        if (!httpUrl || !httpUrl.startsWith('http')) {
            resolve(httpUrl);
            return;
        }
        console.log('[convertHttpImageToBase64] å¼€å§‹è½¬æ¢ HTTP å›¾ç‰‡:', httpUrl.substring(0, 80) + '...');
        const img = new Image();
        img.crossOrigin = 'anonymous'; // å…è®¸è·¨åŸŸ
        img.onload = () => {
            try {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);
                const dataUrl = canvas.toDataURL('image/jpeg', 0.85);
                console.log('[convertHttpImageToBase64] âœ… å·²è½¬æ¢ä¸º base64ï¼Œå¤§å°:', (dataUrl.length / 1024).toFixed(1), 'KB');
                resolve(dataUrl);
            } catch (e) {
                console.warn('[convertHttpImageToBase64] âŒ Canvas è½¬æ¢å¤±è´¥ï¼ˆå¯èƒ½è·¨åŸŸï¼‰:', e.message);
                resolve(httpUrl); // è½¬æ¢å¤±è´¥å›é€€åˆ°åŸå§‹ URL
            }
        };
        img.onerror = () => {
            console.warn('[convertHttpImageToBase64] âŒ å›¾ç‰‡åŠ è½½å¤±è´¥:', httpUrl.substring(0, 80));
            resolve(httpUrl); // åŠ è½½å¤±è´¥å›é€€
        };
        img.src = httpUrl;
    });
}

// ä¿å­˜è¡£æŸœäººç‰©å½¢è±¡åˆ° Dexie
async function saveWardrobeCharacter(imageUrl) {
    try {
        await db.dexiData.put({ key: 'wardrobeCharacter', value: imageUrl });
        // åŒæ—¶ä¿å­˜å½“å‰é€‰æ‹©çš„æ€§åˆ«ï¼Œæ¢è£…æ—¶éœ€è¦ç”¨åˆ°
        await db.dexiData.put({ key: 'wardrobeCharacterGender', value: wardrobeGender });
        console.log('äººç‰©å½¢è±¡å·²ä¿å­˜ï¼Œæ€§åˆ«:', wardrobeGender);
    } catch (error) {
        console.error('ä¿å­˜äººç‰©å½¢è±¡å¤±è´¥:', error);
    }
}

// åŠ è½½è¡£æŸœäººç‰©å½¢è±¡
async function loadWardrobeCharacter() {
    try {
        const item = await db.dexiData.get('wardrobeCharacter');
        const genderItem = await db.dexiData.get('wardrobeCharacterGender');
        
        if (item && item.value) {
            const charImg = document.getElementById('wardrobe-char-base');
            if (charImg) {
                charImg.src = item.value;
                console.log('äººç‰©å½¢è±¡å·²åŠ è½½');
            }
        }
        
        // æ¢å¤æ€§åˆ«è®¾ç½®
        if (genderItem && genderItem.value) {
            wardrobeGender = genderItem.value;
            console.log('äººç‰©æ€§åˆ«å·²æ¢å¤:', wardrobeGender);
        }
    } catch (error) {
        console.error('åŠ è½½äººç‰©å½¢è±¡å¤±è´¥:', error);
    }
}

// ä»ZIPæ–‡ä»¶ä¸­æå–å›¾ç‰‡
async function extractImageFromZip(zipBlob) {
    // æ£€æŸ¥æ˜¯å¦æœ‰JSZipåº“
    if (typeof JSZip === 'undefined') {
        // å¦‚æœæ²¡æœ‰JSZipï¼Œå°è¯•ç›´æ¥è¯»å–ä¸ºå›¾ç‰‡
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(zipBlob);
        });
    }
    
    try {
        const zip = await JSZip.loadAsync(zipBlob);
        let imageFile = null;
        
        // æŸ¥æ‰¾ç¬¬ä¸€ä¸ªå›¾ç‰‡æ–‡ä»¶
        for (const filename in zip.files) {
            if (filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
                imageFile = zip.files[filename];
                break;
            }
        }
        
        if (!imageFile) {
            throw new Error('ZIPæ–‡ä»¶ä¸­æœªæ‰¾åˆ°å›¾ç‰‡');
        }
        
        const imageBlob = await imageFile.async('blob');
        
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(imageBlob);
        });
    } catch (error) {
        console.error('è§£å‹ZIPå¤±è´¥:', error);
        // é™çº§å¤„ç†ï¼šç›´æ¥ä½œä¸ºå›¾ç‰‡è¯»å–
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(zipBlob);
        });
    }
}

// æ·»åŠ è¡£æœé¡¹åˆ°åˆ—è¡¨
function addWardrobeClothesItem(category, imageUrl, name) {
    const listId = 'wardrobe-list-' + category;
    const list = document.getElementById(listId);
    if (!list) return;

    const item = document.createElement('div');
    item.className = 'wardrobe-clothes-item';
    item.style.cssText = 'display:inline-block; flex-shrink:0; width:90px; height:110px; border:1px solid #f0f0f0; border-radius:12px; margin-right:12px; background:#fff; cursor:pointer; text-align:center; padding:6px; transition:all 0.2s;';
    item.innerHTML = `
        <img src="${imageUrl}" alt="${name}" style="width:100%; height:75px; object-fit:contain; margin-bottom:5px;">
        <div class="wardrobe-clothes-name" style="font-size:11px; color:#888; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${name.substring(0, 10)}${name.length > 10 ? '...' : ''}</div>
    `;
    item.onmouseenter = function() {
        this.style.borderColor = '#e0b0ff';
        this.style.background = '#faf4ff';
        this.style.transform = 'translateY(-2px)';
    };
    item.onmouseleave = function() {
        this.style.borderColor = '#f0f0f0';
        this.style.background = '#fff';
        this.style.transform = 'translateY(0)';
    };
    list.appendChild(item);
}

async function showCalendarPage() {
    if (!currentChatCharId) {
        alert("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠå¤©å¯¹è±¡");
        return;
    }
    
    closeChatPanel();
    document.getElementById('calendar-page').style.display = 'flex';
    
    // åˆå§‹åŒ–æ—¥å† DOM ç»‘å®š
    calendar.init();
    
    // è·å–è§’è‰²æ—¶é—´
    const char = await db.characters.get(currentChatCharId);
    const now = Date.now();
    const offset = char.timeOffset || 0;
    const virtualTime = new Date(now + offset);
    
    // è®¾ç½®æ—¥å†åˆå§‹çŠ¶æ€
    calendar.selectedDate = new Date(virtualTime); // å¤åˆ¶ä¸€ä»½
    calendar.date = new Date(virtualTime); // æµè§ˆè§†å›¾ä¹Ÿè®¾ä¸ºå½“å‰æ—¶é—´
    
    calendar.updateTimeInputs(); // æ›´æ–°è¾“å…¥æ¡†
    calendar.render(); // æ¸²æŸ“æ—¥å†
}

function hideCalendarPage() {
    document.getElementById('calendar-page').style.display = 'none';
}

async function saveCalendarTime() {
    if (!currentChatCharId) return;
    
    // ä» calendar å¯¹è±¡è·å–æœ€ç»ˆæ—¶é—´
    const targetTime = calendar.selectedDate.getTime();
    const now = Date.now();
    const offset = targetTime - now;
    
    const char = await db.characters.get(currentChatCharId);
    char.timeOffset = offset;
    
    await db.characters.put(char);
    
    hideCalendarPage();
    alert("æ—¶é—´è®¾å®šå·²æ›´æ–°");
}

// è¾…åŠ©å‡½æ•°ï¼šè·å–æ ¼å¼åŒ–çš„è™šæ‹Ÿæ—¶é—´å­—ç¬¦ä¸²
function getFormattedVirtualTime(offset) {
    const now = Date.now();
    const virtualNow = new Date(now + (offset || 0));
    
    const year = virtualNow.getFullYear();
    const month = virtualNow.getMonth() + 1;
    const day = virtualNow.getDate();
    const hours = virtualNow.getHours().toString().padStart(2, '0');
    const mins = virtualNow.getMinutes().toString().padStart(2, '0');
    const weekDays = ['å‘¨æ—¥', 'å‘¨ä¸€', 'å‘¨äºŒ', 'å‘¨ä¸‰', 'å‘¨å››', 'å‘¨äº”', 'å‘¨å…­'];
    const week = weekDays[virtualNow.getDay()];
    
    return `${year}å¹´${month}æœˆ${day}æ—¥ ${hours}:${mins} (${week})`;
}

// --- App Store é€»è¾‘ ---
// åº”ç”¨å®‰è£…çŠ¶æ€ç®¡ç†
// icity Dexie æ•°æ®åº“åˆå§‹åŒ–ï¼ˆæ— é™å®¹é‡ï¼‰
const icityDb = new Dexie('IcityDB');
icityDb.version(1).stores({
    diaries: '++id, content, time, roleName, wechatId, avatarUrl, isUserPublished, createdAt',
    annotations: '++id, diaryId, text, comment, createdAt'
});
// ç‰ˆæœ¬2ï¼šæ·»åŠ  accountId å­—æ®µç”¨äºè´¦å·æ•°æ®éš”ç¦»
icityDb.version(2).stores({
    diaries: '++id, content, time, roleName, wechatId, avatarUrl, isUserPublished, createdAt, accountId',
    annotations: '++id, diaryId, text, comment, createdAt, accountId'
});

const installedAppsDb = new Dexie('InstalledAppsDB');
installedAppsDb.version(1).stores({
    apps: 'appId, installed, installDate'
});

// æ£€æŸ¥åº”ç”¨æ˜¯å¦å·²å®‰è£…
async function isAppInstalled(appId) {
    try {
        const app = await installedAppsDb.apps.get(appId);
        return app ? app.installed : false;
    } catch (error) {
        console.error('æ£€æŸ¥åº”ç”¨å®‰è£…çŠ¶æ€å¤±è´¥:', error);
        return false;
    }
}

// å®‰è£…åº”ç”¨
async function installApp(appId, desktopIconId, showFunction) {
    try {
        await installedAppsDb.apps.put({
            appId: appId,
            installed: true,
            installDate: new Date()
        });
        
        // æ˜¾ç¤ºæ¡Œé¢å›¾æ ‡
        if (desktopIconId) {
            const icon = document.getElementById(desktopIconId);
            if (icon) {
                icon.style.display = 'flex';
            }
        }
        
        // ä¿å­˜åˆ° localStorage ä½œä¸ºå¤‡ä»½
        const installedApps = JSON.parse(localStorage.getItem('installedApps') || '{}');
        installedApps[appId] = {
            installed: true,
            installDate: new Date().toISOString(),
            desktopIconId: desktopIconId,
            showFunction: showFunction
        };
        localStorage.setItem('installedApps', JSON.stringify(installedApps));
        
        return true;
    } catch (error) {
        console.error('å®‰è£…åº”ç”¨å¤±è´¥:', error);
        return false;
    }
}

// å¸è½½åº”ç”¨
async function uninstallApp(appId, desktopIconId) {
    try {
        await installedAppsDb.apps.delete(appId);
        
        // éšè—æ¡Œé¢å›¾æ ‡
        if (desktopIconId) {
            const icon = document.getElementById(desktopIconId);
            if (icon) {
                icon.style.display = 'none';
            }
        }
        
        // ä» localStorage åˆ é™¤
        const installedApps = JSON.parse(localStorage.getItem('installedApps') || '{}');
        delete installedApps[appId];
        localStorage.setItem('installedApps', JSON.stringify(installedApps));
        
        return true;
    } catch (error) {
        console.error('å¸è½½åº”ç”¨å¤±è´¥:', error);
        return false;
    }
}

// åˆå§‹åŒ–å·²å®‰è£…åº”ç”¨çš„æ¡Œé¢å›¾æ ‡æ˜¾ç¤º
async function initInstalledApps() {
    try {
        // ğŸ”¥ é»˜è®¤é¢„è£…åº”ç”¨ï¼šç½‘æ˜“äº‘éŸ³ä¹ï¼ˆæ¡Œé¢é»˜è®¤æ˜¾ç¤ºï¼Œç¡®ä¿æ•°æ®åº“ä¸­ä¹Ÿæ ‡è®°ä¸ºå·²å®‰è£…ï¼‰
        const defaultApps = [
            { appId: 'netease-music', desktopIconId: 'icon-photo', showFunction: 'showMusicAppPage' }
        ];
        for (const defApp of defaultApps) {
            const existing = await installedAppsDb.apps.get(defApp.appId);
            if (!existing) {
                await installedAppsDb.apps.put({
                    appId: defApp.appId,
                    installed: true,
                    installDate: new Date()
                });
            }
        }
        
        // ä» IndexedDB åŠ è½½
        const installedApps = await installedAppsDb.apps.toArray();
        installedApps.forEach(app => {
            if (app.installed) {
                // ä»åº”ç”¨å•†åº—æ•°æ®ä¸­æ‰¾åˆ°å¯¹åº”çš„åº”ç”¨
                const allApps = [...appStoreData.today, ...appStoreData.games, ...appStoreData.apps, ...appStoreData.updates];
                const appData = allApps.find(a => a.appId === app.appId);
                if (appData && appData.desktopIconId) {
                    const icon = document.getElementById(appData.desktopIconId);
                    if (icon) {
                        icon.style.display = 'flex';
                    }
                }
            }
        });
        
        // ä» localStorage æ¢å¤ï¼ˆå…¼å®¹æ—§æ•°æ®ï¼‰
        const localApps = JSON.parse(localStorage.getItem('installedApps') || '{}');
        Object.keys(localApps).forEach(appId => {
            const appInfo = localApps[appId];
            if (appInfo.installed && appInfo.desktopIconId) {
                const icon = document.getElementById(appInfo.desktopIconId);
                if (icon) {
                    icon.style.display = 'flex';
                }
                // åŒæ­¥åˆ° IndexedDB
                installedAppsDb.apps.put({
                    appId: appId,
                    installed: true,
                    installDate: appInfo.installDate ? new Date(appInfo.installDate) : new Date()
                });
            }
        });
    } catch (error) {
        console.error('åˆå§‹åŒ–å·²å®‰è£…åº”ç”¨å¤±è´¥:', error);
    }
}

// ä¸‹è½½/å®‰è£…åº”ç”¨
async function downloadApp(appId) {
    const allApps = [...appStoreData.today, ...appStoreData.games, ...appStoreData.apps, ...appStoreData.updates];
    const app = allApps.find(a => a.appId === appId);
    
    if (!app) {
        alert('åº”ç”¨ä¸å­˜åœ¨');
        return;
    }
    
    // æ£€æŸ¥æ˜¯å¦å·²å®‰è£…
    const isInstalled = await isAppInstalled(appId);
    if (isInstalled) {
        // å¦‚æœå·²å®‰è£…ï¼Œç›´æ¥æ‰“å¼€åº”ç”¨
        if (app.showFunction && typeof window[app.showFunction] === 'function') {
            window[app.showFunction]();
            hideAppStorePage();
        }
        return;
    }
    
    // æ˜¾ç¤ºä¸‹è½½è¿›åº¦
    showToast('æ­£åœ¨ä¸‹è½½ ' + app.name + '...', 2000);
    
    // æ¨¡æ‹Ÿä¸‹è½½è¿‡ç¨‹
    setTimeout(async () => {
        const success = await installApp(appId, app.desktopIconId, app.showFunction);
        if (success) {
            showToast(app.name + ' å·²å®‰è£…', 2000);
            // åˆ·æ–°åº”ç”¨å•†åº—æ˜¾ç¤º
            const activeTab = document.querySelector('.appstore-tab.active');
            if (activeTab) {
                switchAppStoreTab(activeTab.dataset.tab);
            }
        } else {
            showToast('å®‰è£…å¤±è´¥ï¼Œè¯·é‡è¯•', 2000);
        }
    }, 1500);
}

function showAppStorePage() {
    document.getElementById('appstore-page').style.display = 'flex';
    switchAppStoreTab('today');
}

function hideAppStorePage() {
    const page = document.getElementById('appstore-page');
    if (page) {
        page.style.display = 'none';
    }
}

function showMusicAppPage() {
    document.getElementById('musicAppPage').classList.add('active');
}

function closeMusicApp() {
    document.getElementById('musicAppPage').classList.remove('active');
}

// ç½‘æ˜“äº‘éŸ³ä¹æ’­æ”¾å™¨åŠŸèƒ½
// ============================================

// åˆå§‹åŒ–éŸ³ä¹æ’­æ”¾å™¨Dexieæ•°æ®åº“
const wyyDb = new Dexie('WYYMusicPlayerDB');
wyyDb.version(1).stores({
    userSettings: 'id',
    playlistCards: 'id',
    songs: '++id, name, singer, dateAdded',
    songFiles: '++id, songId, type, data',
    lyrics: '++id, songId, data'
});
wyyDb.version(2).stores({
    userSettings: 'id',
    playlistCards: 'id',
    songs: '++id, name, singer, dateAdded, playlistId',
    songFiles: '++id, songId, type, data',
    lyrics: '++id, songId, data',
    playlists: '++id, name, desc, cover, dateCreated'
});

// éŸ³ä¹æ’­æ”¾å™¨å…ƒç´ 
const wyyPlayBtn = document.getElementById('wyyPlayBtn');
const wyyPlayerPlayBtn = document.getElementById('wyyPlayerPlayBtn');
const wyyRecordCover = document.getElementById('wyyRecordCover');
const wyyCurrentRecordContainer = document.getElementById('wyyCurrentRecordContainer');
const wyyAlbumArtLarge = document.getElementById('wyyAlbumArtLarge');
const wyyCurrentSongName = document.getElementById('wyyCurrentSongName');
const wyyCurrentSingerName = document.getElementById('wyyCurrentSingerName');
const wyyPlayerSongName = document.getElementById('wyyPlayerSongName');
const wyyPlayerSingerName = document.getElementById('wyyPlayerSingerName');
const wyyPlaylistBtn = document.getElementById('wyyPlaylistBtn');
const wyyPlaylistModal = document.getElementById('wyyPlaylistModal');
const wyySongsList = document.getElementById('wyySongsList');
const wyyEmptyPlaylist = document.getElementById('wyyEmptyPlaylist');
const wyyAddSongBtn = document.getElementById('wyyAddSongBtn');
const wyyClearAllBtn = document.getElementById('wyyClearAllBtn');
const wyyProgressBar = document.getElementById('wyyProgressBar');
const wyyProgress = document.getElementById('wyyProgress');
const wyyCurrentTime = document.getElementById('wyyCurrentTime');
const wyyTotalTime = document.getElementById('wyyTotalTime');
const wyyPrevBtn = document.getElementById('wyyPrevBtn');
const wyyNextBtn = document.getElementById('wyyNextBtn');
const wyyPlayBar = document.getElementById('wyyPlayBar');
const wyyBackBtn = document.getElementById('wyyBackBtn');
const wyyMainPage = document.getElementById('wyyMainPage');
const wyyPlayerPage = document.getElementById('wyyPlayerPage');

// æ­Œæ›²è¾“å…¥å…ƒç´ 
const wyySongNameInput = document.getElementById('wyySongNameInput');
const wyySingerNameInput = document.getElementById('wyySingerNameInput');
const wyySongUrlInput = document.getElementById('wyySongUrlInput');
const wyyLyricUrlInput = document.getElementById('wyyLyricUrlInput');

// ä¸Šä¼ é€‰é¡¹æŒ‰é’®
const wyyUrlOptionBtn = document.getElementById('wyyUrlOptionBtn');
const wyyFileOptionBtn = document.getElementById('wyyFileOptionBtn');
const wyyUrlUploadSection = document.getElementById('wyyUrlUploadSection');
const wyyFileUploadSection = document.getElementById('wyyFileUploadSection');

const wyyLyricUrlOptionBtn = document.getElementById('wyyLyricUrlOptionBtn');
const wyyLyricFileOptionBtn = document.getElementById('wyyLyricFileOptionBtn');
const wyyLyricUrlUploadSection = document.getElementById('wyyLyricUrlUploadSection');
const wyyLyricFileUploadSection = document.getElementById('wyyLyricFileUploadSection');

// æ–‡ä»¶ä¸Šä¼ æŒ‰é’®
const wyyUploadCoverBtn = document.getElementById('wyyUploadCoverBtn');
const wyyCoverFileInput = document.getElementById('wyyCoverFileInput');
const wyySongCoverPreview = document.getElementById('wyySongCoverPreview');
const wyyUploadSongFileBtn = document.getElementById('wyyUploadSongFileBtn');
const wyySongFileInput = document.getElementById('wyySongFileInput');
const wyyUploadLyricFileBtn = document.getElementById('wyyUploadLyricFileBtn');
const wyyLyricFileInput = document.getElementById('wyyLyricFileInput');

let wyyAudio = null;
let wyyProgressUpdateInterval = null;

// æ’­æ”¾åˆ—è¡¨æ•°æ®
let wyyPlaylist = [];
let wyyCurrentSongIndex = 0;
let wyyCurrentPlaylistId = null; // å½“å‰é€‰ä¸­çš„æ­Œå•ID

// æ’­æ”¾æ¨¡å¼ï¼š'order' é¡ºåºæ’­æ”¾, 'single' å•æ›²å¾ªç¯
let wyyPlayMode = 'order';

// æ­Œè¯æ˜¾ç¤ºçŠ¶æ€ï¼šfalse æ˜¾ç¤ºå°é¢, true æ˜¾ç¤ºæ­Œè¯
let wyyShowLyrics = false;

// å½“å‰æ­Œè¯æ•°æ®
let wyyCurrentLyrics = [];

// ä¸´æ—¶å­˜å‚¨ä¸Šä¼ çš„æ–‡ä»¶
let wyyTempSongCover = null;
let wyyTempSongFile = null;
let wyyTempLyricFile = null;

// é¡µé¢åˆ‡æ¢åŠŸèƒ½
if (wyyPlayBar) {
    wyyPlayBar.addEventListener('click', (e) => {
        if (!e.target.closest('.wyy-play-controls')) {
            wyyMainPage.classList.remove('active');
            wyyPlayerPage.classList.add('active');
            wyyUpdatePlayerPage();
        }
    });
}

if (wyyBackBtn) {
    wyyBackBtn.addEventListener('click', () => {
        wyyPlayerPage.classList.remove('active');
        wyyMainPage.classList.add('active');
    });
}

// åˆå§‹åŒ–æ’­æ”¾åˆ—è¡¨
async function wyyInitPlaylist() {
    try {
        let songs;
        if (wyyCurrentPlaylistId) {
            // åŠ è½½æŒ‡å®šæ­Œå•çš„æ­Œæ›²
            songs = await wyyDb.songs.where('playlistId').equals(wyyCurrentPlaylistId).toArray();
            // åœ¨å†…å­˜ä¸­æŒ‰æ—¥æœŸæ’åº
            songs.sort((a, b) => {
                const dateA = a.dateAdded ? new Date(a.dateAdded).getTime() : 0;
                const dateB = b.dateAdded ? new Date(b.dateAdded).getTime() : 0;
                return dateA - dateB;
            });
        } else {
            // å¦‚æœæ²¡æœ‰é€‰ä¸­æ­Œå•ï¼ŒåŠ è½½æ‰€æœ‰æ­Œæ›²ï¼ˆå…¼å®¹æ—§æ•°æ®ï¼‰
            songs = await wyyDb.songs.orderBy('dateAdded').toArray();
        }
        
        if (songs.length > 0) {
            wyyPlaylist = songs;
            
            // åŠ è½½æ¯é¦–æ­Œæ›²çš„æ–‡ä»¶æ•°æ®
            for (let i = 0; i < wyyPlaylist.length; i++) {
                const song = wyyPlaylist[i];
                
                // åŠ è½½æ­Œæ›²æ–‡ä»¶
                const songFile = await wyyDb.songFiles.where({ songId: song.id }).first();
                if (songFile) {
                    song.hasLocalFile = true;
                    song.localFileData = songFile.data;
                    song.fileType = songFile.type;
                }
                
                // åŠ è½½æ­Œè¯æ–‡ä»¶
                const lyric = await wyyDb.lyrics.where({ songId: song.id }).first();
                if (lyric) {
                    song.hasLocalLyric = true;
                    song.localLyricData = lyric.data;
                }
            }
            
            wyyUpdatePlaylistDisplay();
        } else {
            // ç©ºæ­Œå•
            wyyPlaylist = [];
            wyyUpdatePlaylistDisplay();
        }
        
        // è®¾ç½®å½“å‰æ’­æ”¾çš„æ­Œæ›²
        if (wyyPlaylist.length > 0) {
            await wyyLoadSong(wyyCurrentSongIndex);
        }
    } catch (error) {
        console.error('åˆå§‹åŒ–æ’­æ”¾åˆ—è¡¨å¤±è´¥:', error);
    }
}

// æ›´æ–°æ’­æ”¾åˆ—è¡¨æ˜¾ç¤º
function wyyUpdatePlaylistDisplay() {
    if (!wyySongsList) return;
    
    if (wyyPlaylist.length === 0) {
        if (wyyEmptyPlaylist) wyyEmptyPlaylist.style.display = 'block';
        wyySongsList.innerHTML = '<div class="wyy-empty-playlist">æš‚æ— æ­Œæ›²ï¼Œè¯·æ·»åŠ æ­Œæ›²</div>';
        return;
    }
    
    if (wyyEmptyPlaylist) wyyEmptyPlaylist.style.display = 'none';
    
    let songsHTML = '';
    wyyPlaylist.forEach((song, index) => {
        const isActive = index === wyyCurrentSongIndex;
        const hasCover = song.cover && song.cover !== '';
        songsHTML += `
            <div class="wyy-song-item ${isActive ? 'active' : ''}" data-index="${index}">
                <div class="wyy-song-item-icon ${!hasCover ? 'default' : ''}" style="${hasCover ? `background-image: url(${song.cover})` : ''}">
                    ${!hasCover ? (isActive ? '<i class="fa fa-play"></i>' : (index + 1)) : ''}
                </div>
                <div class="wyy-song-item-info">
                    <div class="wyy-song-item-name">${song.name}</div>
                    <div class="wyy-song-item-singer">${song.singer}</div>
                </div>
                <div class="wyy-song-item-actions" style="display: flex; gap: 5px; align-items: center;">
                    <button class="wyy-song-item-add" data-song-id="${song.id}" title="æ·»åŠ åˆ°æ­Œå•">
                        <i class="fa fa-plus"></i>
                    </button>
                    <button class="wyy-song-item-remove" data-index="${index}">
                        <i class="fa fa-times"></i>
                    </button>
                </div>
            </div>
        `;
    });
    
    wyySongsList.innerHTML = songsHTML;
    
    // æ·»åŠ æ­Œæ›²ç‚¹å‡»äº‹ä»¶
    document.querySelectorAll('.wyy-song-item').forEach(item => {
        item.addEventListener('click', function(e) {
            if (!e.target.closest('.wyy-song-item-remove') && !e.target.closest('.wyy-song-item-add') && !e.target.closest('.wyy-song-item-actions')) {
                const index = parseInt(this.getAttribute('data-index'));
                wyyPlaySong(index);
                if (wyyPlaylistModal) wyyPlaylistModal.style.display = 'none';
            }
        });
    });
    
    // æ·»åŠ "æ·»åŠ åˆ°æ­Œå•"æŒ‰é’®ç‚¹å‡»äº‹ä»¶
    document.querySelectorAll('.wyy-song-item-add').forEach(btn => {
        btn.addEventListener('click', function(e) {
            e.stopPropagation();
            const songId = parseInt(this.getAttribute('data-song-id'));
            wyyShowAddToPlaylistModal(songId);
        });
    });
    
    // æ·»åŠ åˆ é™¤æŒ‰é’®ç‚¹å‡»äº‹ä»¶
    document.querySelectorAll('.wyy-song-item-remove').forEach(btn => {
        btn.addEventListener('click', function(e) {
            e.stopPropagation();
            const index = parseInt(this.getAttribute('data-index'));
            wyyRemoveSong(index);
        });
    });
}

// æ›´æ–°æ’­æ”¾å™¨é¡µé¢
function wyyUpdatePlayerPage() {
    if (wyyPlaylist.length === 0 || wyyCurrentSongIndex >= wyyPlaylist.length) return;
    
    const song = wyyPlaylist[wyyCurrentSongIndex];
    if (wyyPlayerSongName) wyyPlayerSongName.textContent = song.name;
    if (wyyPlayerSingerName) wyyPlayerSingerName.textContent = song.singer;
    
    if (wyyAlbumArtLarge) {
        if (song.cover && song.cover !== '') {
            wyyAlbumArtLarge.style.backgroundImage = `url(${song.cover})`;
        } else {
            wyyAlbumArtLarge.style.backgroundImage = '';
            wyyAlbumArtLarge.style.backgroundColor = '#f5f5f5';
        }
    }
    
    if (wyyAudio) {
        if (wyyTotalTime) wyyTotalTime.textContent = wyyFormatTime(wyyAudio.duration || 299);
        wyyStartProgressUpdate();
    }
    
    // æ›´æ–°æ­Œè¯æ˜¾ç¤ºçŠ¶æ€
    const wyyLyricsContainer = document.getElementById('wyyLyricsContainer');
    if (wyyShowLyrics) {
        if (wyyAlbumArtLarge) wyyAlbumArtLarge.classList.add('hidden');
        if (wyyLyricsContainer) wyyLyricsContainer.classList.add('active');
        wyyUpdateLyricsDisplay();
    } else {
        if (wyyAlbumArtLarge) wyyAlbumArtLarge.classList.remove('hidden');
        if (wyyLyricsContainer) wyyLyricsContainer.classList.remove('active');
    }
}

// æ’­æ”¾æŒ‡å®šç´¢å¼•çš„æ­Œæ›²
async function wyyPlaySong(index) {
    if (index >= 0 && index < wyyPlaylist.length) {
        wyyCurrentSongIndex = index;
        await wyyLoadSong(index);
        wyyPlayCurrentSong();
        wyyUpdatePlaylistDisplay();
        wyyUpdatePlayerPage();
    }
}

// åŠ è½½æ­Œæ›²
async function wyyLoadSong(index) {
    const song = wyyPlaylist[index];
    
    // åœæ­¢å½“å‰æ’­æ”¾
    if (wyyAudio) {
        wyyAudio.pause();
        wyyStopProgressUpdate();
        if (wyyRecordCover) wyyRecordCover.classList.remove('playing');
        if (wyyPlayBtn) wyyPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
        if (wyyPlayerPlayBtn) wyyPlayerPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
        
        // é‡Šæ”¾ä¹‹å‰çš„å¯¹è±¡URL
        if (wyyAudio.src && wyyAudio.src.startsWith('blob:')) {
            URL.revokeObjectURL(wyyAudio.src);
        }
    }
    
    // åˆ›å»ºæ–°çš„éŸ³é¢‘å¯¹è±¡
    try {
        if (song.hasLocalFile && song.localFileData) {
            // å°†Base64è½¬æ¢ä¸ºBlobå¹¶åˆ›å»ºå¯¹è±¡URL
            const audioData = wyyBase64ToBlob(song.localFileData, song.fileType || 'audio/mpeg');
            const audioUrl = URL.createObjectURL(audioData);
            wyyAudio = new Audio(audioUrl);
        } else if (song.url) {
            // å¤„ç†ç½‘æ˜“äº‘éŸ³ä¹URLï¼ˆå¯èƒ½éœ€è¦ç‰¹æ®Šå¤„ç†ï¼‰
            let audioUrl = song.url;
            // å¦‚æœæ˜¯ç½‘æ˜“äº‘çš„å¤–é“¾ï¼Œå°è¯•æ·»åŠ å‚æ•°
            if (audioUrl.includes('music.163.com')) {
                // ç½‘æ˜“äº‘å¤–é“¾å¯èƒ½éœ€è¦ç‰¹æ®Šå¤„ç†
                console.log('æ£€æµ‹åˆ°ç½‘æ˜“äº‘éŸ³ä¹URLï¼Œå¯èƒ½éœ€è¦ç‰¹æ®Šå¤„ç†');
            }
            
            wyyAudio = new Audio(audioUrl);
            // æ·»åŠ è·¨åŸŸæ”¯æŒ
            wyyAudio.crossOrigin = 'anonymous';
            // è®¾ç½®åŠ è½½ç­–ç•¥
            wyyAudio.load();
        } else {
            console.error('æ²¡æœ‰æœ‰æ•ˆçš„æ­Œæ›²æ–‡ä»¶');
            alert('æ— æ³•åŠ è½½æ­Œæ›²æ–‡ä»¶ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼');
            return;
        }
        
        wyyAudio.loop = false;
        wyyAudio.preload = 'auto';
        
        // é”™è¯¯å¤„ç†
        wyyAudio.addEventListener('error', (e) => {
            console.error('éŸ³é¢‘åŠ è½½é”™è¯¯:', e);
            const error = wyyAudio.error;
            let errorMsg = 'éŸ³é¢‘åŠ è½½å¤±è´¥';
            if (error) {
                switch(error.code) {
                    case error.MEDIA_ERR_ABORTED:
                        errorMsg = 'éŸ³é¢‘åŠ è½½è¢«ä¸­æ­¢';
                        break;
                    case error.MEDIA_ERR_NETWORK:
                        errorMsg = 'ç½‘ç»œé”™è¯¯ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥';
                        break;
                    case error.MEDIA_ERR_DECODE:
                        errorMsg = 'éŸ³é¢‘è§£ç å¤±è´¥ï¼Œå¯èƒ½æ ¼å¼ä¸æ”¯æŒ';
                        break;
                    case error.MEDIA_ERR_SRC_NOT_SUPPORTED:
                        errorMsg = 'éŸ³é¢‘æ ¼å¼ä¸æ”¯æŒï¼Œè¯·å°è¯•å…¶ä»–æ ¼å¼';
                        break;
                }
            }
            console.error(errorMsg);
        });
        
        // æ›´æ–°éŸ³é¢‘äº‹ä»¶ç›‘å¬
        wyyAudio.addEventListener('ended', wyyHandleSongEnded);
        wyyAudio.addEventListener('loadedmetadata', () => {
            if (wyyAudio.duration && !isNaN(wyyAudio.duration) && isFinite(wyyAudio.duration)) {
                if (wyyTotalTime) wyyTotalTime.textContent = wyyFormatTime(wyyAudio.duration);
                console.log('éŸ³é¢‘æ—¶é•¿:', wyyAudio.duration, 'ç§’');
            } else {
                console.warn('æ— æ³•è·å–éŸ³é¢‘æ—¶é•¿');
            }
            wyyUpdateProgress();
        });
        wyyAudio.addEventListener('canplay', () => {
            console.log('éŸ³é¢‘å¯ä»¥å¼€å§‹æ’­æ”¾');
        });
        wyyAudio.addEventListener('canplaythrough', () => {
            console.log('éŸ³é¢‘å®Œå…¨åŠ è½½ï¼Œå¯ä»¥æµç•…æ’­æ”¾');
        });
        wyyAudio.addEventListener('loadeddata', () => {
            console.log('éŸ³é¢‘æ•°æ®åŠ è½½å®Œæˆ');
        });
        wyyAudio.addEventListener('progress', () => {
            if (wyyAudio.buffered.length > 0) {
                const bufferedEnd = wyyAudio.buffered.end(wyyAudio.buffered.length - 1);
                const duration = wyyAudio.duration;
                if (duration > 0) {
                    const bufferedPercent = (bufferedEnd / duration) * 100;
                    console.log('éŸ³é¢‘ç¼“å†²è¿›åº¦:', bufferedPercent.toFixed(1) + '%');
                }
            }
        });
        wyyAudio.addEventListener('stalled', () => {
            console.warn('éŸ³é¢‘åŠ è½½åœæ»');
        });
        wyyAudio.addEventListener('suspend', () => {
            console.warn('éŸ³é¢‘åŠ è½½æš‚åœ');
        });
        wyyAudio.addEventListener('timeupdate', () => {
            wyyUpdateProgress();
            if (wyyShowLyrics) {
                wyyUpdateLyricsDisplay();
            }
        });
        
        // æ›´æ–°æ˜¾ç¤º
        if (wyyCurrentSongName) wyyCurrentSongName.textContent = song.name;
        if (wyyCurrentSingerName) wyyCurrentSingerName.textContent = song.singer;
        
        // æ›´æ–°å”±ç‰‡å°é¢
        if (wyyCurrentRecordContainer) {
            if (song.cover && song.cover !== '') {
                wyyCurrentRecordContainer.style.backgroundImage = `url(${song.cover})`;
            } else {
                wyyCurrentRecordContainer.style.backgroundImage = '';
                wyyCurrentRecordContainer.style.backgroundColor = '#cccccc';
            }
        }
        
        // åŠ è½½æ­Œè¯
        if (song.hasLocalLyric && song.localLyricData) {
            wyyLoadLyricsFromText(song.localLyricData);
        } else if (song.lyricUrl) {
            wyyLoadLyricsFromUrl(song.lyricUrl);
        } else if (song.lyricText) {
            wyyLoadLyricsFromText(song.lyricText);
        }
    } catch (error) {
        console.error('åŠ è½½æ­Œæ›²å¤±è´¥:', error);
        alert('åŠ è½½æ­Œæ›²å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶');
    }
}

// Base64è½¬Blob
function wyyBase64ToBlob(base64, contentType = '') {
    const byteCharacters = atob(base64.split(',')[1]);
    const byteNumbers = new Array(byteCharacters.length);
    for (let i = 0; i < byteCharacters.length; i++) {
        byteNumbers[i] = byteCharacters.charCodeAt(i);
    }
    const byteArray = new Uint8Array(byteNumbers);
    return new Blob([byteArray], { type: contentType });
}

// æ’­æ”¾å½“å‰æ­Œæ›²
async function wyyPlayCurrentSong() {
    if (!wyyAudio) return;
    
    try {
        // ç­‰å¾…éŸ³é¢‘å¯ä»¥æ’­æ”¾
        if (wyyAudio.readyState < 2) {
            await new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    reject(new Error('éŸ³é¢‘åŠ è½½è¶…æ—¶'));
                }, 10000);
                
                const checkReady = () => {
                    if (wyyAudio.readyState >= 2) {
                        clearTimeout(timeout);
                        resolve();
                    } else {
                        setTimeout(checkReady, 100);
                    }
                };
                
                wyyAudio.addEventListener('canplay', () => {
                    clearTimeout(timeout);
                    resolve();
                }, { once: true });
                
                checkReady();
            });
        }
        
        await wyyAudio.play();
        if (wyyPlayBtn) wyyPlayBtn.innerHTML = '<i class="fa fa-pause"></i>';
        if (wyyPlayerPlayBtn) wyyPlayerPlayBtn.innerHTML = '<i class="fa fa-pause"></i>';
        if (wyyRecordCover) wyyRecordCover.classList.add('playing');
        wyyStartProgressUpdate();
        console.log('æ’­æ”¾æˆåŠŸ');
    } catch (err) {
        console.error('æ’­æ”¾å¤±è´¥:', err);
        let errorMsg = 'æ’­æ”¾å¤±è´¥';
        if (err.name === 'NotAllowedError') {
            errorMsg = 'æµè§ˆå™¨é˜»æ­¢äº†è‡ªåŠ¨æ’­æ”¾ï¼Œè¯·æ‰‹åŠ¨ç‚¹å‡»æ’­æ”¾æŒ‰é’®';
        } else if (err.name === 'NotSupportedError') {
            errorMsg = 'éŸ³é¢‘æ ¼å¼ä¸æ”¯æŒï¼Œè¯·å°è¯•å…¶ä»–æ ¼å¼';
        } else if (err.message === 'éŸ³é¢‘åŠ è½½è¶…æ—¶') {
            errorMsg = 'éŸ³é¢‘åŠ è½½è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–æ–‡ä»¶';
        } else {
            errorMsg = 'æ’­æ”¾å¤±è´¥ï¼š' + err.message;
        }
        alert(errorMsg);
    }
}

// å¤„ç†æ­Œæ›²ç»“æŸ
function wyyHandleSongEnded() {
    if (wyyPlaylist.length > 0) {
        if (wyyPlayMode === 'single') {
            // å•æ›²å¾ªç¯ï¼šé‡æ–°æ’­æ”¾å½“å‰æ­Œæ›²
            wyyAudio.currentTime = 0;
            wyyPlayCurrentSong();
        } else {
            // é¡ºåºæ’­æ”¾ï¼šæ’­æ”¾ä¸‹ä¸€é¦–
            wyyCurrentSongIndex = (wyyCurrentSongIndex + 1) % wyyPlaylist.length;
            wyyLoadSong(wyyCurrentSongIndex);
            wyyPlayCurrentSong();
            wyyUpdatePlaylistDisplay();
            wyyUpdatePlayerPage();
        }
    } else {
        if (wyyPlayBtn) wyyPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
        if (wyyPlayerPlayBtn) wyyPlayerPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
        if (wyyRecordCover) wyyRecordCover.classList.remove('playing');
        wyyStopProgressUpdate();
    }
}

// æ·»åŠ ä¸Šä¼ æ­Œæ›²
async function wyyAddSong() {
    if (!wyySongNameInput || !wyySingerNameInput) return;
    
    const name = wyySongNameInput.value.trim();
    const singer = wyySingerNameInput.value.trim();
    const url = wyySongUrlInput ? wyySongUrlInput.value.trim() : '';
    const lyricUrl = wyyLyricUrlInput ? wyyLyricUrlInput.value.trim() : '';
    
    if (!name || !singer) {
        alert('è¯·å¡«å†™æ­Œæ›²åç§°å’Œæ­Œæ‰‹');
        return;
    }
    
    // æ£€æŸ¥æ˜¯å¦æœ‰æ­Œæ›²æ–‡ä»¶
    if (!wyyTempSongFile && !url) {
        alert('è¯·ä¸Šä¼ æ­Œæ›²æ–‡ä»¶æˆ–è¾“å…¥æ­Œæ›²URL');
        return;
    }
    
    // æ£€æŸ¥æ˜¯å¦é€‰ä¸­äº†æ­Œå•
    if (!wyyCurrentPlaylistId) {
        alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ­Œå•æˆ–åˆ›å»ºæ–°æ­Œå•');
        return;
    }
    
    try {
        const songData = {
            name,
            singer,
            cover: wyyTempSongCover || '',
            lyricUrl: '',
            playlistId: wyyCurrentPlaylistId,
            hasLocalFile: false,
            hasLocalLyric: false,
            dateAdded: new Date()
        };
        
        // ä¿å­˜æ­Œæ›²åŸºæœ¬ä¿¡æ¯
        const songId = await wyyDb.songs.add(songData);
        
        // å¤„ç†æ­Œæ›²æ–‡ä»¶
        if (wyyTempSongFile) {
            await wyyDb.songFiles.add({
                songId: songId,
                type: wyyTempSongFile.type,
                data: wyyTempSongFile.data
            });
            
            songData.hasLocalFile = true;
            songData.localFileData = wyyTempSongFile.data;
            songData.fileType = wyyTempSongFile.type;
        } else if (url) {
            if (!url.startsWith('http://') && !url.startsWith('https://')) {
                alert('è¯·æä¾›æœ‰æ•ˆçš„æ­Œæ›²URLï¼ˆä»¥http://æˆ–https://å¼€å¤´ï¼‰');
                return;
            }
            songData.url = url;
            await wyyDb.songs.update(songId, { url: url });
        }
        
        // å¤„ç†æ­Œè¯æ–‡ä»¶
        if (wyyTempLyricFile) {
            await wyyDb.lyrics.add({
                songId: songId,
                data: wyyTempLyricFile.data
            });
            
            songData.hasLocalLyric = true;
            songData.localLyricData = wyyTempLyricFile.data;
        } else if (lyricUrl) {
            songData.lyricUrl = lyricUrl;
            await wyyDb.songs.update(songId, { lyricUrl: lyricUrl });
        }
        
        // å¤„ç†å°é¢
        if (wyyTempSongCover) {
            await wyyDb.songs.update(songId, { cover: wyyTempSongCover });
        }
        
        songData.id = songId;
        wyyPlaylist.push(songData);
        
        // æ¸…ç©ºè¾“å…¥æ¡†å’Œä¸´æ—¶æ•°æ®
        wyySongNameInput.value = '';
        wyySingerNameInput.value = '';
        if (wyySongUrlInput) wyySongUrlInput.value = '';
        if (wyyLyricUrlInput) wyyLyricUrlInput.value = '';
        if (wyySongCoverPreview) wyySongCoverPreview.style.backgroundImage = '';
        wyyTempSongCover = null;
        wyyTempSongFile = null;
        wyyTempLyricFile = null;
        
        wyyUpdatePlaylistDisplay();
        
        // å¦‚æœæ˜¯ç¬¬ä¸€é¦–æ­Œæ›²ï¼Œè®¾ç½®ä¸ºå½“å‰æ’­æ”¾
        if (wyyPlaylist.length === 1) {
            wyyCurrentSongIndex = 0;
            await wyyLoadSong(0);
        }
        
        alert('æ­Œæ›²æ·»åŠ æˆåŠŸï¼');
    } catch (error) {
        console.error('æ·»åŠ æ­Œæ›²å¤±è´¥:', error);
        alert('æ·»åŠ æ­Œæ›²å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
}

// åˆ é™¤æ­Œæ›²
async function wyyRemoveSong(index) {
    if (index >= 0 && index < wyyPlaylist.length) {
        const song = wyyPlaylist[index];
        
        try {
            // ä»æ•°æ®åº“ä¸­åˆ é™¤
            await wyyDb.songs.delete(song.id);
            await wyyDb.songFiles.where({ songId: song.id }).delete();
            await wyyDb.lyrics.where({ songId: song.id }).delete();
            
            // é‡Šæ”¾å¯¹è±¡URL
            if (song.hasLocalFile && wyyAudio && wyyAudio.src && wyyAudio.src.startsWith('blob:')) {
                URL.revokeObjectURL(wyyAudio.src);
            }
            
            wyyPlaylist.splice(index, 1);
            
            // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰æ’­æ”¾çš„æ­Œæ›²
            if (index === wyyCurrentSongIndex) {
                if (wyyPlaylist.length > 0) {
                    wyyCurrentSongIndex = Math.min(wyyCurrentSongIndex, wyyPlaylist.length - 1);
                    await wyyLoadSong(wyyCurrentSongIndex);
                    if (wyyAudio && !wyyAudio.paused) {
                        wyyPlayCurrentSong();
                    }
                } else {
                    if (wyyAudio) {
                        wyyAudio.pause();
                    }
                    if (wyyCurrentSongName) wyyCurrentSongName.textContent = 'æš‚æ— æ­Œæ›²';
                    if (wyyCurrentSingerName) wyyCurrentSingerName.textContent = '';
                    if (wyyPlayerSongName) wyyPlayerSongName.textContent = 'æš‚æ— æ­Œæ›²';
                    if (wyyPlayerSingerName) wyyPlayerSingerName.textContent = '';
                    if (wyyCurrentRecordContainer) {
                        wyyCurrentRecordContainer.style.backgroundImage = '';
                        wyyCurrentRecordContainer.style.backgroundColor = '#cccccc';
                    }
                    if (wyyAlbumArtLarge) {
                        wyyAlbumArtLarge.style.backgroundImage = '';
                        wyyAlbumArtLarge.style.backgroundColor = '#f5f5f5';
                    }
                    if (wyyPlayBtn) wyyPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
                    if (wyyPlayerPlayBtn) wyyPlayerPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
                    if (wyyRecordCover) wyyRecordCover.classList.remove('playing');
                    wyyStopProgressUpdate();
                }
            } else if (index < wyyCurrentSongIndex) {
                wyyCurrentSongIndex--;
            }
            
            wyyUpdatePlaylistDisplay();
            wyyUpdatePlayerPage();
        } catch (error) {
            console.error('åˆ é™¤æ­Œæ›²å¤±è´¥:', error);
        }
    }
}

// æ¸…ç©ºåˆ—è¡¨
async function wyyClearAllSongs() {
    if (wyyPlaylist.length > 0 && confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æ­Œæ›²å—ï¼Ÿ')) {
        try {
            // é‡Šæ”¾æ‰€æœ‰å¯¹è±¡URL
            wyyPlaylist.forEach(song => {
                if (song.hasLocalFile && wyyAudio && wyyAudio.src && wyyAudio.src.startsWith('blob:')) {
                    URL.revokeObjectURL(wyyAudio.src);
                }
            });
            
            // æ¸…ç©ºæ•°æ®åº“
            await wyyDb.songs.clear();
            await wyyDb.songFiles.clear();
            await wyyDb.lyrics.clear();
            
            wyyPlaylist = [];
            if (wyyAudio) {
                wyyAudio.pause();
            }
            if (wyyCurrentSongName) wyyCurrentSongName.textContent = 'æš‚æ— æ­Œæ›²';
            if (wyyCurrentSingerName) wyyCurrentSingerName.textContent = '';
            if (wyyPlayerSongName) wyyPlayerSongName.textContent = 'æš‚æ— æ­Œæ›²';
            if (wyyPlayerSingerName) wyyPlayerSingerName.textContent = '';
            if (wyyCurrentRecordContainer) {
                wyyCurrentRecordContainer.style.backgroundImage = '';
                wyyCurrentRecordContainer.style.backgroundColor = '#cccccc';
            }
            if (wyyAlbumArtLarge) {
                wyyAlbumArtLarge.style.backgroundImage = '';
                wyyAlbumArtLarge.style.backgroundColor = '#f5f5f5';
            }
            if (wyyPlayBtn) wyyPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
            if (wyyPlayerPlayBtn) wyyPlayerPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
            if (wyyRecordCover) wyyRecordCover.classList.remove('playing');
            wyyStopProgressUpdate();
            
            wyyUpdatePlaylistDisplay();
            wyyUpdatePlayerPage();
        } catch (error) {
            console.error('æ¸…ç©ºåˆ—è¡¨å¤±è´¥:', error);
        }
    }
}

// åŠ è½½æ­Œè¯
function wyyLoadLyricsFromUrl(url) {
    if (!url) {
        wyyCurrentLyrics = [];
        wyyUpdateLyricsDisplay();
        return;
    }
    
    fetch(url)
        .then(response => response.text())
        .then(text => {
            wyyLoadLyricsFromText(text);
        })
        .catch(error => {
            console.log('æ­Œè¯åŠ è½½å¤±è´¥:', error);
            wyyCurrentLyrics = [];
            wyyUpdateLyricsDisplay();
        });
}

// è§£æLRCæ­Œè¯
function wyyParseLyrics(text) {
    if (!text) return [];
    
    const lines = text.split('\n');
    const lyrics = [];
    
    for (let line of lines) {
        line = line.trim();
        if (!line) continue;
        
        // åŒ¹é…æ—¶é—´æ ‡ç­¾ [mm:ss.xx] æˆ– [mm:ss]
        const timeRegex = /\[(\d{2}):(\d{2})(?:\.(\d{2,3}))?\]/g;
        const matches = [...line.matchAll(timeRegex)];
        
        if (matches.length > 0) {
            const lyricText = line.replace(timeRegex, '').trim();
            if (!lyricText) continue;
            
            for (let match of matches) {
                const minutes = parseInt(match[1]);
                const seconds = parseInt(match[2]);
                const milliseconds = match[3] ? parseInt(match[3].padEnd(3, '0')) : 0;
                const time = minutes * 60 + seconds + milliseconds / 1000;
                
                lyrics.push({
                    time: time,
                    text: lyricText
                });
            }
        }
    }
    
    // æŒ‰æ—¶é—´æ’åº
    lyrics.sort((a, b) => a.time - b.time);
    return lyrics;
}

function wyyLoadLyricsFromText(text) {
    if (!text) {
        wyyCurrentLyrics = [];
        wyyUpdateLyricsDisplay();
        return;
    }
    
    // å¦‚æœæ˜¯Base64ç¼–ç ï¼Œå…ˆè§£ç 
    let lyricText = text;
    if (text.startsWith('data:text/plain;base64,')) {
        try {
            const base64Data = text.split(',')[1];
            lyricText = atob(base64Data);
        } catch (e) {
            console.error('æ­Œè¯è§£ç å¤±è´¥:', e);
        }
    }
    
    wyyCurrentLyrics = wyyParseLyrics(lyricText);
    wyyUpdateLyricsDisplay();
}

// æ›´æ–°æ­Œè¯æ˜¾ç¤º
function wyyUpdateLyricsDisplay() {
    const lyricsContent = document.getElementById('wyyLyricsContent');
    if (!lyricsContent) return;
    
    if (wyyCurrentLyrics.length === 0) {
        lyricsContent.innerHTML = '<div style="opacity: 0.6;">æš‚æ— æ­Œè¯</div>';
        return;
    }
    
    // å¦‚æœæ­£åœ¨æ’­æ”¾ï¼Œé«˜äº®å½“å‰æ­Œè¯
    if (wyyAudio && !wyyAudio.paused) {
        const currentTime = wyyAudio.currentTime;
        let activeIndex = -1;
        
        for (let i = wyyCurrentLyrics.length - 1; i >= 0; i--) {
            if (currentTime >= wyyCurrentLyrics[i].time) {
                activeIndex = i;
                break;
            }
        }
        
        let html = '';
        wyyCurrentLyrics.forEach((lyric, index) => {
            const isActive = index === activeIndex;
            html += `<div style="margin: 10px 0; ${isActive ? 'color: #fff; font-weight: bold; font-size: 18px;' : 'opacity: 0.6;'}">${lyric.text}</div>`;
        });
        
        lyricsContent.innerHTML = html;
        
        // æ»šåŠ¨åˆ°å½“å‰æ­Œè¯
        if (activeIndex >= 0) {
            const activeElement = lyricsContent.children[activeIndex];
            if (activeElement) {
                activeElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }
    } else {
        // æœªæ’­æ”¾æ—¶æ˜¾ç¤ºæ‰€æœ‰æ­Œè¯
        let html = '';
        wyyCurrentLyrics.forEach(lyric => {
            html += `<div style="margin: 10px 0; opacity: 0.6;">${lyric.text}</div>`;
        });
        lyricsContent.innerHTML = html;
    }
}

// æ’­æ”¾æŒ‰é’®äº‹ä»¶
if (wyyPlayBtn) {
    wyyPlayBtn.addEventListener('click', async () => {
        if (wyyPlaylist.length === 0) {
            alert('è¯·å…ˆæ·»åŠ æ­Œæ›²');
            return;
        }
        
        if (!wyyAudio) {
            await wyyLoadSong(wyyCurrentSongIndex);
        }
        
        if (wyyAudio && wyyAudio.paused) {
            await wyyPlayCurrentSong();
        } else if (wyyAudio) {
            wyyAudio.pause();
            wyyPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
            if (wyyPlayerPlayBtn) wyyPlayerPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
            if (wyyRecordCover) wyyRecordCover.classList.remove('playing');
            wyyStopProgressUpdate();
        }
    });
}

if (wyyPlayerPlayBtn) {
    wyyPlayerPlayBtn.addEventListener('click', async () => {
        if (wyyPlaylist.length === 0) {
            alert('è¯·å…ˆæ·»åŠ æ­Œæ›²');
            return;
        }
        
        if (!wyyAudio) {
            await wyyLoadSong(wyyCurrentSongIndex);
        }
        
        if (wyyAudio && wyyAudio.paused) {
            await wyyPlayCurrentSong();
        } else if (wyyAudio) {
            wyyAudio.pause();
            if (wyyPlayBtn) wyyPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
            wyyPlayerPlayBtn.innerHTML = '<i class="fa fa-play"></i>';
            if (wyyRecordCover) wyyRecordCover.classList.remove('playing');
            wyyStopProgressUpdate();
        }
    });
}

// ä¸Šä¸€é¦–/ä¸‹ä¸€é¦–
if (wyyPrevBtn) {
    wyyPrevBtn.addEventListener('click', () => {
        if (wyyPlaylist.length === 0) return;
        
        wyyCurrentSongIndex = (wyyCurrentSongIndex - 1 + wyyPlaylist.length) % wyyPlaylist.length;
        wyyPlaySong(wyyCurrentSongIndex);
    });
}

if (wyyNextBtn) {
    wyyNextBtn.addEventListener('click', () => {
        if (wyyPlaylist.length === 0) return;
        
        wyyCurrentSongIndex = (wyyCurrentSongIndex + 1) % wyyPlaylist.length;
        wyyPlaySong(wyyCurrentSongIndex);
    });
}

// å¾ªç¯æ¨¡å¼åˆ‡æ¢
const wyyLoopModeBtn = document.getElementById('wyyLoopModeBtn');
const wyyLoopIcon = document.getElementById('wyyLoopIcon');

if (wyyLoopModeBtn && wyyLoopIcon) {
    wyyLoopModeBtn.addEventListener('click', () => {
        if (wyyPlayMode === 'order') {
            // åˆ‡æ¢åˆ°å•æ›²å¾ªç¯
            wyyPlayMode = 'single';
            wyyLoopIcon.className = 'fa fa-repeat';
            wyyLoopModeBtn.classList.add('wyy-loop-mode-single');
            if (wyyAudio) {
                wyyAudio.loop = false; // ä½¿ç”¨è‡ªå®šä¹‰å¾ªç¯é€»è¾‘
            }
        } else {
            // åˆ‡æ¢åˆ°é¡ºåºæ’­æ”¾
            wyyPlayMode = 'order';
            wyyLoopIcon.className = 'fa fa-list';
            wyyLoopModeBtn.classList.remove('wyy-loop-mode-single');
            if (wyyAudio) {
                wyyAudio.loop = false;
            }
        }
    });
}

// æ’­æ”¾åˆ—è¡¨æŒ‰é’®äº‹ä»¶ï¼ˆä¸»é¡µé¢ï¼‰
if (wyyPlaylistBtn) {
    wyyPlaylistBtn.addEventListener('click', () => {
        if (wyyPlaylistModal) wyyPlaylistModal.style.display = 'flex';
    });
}

// æ’­æ”¾å™¨è¯¦æƒ…é¡µé¢çš„æ’­æ”¾åˆ—è¡¨æŒ‰é’®ï¼ˆæ‰“å¼€æ’­æ”¾åˆ—è¡¨ï¼‰
const wyyPlayerPlaylistBtn = document.getElementById('wyyPlayerPlaylistBtn');
const wyyLyricsContainer = document.getElementById('wyyLyricsContainer');

if (wyyPlayerPlaylistBtn) {
    wyyPlayerPlaylistBtn.addEventListener('click', () => {
        if (wyyPlaylistModal) wyyPlaylistModal.style.display = 'flex';
    });
}

// å°é¢ç‚¹å‡»åˆ‡æ¢æ­Œè¯
if (wyyAlbumArtLarge) {
    wyyAlbumArtLarge.addEventListener('click', () => {
        wyyShowLyrics = !wyyShowLyrics;
        
        if (wyyShowLyrics) {
            wyyAlbumArtLarge.classList.add('hidden');
            if (wyyLyricsContainer) wyyLyricsContainer.classList.add('active');
            wyyUpdateLyricsDisplay();
        } else {
            wyyAlbumArtLarge.classList.remove('hidden');
            if (wyyLyricsContainer) wyyLyricsContainer.classList.remove('active');
        }
    });
}

// è¿›åº¦æ¡åŠŸèƒ½
function wyyStartProgressUpdate() {
    wyyStopProgressUpdate();
    wyyProgressUpdateInterval = setInterval(wyyUpdateProgress, 1000);
    wyyUpdateProgress();
}

function wyyStopProgressUpdate() {
    if (wyyProgressUpdateInterval) {
        clearInterval(wyyProgressUpdateInterval);
        wyyProgressUpdateInterval = null;
    }
}

function wyyUpdateProgress() {
    if (!wyyAudio || !wyyAudio.duration) return;
    
    const percent = (wyyAudio.currentTime / wyyAudio.duration) * 100;
    if (wyyProgress) wyyProgress.style.width = percent + '%';
    if (wyyCurrentTime) wyyCurrentTime.textContent = wyyFormatTime(wyyAudio.currentTime);
    if (wyyTotalTime) wyyTotalTime.textContent = wyyFormatTime(wyyAudio.duration);
}

function wyyFormatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

if (wyyProgressBar) {
    wyyProgressBar.addEventListener('click', (e) => {
        if (!wyyAudio) return;
        
        const rect = wyyProgressBar.getBoundingClientRect();
        const percent = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
        wyyAudio.currentTime = percent * wyyAudio.duration;
        wyyUpdateProgress();
    });
}

// æ·»åŠ ä¸Šä¼ é€‰é¡¹åˆ‡æ¢åŠŸèƒ½
if (wyyUrlOptionBtn && wyyFileOptionBtn && wyyUrlUploadSection && wyyFileUploadSection) {
    wyyUrlOptionBtn.addEventListener('click', () => {
        wyyUrlOptionBtn.classList.add('active');
        wyyFileOptionBtn.classList.remove('active');
        wyyUrlUploadSection.classList.add('active');
        wyyFileUploadSection.classList.remove('active');
    });

    wyyFileOptionBtn.addEventListener('click', () => {
        wyyFileOptionBtn.classList.add('active');
        wyyUrlOptionBtn.classList.remove('active');
        wyyFileUploadSection.classList.add('active');
        wyyUrlUploadSection.classList.remove('active');
    });
}

if (wyyLyricUrlOptionBtn && wyyLyricFileOptionBtn && wyyLyricUrlUploadSection && wyyLyricFileUploadSection) {
    wyyLyricUrlOptionBtn.addEventListener('click', () => {
        wyyLyricUrlOptionBtn.classList.add('active');
        wyyLyricFileOptionBtn.classList.remove('active');
        wyyLyricUrlUploadSection.classList.add('active');
        wyyLyricFileUploadSection.classList.remove('active');
    });

    wyyLyricFileOptionBtn.addEventListener('click', () => {
        wyyLyricFileOptionBtn.classList.add('active');
        wyyLyricUrlOptionBtn.classList.remove('active');
        wyyLyricFileUploadSection.classList.add('active');
        wyyLyricUrlUploadSection.classList.remove('active');
    });
}

// ä¸Šä¼ å°é¢æŒ‰é’®
if (wyyUploadCoverBtn && wyyCoverFileInput) {
    wyyUploadCoverBtn.addEventListener('click', () => {
        wyyCoverFileInput.click();
    });

    wyyCoverFileInput.addEventListener('change', function(event) {
        const file = event.target.files[0];
        if (file) {
            if (!file.type.match('image.*')) {
                alert('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶ï¼');
                return;
            }
            
            if (file.size > 2 * 1024 * 1024) {
                alert('å›¾ç‰‡å¤§å°ä¸èƒ½è¶…è¿‡2MBï¼');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                if (wyySongCoverPreview) wyySongCoverPreview.style.backgroundImage = `url(${e.target.result})`;
                wyyTempSongCover = e.target.result;
            };
            reader.readAsDataURL(file);
        }
    });
}

// ä¸Šä¼ æ­Œæ›²æ–‡ä»¶æŒ‰é’®
if (wyyUploadSongFileBtn && wyySongFileInput) {
    wyyUploadSongFileBtn.addEventListener('click', () => {
        wyySongFileInput.click();
    });

    wyySongFileInput.addEventListener('change', function(event) {
        const file = event.target.files[0];
        if (file) {
            const validAudioTypes = [
                'audio/mpeg', 'audio/mp3', 'audio/wav', 'audio/wave', 'audio/x-wav',
                'audio/ogg', 'audio/oga', 'audio/x-m4a', 'audio/mp4', 'audio/flac',
                'audio/x-flac', 'audio/aac', 'audio/aacp'
            ];
            
            const validExtensions = ['.mp3', '.wav', '.ogg', '.m4a', '.flac', '.aac'];
            const fileName = file.name.toLowerCase();
            const isValidExtension = validExtensions.some(ext => fileName.endsWith(ext));
            
            if (!validAudioTypes.includes(file.type) && !isValidExtension) {
                alert('è¯·é€‰æ‹©æœ‰æ•ˆçš„éŸ³é¢‘æ–‡ä»¶ï¼ˆMP3ã€WAVã€OGGã€M4Aã€FLACã€AACç­‰æ ¼å¼ï¼‰ï¼');
                return;
            }
            
            if (file.size > 50 * 1024 * 1024) {
                alert('éŸ³é¢‘æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡50MBï¼');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                wyyTempSongFile = {
                    data: e.target.result,
                    type: file.type || 'audio/mpeg',
                    name: file.name
                };
                alert(`å·²é€‰æ‹©æ­Œæ›²æ–‡ä»¶: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`);
            };
            reader.readAsDataURL(file);
        }
    });
}

// ä¸Šä¼ æ­Œè¯æ–‡ä»¶æŒ‰é’®
if (wyyUploadLyricFileBtn && wyyLyricFileInput) {
    wyyUploadLyricFileBtn.addEventListener('click', () => {
        wyyLyricFileInput.click();
    });

    wyyLyricFileInput.addEventListener('change', function(event) {
        const file = event.target.files[0];
        if (file) {
            const validTypes = ['.lrc', '.txt'];
            const fileName = file.name.toLowerCase();
            const isValidType = validTypes.some(type => fileName.endsWith(type));
            
            if (!isValidType) {
                alert('è¯·é€‰æ‹©LRCæˆ–TXTæ ¼å¼çš„æ­Œè¯æ–‡ä»¶ï¼');
                return;
            }
            
            if (file.size > 1 * 1024 * 1024) {
                alert('æ­Œè¯æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡1MBï¼');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                wyyTempLyricFile = {
                    data: e.target.result,
                    name: file.name
                };
                alert(`å·²é€‰æ‹©æ­Œè¯æ–‡ä»¶: ${file.name}`);
            };
            reader.readAsDataURL(file);
        }
    });
}

// æ·»åŠ æ­Œæ›²æŒ‰é’®äº‹ä»¶
if (wyyAddSongBtn) {
    wyyAddSongBtn.addEventListener('click', wyyAddSong);
}

// æ¸…ç©ºåˆ—è¡¨æŒ‰é’®äº‹ä»¶
if (wyyClearAllBtn) {
    wyyClearAllBtn.addEventListener('click', wyyClearAllSongs);
}

// ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
if (wyyPlaylistModal) {
    wyyPlaylistModal.addEventListener('click', (e) => {
        if (e.target === wyyPlaylistModal) {
            wyyPlaylistModal.style.display = 'none';
            wyyTempSongCover = null;
            wyyTempSongFile = null;
            wyyTempLyricFile = null;
            if (wyySongCoverPreview) wyySongCoverPreview.style.backgroundImage = '';
        }
    });
}

// ä¿¡æ¯é¡µé¢æ•°æ®
const messageChats = [
    { 
        id: 'welcome', 
        name: 'æ¬¢è¿å°åŠ©æ‰‹', 
        avatar: 'https://img.icons8.com/color/96/chat.png', 
        time: 'åˆšåˆš', 
        preview: 'æ¬¢è¿ä½¿ç”¨è¿™ä¸ªç½‘é¡µï¼', 
        unread: false, 
        chatTimeLabel: 'åˆšåˆš',
        messages: [
            { 
                type: 'received', 
                text: 'æ¬¢è¿ä½¿ç”¨è¿™ä¸ªç½‘é¡µï¼ğŸ‰\n\nè¿™æ˜¯ä¸€ä¸ªä»¿ iOS é£æ ¼çš„ä¿¡æ¯åº”ç”¨ï¼Œä½ å¯ä»¥åœ¨è¿™é‡Œï¼š\n\nâ€¢ æŸ¥çœ‹å’Œç®¡ç†ä½ çš„ä¿¡æ¯\nâ€¢ ä¸å¥½å‹èŠå¤©\nâ€¢ å‘é€å’Œæ¥æ”¶æ¶ˆæ¯\n\nå¸Œæœ›ä½ èƒ½å–œæ¬¢è¿™ä¸ªè®¾è®¡ï¼å¦‚æœ‰ä»»ä½•é—®é¢˜ï¼Œéšæ—¶å‘Šè¯‰æˆ‘ã€‚' 
            }
        ]
    }
];

// çŸ­ä¿¡ç¼–è¾‘æ¨¡å¼çŠ¶æ€
let isMessageEditMode = false;
let selectedMessageChats = new Set();

// åˆ‡æ¢çŸ­ä¿¡ç¼–è¾‘æ¨¡å¼
async function toggleMessageEditMode() {
    isMessageEditMode = !isMessageEditMode;
    selectedMessageChats.clear();
    
    const editBtn = document.getElementById('message-edit-btn');
    const listContainer = document.getElementById('message-chat-list-container');
    
    if (isMessageEditMode) {
        editBtn.textContent = 'å®Œæˆ';
        if (listContainer) {
            listContainer.classList.add('edit-mode');
        }
        // æ˜¾ç¤ºåˆ‡æ¢è´¦å·å’Œåˆ é™¤æŒ‰é’®
        showMessageEditActions();
    } else {
        editBtn.textContent = 'ç¼–è¾‘';
        if (listContainer) {
            listContainer.classList.remove('edit-mode');
        }
        // éšè—æ“ä½œæŒ‰é’®
        hideMessageEditActions();
    }
    
    // é‡æ–°æ¸²æŸ“åˆ—è¡¨ä»¥æ˜¾ç¤ºé€‰æ‹©æ¡†
    await renderMessageList();
}

// æ˜¾ç¤ºç¼–è¾‘æ¨¡å¼æ“ä½œæŒ‰é’®
function showMessageEditActions() {
    const actionsContainer = document.getElementById('message-edit-actions');
    if (actionsContainer) {
        actionsContainer.style.display = 'block';
    }
    updateMessageDeleteButton();
}

// éšè—ç¼–è¾‘æ¨¡å¼æ“ä½œæŒ‰é’®
function hideMessageEditActions() {
    const actionsContainer = document.getElementById('message-edit-actions');
    if (actionsContainer) {
        actionsContainer.style.display = 'none';
    }
    const deleteBtn = document.getElementById('message-delete-btn');
    if (deleteBtn) {
        deleteBtn.style.display = 'none';
    }
}

// åœ¨ç¼–è¾‘æ¨¡å¼ä¸‹æ˜¾ç¤ºåˆ‡æ¢è´¦å·æŒ‰é’®
async function showMessageSwitchAccount() {
    await showSwitchAccountModal();
}

// åˆ‡æ¢çŸ­ä¿¡èŠå¤©é€‰æ‹©çŠ¶æ€
async function toggleMessageChatSelection(chatId) {
    if (!isMessageEditMode) return;
    
    // ä¸å…è®¸é€‰æ‹©æ¬¢è¿å°åŠ©æ‰‹
    if (chatId === 'welcome') return;
    
    if (selectedMessageChats.has(chatId)) {
        selectedMessageChats.delete(chatId);
    } else {
        selectedMessageChats.add(chatId);
    }
    
    await renderMessageList();
    updateMessageDeleteButton();
}

// æ›´æ–°åˆ é™¤æŒ‰é’®çŠ¶æ€
function updateMessageDeleteButton() {
    const deleteBtn = document.getElementById('message-delete-btn');
    if (deleteBtn) {
        if (selectedMessageChats.size > 0) {
            deleteBtn.style.display = 'flex';
            deleteBtn.textContent = `åˆ é™¤(${selectedMessageChats.size})`;
        } else {
            deleteBtn.style.display = 'none';
        }
    }
}

// åˆ é™¤é€‰ä¸­çš„çŸ­ä¿¡èŠå¤©
async function deleteSelectedMessageChats() {
    if (selectedMessageChats.size === 0) return;
    
    // è¿‡æ»¤æ‰æ¬¢è¿å°åŠ©æ‰‹ï¼ˆä¸å…è®¸åˆ é™¤ï¼‰
    const chatsToDelete = Array.from(selectedMessageChats).filter(id => id !== 'welcome');
    if (chatsToDelete.length === 0) return;
    
    if (!confirm(`ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${chatsToDelete.length} ä¸ªèŠå¤©å—ï¼Ÿ`)) {
        return;
    }
    
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    // ä» Dexie åˆ é™¤é€‰ä¸­èŠå¤©çš„æ‰€æœ‰æ¶ˆæ¯
    const allMessages = await db.sms_messages.where('accountId').equals(accountId).toArray();
    const idsToDelete = allMessages.filter(msg => {
        let chatId;
        if (msg.type === 'sent') {
            chatId = msg.number || msg.receiverId || msg.sender;
        } else {
            chatId = msg.number || msg.sender;
        }
        return chatsToDelete.includes(chatId);
    }).map(msg => msg.id);
    
    await db.sms_messages.bulkDelete(idsToDelete);
    
    // å¦‚æœå½“å‰æ‰“å¼€çš„èŠå¤©è¢«åˆ é™¤äº†ï¼Œå…ˆè¿”å›åˆ—è¡¨é¡µ
    if (currentMessageChatId && selectedMessageChats.has(currentMessageChatId)) {
        goBackMessageList();
    }
    
    // æ¸…ç©ºé€‰æ‹©å¹¶é€€å‡ºç¼–è¾‘æ¨¡å¼
    selectedMessageChats.clear();
    isMessageEditMode = false;
    
    const editBtn = document.getElementById('message-edit-btn');
    if (editBtn) editBtn.textContent = 'ç¼–è¾‘';
    
    const listContainer = document.getElementById('message-chat-list-container');
    if (listContainer) {
        listContainer.classList.remove('edit-mode');
    }
    
    hideMessageEditActions();
    
    // é‡æ–°æ¸²æŸ“åˆ—è¡¨
    await renderMessageList();
}

// æ¸²æŸ“ä¿¡æ¯åˆ—è¡¨
async function renderMessageList() {
    const listContainer = document.getElementById('message-chat-list-container');
    if (!listContainer) return;
    
    // ğŸ¯ ä» Dexie è¯»å–çŸ­ä¿¡è®°å½•ï¼ˆæŒ‰è´¦å·è¿‡æ»¤ï¼‰
    const accountId = getCurrentAccountId();
    let smsMessages = [];
    
    if (accountId) {
        smsMessages = await db.sms_messages.where('accountId').equals(accountId).toArray();
    }
    
    // æŒ‰èŠå¤©IDåˆ†ç»„ï¼ˆä¿®å¤ï¼šå‘é€çš„æ¶ˆæ¯ä½¿ç”¨æ¥æ”¶è€…IDï¼Œæ¥æ”¶çš„æ¶ˆæ¯ä½¿ç”¨å‘é€è€…IDï¼‰
    const groupedChats = {};
    
    // é¢„åŠ è½½è§’è‰²å¤´åƒç¼“å­˜
    const charAvatarCache = {};
    
    for (const msg of smsMessages) {
        // ğŸ¯ ä¿®å¤ï¼šå¯¹äºå‘é€çš„æ¶ˆæ¯ï¼Œä½¿ç”¨numberï¼ˆæ¥æ”¶è€…IDï¼‰åˆ†ç»„
        // å¯¹äºæ¥æ”¶çš„æ¶ˆæ¯ï¼Œä½¿ç”¨numberæˆ–senderï¼ˆå‘é€è€…IDï¼‰åˆ†ç»„
        let chatId;
        if (msg.type === 'sent') {
            // å‘é€çš„æ¶ˆæ¯ï¼šä½¿ç”¨numberå­—æ®µï¼ˆåº”è¯¥æ˜¯æ¥æ”¶è€…çš„IDï¼‰
            chatId = msg.number || msg.receiverId || msg.sender;
        } else {
            // æ¥æ”¶çš„æ¶ˆæ¯ï¼šä½¿ç”¨å‘é€è€…çš„ID
            chatId = msg.number || msg.sender;
        }
        
        if (!groupedChats[chatId]) {
            // ğŸ¯ ä¿®å¤ï¼šæ˜¾ç¤ºæ¥æ”¶è€…çš„åå­—ï¼ˆå¯¹äºå‘é€çš„æ¶ˆæ¯ï¼Œä½¿ç”¨å­˜å‚¨çš„æ¥æ”¶è€…ä¿¡æ¯ï¼‰
            let displayName = msg.sender;
            let displayAvatar = '';
            
            // å¦‚æœæœ‰ charIdï¼Œä»æ•°æ®åº“è·å–è§’è‰²å¤´åƒ
            if (msg.charId && !charAvatarCache[msg.charId]) {
                const char = await db.characters.get(msg.charId);
                if (char) {
                    charAvatarCache[msg.charId] = char.avatar;
                }
            }
            if (msg.charId && charAvatarCache[msg.charId]) {
                displayAvatar = charAvatarCache[msg.charId];
            }
            
            // å¦‚æœæ˜¯å‘é€çš„æ¶ˆæ¯ï¼Œä½¿ç”¨å­˜å‚¨çš„æ¥æ”¶è€…ä¿¡æ¯
            if (msg.type === 'sent' && msg.receiverName) {
                displayName = msg.receiverName;
                // æŸ¥æ‰¾åŒèŠå¤©ä¸­æ¥æ”¶çš„æ¶ˆæ¯ï¼Œè·å–æ¥æ”¶è€…å¤´åƒ
                const receivedMsg = smsMessages.find(m => 
                    (m.number || m.sender) === chatId && m.type !== 'sent'
                );
                if (receivedMsg && receivedMsg.charId) {
                    if (!charAvatarCache[receivedMsg.charId]) {
                        const char = await db.characters.get(receivedMsg.charId);
                        if (char) charAvatarCache[receivedMsg.charId] = char.avatar;
                    }
                    displayAvatar = charAvatarCache[receivedMsg.charId] || displayAvatar;
                }
            }
            
            groupedChats[chatId] = {
                id: chatId,
                name: displayName,
                avatar: displayAvatar,
                number: msg.number,
                messages: [],
                isBlocked: msg.isBlocked || false
            };
        }
        groupedChats[chatId].messages.push(msg);
    }
    
    // è½¬æ¢æˆæ•°ç»„å¹¶æŒ‰æœ€æ–°æ¶ˆæ¯æ—¶é—´æ’åº
    const chats = Object.values(groupedChats).map(chat => {
        // ğŸ¯ ä¿®å¤ï¼šæŒ‰æ—¶é—´æ’åºï¼Œå–æœ€æ–°çš„æ¶ˆæ¯ä½œä¸ºé¢„è§ˆ
        chat.messages.sort((a, b) => (a.time || a.timestamp || 0) - (b.time || b.timestamp || 0));
        const lastMsg = chat.messages[chat.messages.length - 1]; // å–æœ€åä¸€æ¡ï¼ˆæœ€æ–°çš„ï¼‰
        return {
            ...chat,
            time: formatMessageTime(lastMsg.time),
            preview: lastMsg.content,
            unread: !lastMsg.read
        };
    }).sort((a, b) => {
        // æŒ‰æœ€æ–°æ¶ˆæ¯æ—¶é—´é™åºæ’åˆ—
        const aLastTime = a.messages[a.messages.length - 1].time || 0;
        const bLastTime = b.messages[b.messages.length - 1].time || 0;
        return bLastTime - aLastTime;
    });
    
    // å§‹ç»ˆæ·»åŠ æ¬¢è¿æ¶ˆæ¯ï¼ˆç¡®ä¿å®ƒå§‹ç»ˆæ˜¾ç¤ºåœ¨åˆ—è¡¨ä¸­ï¼‰
    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨æ¬¢è¿æ¶ˆæ¯ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™æ·»åŠ 
    const hasWelcome = chats.some(chat => chat.id === 'welcome');
    if (!hasWelcome) {
        chats.push({
            id: 'welcome',
            name: 'æ¬¢è¿å°åŠ©æ‰‹',
            avatar: 'https://img.icons8.com/color/96/chat.png',
            time: 'åˆšåˆš',
            preview: 'æ¬¢è¿ä½¿ç”¨è¿™ä¸ªç½‘é¡µï¼',
            unread: false
        });
    }
    
    listContainer.innerHTML = '';
    chats.forEach(chat => {
        const unreadClass = chat.unread ? 'message-unread' : '';
        const unreadDot = chat.unread ? `<div class="message-unread-dot"></div>` : '';
        const isSelected = selectedMessageChats.has(chat.id);
        const selectedClass = isSelected ? 'message-chat-selected' : '';
        
        // æ¬¢è¿å°åŠ©æ‰‹åœ¨ç¼–è¾‘æ¨¡å¼ä¸‹ä¸æ˜¾ç¤ºé€‰æ‹©æ¡†ï¼Œä¹Ÿä¸èƒ½è¢«é€‰æ‹©
        const isWelcome = chat.id === 'welcome';
        const showCheckbox = isMessageEditMode && !isWelcome;
        
        // ç¼–è¾‘æ¨¡å¼ä¸‹æ˜¾ç¤ºé€‰æ‹©æ¡†ï¼Œå¦åˆ™ç›´æ¥æ‰“å¼€èŠå¤©ï¼ˆæ¬¢è¿å°åŠ©æ‰‹å§‹ç»ˆå¯ä»¥æ‰“å¼€ï¼‰
        const onClickAction = showCheckbox
            ? `toggleMessageChatSelection('${chat.id}')`
            : `openMessageChat('${chat.id}')`;
        
        const checkbox = showCheckbox
            ? `<div class="message-chat-checkbox ${isSelected ? 'checked' : ''}">
                <svg viewBox="0 0 24 24" style="width:20px;height:20px;stroke:currentColor;fill:none;stroke-width:3;">
                    ${isSelected ? '<path d="M20 6L9 17l-5-5"></path>' : ''}
                </svg>
               </div>`
            : '';
        
        const defaultAvatarClass = chat.avatar ? '' : 'default-avatar';
        const avatarImg = chat.avatar 
            ? `<img src="${chat.avatar}" style="width:100%;height:100%;object-fit:cover;" onerror="this.style.display='none';this.parentElement.classList.add('default-avatar');">`
            : '';
        
        const html = `
            <div class="message-chat-item ${unreadClass} ${selectedClass}" onclick="${onClickAction}">
                ${checkbox}
                <div class="message-avatar ${defaultAvatarClass}">
                    ${avatarImg}
                </div>
                <div class="message-chat-info">
                    <div class="message-chat-top">
                        <span class="message-chat-name">${chat.name}</span>
                        <div class="message-chat-time">
                            <span>${chat.time}</span>
                        </div>
                    </div>
                    <div class="message-chat-bottom">
                        <div class="message-chat-preview">${chat.preview}</div>
                        ${unreadDot}
                    </div>
                </div>
            </div>
        `;
        listContainer.insertAdjacentHTML('beforeend', html);
    });
    
    // æ›´æ–°åˆ é™¤æŒ‰é’®
    updateMessageDeleteButton();
}

// æ ¼å¼åŒ–æ¶ˆæ¯æ—¶é—´ï¼ˆåˆ—è¡¨è§†å›¾ç”¨ï¼‰
function formatMessageTime(timestamp, timeOffset = 0) {
    // ä½¿ç”¨è™šæ‹Ÿæ—¶é—´è¿›è¡Œè®¡ç®—
    const virtualNow = Date.now() + timeOffset;
    const virtualTimestamp = timestamp + timeOffset;
    const diff = virtualNow - virtualTimestamp;
    const date = new Date(virtualTimestamp);
    
    const timeStr = date.getHours() + ':' + String(date.getMinutes()).padStart(2, '0');
    
    // 1åˆ†é’Ÿå†…
    if (diff < 60000) {
        return 'åˆšåˆš';
    }
    // 1å°æ—¶å†…
    if (diff < 3600000) {
        return Math.floor(diff / 60000) + 'åˆ†é’Ÿå‰';
    }
    // ä»Šå¤©
    const today = new Date(virtualNow);
    if (date.getDate() === today.getDate() && 
        date.getMonth() === today.getMonth() && 
        date.getFullYear() === today.getFullYear()) {
        return timeStr;
    }
    // æ˜¨å¤©
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);
    if (date.getDate() === yesterday.getDate() && 
        date.getMonth() === yesterday.getMonth() && 
        date.getFullYear() === yesterday.getFullYear()) {
        return 'æ˜¨å¤© ' + timeStr;
    }
    // ä¸€å‘¨å†…
    if (diff < 7 * 24 * 3600000) {
        const days = ['å‘¨æ—¥', 'å‘¨ä¸€', 'å‘¨äºŒ', 'å‘¨ä¸‰', 'å‘¨å››', 'å‘¨äº”', 'å‘¨å…­'];
        return days[date.getDay()] + ' ' + timeStr;
    }
    // æ›´æ—©ï¼ˆåŒå¹´æ˜¾ç¤ºæœˆ/æ—¥ï¼Œä¸åŒå¹´æ˜¾ç¤ºå¹´/æœˆ/æ—¥ï¼‰
    if (date.getFullYear() === today.getFullYear()) {
        return (date.getMonth() + 1) + 'æœˆ' + date.getDate() + 'æ—¥ ' + timeStr;
    }
    return date.getFullYear() + '/' + (date.getMonth() + 1) + '/' + date.getDate();
}

// æ ¼å¼åŒ–çŸ­ä¿¡è¯¦æƒ…é¡µçš„æ—¶é—´æˆ³ï¼ˆæ˜¾ç¤ºå®Œæ•´æ—¥æœŸå’Œæ—¶é—´ï¼‰
function formatSmsDetailTime(timestamp) {
    if (!timestamp) return '';
    const date = new Date(timestamp);
    const now = new Date();
    
    const hours = date.getHours();
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const timeStr = `${hours}:${minutes}`;
    
    // ä»Šå¤©ï¼šåªæ˜¾ç¤ºæ—¶é—´
    if (date.getDate() === now.getDate() && 
        date.getMonth() === now.getMonth() && 
        date.getFullYear() === now.getFullYear()) {
        return `ä»Šå¤© ${timeStr}`;
    }
    
    // æ˜¨å¤©
    const yesterday = new Date(now);
    yesterday.setDate(yesterday.getDate() - 1);
    if (date.getDate() === yesterday.getDate() && 
        date.getMonth() === yesterday.getMonth() && 
        date.getFullYear() === yesterday.getFullYear()) {
        return `æ˜¨å¤© ${timeStr}`;
    }
    
    // ä¸€å‘¨å†…
    const diff = now - date;
    if (diff < 7 * 24 * 3600000) {
        const days = ['å‘¨æ—¥', 'å‘¨ä¸€', 'å‘¨äºŒ', 'å‘¨ä¸‰', 'å‘¨å››', 'å‘¨äº”', 'å‘¨å…­'];
        return `${days[date.getDay()]} ${timeStr}`;
    }
    
    // ä»Šå¹´
    if (date.getFullYear() === now.getFullYear()) {
        return `${date.getMonth() + 1}æœˆ${date.getDate()}æ—¥ ${timeStr}`;
    }
    
    // æ›´æ—©
    return `${date.getFullYear()}å¹´${date.getMonth() + 1}æœˆ${date.getDate()}æ—¥ ${timeStr}`;
}

// å½“å‰çŸ­ä¿¡èŠå¤©çš„è”ç³»äººIDï¼ˆå…¨å±€å˜é‡ï¼‰
let currentMessageChatId = null;
let currentMessageChatName = null;

// æ‰“å¼€èŠå¤©è¯¦æƒ…
async function openMessageChat(id) {
    console.log('openMessageChat called with id:', id);
    
    const accountId = getCurrentAccountId();
    
    // ğŸ¯ ä» Dexie è¯»å–çŸ­ä¿¡è®°å½•
    let smsMessages = [];
    if (accountId) {
        smsMessages = await db.sms_messages.where('accountId').equals(accountId).toArray();
    }
    
    // æŸ¥æ‰¾è¯¥è”ç³»äººçš„æ‰€æœ‰æ¶ˆæ¯ï¼ˆä¿®å¤ï¼šæ”¯æŒå‘é€å’Œæ¥æ”¶çš„æ¶ˆæ¯ï¼‰
    const chatMessages = smsMessages.filter(msg => {
        if (msg.type === 'sent') {
            // å‘é€çš„æ¶ˆæ¯ï¼šä½¿ç”¨numberï¼ˆæ¥æ”¶è€…IDï¼‰æˆ–receiverIdåŒ¹é…
            return (msg.number || msg.receiverId) === id;
        } else {
            // æ¥æ”¶çš„æ¶ˆæ¯ï¼šä½¿ç”¨å‘é€è€…çš„IDåŒ¹é…
            return (msg.number || msg.sender) === id;
        }
    });
    
    if (chatMessages.length === 0 && id !== 'welcome') {
        // å¦‚æœæ˜¯ä»æ–°å»ºçŸ­ä¿¡æµç¨‹æ¥çš„ï¼Œå…è®¸æ‰“å¼€ç©ºèŠå¤©
        if (window._smsSelectedCharId) {
            const targetChar = await db.characters.get(window._smsSelectedCharId);
            if (targetChar) {
                const charName = targetChar.remark || targetChar.wx_nickname || targetChar.name;
                const charAvatar = targetChar.avatar || '';
                currentMessageChatId = id;
                currentMessageChatName = charName;
                
                // ğŸ¯ ä¿®å¤ï¼šå…ˆéšè—åˆ—è¡¨é¡µ
                const listPage = document.getElementById('message-list-page');
                if (listPage) {
                    listPage.style.display = 'none';
                }
                
                // ğŸ¯ ä¿®å¤ï¼šæ­£ç¡®æ˜¾ç¤ºè¯¦æƒ…é¡µï¼ˆå…ˆè®¾ç½®displayå†æ·»åŠ activeï¼‰
                const detailPage = document.getElementById('message-detail-page');
                detailPage.style.display = 'flex';
                setTimeout(() => {
                    detailPage.classList.add('active');
                }, 10);
                
                // è®¾ç½®å¤´åƒ
                const avatarEl = document.getElementById('message-detail-avatar');
                if (avatarEl) {
                    const avatarContainer = avatarEl.parentElement;
                    if (charAvatar) {
                        avatarEl.src = charAvatar;
                        avatarEl.style.display = '';
                        avatarContainer.classList.remove('default-avatar');
                        avatarEl.onerror = function() {
                            this.style.display = 'none';
                            avatarContainer.classList.add('default-avatar');
                        };
                    } else {
                        avatarEl.style.display = 'none';
                        avatarContainer.classList.add('default-avatar');
                    }
                }
                document.getElementById('message-detail-name').innerText = charName;
                document.getElementById('message-container').innerHTML = '';
                
                // åˆå§‹åŒ–è¾“å…¥æ¡†çŠ¶æ€
                const msgInput = document.getElementById('message-msg-input');
                if (msgInput) {
                    msgInput.value = '';
                    handleMessageInputChange(msgInput);
                }
                
                return;
            }
        }
        console.error('Chat not found:', id);
        return;
    }
    
    // æ„å»ºèŠå¤©å¯¹è±¡
    let chat;
    if (id === 'welcome') {
        // æ¬¢è¿æ¶ˆæ¯
        chat = {
            id: 'welcome',
            name: 'æ¬¢è¿å°åŠ©æ‰‹',
            avatar: 'https://img.icons8.com/color/96/chat.png',
            chatTimeLabel: 'åˆšåˆš',
            messages: [{
                type: 'received',
                text: 'æ¬¢è¿ä½¿ç”¨è¿™ä¸ªç½‘é¡µï¼ğŸ‰\n\nè¿™æ˜¯ä¸€ä¸ªä»¿ iOS é£æ ¼çš„ä¿¡æ¯åº”ç”¨ï¼Œä½ å¯ä»¥åœ¨è¿™é‡Œï¼š\n\nâ€¢ æŸ¥çœ‹å’Œç®¡ç†ä½ çš„ä¿¡æ¯\nâ€¢ ä¸å¥½å‹èŠå¤©\nâ€¢ å‘é€å’Œæ¥æ”¶æ¶ˆæ¯\n\nå¸Œæœ›ä½ èƒ½å–œæ¬¢è¿™ä¸ªè®¾è®¡ï¼å¦‚æœ‰ä»»ä½•é—®é¢˜ï¼Œéšæ—¶å‘Šè¯‰æˆ‘ã€‚'
            }]
        };
        currentMessageChatId = null;
        currentMessageChatName = null;
    } else {
        // çœŸå®çŸ­ä¿¡
        console.log('[openMessageChat] èŠå¤©æ¶ˆæ¯æ•°é‡:', chatMessages.length);
        console.log('[openMessageChat] ç¬¬ä¸€æ¡æ¶ˆæ¯:', chatMessages[0]);
        
        // ğŸ¯ ä¿®å¤ï¼šæ‰¾åˆ°æ¥æ”¶æ¶ˆæ¯æ¥ç¡®å®šæ¥æ”¶è€…ä¿¡æ¯ï¼ˆå¦‚æœåªæœ‰å‘é€æ¶ˆæ¯ï¼Œä½¿ç”¨å­˜å‚¨çš„æ¥æ”¶è€…ä¿¡æ¯ï¼‰
        const receivedMsg = chatMessages.find(msg => msg.type !== 'sent');
        const firstMsg = receivedMsg || chatMessages[chatMessages.length - 1]; // ä¼˜å…ˆä½¿ç”¨æ¥æ”¶æ¶ˆæ¯ï¼Œå¦åˆ™ç”¨æœ€æ—©çš„æ¶ˆæ¯
        
        console.log('[openMessageChat] ç¬¬ä¸€æ¡æ¶ˆæ¯å†…å®¹:', firstMsg);
        
        // ç¡®å®šæ˜¾ç¤ºçš„åå­—å’Œå¤´åƒï¼ˆä»è§’è‰²æ•°æ®åº“è·å–ï¼‰
        let displayName = firstMsg.sender;
        let displayAvatar = '';
        
        // å¦‚æœæœ‰ charIdï¼Œä»æ•°æ®åº“è·å–è§’è‰²å¤´åƒ
        if (firstMsg.charId) {
            const char = await db.characters.get(firstMsg.charId);
            if (char) {
                displayAvatar = char.avatar || displayAvatar;
            }
        }
        
        // å¦‚æœç¬¬ä¸€æ¡æ¶ˆæ¯æ˜¯å‘é€çš„æ¶ˆæ¯ï¼Œä½¿ç”¨å­˜å‚¨çš„æ¥æ”¶è€…ä¿¡æ¯
        if (firstMsg.type === 'sent' && firstMsg.receiverName) {
            displayName = firstMsg.receiverName;
            // å°è¯•ä»æ¥æ”¶æ¶ˆæ¯ä¸­è·å–å¤´åƒ
            const receivedMsgForAvatar = chatMessages.find(msg => msg.type !== 'sent');
            if (receivedMsgForAvatar && receivedMsgForAvatar.charId) {
                const char = await db.characters.get(receivedMsgForAvatar.charId);
                if (char) {
                    displayAvatar = char.avatar || displayAvatar;
                }
            }
        }
        
        console.log('[openMessageChat] æ˜¾ç¤ºåç§°:', displayName);
        console.log('[openMessageChat] æ˜¾ç¤ºå¤´åƒ:', displayAvatar);
        
        // ğŸ”¥ ä¿®å¤ï¼šæŒ‰æ—¶é—´æˆ³æ’åºï¼Œç¡®ä¿æœ€æ—©çš„æ¶ˆæ¯åœ¨æœ€ä¸Šé¢
        chatMessages.sort((a, b) => (a.time || a.timestamp || 0) - (b.time || b.timestamp || 0));
        
        chat = {
            id: id,
            name: displayName,
            avatar: displayAvatar,
            chatTimeLabel: formatMessageTime(firstMsg.time || firstMsg.timestamp || Date.now()),
            messages: chatMessages.map(msg => {
                const msgText = msg.content || msg.message || '';
                console.log('[openMessageChat] æ˜ å°„æ¶ˆæ¯:', { type: msg.type, text: msgText });
                return {
                    type: msg.type || (msg.sender === displayName ? 'received' : 'sent'),
                    text: msgText,
                    time: msg.time || msg.timestamp || 0
                };
            })
        };
        
        console.log('[openMessageChat] æœ€ç»ˆèŠå¤©å¯¹è±¡:', chat);
        
        // ä¿å­˜å½“å‰èŠå¤©ä¿¡æ¯
        currentMessageChatId = id;
        currentMessageChatName = displayName;
        
        // æ ‡è®°ä¸ºå·²è¯»ï¼ˆä¿®å¤ï¼šæ”¯æŒå‘é€å’Œæ¥æ”¶çš„æ¶ˆæ¯ï¼‰
        const idsToUpdate = chatMessages.map(msg => msg.id);
        for (const msgId of idsToUpdate) {
            await db.sms_messages.update(msgId, { read: true });
        }
    }
    
    // éšè—åˆ—è¡¨é¡µ
    const listPage = document.getElementById('message-list-page');
    if (listPage) {
        listPage.style.display = 'none';
    }
    
    // æ˜¾ç¤ºè¯¦æƒ…é¡µ
    const detailPage = document.getElementById('message-detail-page');
    if (!detailPage) {
        console.error('Detail page not found');
        return;
    }
    
    // å…ˆè®¾ç½® displayï¼Œå†æ·»åŠ  active ç±»è§¦å‘åŠ¨ç”»
    detailPage.style.display = 'flex';
    // ä½¿ç”¨ setTimeout ç¡®ä¿ display è®¾ç½®åå†è§¦å‘åŠ¨ç”»
    setTimeout(() => {
        detailPage.classList.add('active');
    }, 10);
    
    // è®¾ç½®èŠå¤©ä¿¡æ¯
    document.getElementById('message-detail-name').innerText = chat.name;
    const avatarEl = document.getElementById('message-detail-avatar');
    if (avatarEl) {
        const avatarContainer = avatarEl.parentElement;
        if (chat.avatar) {
            avatarEl.src = chat.avatar;
            avatarEl.style.display = '';
            avatarContainer.classList.remove('default-avatar');
            avatarEl.onerror = function() {
                this.style.display = 'none';
                avatarContainer.classList.add('default-avatar');
            };
        } else {
            avatarEl.style.display = 'none';
            avatarContainer.classList.add('default-avatar');
        }
    }
    
    // æ¸²æŸ“æ¶ˆæ¯
    const msgContainer = document.getElementById('message-container');
    if (!msgContainer) {
        console.error('Message container not found');
        return;
    }
    
    // æ¸²æŸ“æ¶ˆæ¯ï¼Œåœ¨æœ‰æ—¶é—´é—´éš”çš„åœ°æ–¹æ’å…¥æ—¶é—´æˆ³
    const firstMsgTime = chat.messages.length > 0 && chat.messages[0].time ? chat.messages[0].time : 0;
    let htmlContent = `<div class="message-ts-group"><span class="message-ts-label">iMessage</span><span class="message-ts-time">${firstMsgTime ? formatSmsDetailTime(firstMsgTime) : (chat.chatTimeLabel || 'ä»Šå¤©')}</span></div>`;
    
    let lastTimestamp = firstMsgTime;
    chat.messages.forEach((msg, index) => {
        // å¦‚æœä¸ä¸Šä¸€æ¡æ¶ˆæ¯é—´éš”è¶…è¿‡5åˆ†é’Ÿï¼Œæ’å…¥æ—¶é—´æˆ³
        if (index > 0 && msg.time && lastTimestamp) {
            const gap = msg.time - lastTimestamp;
            if (gap > 5 * 60 * 1000) { // 5åˆ†é’Ÿ
                htmlContent += `<div class="message-ts-group"><span class="message-ts-time">${formatSmsDetailTime(msg.time)}</span></div>`;
            }
        }
        if (msg.time) lastTimestamp = msg.time;
        
        htmlContent += `<div class="message-wrapper"><div class="message-bubble ${msg.type === 'sent' ? 'message-sent' : 'message-received'}">${msg.text.replace(/\n/g, '<br>')}</div></div>`;
        if (msg.type === 'sent' && index === chat.messages.length - 1) {
            htmlContent += `<div class="message-delivery-text" style="opacity:1">å·²é€è¾¾</div>`;
        }
    });
    
    msgContainer.innerHTML = htmlContent;
    
    // æ»šåŠ¨åˆ°åº•éƒ¨
    setTimeout(() => {
        const scrollArea = document.getElementById('message-area-scroll');
        if (scrollArea) {
            scrollArea.scrollTo({ top: scrollArea.scrollHeight, behavior: 'instant' });
        }
    }, 10);
    
    // åˆå§‹åŒ–è¾“å…¥æ¡†çŠ¶æ€ï¼ˆéšè—å‘é€æŒ‰é’®ï¼Œæ˜¾ç¤ºéº¦å…‹é£ï¼‰
    const msgInput = document.getElementById('message-msg-input');
    if (msgInput) {
        msgInput.value = '';
        handleMessageInputChange(msgInput);
    }
}

// ç¡®ä¿å‡½æ•°åœ¨å…¨å±€ä½œç”¨åŸŸ
window.openMessageChat = openMessageChat;
window.sendMessageDetail = sendMessageDetail;
window.handleMessageInputChange = handleMessageInputChange;
window.acceptMessageReply = acceptMessageReply;
window.toggleMessageEditMode = toggleMessageEditMode;
window.toggleMessageChatSelection = toggleMessageChatSelection;
window.deleteSelectedMessageChats = deleteSelectedMessageChats;
window.showMessageSwitchAccount = showMessageSwitchAccount;

function showMessagePage() {
    document.getElementById('message-page').classList.add('active');
    // é»˜è®¤æ˜¾ç¤ºåˆ—è¡¨é¡µ
    document.getElementById('message-list-page').style.display = 'flex';
    // ç¡®ä¿è¯¦æƒ…é¡µå’Œæ–°å»ºé¡µéšè—
    const detailPage = document.getElementById('message-detail-page');
    if (detailPage) {
        detailPage.classList.remove('active');
        detailPage.style.display = 'none';
    }
    const composePage = document.getElementById('message-compose-page');
    if (composePage) {
        composePage.classList.remove('active');
        composePage.style.display = 'none';
    }
    // æ¸²æŸ“åˆ—è¡¨
    renderMessageList();
}

function hideMessagePage() {
    document.getElementById('message-page').classList.remove('active');
    document.getElementById('message-list-page').style.display = 'none';
    document.getElementById('message-detail-page').classList.remove('active');
    document.getElementById('message-compose-page').classList.remove('active');
}

function goBackMessageList() {
    const detailPage = document.getElementById('message-detail-page');
    if (detailPage) {
        detailPage.classList.remove('active');
        // ç­‰å¾…åŠ¨ç”»å®Œæˆåå†éšè—
        setTimeout(() => {
            detailPage.style.display = 'none';
        }, 400);
    }
    
    // æ˜¾ç¤ºåˆ—è¡¨é¡µ
    const listPage = document.getElementById('message-list-page');
    if (listPage) {
        listPage.style.display = 'flex';
    }
}

// æ–°å»ºçŸ­ä¿¡ï¼šæ­¥éª¤å¼é€‰æ‹©è”ç³»äºº + ç”¨æˆ·æ¡£æ¡ˆ
let composeSelectedCharId = null; // é€‰ä¸­çš„è§’è‰²ID

async function openComposeMessage() {
    composeSelectedCharId = null;
    
    // é‡ç½®UI
    document.getElementById('compose-step-title').textContent = 'é€‰æ‹©è”ç³»äºº';
    document.getElementById('compose-step-char').style.display = 'block';
    document.getElementById('compose-step-user').style.display = 'none';
    document.getElementById('compose-search-input').value = '';
    
    // åŠ è½½è§’è‰²åˆ—è¡¨ï¼ˆå¥½å‹è§’è‰²ï¼‰
    await loadComposeCharList();
    
    // å…ˆè®¾ç½® displayï¼Œå†æ·»åŠ  active ç±»è§¦å‘åŠ¨ç”»
    const composePage = document.getElementById('message-compose-page');
    composePage.style.display = 'flex';
    setTimeout(() => {
        composePage.classList.add('active');
    }, 10);
}

function closeComposeMessage() {
    const composePage = document.getElementById('message-compose-page');
    composePage.classList.remove('active');
    // ç­‰å¾…åŠ¨ç”»å®Œæˆåå†éšè—
    setTimeout(() => {
        composePage.style.display = 'none';
    }, 400);
}

// åŠ è½½è§’è‰²åˆ—è¡¨
async function loadComposeCharList() {
    const accountId = getCurrentAccountId();
    const allChars = await db.characters.toArray();
    // ğŸ¯ ä¿®å¤ï¼šçŸ­ä¿¡ä¸å—å¾®ä¿¡å¥½å‹çŠ¶æ€é™åˆ¶ï¼Œå¥½å‹/è¢«åˆ é™¤/è¢«æ‹‰é»‘éƒ½å¯ä»¥å‘çŸ­ä¿¡
    const allowedStatuses = ['friend', 'deleted_by_char', 'blocked_by_char'];
    const friends = allChars.filter(c => {
        if (c.type === 'user') return false;
        const status = getFriendStatus(c, accountId);
        return allowedStatuses.includes(status);
    });
    
    const container = document.getElementById('compose-char-list');
    if (friends.length === 0) {
        container.innerHTML = '<div style="padding:40px 16px; text-align:center; color:#999; font-size:15px;">æš‚æ— å¥½å‹</div>';
        return;
    }
    
    container.innerHTML = friends.map(f => {
        const displayName = f.remark || f.wx_nickname || f.name;
        const phone = f.identity?.phone || '';
        const avatarStyle = f.avatar ? `background-image:url(${f.avatar})` : 'background-color:#ddd';
        const status = getFriendStatus(f, accountId);
        // æ˜¾ç¤ºçŠ¶æ€æ ‡ç­¾
        let statusBadge = '';
        if (status === 'deleted_by_char') {
            statusBadge = '<span style="font-size:11px; color:#ff9500; background:#fff5e6; padding:2px 6px; border-radius:4px; margin-left:8px;">è¢«Taåˆ é™¤</span>';
        } else if (status === 'blocked_by_char') {
            statusBadge = '<span style="font-size:11px; color:#ff3b30; background:#ffe5e5; padding:2px 6px; border-radius:4px; margin-left:8px;">è¢«Taæ‹‰é»‘</span>';
        }
        return `<div class="compose-contact-item" data-name="${displayName}" data-phone="${phone}" onclick="selectComposeChar(${f.id})">
            <div style="width:44px; height:44px; border-radius:50%; background-size:cover; background-position:center; flex-shrink:0; ${avatarStyle}"></div>
            <div style="flex:1; min-width:0; border-bottom:0.5px solid #f0f0f0; padding:14px 0; margin-left:12px;">
                <div style="display:flex; align-items:center;"><span style="font-size:16px; color:#000; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${displayName}</span>${statusBadge}</div>
                ${phone ? `<div style="font-size:13px; color:#8e8e93; margin-top:2px;">${phone}</div>` : ''}
            </div>
        </div>`;
    }).join('');
}

// é€‰æ‹©è§’è‰² â†’ è¿›å…¥æ­¥éª¤2é€‰æ‹©ç”¨æˆ·æ¡£æ¡ˆ
async function selectComposeChar(charId) {
    composeSelectedCharId = charId;
    const char = await db.characters.get(charId);
    const charName = char.remark || char.wx_nickname || char.name;
    
    document.getElementById('compose-step-title').textContent = `å‘ç»™ ${charName}`;
    document.getElementById('compose-step-char').style.display = 'none';
    document.getElementById('compose-step-user').style.display = 'block';
    document.getElementById('compose-search-input').value = '';
    
    // åŠ è½½ç”¨æˆ·æ¡£æ¡ˆåˆ—è¡¨
    await loadComposeUserList(charId);
}

// åŠ è½½ç”¨æˆ·æ¡£æ¡ˆåˆ—è¡¨
async function loadComposeUserList(charId) {
    const allChars = await db.characters.toArray();
    const users = allChars.filter(c => c.type === 'user');
    const targetChar = await db.characters.get(charId);
    
    const container = document.getElementById('compose-user-list');
    if (users.length === 0) {
        container.innerHTML = '<div style="padding:40px 16px; text-align:center; color:#999; font-size:15px;">æš‚æ— ç”¨æˆ·æ¡£æ¡ˆ</div>';
        return;
    }
    
    container.innerHTML = users.map(u => {
        const avatarStyle = u.avatar ? `background-image:url(${u.avatar})` : 'background-color:#ddd';
        const phone = u.identity?.phone || '';
        
        // æ£€æŸ¥è¿™ä¸ªç”¨æˆ·å’Œç›®æ ‡è§’è‰²ä¹‹é—´æ˜¯å¦æœ‰å¾®ä¿¡èŠå¤©è®°å½•
        const hasContext = checkIfUserHasChatWithChar(u, targetChar);
        
        const contextLabel = hasContext 
            ? '<span style="font-size:11px; color:#07c160; background:#e8f8f0; padding:2px 6px; border-radius:4px; margin-left:8px;">æœ‰èŠå¤©è®°å½•</span>'
            : '<span style="font-size:11px; color:#ff9500; background:#fff5e6; padding:2px 6px; border-radius:4px; margin-left:8px;">é™Œç”Ÿå·ç </span>';
        
        return `<div class="compose-contact-item" data-name="${u.name}" onclick="confirmComposeSms(${charId}, ${u.id})">
            <div style="width:44px; height:44px; border-radius:50%; background-size:cover; background-position:center; flex-shrink:0; ${avatarStyle}"></div>
            <div style="flex:1; min-width:0; border-bottom:0.5px solid #f0f0f0; padding:14px 0; margin-left:12px;">
                <div style="display:flex; align-items:center;">
                    <span style="font-size:16px; color:#000; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${u.name}</span>
                    ${contextLabel}
                </div>
                ${phone ? `<div style="font-size:13px; color:#8e8e93; margin-top:2px;">${phone}</div>` : ''}
            </div>
        </div>`;
    }).join('');
}

// æ£€æŸ¥ç”¨æˆ·ä¸è§’è‰²ä¹‹é—´æ˜¯å¦æœ‰å¾®ä¿¡èŠå¤©è®°å½•
function checkIfUserHasChatWithChar(userChar, targetChar) {
    // è·å–æ‰€æœ‰å¾®ä¿¡è´¦å·ï¼ˆæ¯ä¸ªç”¨æˆ·å¯èƒ½å¯¹åº”ä¸€ä¸ªcurrentMyCharIdï¼‰
    // æ£€æŸ¥è¯¥ç”¨æˆ·IDå¯¹åº”çš„èŠå¤©è®°å½•
    const accountId = String(userChar.id);
    const history = getChatHistory(targetChar, accountId);
    return history && history.length > 0;
}

// ç¡®è®¤é€‰æ‹©ï¼Œå¼€å§‹çŸ­ä¿¡èŠå¤©
async function confirmComposeSms(charId, userId) {
    const char = await db.characters.get(charId);
    const userChar = await db.characters.get(userId);
    if (!char || !userChar) return;
    
    const charName = char.remark || char.wx_nickname || char.name;
    const charPhone = char.identity?.phone || generateVirtualPhoneNumber(char.id);
    
    // è®¾ç½®å½“å‰çŸ­ä¿¡èŠå¤©çš„ä¿¡æ¯
    currentMessageChatId = charPhone;
    currentMessageChatName = charName;
    
    // å­˜å‚¨é€‰ä¸­çš„ç”¨æˆ·æ¡£æ¡ˆIDï¼Œç”¨äºå‘ä¿¡å’ŒAIä¸Šä¸‹æ–‡
    window._smsSelectedUserId = userId;
    window._smsSelectedCharId = charId;
    
    // å…³é—­é€‰æ‹©é¡µé¢
    closeComposeMessage();
    
    // æ£€æŸ¥æ˜¯å¦å·²æœ‰çŸ­ä¿¡è®°å½•ï¼Œå¦‚æœæ²¡æœ‰åˆ™åˆ›å»ºåˆå§‹è®°å½•
    const accountId = getCurrentAccountId();
    
    // ç›´æ¥æ‰“å¼€çŸ­ä¿¡è¯¦æƒ…é¡µ
    openMessageChat(charPhone);
}

// æœç´¢è¿‡æ»¤
function filterComposeList() {
    const keyword = document.getElementById('compose-search-input').value.trim().toLowerCase();
    const step1Visible = document.getElementById('compose-step-char').style.display !== 'none';
    const containerId = step1Visible ? 'compose-char-list' : 'compose-user-list';
    const items = document.querySelectorAll(`#${containerId} .compose-contact-item`);
    
    items.forEach(item => {
        const name = (item.getAttribute('data-name') || '').toLowerCase();
        const phone = (item.getAttribute('data-phone') || '').toLowerCase();
        if (!keyword || name.includes(keyword) || phone.includes(keyword)) {
            item.style.display = 'flex';
        } else {
            item.style.display = 'none';
        }
    });
}

// å‘é€çŸ­ä¿¡è¯¦æƒ…é¡µçš„æ¶ˆæ¯
async function sendMessageDetail() {
    const input = document.getElementById('message-msg-input');
    const text = input.value.trim();
    
    if (!text) return;
    
    // å¦‚æœæ²¡æœ‰å½“å‰èŠå¤©ï¼Œä¸èƒ½å‘é€
    if (!currentMessageChatId || currentMessageChatId === 'welcome') {
        alert('æ— æ³•å‘é€æ¶ˆæ¯');
        return;
    }
    
    // ğŸ¯ æ£€æŸ¥ä½™é¢ï¼ˆæ¯æ¡çŸ­ä¿¡0.1å…ƒï¼‰
    const SMS_COST = 0.1;
    const balance = getPhoneBalance();
    if (balance < SMS_COST) {
        const recharge = confirm(`ä½™é¢ä¸è¶³ï¼ˆå½“å‰ä½™é¢ï¼šÂ¥${balance.toFixed(2)}ï¼‰\n\næ¯æ¡çŸ­ä¿¡éœ€è¦ Â¥${SMS_COST.toFixed(2)}ï¼Œè¯·å…ˆå……å€¼ã€‚\n\næ˜¯å¦å‰å¾€å……å€¼ï¼Ÿ`);
        if (recharge) {
            hideMessagePage();
            setTimeout(() => {
                showPhoneRechargePage();
            }, 300);
        }
        return;
    }
    
    // è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯
    const accountId = getCurrentAccountId();
    if (!accountId) {
        alert('è¯·å…ˆç™»å½•');
        return;
    }
    
    const myChar = await db.characters.get(parseInt(accountId));
    if (!myChar) {
        alert('æ‰¾ä¸åˆ°ç”¨æˆ·ä¿¡æ¯');
        return;
    }
    
    // ğŸ¯ æ‰£è´¹ - æ”¯æŒé€‰æ‹©æ”¯ä»˜æ–¹å¼
    const paymentResult = await showPaymentMethodSelection(SMS_COST, 'çŸ­ä¿¡è´¹ç”¨');
    if (!paymentResult.success) {
        alert('æ”¯ä»˜å¤±è´¥ï¼Œè¯·é‡è¯•');
        return;
    }
    
    // æ¸…ç©ºè¾“å…¥æ¡†
    input.value = '';
    handleMessageInputChange(input);
    
    // ä¿å­˜å‘é€çš„æ¶ˆæ¯åˆ° Dexie
    const myPhoneNumber = myChar.identity?.phone || generateVirtualPhoneNumber(myChar.id);
    
    // ğŸ¯ å…³é”®ä¿®å¤ï¼šä½¿ç”¨å½“å‰èŠå¤©çš„IDï¼ˆæ¥æ”¶è€…çš„IDï¼‰ä½œä¸ºèŠå¤©æ ‡è¯†
    // è¿™æ ·æ¶ˆæ¯ä¼šå½’å…¥æ­£ç¡®çš„èŠå¤©ï¼Œè€Œä¸æ˜¯åˆ›å»ºæ–°çš„èŠå¤©
    // åŒæ—¶å­˜å‚¨æ¥æ”¶è€…ä¿¡æ¯ï¼Œç¡®ä¿åˆ†ç»„å’Œæ˜¾ç¤ºæ­£ç¡®
    await db.sms_messages.add({
        accountId: accountId,
        charId: null, // å‘é€çš„æ¶ˆæ¯ä¸éœ€è¦ charId
        sender: myChar.nick || myChar.name,
        number: currentMessageChatId, // ä½¿ç”¨æ¥æ”¶è€…çš„IDä½œä¸ºnumberï¼Œç¡®ä¿åˆ†ç»„æ­£ç¡®
        content: text,
        time: Date.now(),
        read: true,
        type: 'sent', // æ ‡è®°ä¸ºå‘é€çš„æ¶ˆæ¯
        receiverName: currentMessageChatName, // å­˜å‚¨æ¥æ”¶è€…åå­—ï¼Œç”¨äºæ˜¾ç¤º
        receiverId: currentMessageChatId // å­˜å‚¨æ¥æ”¶è€…ID
    });
    
    // é‡æ–°æ¸²æŸ“æ¶ˆæ¯åˆ—è¡¨
    renderMessageList();
    
    // åœ¨è¯¦æƒ…é¡µæ˜¾ç¤ºæ–°æ¶ˆæ¯
    const msgContainer = document.getElementById('message-container');
    if (msgContainer) {
        const scrollArea = document.getElementById('message-area-scroll');
        const wasAtBottom = scrollArea.scrollHeight - scrollArea.scrollTop <= scrollArea.clientHeight + 50;
        
        const newMsgHtml = `<div class="message-wrapper"><div class="message-bubble message-sent">${text.replace(/\n/g, '<br>')}</div></div>`;
        msgContainer.innerHTML += newMsgHtml;
        
        // å¦‚æœä¹‹å‰åœ¨åº•éƒ¨ï¼Œæ»šåŠ¨åˆ°åº•éƒ¨
        if (wasAtBottom) {
            setTimeout(() => {
                scrollArea.scrollTo({ top: scrollArea.scrollHeight, behavior: 'smooth' });
            }, 10);
        }
    }
}

// å¤„ç†çŸ­ä¿¡è¾“å…¥æ¡†å˜åŒ–ï¼ˆåˆ‡æ¢éº¦å…‹é£å’Œå‘é€æŒ‰é’®ï¼‰
function handleMessageInputChange(input) {
    const hasText = input.value.trim().length > 0;
    const micIcon = document.getElementById('message-icon-mic');
    const sendBtn = document.getElementById('message-btn-send');
    
    if (hasText) {
        if (micIcon) micIcon.style.display = 'none';
        if (sendBtn) sendBtn.style.display = 'flex';
    } else {
        if (micIcon) micIcon.style.display = 'flex';
        if (sendBtn) sendBtn.style.display = 'none';
    }
}

// çŸ­ä¿¡é¡µé¢æ¥å—å›å¤ï¼ˆè°ƒç”¨APIï¼‰
async function acceptMessageReply() {
    if (!currentMessageChatId || currentMessageChatId === 'welcome') {
        alert('æ— æ³•æ¥å—å›å¤');
        return;
    }
    
    // é€šè¿‡è”ç³»äººåç§°æˆ–è§’è‰²IDæŸ¥æ‰¾è§’è‰²
    const allChars = await db.characters.toArray();
    let targetChar = null;
    
    // ä¼˜å…ˆé€šè¿‡å­˜å‚¨çš„è§’è‰²IDæŸ¥æ‰¾
    if (window._smsSelectedCharId) {
        targetChar = await db.characters.get(window._smsSelectedCharId);
    }
    
    // å›é€€ï¼šé€šè¿‡åå­—æŸ¥æ‰¾
    if (!targetChar) {
        targetChar = allChars.find(char => 
            (char.nick || char.name) === currentMessageChatName ||
            (char.remark || char.wx_nickname || char.name) === currentMessageChatName
        );
    }
    
    // å†å›é€€ï¼šé€šè¿‡æ‰‹æœºå·æŸ¥æ‰¾
    if (!targetChar) {
        targetChar = allChars.find(char => 
            char.identity?.phone === currentMessageChatId
        );
    }
    
    if (!targetChar) {
        alert('æ‰¾ä¸åˆ°å¯¹åº”çš„è§’è‰²');
        return;
    }
    
    const accountId = getCurrentAccountId();
    if (!accountId) {
        alert('è¯·å…ˆç™»å½•');
        return;
    }
    
    const myChar = await db.characters.get(parseInt(accountId));
    if (!myChar) {
        alert('æ‰¾ä¸åˆ°ç”¨æˆ·ä¿¡æ¯');
        return;
    }
    
    // ç¡®å®šä½¿ç”¨çš„ç”¨æˆ·æ¡£æ¡ˆï¼šä¼˜å…ˆç”¨é€‰æ‹©çš„ç”¨æˆ·æ¡£æ¡ˆï¼Œå¦åˆ™ç”¨å½“å‰è´¦å·
    const smsUserId = window._smsSelectedUserId || null;
    let smsUserChar = null;
    let contextAccountId = accountId; // ç”¨äºè·å–å¾®ä¿¡èŠå¤©ä¸Šä¸‹æ–‡çš„è´¦å·ID
    
    if (smsUserId) {
        smsUserChar = await db.characters.get(smsUserId);
        if (smsUserChar) {
            contextAccountId = String(smsUserId);
        }
    }
    
    console.log('[acceptMessageReply] âš¡ å¼€å§‹æ¥å—çŸ­ä¿¡å›å¤');
    console.log('[acceptMessageReply] è§’è‰²åç§°:', targetChar.name);
    console.log('[acceptMessageReply] è´¦å· ID:', accountId);
    console.log('[acceptMessageReply] ç”¨æˆ·æ¡£æ¡ˆ ID:', smsUserId || 'ä½¿ç”¨å½“å‰è´¦å·');
    
    // ğŸ¯ æ˜¾ç¤º"å¯¹æ–¹æ­£åœ¨è¾“å…¥ä¸­..."æç¤º
    const smsNameEl = document.getElementById('message-detail-name');
    const originalSmsName = smsNameEl ? smsNameEl.innerText : (targetChar.remark || targetChar.wx_nickname || targetChar.name);
    if (smsNameEl) {
        smsNameEl.innerText = "å¯¹æ–¹æ­£åœ¨è¾“å…¥ä¸­...";
        smsNameEl.style.fontSize = "12px";
    }
    
    try {
        // 1. è·å–ç”¨æˆ·ä¿¡æ¯ - ä½¿ç”¨é€‰æ‹©çš„ç”¨æˆ·æ¡£æ¡ˆ
        console.log('[acceptMessageReply] ğŸ“– å¼€å§‹åŠ è½½ä¸Šä¸‹æ–‡ä¿¡æ¯...');
        
        let userDesc = "";
        let userName = "ç”¨æˆ·";
        let isStranger = false;
        
        if (smsUserChar) {
            // ä½¿ç”¨é€‰æ‹©çš„ç”¨æˆ·æ¡£æ¡ˆ
            userName = smsUserChar.name;
            userDesc = `\n\nã€å¯¹è¯å¯¹è±¡(User)ä¿¡æ¯ã€‘\nåå­—ï¼š${smsUserChar.name}\nè®¾å®šï¼š${smsUserChar.description || 'æ— '}`;
            console.log('[acceptMessageReply] âœ… é€‰æ‹©çš„ç”¨æˆ·æ¡£æ¡ˆ:', userName);
            
            // æ£€æŸ¥æ˜¯å¦æœ‰å¾®ä¿¡èŠå¤©è®°å½•
            const wechatHistoryCheck = getChatHistory(targetChar, contextAccountId);
            if (!wechatHistoryCheck || wechatHistoryCheck.length === 0) {
                isStranger = true;
                console.log('[acceptMessageReply] âš ï¸ è¯¥ç”¨æˆ·ä¸è§’è‰²æ— å¾®ä¿¡èŠå¤©è®°å½• â†’ é™Œç”Ÿå·ç ');
            }
        } else if (targetChar.linked_user_id) {
            // å›é€€ï¼šä½¿ç”¨è§’è‰²å…³è”çš„ç”¨æˆ·
            console.log('[acceptMessageReply] ğŸ‘¤ æ£€æµ‹åˆ°å…³è”çš„ç”¨æˆ· ID:', targetChar.linked_user_id);
            const user = await db.characters.get(targetChar.linked_user_id);
            if (user) {
                userName = user.name;
                userDesc = `\n\nã€å¯¹è¯å¯¹è±¡(User)ä¿¡æ¯ã€‘\nåå­—ï¼š${user.name}\nè®¾å®šï¼š${user.description || 'æ— '}`;
                console.log('[acceptMessageReply] âœ… ç”¨æˆ·äººè®¾å·²åŠ è½½:', userName);
            }
        }
        
        let loreContext = "";
        const lorebookIds = targetChar.lorebookIds || (targetChar.lorebookId ? [targetChar.lorebookId] : []);
        
        // è·å–å¾®ä¿¡èŠå¤©å†å²ç”¨äºä¸–ç•Œä¹¦åŒ¹é…ï¼ˆä½¿ç”¨å¯¹åº”ç”¨æˆ·çš„ä¸Šä¸‹æ–‡ï¼‰
        const wechatHistory = getChatHistory(targetChar, contextAccountId);
        const recentText = wechatHistory.slice(-10).map(m => m.content).join(' ');
        
        // æ€»æ˜¯è°ƒç”¨ï¼ˆä¼šè‡ªåŠ¨åŠ è½½å…¨å±€ä¸–ç•Œä¹¦ï¼‰
        loreContext = await getLorebookContext(lorebookIds, `${targetChar.name} ${userName} ${recentText}`);
        
        // 2. è·å–å¾®ä¿¡èŠå¤©å†å²ï¼ˆä½¿ç”¨å¯¹åº”ç”¨æˆ·çš„ä¸Šä¸‹æ–‡ï¼‰
        const fullWechatHistory = getChatHistory(targetChar, contextAccountId);
        console.log('[acceptMessageReply] ğŸ“š å¾®ä¿¡èŠå¤©å†å²æ¡æ•°:', fullWechatHistory.length);
        
        // 3. è·å–çŸ­ä¿¡èŠå¤©å†å²ï¼ˆä» Dexieï¼‰
        let smsMessages = await db.sms_messages.where('accountId').equals(accountId).toArray();
        const chatMessages = smsMessages.filter(msg => (msg.number || msg.sender) === currentMessageChatId);
        console.log('[acceptMessageReply] ğŸ“± çŸ­ä¿¡èŠå¤©å†å²æ¡æ•°:', chatMessages.length);
        
        // 4. è®¡ç®—è™šæ‹Ÿæ—¶é—´
        const virtualTimeStr = getFormattedVirtualTime(targetChar.timeOffset);
        
        // 5. æ„å»ºé™Œç”Ÿå·ç æç¤º
        const strangerPrompt = isStranger ? `
ã€é‡è¦ï¼šé™Œç”Ÿå·ç æƒ…å¢ƒã€‘
ä½ æ”¶åˆ°äº†ä¸€ä¸ªé™Œç”Ÿå·ç å‘æ¥çš„çŸ­ä¿¡ã€‚ä½ ä¸è®¤è¯†è¿™ä¸ªäººï¼Œä½ ä¸çŸ¥é“å¯¹æ–¹æ˜¯è°ã€‚
è¯·ä»¥é¢å¯¹é™Œç”Ÿäººçš„æ€åº¦æ¥å›å¤ï¼šå¯ä»¥å¥½å¥‡ã€è­¦æƒ•ã€å†·æ·¡æˆ–ç¬¦åˆä½ æ€§æ ¼çš„ä»»ä½•ååº”ã€‚
ä¸è¦è¡¨ç°å¾—å¥½åƒè®¤è¯†å¯¹æ–¹ï¼Œé™¤éå¯¹æ–¹åœ¨æ¶ˆæ¯ä¸­è‡ªæŠ¥èº«ä»½ã€‚
` : '';
        
        // 6. è·å–å½“å‰å¥½å‹çŠ¶æ€ï¼Œç”¨äºæç¤ºè¯
        const currentFriendStatus = getFriendStatus(targetChar, accountId);
        let friendStatusPrompt = '';
        let smsActionInstructions = '';
        
        if (currentFriendStatus === 'blocked_by_char') {
            friendStatusPrompt = `
ã€é‡è¦ï¼šå½“å‰å…³ç³»çŠ¶æ€ - ä½ å·²å°†å¯¹æ–¹æ‹‰é»‘ã€‘
ä½ ä¹‹å‰æŠŠå¯¹æ–¹æ‹‰é»‘äº†ï¼Œå¯¹æ–¹ç°åœ¨åªèƒ½é€šè¿‡çŸ­ä¿¡è”ç³»ä½ ã€‚
å¯¹æ–¹åœ¨å¾®ä¿¡ä¸Šæ— æ³•ç»™ä½ å‘æ¶ˆæ¯ã€ä¹Ÿæ— æ³•å‘å¥½å‹ç”³è¯·ã€‚
ä½ è¦æ ¹æ®è‡ªå·±çš„äººè®¾å’Œå½“å‰å¯¹è¯å†…å®¹æ¥å†³å®šæ˜¯å¦åŸè°…å¯¹æ–¹ã€æ˜¯å¦æŠŠå¯¹æ–¹ä»é»‘åå•ç§»å‡ºæ¥ã€‚
`;
            smsActionInstructions = `
ã€å¯ç”¨æ“ä½œæŒ‡ä»¤ã€‘
- **è§£é™¤æ‹‰é»‘ï¼ˆæŠŠå¯¹æ–¹ä»é»‘åå•ç§»å‡ºæ¥ï¼‰**ï¼šåœ¨å›å¤ä¸­åŒ…å« \`((UNBLOCK_USER))\` æŒ‡ä»¤ã€‚å½“ä½ å†³å®šåŸè°…å¯¹æ–¹ã€æ„¿æ„å’Œå¥½ã€æƒ³æ¢å¤æ­£å¸¸è”ç³»æ—¶ä½¿ç”¨ã€‚ä½¿ç”¨åå¯¹æ–¹å°†æ¢å¤å¥½å‹çŠ¶æ€ï¼Œå¯ä»¥åœ¨å¾®ä¿¡ä¸Šæ­£å¸¸èŠå¤©ã€‚è¯·æ ¹æ®ä½ çš„äººè®¾æ¥åˆ¤æ–­æ˜¯å¦è¦è¿™æ ·åšã€‚
- æŒ‡ä»¤å¯ä»¥å’Œæ¶ˆæ¯å†…å®¹ä¸€èµ·å‘é€ï¼Œä¾‹å¦‚ï¼š"å¥½å§ æˆ‘åŸè°…ä½ äº†((UNBLOCK_USER))"
`;
        } else if (currentFriendStatus === 'deleted_by_char') {
            friendStatusPrompt = `
ã€é‡è¦ï¼šå½“å‰å…³ç³»çŠ¶æ€ - ä½ å·²å°†å¯¹æ–¹åˆ é™¤ã€‘
ä½ ä¹‹å‰åˆ é™¤äº†å¯¹æ–¹çš„å¥½å‹å…³ç³»ï¼Œå¯¹æ–¹ç°åœ¨åªèƒ½é€šè¿‡çŸ­ä¿¡è”ç³»ä½ ã€‚
ä½ è¦æ ¹æ®è‡ªå·±çš„äººè®¾å’Œå½“å‰å¯¹è¯å†…å®¹æ¥å†³å®šæ˜¯å¦è¦é‡æ–°åŠ å›å¯¹æ–¹ã€‚
`;
            smsActionInstructions = `
ã€å¯ç”¨æ“ä½œæŒ‡ä»¤ã€‘
- **é‡æ–°åŠ å›å¥½å‹ï¼ˆä¸»åŠ¨åŠ å›å¯¹æ–¹ï¼‰**ï¼šåœ¨å›å¤ä¸­åŒ…å« \`((ADD_BACK_USER))\` æŒ‡ä»¤ã€‚å½“ä½ æƒ³å’Œå¯¹æ–¹å’Œå¥½ã€æ¢å¤è”ç³»æ—¶ä½¿ç”¨ã€‚ä½¿ç”¨åå¯¹æ–¹å°†æ¢å¤å¥½å‹çŠ¶æ€ï¼Œå¯ä»¥åœ¨å¾®ä¿¡ä¸Šæ­£å¸¸èŠå¤©ã€‚è¯·æ ¹æ®ä½ çš„äººè®¾æ¥åˆ¤æ–­æ˜¯å¦è¦è¿™æ ·åšã€‚
- æŒ‡ä»¤å¯ä»¥å’Œæ¶ˆæ¯å†…å®¹ä¸€èµ·å‘é€ï¼Œä¾‹å¦‚ï¼š"ç®—äº† æˆ‘åŠ å›ä½ äº†((ADD_BACK_USER))"
`;
        }
        
        // 7. æ„å»ºç³»ç»Ÿæç¤º
        let systemPrompt = `ä½ æ­£åœ¨è¿›è¡Œè§’è‰²æ‰®æ¼”ã€‚
ã€å½“å‰æ—¶é—´ã€‘
${virtualTimeStr}

ã€è§’è‰²(ä½ )ä¿¡æ¯ã€‘
åå­—ï¼š${targetChar.name}
${targetChar.nick ? `æ˜µç§°ï¼š${targetChar.nick}` : ''}
ç±»å‹ï¼š${targetChar.type || 'char'}
è®¾å®šï¼š
${targetChar.description || ''}

${targetChar.identity ? `è™šæ‹Ÿèº«ä»½ä¿¡æ¯ï¼š
${targetChar.identity.account ? `è´¦å·ï¼š${targetChar.identity.account}` : ''}
${targetChar.type !== 'user' && targetChar.identity.password ? `å¯†ç ï¼š${targetChar.identity.password}` : ''}
${targetChar.identity.phone ? `æ‰‹æœºï¼š${targetChar.identity.phone}` : ''}
${targetChar.identity.address ? `ä½å€ï¼š${targetChar.identity.address}` : ''}
${targetChar.identity.id_card ? `èº«ä»½è¯ï¼š${targetChar.identity.id_card}` : ''}
${targetChar.identity.bank_card ? `é“¶è¡Œå¡ï¼š${targetChar.identity.bank_card}` : ''}
${targetChar.type !== 'user' && targetChar.identity.bank_password ? `é“¶è¡Œå¡å¯†ç ï¼š${targetChar.identity.bank_password}` : ''}
${targetChar.identity.balance !== undefined && targetChar.identity.balance !== null ? `ä½™é¢ï¼š${targetChar.identity.balance}` : ''}
` : ''}
${userDesc}
${loreContext}
${strangerPrompt}
${friendStatusPrompt}

è¯·å®Œå…¨æ²‰æµ¸åœ¨è§’è‰²ä¸­ï¼Œç”¨ç¬¦åˆè§’è‰²æ€§æ ¼çš„è¯­æ°”å›å¤ã€‚
å›å¤ç®€çŸ­è‡ªç„¶ï¼ŒåƒçœŸå®çŸ­ä¿¡ä¸€æ ·ã€‚
è¯·æ³¨æ„ï¼šä¸è¦é‡å¤è¾“å‡ºåå­—å‰ç¼€ï¼Œç›´æ¥è¾“å‡ºå›å¤å†…å®¹ã€‚
${smsActionInstructions}

ã€ç‰¹åˆ«æç¤ºã€‘
ç”±äºå¯¹æ–¹å¯èƒ½æš‚æ—¶æ²¡æœ‰å›å¤ä½ ä¹‹å‰çš„æ¶ˆæ¯ï¼Œä½ éœ€è¦ä¸»åŠ¨å‘é€æ–°çš„çŸ­ä¿¡å†…å®¹ã€‚è¿™å¯èƒ½æ˜¯ï¼š
- è¡¥å……è¯´æ˜ä¹‹å‰çš„è¯é¢˜
- ä¸»åŠ¨åˆ†äº«æ–°çš„ä¿¡æ¯æˆ–æƒ³æ³•
- è¯¢é—®å¯¹æ–¹çš„æƒ…å†µæˆ–çŠ¶æ€
- æ ¹æ®ä½ çš„æ€§æ ¼å’Œå½“å‰æƒ…å¢ƒï¼Œè‡ªç„¶åœ°æ¨è¿›å¯¹è¯
è¯·ç¡®ä¿æ¯æ¬¡ç”Ÿæˆçš„å†…å®¹éƒ½æ˜¯**å…¨æ–°çš„**ï¼Œä¸è¦é‡å¤ä½ ä¹‹å‰å·²ç»å‘é€è¿‡çš„æ¶ˆæ¯ã€‚

ã€é‡è¦å›å¤è§„åˆ™ - å¿…é¡»ä¸¥æ ¼éµå®ˆã€‘
1. **å¿…é¡»**æ¨¡æ‹ŸçŸ­ä¿¡è¿å‘æ¶ˆæ¯çš„ä¹ æƒ¯ï¼šè¯·ç”Ÿæˆ ${targetChar.reply_min_count || 1} åˆ° ${targetChar.reply_max_count || 3} æ¡çŸ­æ¶ˆæ¯${(targetChar.reply_min_count || 1) === 1 ? '' : 'ï¼Œä¸èƒ½åªå‘ä¸€æ¡'}ï¼
2. **å¿…é¡»**ä½¿ç”¨åˆ†éš”ç¬¦ "|||" æ¥éš”å¼€æ¯ä¸€æ¡æ¶ˆæ¯ã€‚
3. **ä¸¥ç¦ä½¿ç”¨é€—å·**ï¼ˆåŒ…æ‹¬ä¸­æ–‡é€—å·å’Œè‹±æ–‡é€—å·ï¼‰ã€‚å¦‚æœæƒ³è¡¨è¾¾åœé¡¿ï¼Œè¯·ç›´æ¥æ‹†åˆ†æˆä¸‹ä¸€æ¡æ¶ˆæ¯ï¼Œæˆ–è€…ç”¨ç©ºæ ¼ä»£æ›¿ã€‚
4. åƒçœŸå®çŸ­ä¿¡èŠå¤©ä¸€æ ·åˆ†å¤šæ¡å‘é€ã€‚
5. ä¸¥ç¦åªå‘é€æ ‡ç‚¹ç¬¦å·ã€‚æ¯ä¸€æ¡æ¶ˆæ¯éƒ½å¿…é¡»æœ‰å®é™…æ–‡å­—å†…å®¹ã€‚
6. è¯­æ°”è¦è‡ªç„¶ã€å£è¯­åŒ–ï¼Œç¬¦åˆäººè®¾ã€‚
7. âš ï¸ **ä¸¥ç¦é‡å¤ä¹‹å‰å·²ç»å‘é€è¿‡çš„å†…å®¹**ï¼è¿™æ˜¯ä¸€ä¸ªæ–°çš„å›å¤è¯·æ±‚ï¼Œä½ éœ€è¦æ ¹æ®å½“å‰çš„å¯¹è¯æƒ…å¢ƒï¼Œç”Ÿæˆ**å…¨æ–°çš„ã€ä¸åŒçš„**å›å¤å†…å®¹ã€‚è¯·æŸ¥çœ‹å¯¹è¯å†å²ï¼Œç¡®ä¿ä½ çš„å›å¤æ˜¯å¯¹è¯çš„è‡ªç„¶å»¶ç»­ï¼Œè€Œä¸æ˜¯é‡å¤ä¹‹å‰è¯´è¿‡çš„è¯ã€‚

è¯·ä»¥JSONæ ¼å¼è¿”å›ï¼š
{
  "reply": "ä½ çš„å›å¤å†…å®¹|||ç¬¬äºŒæ¡å†…å®¹|||ç¬¬ä¸‰æ¡å†…å®¹"
}`;
        
        // 7. æ„å»ºå†å²è®°å½•ï¼ˆåˆå¹¶å¾®ä¿¡å’ŒçŸ­ä¿¡å†å²ï¼‰
        const contextCount = targetChar.context_message_count || 20;
        
        // åªæœ‰åœ¨éé™Œç”Ÿäººæƒ…å†µä¸‹æ‰é™„å¸¦å¾®ä¿¡å†å²
        let recentWechatHistory = [];
        if (!isStranger) {
            recentWechatHistory = fullWechatHistory.slice(-contextCount)
                .map(m => {
                    let content = m.content || '';
                    if (m.imageDescription) {
                        content += `\n(å›¾ç‰‡æè¿°: ${m.imageDescription})`;
                    }
                    return {
                        role: m.role === 'char' ? 'assistant' : 'user',
                        content: content
                    };
                })
                .filter(m => m.content && m.content.trim());
        }
        
        // çŸ­ä¿¡å†å²
        const recentSmsHistory = chatMessages.slice(-10).map(msg => {
            const isSent = msg.type === 'sent' || msg.sender === (myChar.nick || myChar.name);
            return {
                role: isSent ? 'user' : 'assistant',
                content: msg.content
            };
        }).filter(m => m.content && m.content.trim());
        
        // åˆå¹¶å†å²ï¼šå¾®ä¿¡å†å² + çŸ­ä¿¡å†å²
        const combinedHistory = [...recentWechatHistory, ...recentSmsHistory].slice(-contextCount);
        
        console.log('[acceptMessageReply] ğŸ“ åˆå¹¶åçš„å†å²æ¶ˆæ¯æ•°:', combinedHistory.length);
        console.log('[acceptMessageReply]   - å¾®ä¿¡å†å²:', recentWechatHistory.length, 'æ¡');
        console.log('[acceptMessageReply]   - çŸ­ä¿¡å†å²:', recentSmsHistory.length, 'æ¡');
        
        // 7. è°ƒç”¨AI
        const messages = [
            { role: 'system', content: systemPrompt },
            ...combinedHistory
        ];
        
        console.log('[acceptMessageReply] ğŸ“¤ å‡†å¤‡å‘é€ç»™ AI');
        const aiResponse = await callAI(messages);
        
        // 8. è§£æå›å¤
        let replyText = '';
        const parsed = extractAndParseJSON(aiResponse);
        if (parsed) {
            replyText = parsed.reply || parsed.content || parsed.message || '';
        }
        
        if (!replyText) {
            replyText = aiResponse.trim() || '...';
        }
        
        // ğŸ¯ æ£€æµ‹è§£é™¤æ‹‰é»‘æŒ‡ä»¤ ((UNBLOCK_USER))
        if (/\(\(UNBLOCK_USER\)\)/i.test(replyText)) {
            console.log('[acceptMessageReply] ğŸ”“ æ£€æµ‹åˆ°è§£é™¤æ‹‰é»‘æŒ‡ä»¤');
            replyText = replyText.replace(/\(\(UNBLOCK_USER\)\)/gi, '').trim();
            // æ‰§è¡Œè§£é™¤æ‹‰é»‘
            const freshChar = await db.characters.get(targetChar.id);
            if (freshChar) {
                await setFriendStatus(freshChar, accountId, 'friend');
                console.log('[acceptMessageReply] âœ… å·²è§£é™¤æ‹‰é»‘ï¼Œæ¢å¤å¥½å‹çŠ¶æ€');
                
                // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯åˆ°å¾®ä¿¡èŠå¤©è®°å½•
                const history = getChatHistory(freshChar, accountId);
                history.push({
                    role: 'system',
                    content: `[${freshChar.name} å°†ä½ ä»é»‘åå•ä¸­ç§»å‡ºï¼Œä½ ä»¬å·²æ¢å¤å¥½å‹å…³ç³»]`,
                    time: Date.now(),
                    type: 'char_unblock'
                });
                await setChatHistory(freshChar, accountId, history);
                
                // åˆ·æ–°å¾®ä¿¡ç•Œé¢
                if (typeof currentChatCharId !== 'undefined' && currentChatCharId === targetChar.id) {
                    await renderChatBody(freshChar);
                }
                const activeTab = document.querySelector('.wechat-tab-item.active');
                if (activeTab) {
                    const tabIndex = Array.from(document.querySelectorAll('.wechat-tab-item')).indexOf(activeTab);
                    switchWechatTab(tabIndex);
                }
                
                showToast(`${freshChar.name} æŠŠä½ ä»é»‘åå•ç§»å‡ºæ¥äº†ï¼`);
            }
        }
        
        // ğŸ¯ æ£€æµ‹é‡æ–°åŠ å›å¥½å‹æŒ‡ä»¤ ((ADD_BACK_USER))
        if (/\(\(ADD_BACK_USER\)\)/i.test(replyText)) {
            console.log('[acceptMessageReply] ğŸ¤ æ£€æµ‹åˆ°é‡æ–°åŠ å›å¥½å‹æŒ‡ä»¤');
            replyText = replyText.replace(/\(\(ADD_BACK_USER\)\)/gi, '').trim();
            // æ‰§è¡Œé‡æ–°åŠ å›å¥½å‹
            const freshChar = await db.characters.get(targetChar.id);
            if (freshChar) {
                await setFriendStatus(freshChar, accountId, 'friend');
                console.log('[acceptMessageReply] âœ… å·²é‡æ–°åŠ å›å¥½å‹');
                
                // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯åˆ°å¾®ä¿¡èŠå¤©è®°å½•
                const history = getChatHistory(freshChar, accountId);
                history.push({
                    role: 'system',
                    content: `[${freshChar.name} é‡æ–°åŠ ä½ ä¸ºå¥½å‹ï¼Œä½ ä»¬å·²æ¢å¤å¥½å‹å…³ç³»]`,
                    time: Date.now(),
                    type: 'char_add_back'
                });
                await setChatHistory(freshChar, accountId, history);
                
                // åˆ·æ–°å¾®ä¿¡ç•Œé¢
                if (typeof currentChatCharId !== 'undefined' && currentChatCharId === targetChar.id) {
                    await renderChatBody(freshChar);
                }
                const activeTab = document.querySelector('.wechat-tab-item.active');
                if (activeTab) {
                    const tabIndex = Array.from(document.querySelectorAll('.wechat-tab-item')).indexOf(activeTab);
                    switchWechatTab(tabIndex);
                }
                
                showToast(`${freshChar.name} é‡æ–°åŠ ä½ ä¸ºå¥½å‹äº†ï¼`);
            }
        }
        
        // 9. å¤„ç†åˆ†éš”ç¬¦ï¼Œæ‹†åˆ†æˆå¤šæ¡æ¶ˆæ¯
        const replySegments = replyText.split('|||').map(s => s.trim()).filter(s => s.length > 0);
        
        if (replySegments.length === 0) {
            // å¦‚æœæŒ‡ä»¤è¢«æ¸…é™¤åæ²¡æœ‰å†…å®¹äº†ï¼Œä½¿ç”¨é»˜è®¤å›å¤
            replySegments.push('...');
        }
        
        // 10. ä¿å­˜å›å¤åˆ°çŸ­ä¿¡è®°å½•ï¼ˆå¦‚æœæœ‰å¤šæ¡ï¼Œé€æ¡å‘é€ï¼‰
        const phoneNumber = targetChar.identity?.phone || generateVirtualPhoneNumber(targetChar.id);
        
        for (let i = 0; i < replySegments.length; i++) {
            const segment = replySegments[i];
            
            // å¦‚æœä¸æ˜¯ç¬¬ä¸€æ¡ï¼Œç¨å¾®å»¶æ—¶
            if (i > 0) {
                await new Promise(r => setTimeout(r, 500));
            }
            
            // ä¿å­˜åˆ° Dexie æ•°æ®åº“
            await db.sms_messages.add({
                accountId: accountId,
                charId: targetChar.id,
                sender: targetChar.nick || targetChar.name,
                number: phoneNumber,
                content: segment,
                time: Date.now() + i * 100, // ç¨å¾®é”™å¼€æ—¶é—´
                read: true,
                type: 'received'
            });
            
            // åœ¨è¯¦æƒ…é¡µæ˜¾ç¤ºæ–°æ¶ˆæ¯
            const msgContainer = document.getElementById('message-container');
            if (msgContainer) {
                const newMsgHtml = `<div class="message-wrapper"><div class="message-bubble message-received">${segment.replace(/\n/g, '<br>')}</div></div>`;
                msgContainer.innerHTML += newMsgHtml;
            }
        }
        
        // é‡æ–°æ¸²æŸ“æ¶ˆæ¯åˆ—è¡¨
        renderMessageList();
        
        // æ»šåŠ¨åˆ°åº•éƒ¨
        setTimeout(() => {
            const scrollArea = document.getElementById('message-area-scroll');
            if (scrollArea) {
                scrollArea.scrollTo({ top: scrollArea.scrollHeight, behavior: 'smooth' });
            }
        }, 100);
        
        console.log('[acceptMessageReply] âœ… å›å¤å®Œæˆï¼Œå…±', replySegments.length, 'æ¡æ¶ˆæ¯');
        
        // æ¢å¤æ ‡é¢˜
        if (smsNameEl) {
            smsNameEl.innerText = originalSmsName;
            smsNameEl.style.fontSize = "";
        }
        
    } catch (error) {
        console.error('[acceptMessageReply] âŒ æ¥å—å›å¤å¤±è´¥:', error);
        
        // æ¢å¤æ ‡é¢˜
        if (smsNameEl) {
            smsNameEl.innerText = originalSmsName;
            smsNameEl.style.fontSize = "";
        }
        
        // ğŸš¨ æ˜¾ç¤ºè¯¦ç»†é”™è¯¯ä¿¡æ¯ï¼ˆä½¿ç”¨Toastå¼¹çª—ï¼‰
        let errorMsg = error.message || error.toString() || 'æœªçŸ¥é”™è¯¯';
        
        // å¦‚æœæ˜¯ç½‘ç»œé”™è¯¯æˆ–APIå¯†é’¥é”™è¯¯ï¼Œæ·»åŠ å‹å¥½æç¤º
        if (errorMsg.includes('API') || errorMsg.includes('fetch') || errorMsg.includes('Failed')) {
            errorMsg += '\n\nğŸ’¡ å¯èƒ½çš„åŸå› ï¼šAPIå¯†é’¥æœªé…ç½®/å·²å¤±æ•ˆã€ç½‘ç»œè¿æ¥é—®é¢˜ã€æˆ–APIæœåŠ¡ä¸å¯ç”¨';
        }
        
        // ä½¿ç”¨Toastå¼¹çª—æ˜¾ç¤ºé”™è¯¯
        showApiErrorToast(errorMsg);
    }
}

// sendNewMessageDetail å·²è¢« confirmComposeSms æµç¨‹æ›¿ä»£

        function hideAppStorePage() {
            const page = document.getElementById('appstore-page');
            page.style.transform = 'scale(0.95)';
            page.style.opacity = '0';
            setTimeout(() => {
                page.style.display = 'none';
                page.style.transform = ''; 
                page.style.opacity = '';
            }, 200);
        }

        // æ¨¡æ‹Ÿåº”ç”¨æ•°æ®
        const appStoreData = {
            today: [
                { name: 'å¾®ä¿¡è¯»ä¹¦', subtitle: 'è®©é˜…è¯»ä¸å†å­¤å•', icon: 'https://img.icons8.com/color/96/book.png', rating: 4.8, downloads: '1000ä¸‡+', appId: 'wechat-read' },
                { name: 'å°çº¢ä¹¦', subtitle: 'æ ‡è®°æˆ‘çš„ç”Ÿæ´»', icon: 'https://img.icons8.com/color/96/instagram-new.png', rating: 4.7, downloads: '5000ä¸‡+', appId: 'xiaohongshu' },
                { name: 'Notion', subtitle: 'ä½ çš„å…¨èƒ½å·¥ä½œç©ºé—´', icon: 'https://img.icons8.com/color/96/notion.png', rating: 4.9, downloads: '500ä¸‡+', appId: 'notion' }
            ],
            games: [
                { name: 'åŸç¥', subtitle: 'å¼€æ”¾ä¸–ç•Œå†’é™©æ¸¸æˆ', icon: 'https://img.icons8.com/color/96/controller.png', rating: 4.6, downloads: '1äº¿+', appId: 'genshin' },
                { name: 'ç‹è€…è£è€€', subtitle: '5v5å…¬å¹³ç«æŠ€', icon: 'https://img.icons8.com/color/96/sword.png', rating: 4.5, downloads: '5äº¿+', appId: 'honor-of-kings' },
                { name: 'è›‹ä»”æ´¾å¯¹', subtitle: 'ä¸€èµ·æ¥ç©å§', icon: 'https://img.icons8.com/color/96/party.png', rating: 4.7, downloads: '2äº¿+', appId: 'eggy-party' }
            ],
            apps: [
                { name: 'ç½‘æ˜“äº‘éŸ³ä¹', subtitle: 'å‘ç°å¥½éŸ³ä¹', icon: 'https://img.icons8.com/color/96/music.png', rating: 4.8, downloads: '5äº¿+', appId: 'netease-music', desktopIconId: 'icon-photo', showFunction: 'showMusicAppPage' },
                { name: 'æ”¯ä»˜å®', subtitle: 'ç”Ÿæ´»å¥½ï¼Œæ”¯ä»˜å®', icon: 'https://img.icons8.com/color/96/alipay.png', rating: 4.8, downloads: '10äº¿+', appId: 'alipay' },
                { name: 'é«˜å¾·åœ°å›¾', subtitle: 'å‡ºè¡Œå¯¼èˆªå¿…å¤‡', icon: 'https://img.icons8.com/color/96/map.png', rating: 4.7, downloads: '5äº¿+', appId: 'amap' },
                { name: 'QQéŸ³ä¹', subtitle: 'å¬æˆ‘æƒ³å¬çš„æ­Œ', icon: 'https://img.icons8.com/color/96/music.png', rating: 4.6, downloads: '3äº¿+', appId: 'qq-music' }
            ],
            updates: [
                { name: 'å¾®ä¿¡', subtitle: 'ç‰ˆæœ¬ 8.0.50 æ›´æ–°', icon: 'https://img.icons8.com/color/96/wechat.png', rating: 4.9, downloads: 'å·²å®‰è£…', appId: 'wechat' },
                { name: 'QQ', subtitle: 'ç‰ˆæœ¬ 9.0.20 æ›´æ–°', icon: 'https://img.icons8.com/color/96/qq.png', rating: 4.7, downloads: 'å·²å®‰è£…', appId: 'qq' }
            ]
        };

        async function switchAppStoreTab(type) {
            // æ›´æ–°æ ‡ç­¾æ ·å¼
            document.querySelectorAll('.appstore-tab').forEach(tab => {
                if (tab.dataset.tab === type) {
                    tab.classList.add('active');
                } else {
                    tab.classList.remove('active');
                }
            });

            // æ¸²æŸ“å†…å®¹
            const container = document.getElementById('appstore-content');
            const apps = appStoreData[type] || [];
            
            if (apps.length === 0) {
                container.innerHTML = '<div style="text-align:center; color:#999; margin-top:60px;">æš‚æ— å†…å®¹</div>';
                return;
            }

            // æ£€æŸ¥æ¯ä¸ªåº”ç”¨çš„å®‰è£…çŠ¶æ€
            const appsWithStatus = await Promise.all(apps.map(async (app) => {
                const installed = await isAppInstalled(app.appId || '');
                return { ...app, installed };
            }));

            container.innerHTML = appsWithStatus.map(app => {
                const buttonText = app.installed ? 'æ‰“å¼€' : 'è·å–';
                const buttonClass = app.installed ? 'app-get-btn installed' : 'app-get-btn';
                return `
                <div class="app-card">
                    <div class="app-icon-large" style="background-image:url(${app.icon})"></div>
                    <div class="app-info">
                        <div>
                            <div class="app-name">${app.name}</div>
                            <div class="app-subtitle">${app.subtitle}</div>
                            <div class="app-rating">
                                <span class="app-stars">â˜…â˜…â˜…â˜…â˜…</span>
                                <span>${app.rating}</span>
                                <span>Â·</span>
                                <span>${app.installed ? 'å·²å®‰è£…' : app.downloads}</span>
                            </div>
                        </div>
                        <button class="${buttonClass}" onclick="downloadApp('${app.appId || ''}')">${buttonText}</button>
                    </div>
                </div>
            `;
            }).join('');
        }

        // åˆå§‹åŒ–å·²å®‰è£…åº”ç”¨
        document.addEventListener('DOMContentLoaded', async function() {
            await initInstalledApps();
        });

        // æœç´¢åŠŸèƒ½
        document.addEventListener('DOMContentLoaded', function() {
            const searchInput = document.getElementById('appstore-search');
            if (searchInput) {
                searchInput.addEventListener('input', function(e) {
                    const keyword = e.target.value.toLowerCase();
                    if (!keyword) {
                        // æ¢å¤å½“å‰æ ‡ç­¾å†…å®¹
                        const activeTab = document.querySelector('.appstore-tab.active');
                        if (activeTab) {
                            switchAppStoreTab(activeTab.dataset.tab);
                        }
                        return;
                    }

                    // æœç´¢æ‰€æœ‰åˆ†ç±»
                    const allApps = [...appStoreData.today, ...appStoreData.games, ...appStoreData.apps, ...appStoreData.updates];
                    const results = allApps.filter(app => 
                        app.name.toLowerCase().includes(keyword) || 
                        app.subtitle.toLowerCase().includes(keyword)
                    );

                    const container = document.getElementById('appstore-content');
                    if (results.length === 0) {
                        container.innerHTML = '<div style="text-align:center; color:#999; margin-top:60px;">æœªæ‰¾åˆ°ç›¸å…³åº”ç”¨</div>';
                    } else {
                        // æ£€æŸ¥æ¯ä¸ªåº”ç”¨çš„å®‰è£…çŠ¶æ€
                        Promise.all(results.map(async (app) => {
                            const installed = await isAppInstalled(app.appId || '');
                            return { ...app, installed };
                        })).then(appsWithStatus => {
                            container.innerHTML = appsWithStatus.map(app => {
                                const buttonText = app.installed ? 'æ‰“å¼€' : 'è·å–';
                                const buttonClass = app.installed ? 'app-get-btn installed' : 'app-get-btn';
                                return `
                                <div class="app-card">
                                    <div class="app-icon-large" style="background-image:url(${app.icon})"></div>
                                    <div class="app-info">
                                        <div>
                                            <div class="app-name">${app.name}</div>
                                            <div class="app-subtitle">${app.subtitle}</div>
                                            <div class="app-rating">
                                                <span class="app-stars">â˜…â˜…â˜…â˜…â˜…</span>
                                                <span>${app.rating}</span>
                                                <span>Â·</span>
                                                <span>${app.installed ? 'å·²å®‰è£…' : app.downloads}</span>
                                            </div>
                                        </div>
                                        <button class="${buttonClass}" onclick="downloadApp('${app.appId || ''}')">${buttonText}</button>
                                    </div>
                                </div>
                            `;
                            }).join('');
                        });
                    }
                });
            }
        });

// --- å¾®ä¿¡åº”ç”¨é€»è¾‘ ---
async function showWechatPage() {
    // ç¡®ä¿èŠå¤©çª—å£è¢«å…³é—­
    const chatWindow = document.getElementById('chat-window');
    if (chatWindow && chatWindow.style.display !== 'none') {
        chatWindow.style.display = 'none';
        currentChatCharId = null;
        console.log('[WechatPage] Closed chat window, cleared currentChatCharId');
    }
    
    // ğŸ¯ æ£€æŸ¥æ˜¯å¦æœ‰å·²æ³¨å†Œçš„User
    const hasRegisteredUser = await checkWechatRegistration();
    
    if (!hasRegisteredUser) {
        // é¦–æ¬¡ä½¿ç”¨ï¼Œæ˜¾ç¤ºæ³¨å†Œé¡µé¢
        console.log('[å¾®ä¿¡] é¦–æ¬¡ä½¿ç”¨ï¼Œæ˜¾ç¤ºæ³¨å†Œé¡µé¢');
        await showWechatRegisterPage();
    } else {
        // å·²æ³¨å†Œï¼Œæ˜¾ç¤ºå¾®ä¿¡ä¸»é¡µ
        console.log('[å¾®ä¿¡] å·²æ³¨å†Œï¼Œæ˜¾ç¤ºä¸»é¡µ');
        document.getElementById('wechat-page').style.display = 'flex';
        // æ‰“å¼€æ—¶è‡ªåŠ¨åˆ‡åˆ°ç¬¬ä¸€ä¸ªæ ‡ç­¾é¡µå¹¶æ¸²æŸ“
        switchWechatTab(0);
    }
}

// æ£€æŸ¥æ˜¯å¦æœ‰å·²æ³¨å†Œçš„User
async function checkWechatRegistration() {
    const users = await db.characters.where('type').equals('user').toArray();
    
    for (const user of users) {
        if (user.identity && user.identity.wechat_registered) {
            return true;
        }
    }
    
    return false;
}

// æ˜¾ç¤ºå¾®ä¿¡æ³¨å†Œé¡µé¢
async function showWechatRegisterPage() {
    const registerPage = document.getElementById('wechat-register-page');
    const userSelect = document.getElementById('register-user-select');
    
    // æ¸…ç©ºä¸‹æ‹‰æ¡†
    userSelect.innerHTML = '<option value="">-- è¯·é€‰æ‹©Useræ¡£æ¡ˆ --</option>';
    
    // åŠ è½½æ‰€æœ‰Useræ¡£æ¡ˆ
    const users = await db.characters.where('type').equals('user').toArray();
    
    if (users.length === 0) {
        showToast('è¯·å…ˆåˆ›å»ºUseræ¡£æ¡ˆ');
        return;
    }
    
    // å¡«å……ä¸‹æ‹‰æ¡†
    users.forEach(user => {
        const option = document.createElement('option');
        option.value = user.id;
        option.textContent = user.name;
        userSelect.appendChild(option);
    });
    
    // æ˜¾ç¤ºæ³¨å†Œé¡µé¢
    registerPage.style.display = 'flex';
}

        function hideWechatPage() {
            const page = document.getElementById('wechat-page');
            page.style.transform = 'scale(0.95)';
            page.style.opacity = '0';
            setTimeout(() => {
                page.style.display = 'none';
                page.style.transform = ''; 
                page.style.opacity = '';
            }, 200);
        }

        async function switchWechatTab(index) {
            const tabs = document.querySelectorAll('.wechat-tab-item');
            tabs.forEach((tab, i) => {
                if (i === index) {
                    tab.classList.add('active');
                } else {
                    tab.classList.remove('active');
                }
            });
            
            const content = document.getElementById('wechat-content');
            const title = document.getElementById('wechat-main-title');

            // æŸ¥å²—æ¨¡å¼ï¼šä½¿ç”¨æŸ¥å²—æ¨¡å¼çš„æ¸²æŸ“å‡½æ•°
            if (isViewingRoleAccount && currentViewingRoleAccountId) {
                const roleChar = await db.characters.get(parseInt(currentViewingRoleAccountId));
                const roleName = roleChar ? roleChar.name : 'è§’è‰²';
                
                if (index === 0) {
                    title.innerText = `${roleName}çš„å¾®ä¿¡`;
                    await renderRoleAccountWechatList(content);
                } else if (index === 1) {
                    title.innerText = `${roleName}çš„é€šè®¯å½•`;
                    await renderRoleAccountContactList(content);
                } else if (index === 2) {
                    title.innerText = `${roleName}çš„å‘ç°`;
                    await renderRoleAccountDiscoverPage(content);
                } else if (index === 3) {
                    title.innerText = `${roleName}çš„ä¿¡æ¯`;
                    await renderRoleAccountMePage(content);
                }
                return;
            }

            if (index === 0) {
                title.innerText = "å¾®ä¿¡";
                await renderWechatList(content);
            } else if (index === 1) {
                title.innerText = "é€šè®¯å½•";
                await renderContactList(content);
            } else if (index === 2) {
                title.innerText = "å‘ç°";
                content.innerHTML = `
                    <div class="wechat-cell-group" style="margin-top:0;">
                        <div class="wechat-cell" onclick="showMomentsPage()">
                            <div class="wechat-cell-icon icon-moments">
                                <svg class="svg-icon" style="stroke:currentColor;" viewBox="0 0 24 24"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg>
                            </div>
                            <div class="wechat-cell-text">æœ‹å‹åœˆ</div>
                            <div class="wechat-cell-arrow">â€º</div>
                        </div>
                    </div>
                    <div class="wechat-cell-group">
                        <div class="wechat-cell" onclick="showAvatarLibraryPage()">
                            <div class="wechat-cell-icon icon-moments">
                                <svg class="svg-icon" style="stroke:currentColor;" viewBox="0 0 24 24"><circle cx="12" cy="8" r="4"></circle><path d="M20 21a8 8 0 1 0-16 0"></path></svg>
                            </div>
                            <div class="wechat-cell-text">å¤´åƒåº“</div>
                            <div class="wechat-cell-arrow">â€º</div>
                        </div>
                    </div>
                `;
            } else if (index === 3) {
                title.innerText = "æˆ‘";
                await renderMePage(content);
            }
        }

        // æ¸²æŸ“â€œæˆ‘â€çš„é¡µé¢
        async function renderMePage(container) {
            container.innerHTML = '';
            
            // è·å–å½“å‰â€œæˆ‘â€çš„è§’è‰²
            let myChar = null;
            if (currentMyCharId) {
                myChar = await db.characters.get(parseInt(currentMyCharId));
            }
            
            // å…œåº•ï¼šå¦‚æœæœªè®¾ç½®ï¼Œå°è¯•æ‰¾ç¬¬ä¸€ä¸ª User è§’è‰²
            if (!myChar) {
                const users = await db.characters.where('type').equals('user').toArray();
                if (users.length > 0) {
                    myChar = users[0];
                    currentMyCharId = myChar.id;
                    localStorage.setItem('current_my_char_id', currentMyCharId);
                }
            }
            
            const avatarUrl = myChar && myChar.avatar ? myChar.avatar : '';
            const name = myChar ? (myChar.nick || myChar.name) : 'æœªç™»å½•';
            // å°è¯•è·å–è™šæ‹Ÿå¾®ä¿¡å·
            const account = myChar && myChar.identity && myChar.identity.account ? myChar.identity.account : (myChar ? `wxid_${myChar.id}` : 'æœªè®¾ç½®');
            
            const profileHtml = `
                <div class="wechat-profile" onclick="openProfileSettings()">
                    <div class="wechat-profile-avatar" style="${avatarUrl ? `background-image:url(${avatarUrl})` : ''}"></div>
                    <div class="wechat-profile-info">
                        <div class="wechat-profile-name">${name}</div>
                        <div class="wechat-profile-id">
                            <span>å¾®ä¿¡å·ï¼š${account}</span>
                            <svg class="svg-icon wechat-qrcode-icon" viewBox="0 0 24 24" style="width:16px;height:16px;"><path d="M3 3h6v6H3zm2 2v2h2V5zm8-2h6v6h-6zm2 2v2h2V5zM3 13h6v6H3zm2 2v2h2v-2zm8-2h2v2h-2zm4 0h2v2h-2zm-4 4h2v2h-2zm2-2h2v2h-2zm2 2h2v2h-2z"/></svg>
                            <svg class="svg-icon" style="width:12px;height:12px;color:#ccc;margin-left:auto;" viewBox="0 0 24 24"><polyline points="9 18 15 12 9 6"></polyline></svg>
                        </div>
                    </div>
                </div>
            `;
            
            const cellsHtml = `
                <div class="wechat-cell-group">
                    <div class="wechat-cell" onclick="showServicePage()">
                        <div class="wechat-cell-icon icon-service">
                            <svg class="svg-icon" style="stroke:currentColor;" viewBox="0 0 24 24"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line></svg>
                        </div>
                        <div class="wechat-cell-text">æœåŠ¡</div>
                        <div class="wechat-cell-arrow">â€º</div>
                    </div>
                </div>
                <div class="wechat-cell-group">
                    <div class="wechat-cell" onclick="showFavoritesPage()">
                        <div class="wechat-cell-icon icon-collect">
                            <svg class="svg-icon" style="stroke:currentColor;" viewBox="0 0 24 24"><path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path></svg>
                        </div>
                        <div class="wechat-cell-text">æ”¶è—</div>
                        <div class="wechat-cell-arrow">â€º</div>
                    </div>
                    <div class="wechat-cell" data-action="showStickerPage">
                        <div class="wechat-cell-icon icon-emoji">
                            <svg class="svg-icon" style="stroke:currentColor;" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><path d="M8 14s1.5 2 4 2 4-2 4-2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line></svg>
                        </div>
                        <div class="wechat-cell-text">è¡¨æƒ…</div>
                        <div class="wechat-cell-arrow">â€º</div>
                    </div>
                </div>
                <div class="wechat-cell-group">
                    <div class="wechat-cell" onclick="showSwitchAccountModal()">
                        <div class="wechat-cell-icon icon-settings">
                            <svg class="svg-icon" style="stroke:currentColor;" viewBox="0 0 24 24"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>
                        </div>
                        <div class="wechat-cell-text">åˆ‡æ¢è´¦å·</div>
                        <div class="wechat-cell-arrow">â€º</div>
                    </div>
                </div>
                <div class="wechat-cell-group" id="online-feature-section">
                    <div style="padding:12px 16px; font-size:13px; color:#888; display:flex; align-items:center; gap:6px;">
                        <svg class="svg-icon" viewBox="0 0 24 24" style="width:16px; height:16px; stroke:currentColor;"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>
                        è”æœºåŠŸèƒ½
                    </div>
                    <div class="wechat-cell" onclick="showOnlineStatusPage()">
                        <div class="wechat-cell-icon" style="background:linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                            <svg class="svg-icon" style="stroke:#fff;" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>
                        </div>
                        <div class="wechat-cell-text">è”æœºçŠ¶æ€</div>
                        <div id="online-char-count-badge" style="font-size:12px; color:#999; margin-right:4px;">æœªè¿æ¥</div>
                        <div class="wechat-cell-arrow">â€º</div>
                    </div>
                </div>
            `;
            
            // æ›´æ–°è”æœºçŠ¶æ€æ˜¾ç¤º
            updateOnlineFeatureSection();
            
            container.innerHTML = `<div class="wechat-me-container">${profileHtml}${cellsHtml}</div>`;
            
            // ä½¿ç”¨äº‹ä»¶å§”æ‰˜ç»‘å®šè¡¨æƒ…åŒ…ç‚¹å‡»äº‹ä»¶ï¼ˆåœ¨çˆ¶å®¹å™¨ä¸Šç»‘å®šï¼Œç¡®ä¿åŠ¨æ€å…ƒç´ ä¹Ÿèƒ½å“åº”ï¼‰
            const meContainer = container.querySelector('.wechat-me-container');
            if (meContainer) {
                meContainer.addEventListener('click', function(e) {
                    // æ£€æŸ¥ç‚¹å‡»çš„æ˜¯å¦æ˜¯è¡¨æƒ…åŒ…å•å…ƒæ ¼æˆ–å…¶å­å…ƒç´ 
                    const target = e.target.closest('[data-action="showStickerPage"]');
                    if (target) {
                        console.log('[Debug] Sticker cell clicked via event delegation!');
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('[Debug] showStickerPage type:', typeof showStickerPage);
                        console.log('[Debug] window.showStickerPage type:', typeof window.showStickerPage);
                        if (typeof showStickerPage === 'function') {
                            console.log('[Debug] Calling showStickerPage()');
                            showStickerPage();
                        } else if (typeof window.showStickerPage === 'function') {
                            console.log('[Debug] Calling window.showStickerPage()');
                            window.showStickerPage();
                        } else {
                            console.error('[Debug] showStickerPage function not found, trying direct access');
                            // å°è¯•ç›´æ¥è°ƒç”¨
                            try {
                                const page = document.getElementById('sticker-page');
                                if (page) {
                                    console.log('[Debug] Found sticker-page element, showing it directly');
                                    page.style.display = 'flex';
                                    if (typeof renderStickerCategories === 'function') {
                                        renderStickerCategories();
                                    }
                                } else {
                                    console.error('[Debug] sticker-page element not found in DOM');
                                }
                            } catch (err) {
                                console.error('[Debug] Error:', err);
                            }
                        }
                    }
                });
                console.log('[Debug] Event delegation listener added to wechat-me-container');
            } else {
                console.error('[Debug] wechat-me-container not found!');
            }
            
            // ä¹Ÿç›´æ¥ç»‘å®šä¸€æ¬¡ä½œä¸ºå¤‡ç”¨
            const stickerCell = container.querySelector('[data-action="showStickerPage"]');
            console.log('[Debug] stickerCell found:', stickerCell);
            if (stickerCell) {
                stickerCell.style.cursor = 'pointer';
                stickerCell.addEventListener('click', function(e) {
                    console.log('[Debug] Sticker cell clicked (direct binding)!');
                    e.preventDefault();
                    e.stopPropagation();
                    if (typeof showStickerPage === 'function') {
                        showStickerPage();
                    } else if (typeof window.showStickerPage === 'function') {
                        window.showStickerPage();
                    }
                });
            }
        }

        // æ‰“å¼€ä¸ªäººèµ„æ–™è®¾ç½®é¡µé¢
        async function openProfileSettings() {
            const myChar = await db.characters.get(parseInt(currentMyCharId));
            if (!myChar) {
                alert('è¯·å…ˆç™»å½•è´¦å·');
                return;
            }
            
            const modal = document.createElement('div');
            modal.id = 'profile-settings-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: #f5f5f5;
                z-index: 10000;
                display: flex;
                flex-direction: column;
            `;
            
            const currentAvatar = myChar.avatar || '';
            const currentNick = myChar.nick || myChar.name || '';
            const realName = myChar.name || '';
            
            modal.innerHTML = `
                <div style="background: #fff; height: 88px; padding-top: 44px; padding-left: 16px; padding-right: 16px; display: flex; align-items: center; border-bottom: 1px solid #e8e8e8; box-sizing: border-box;">
                    <svg onclick="closeProfileSettings()" viewBox="0 0 24 24" style="width: 24px; height: 24px; cursor: pointer; stroke: #333; fill: none; stroke-width: 2;">
                        <polyline points="15 18 9 12 15 6"></polyline>
                    </svg>
                    <span style="flex: 1; text-align: center; font-size: 16px; font-weight: 600; margin-left: -24px;">ä¸ªäººä¿¡æ¯</span>
                </div>
                
                <div style="flex: 1; overflow-y: auto;">
                    <div style="background: #fff; margin-top: 12px;">
                        <div onclick="document.getElementById('profile-avatar-input').click()" style="padding: 14px 16px; border-bottom: 1px solid #f0f0f0; display: flex; align-items: center; justify-content: space-between; cursor: pointer;">
                            <span style="font-size: 15px; color: #333;">å¤´åƒ</span>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <div id="profile-avatar-preview" style="width: 50px; height: 50px; border-radius: 6px; background-image: url(${currentAvatar}); background-size: cover; background-position: center; background-color: #f0f0f0;"></div>
                                <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; stroke: #999; fill: none;">
                                    <polyline points="9 18 15 12 9 6"></polyline>
                                </svg>
                            </div>
                        </div>
                        <input type="file" id="profile-avatar-input" accept="image/*" style="display: none;">
                        
                        <div style="padding: 14px 16px; border-bottom: 1px solid #f0f0f0; display: flex; align-items: center; justify-content: space-between;">
                            <span style="font-size: 15px; color: #333;">æ˜µç§°</span>
                            <input type="text" id="profile-nick-input" value="${currentNick}" placeholder="è¯·è¾“å…¥æ˜µç§°ï¼ˆç½‘åï¼‰" style="flex: 1; max-width: 200px; padding: 6px 12px; border: 1px solid #e8e8e8; border-radius: 6px; font-size: 15px; text-align: right;">
                        </div>
                        
                        <div style="padding: 14px 16px; border-bottom: 1px solid #f0f0f0; display: flex; align-items: center; justify-content: space-between;">
                            <span style="font-size: 15px; color: #333;">çœŸå</span>
                            <span style="font-size: 15px; color: #999;">${realName}</span>
                        </div>
                        
                        <div style="padding: 14px 16px; display: flex; align-items: center; justify-content: space-between;">
                            <span style="font-size: 15px; color: #333;">å¾®ä¿¡å·</span>
                            <span style="font-size: 15px; color: #999;">${myChar.identity?.account || `wxid_${myChar.id}`}</span>
                        </div>
                    </div>
                </div>
                
                <div style="padding: 16px; background: #fff; border-top: 1px solid #e8e8e8;">
                    <button onclick="saveProfileSettings()" style="width: 100%; padding: 14px; background: var(--ins-pink); color: #fff; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer;">
                        ä¿å­˜
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // ç»‘å®šå¤´åƒä¸Šä¼ äº‹ä»¶
            const avatarInput = document.getElementById('profile-avatar-input');
            const avatarPreview = document.getElementById('profile-avatar-preview');
            
            avatarInput.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        avatarPreview.style.backgroundImage = `url(${event.target.result})`;
                        avatarPreview.dataset.newAvatar = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            };
        }
        
        function closeProfileSettings() {
            const modal = document.getElementById('profile-settings-modal');
            if (modal) modal.remove();
        }
        
        async function saveProfileSettings() {
            const myChar = await db.characters.get(parseInt(currentMyCharId));
            if (!myChar) return;
            
            const nickInput = document.getElementById('profile-nick-input');
            const avatarPreview = document.getElementById('profile-avatar-preview');
            
            const newNick = nickInput.value.trim();
            const newAvatar = avatarPreview.dataset.newAvatar;
            
            if (!newNick) {
                alert('æ˜µç§°ä¸èƒ½ä¸ºç©º');
                return;
            }
            
            // åªæ›´æ–°æ˜µç§°ï¼ˆç½‘åï¼‰ï¼Œä¸ä¿®æ”¹çœŸå(name)
            myChar.nick = newNick;
            if (newAvatar) {
                myChar.avatar = newAvatar;
            }
            
            await db.characters.put(myChar);
            
            // åˆ·æ–°ä¸ªäººä¸­å¿ƒé¡µé¢
            closeProfileSettings();
            const meTab = document.querySelector('.wechat-tab-item:nth-child(4)');
            if (meTab && meTab.classList.contains('active')) {
                const container = document.getElementById('wechat-content');
                await renderMePage(container);
            }
            
            // âœ… å¦‚æœå½“å‰æœ‰æ‰“å¼€çš„èŠå¤©çª—å£ï¼Œåˆ·æ–°èŠå¤©ç•Œé¢ä»¥æ›´æ–°å¤´åƒ
            if (currentChatCharId) {
                const chatChar = await db.characters.get(currentChatCharId);
                if (chatChar) {
                    await renderChatBody(chatChar);
                }
            }
            
            showToast('ä¿å­˜æˆåŠŸ');
        }

        // å·²ç™»å½•çš„è§’è‰²è´¦å·åˆ—è¡¨ï¼ˆå­˜å‚¨è§’è‰²IDï¼‰
        let loggedInRoleAccounts = JSON.parse(localStorage.getItem('logged_in_role_accounts') || '[]');
        
        // å½“å‰æ˜¯å¦åœ¨æŸ¥çœ‹è§’è‰²è´¦å·ï¼ˆç”¨äºåŒºåˆ†ç”¨æˆ·è´¦å·å’Œè§’è‰²è´¦å·ï¼‰
        let isViewingRoleAccount = false;
        let currentViewingRoleAccountId = null;
        
        async function showSwitchAccountModal() {
            const modal = document.getElementById('switch-account-modal');
            const list = document.getElementById('account-switch-list');
            list.innerHTML = '';
            
            // æ¸…ç©ºè¾“å…¥æ¡†
            document.getElementById('role-login-account').value = '';
            document.getElementById('role-login-password').value = '';
            document.getElementById('role-login-error').style.display = 'none';
            
            // 1. æ˜¾ç¤ºç”¨æˆ·è´¦å·ï¼ˆæˆ‘çš„è´¦å·ï¼‰
            const users = await db.characters.where('type').equals('user').toArray();
            
            if (users.length > 0) {
                const userTitle = document.createElement('div');
                userTitle.style.cssText = 'font-size:12px; color:#999; padding:8px 12px; background:#f8f8f8;';
                userTitle.textContent = 'æˆ‘çš„è´¦å·';
                list.appendChild(userTitle);
                
                users.forEach(u => {
                    const item = document.createElement('div');
                    item.className = 'account-item';
                    item.onclick = () => performSwitchAccount(u.id);
                    
                    const avatarStyle = u.avatar ? `background-image:url(${u.avatar})` : 'background-color:#eee';
                    const isCurrent = !isViewingRoleAccount && currentMyCharId && parseInt(currentMyCharId) === u.id;
                    
                    item.innerHTML = `
                        <div class="account-avatar" style="${avatarStyle}"></div>
                        <div style="flex:1;">
                            <div style="font-weight:500; color:#333;">${u.nick || u.name}</div>
                            <div style="font-size:12px; color:#999;">${u.identity && u.identity.account ? u.identity.account : 'æ— å¾®ä¿¡å·'}</div>
                        </div>
                        ${isCurrent ? '<div style="color:var(--ins-pink);">âœ“</div>' : ''}
                    `;
                    list.appendChild(item);
                });
            }
            
            // 2. æ˜¾ç¤ºå·²ç™»å½•çš„è§’è‰²è´¦å·
            if (loggedInRoleAccounts.length > 0) {
                const roleTitle = document.createElement('div');
                roleTitle.style.cssText = 'font-size:12px; color:#999; padding:8px 12px; background:#f8f8f8; margin-top:10px;';
                roleTitle.textContent = 'å·²ç™»å½•çš„è§’è‰²è´¦å·ï¼ˆæŸ¥å²—ï¼‰';
                list.appendChild(roleTitle);
                
                for (const roleId of loggedInRoleAccounts) {
                    const role = await db.characters.get(parseInt(roleId));
                    if (!role) continue;
                    
                    const item = document.createElement('div');
                    item.className = 'account-item';
                    item.style.position = 'relative';
                    
                    const avatarStyle = role.avatar ? `background-image:url(${role.avatar})` : 'background-color:#eee';
                    const isCurrent = isViewingRoleAccount && currentViewingRoleAccountId === roleId;
                    
                    item.innerHTML = `
                        <div class="account-avatar" style="${avatarStyle}"></div>
                        <div style="flex:1;" onclick="switchToRoleAccount('${roleId}')">
                            <div style="font-weight:500; color:#333;">${role.name}</div>
                            <div style="font-size:12px; color:#999;">${role.identity && role.identity.account ? role.identity.account : 'æ— å¾®ä¿¡å·'}</div>
                        </div>
                        ${isCurrent ? '<div style="color:var(--ins-pink); margin-right:10px;">âœ“</div>' : ''}
                        <div onclick="event.stopPropagation(); removeRoleAccount('${roleId}')" style="color:#ff3b30; font-size:20px; padding:5px 10px; cursor:pointer;">Ã—</div>
                    `;
                    item.onclick = () => switchToRoleAccount(roleId);
                    list.appendChild(item);
                }
            }
            
            if (users.length === 0 && loggedInRoleAccounts.length === 0) {
                list.innerHTML = '<div style="text-align:center; padding:20px; color:#999;">æš‚æ— è´¦å·</div>';
            }
            
            modal.style.display = 'flex';
        }
        
        // ç§»é™¤å·²ç™»å½•çš„è§’è‰²è´¦å·
        async function removeRoleAccount(roleId) {
            loggedInRoleAccounts = loggedInRoleAccounts.filter(id => id !== roleId);
            localStorage.setItem('logged_in_role_accounts', JSON.stringify(loggedInRoleAccounts));
            
            // å¦‚æœæ­£åœ¨æŸ¥çœ‹è¿™ä¸ªè´¦å·ï¼Œåˆ‡å›ç”¨æˆ·è´¦å·
            if (isViewingRoleAccount && currentViewingRoleAccountId === roleId) {
                isViewingRoleAccount = false;
                currentViewingRoleAccountId = null;
                await switchWechatTab(0);
            }
            
            await showSwitchAccountModal();
        }
        
        // ç™»å½•è§’è‰²è´¦å·
        async function loginRoleAccount() {
            const account = document.getElementById('role-login-account').value.trim();
            const password = document.getElementById('role-login-password').value.trim();
            const errorEl = document.getElementById('role-login-error');
            
            errorEl.style.display = 'none';
            
            if (!account) {
                errorEl.textContent = 'è¯·è¾“å…¥è´¦å·';
                errorEl.style.display = 'block';
                return;
            }
            
            if (!password) {
                errorEl.textContent = 'è¯·è¾“å…¥å¯†ç ';
                errorEl.style.display = 'block';
                return;
            }
            
            // æŸ¥æ‰¾è§’è‰²
            const allChars = await db.characters.toArray();
            const targetChar = allChars.find(c => c.identity && c.identity.account === account);
            
            if (!targetChar) {
                errorEl.textContent = 'è´¦å·ä¸å­˜åœ¨';
                errorEl.style.display = 'block';
                return;
            }
            
            // æ£€æŸ¥æ˜¯ä¸æ˜¯Userç±»å‹ï¼ˆä¸å…è®¸ç™»å½•è‡ªå·±çš„è´¦å·ï¼‰
            if (targetChar.type === 'user') {
                errorEl.textContent = 'è¿™æ˜¯ç”¨æˆ·è´¦å·ï¼Œè¯·ç›´æ¥åˆ‡æ¢';
                errorEl.style.display = 'block';
                return;
            }
            
            // éªŒè¯å¯†ç 
            const correctPassword = targetChar.identity?.password || '';
            if (password !== correctPassword) {
                errorEl.textContent = 'å¯†ç é”™è¯¯';
                errorEl.style.display = 'block';
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦å·²ç™»å½•
            const roleIdStr = String(targetChar.id);
            if (loggedInRoleAccounts.includes(roleIdStr)) {
                errorEl.textContent = 'è¯¥è´¦å·å·²ç™»å½•ï¼Œå¯ç›´æ¥åˆ‡æ¢';
                errorEl.style.display = 'block';
                return;
            }
            
            // ç™»å½•æˆåŠŸï¼Œæ·»åŠ åˆ°åˆ—è¡¨
            loggedInRoleAccounts.push(roleIdStr);
            localStorage.setItem('logged_in_role_accounts', JSON.stringify(loggedInRoleAccounts));
            
            // æ˜¾ç¤ºåŠ è½½æç¤º
            errorEl.style.color = 'var(--ins-pink)';
            errorEl.textContent = 'æ­£åœ¨ç”Ÿæˆè§’è‰²WeChatæ•°æ®...';
            errorEl.style.display = 'block';
            
            // è°ƒç”¨APIç”Ÿæˆè§’è‰²çš„WeChatæ•°æ®
            try {
                await generateRoleWechatData(targetChar);
                
                // æ¸…ç©ºè¾“å…¥æ¡†
                document.getElementById('role-login-account').value = '';
                document.getElementById('role-login-password').value = '';
                errorEl.style.display = 'none';
                errorEl.style.color = '#ff3b30';
                
                // åˆ·æ–°åˆ—è¡¨å¹¶è‡ªåŠ¨åˆ‡æ¢åˆ°è¯¥è´¦å·
                await showSwitchAccountModal();
                await switchToRoleAccount(roleIdStr);
                
                showToast('ç™»å½•æˆåŠŸï¼Œå·²ç”ŸæˆWeChatæ•°æ®');
            } catch (error) {
                console.error('ç”Ÿæˆè§’è‰²WeChatæ•°æ®å¤±è´¥:', error);
                errorEl.style.color = '#ff3b30';
                errorEl.textContent = 'ç”Ÿæˆæ•°æ®å¤±è´¥ï¼š' + error.message;
                errorEl.style.display = 'block';
            }
        }
        
        // åˆ‡æ¢åˆ°è§’è‰²è´¦å·ï¼ˆæŸ¥å²—æ¨¡å¼ï¼‰
        async function switchToRoleAccount(roleId) {
            // ä¿å­˜åŸæ¥çš„ç”¨æˆ·ID
            if (!window.originalMyCharIdBeforeRoleView) {
                window.originalMyCharIdBeforeRoleView = currentMyCharId;
            }
            
            isViewingRoleAccount = true;
            currentViewingRoleAccountId = roleId;
            
            // åˆ‡æ¢åˆ°è§’è‰²è§†è§’
            const roleChar = await db.characters.get(parseInt(roleId));
            if (roleChar) {
                currentMyCharId = roleChar.id;
            }
            
            closeModal('switch-account-modal');
            
            // åˆ‡æ¢åˆ°èŠå¤©åˆ—è¡¨æ ‡ç­¾å¹¶åˆ·æ–°
            await switchWechatTab(0);
        }
        
        // ç”Ÿæˆè§’è‰²çš„WeChatæ•°æ®ï¼ˆè°ƒç”¨AIï¼‰
        async function generateRoleWechatData(roleChar) {
            console.log('[generateRoleWechatData] å¼€å§‹ä¸ºè§’è‰²ç”ŸæˆWeChatæ•°æ®:', roleChar.name);
            
            // è·å–å½“å‰ç”¨æˆ·
            const myChar = window.originalMyCharIdBeforeRoleView ? 
                await db.characters.get(parseInt(window.originalMyCharIdBeforeRoleView)) : 
                (currentMyCharId ? await db.characters.get(parseInt(currentMyCharId)) : null);
            
            // è·å–è§’è‰²å…³è”çš„ä¸–ç•Œä¹¦ï¼ˆè‡ªåŠ¨åŒ…å«å…¨å±€ä¸–ç•Œä¹¦ï¼‰
            let loreContext = "";
            const lorebookIds = roleChar.lorebookIds || (roleChar.lorebookId ? [roleChar.lorebookId] : []);
            loreContext = await getLorebookContext(lorebookIds, roleChar.name);
            
            // è·å–è§’è‰²ä¸ç”¨æˆ·çš„èŠå¤©è®°å½•
            const accountId = myChar ? String(myChar.id) : getCurrentAccountId();
            const chatHistory = getChatHistory(roleChar, accountId);
            const recentChats = chatHistory.slice(-20).map(m => `${m.role === 'user' ? (myChar?.name || 'ç”¨æˆ·') : roleChar.name}: ${m.content}`).join('\n');
            
            // æ„å»ºAIæç¤º - ç”Ÿæˆæ›´å®Œæ•´çš„æ•°æ®ï¼ŒåŒ…æ‹¬èŠå¤©è®°å½•
            const prompt = `ä½ æ˜¯ä¸€ä¸ªæ•°æ®ç”ŸæˆåŠ©æ‰‹ã€‚è¯·æ ¹æ®ä»¥ä¸‹è§’è‰²ä¿¡æ¯ï¼Œç”Ÿæˆè¿™ä¸ªè§’è‰²çš„å¾®ä¿¡æ•°æ®ã€‚

ã€è§’è‰²ä¿¡æ¯ã€‘
åå­—ï¼š${roleChar.name}
${roleChar.nick ? `æ˜µç§°ï¼š${roleChar.nick}` : ''}
ç±»å‹ï¼š${roleChar.type || 'char'}
è®¾å®šï¼š${roleChar.description || 'æ— '}

${roleChar.identity ? `ã€è™šæ‹Ÿèº«ä»½ã€‘
è´¦å·ï¼š${roleChar.identity.account || 'æœªçŸ¥'}
æ‰‹æœºï¼š${roleChar.identity.phone || 'æœªçŸ¥'}
ä½å€ï¼š${roleChar.identity.address || 'æœªçŸ¥'}
ä½™é¢ï¼š${roleChar.identity.balance || 0}
` : ''}

${myChar ? `ã€ä¸ç”¨æˆ·çš„å…³ç³»ã€‘
ç”¨æˆ·åï¼š${myChar.name}
ç”¨æˆ·è®¾å®šï¼š${myChar.description || 'æ— '}
` : ''}

${recentChats ? `ã€ä¸ç”¨æˆ·çš„æœ€è¿‘èŠå¤©è®°å½•ï¼ˆçœŸå®ï¼‰ã€‘
${recentChats}
` : ''}

${loreContext ? `ã€ä¸–ç•Œè§‚èƒŒæ™¯ã€‘
${loreContext}
` : ''}

è¯·ç”Ÿæˆä»¥ä¸‹JSONæ•°æ®ï¼ˆä¸¥æ ¼æŒ‰ç…§æ ¼å¼è¿”å›ï¼Œä¸è¦åŒ…å«markdownä»£ç å—ï¼‰ï¼š
{
    "friends": [
        {
            "id": "friend_1",
            "name": "å¥½å‹åå­—",
            "remark": "å¤‡æ³¨ï¼ˆå¯é€‰ï¼Œæ²¡æœ‰å°±ç•™ç©ºï¼‰",
            "relation": "å…³ç³»æè¿°ï¼ˆå¦‚ï¼šåŒäº‹ã€æœ‹å‹ã€å®¶äººç­‰ï¼‰",
            "avatar": "",
            "lastMessage": "æœ€åä¸€æ¡æ¶ˆæ¯å†…å®¹",
            "lastMessageTime": "åˆšåˆš/5åˆ†é’Ÿå‰/1å°æ—¶å‰/æ˜¨å¤©ç­‰",
            "unread": 0,
            "chatHistory": [
                {"role": "friend", "content": "æ¶ˆæ¯å†…å®¹", "time": "10:30"},
                {"role": "me", "content": "æ¶ˆæ¯å†…å®¹", "time": "10:32"}
            ]
        }
    ],
    "moments": [
        {
            "author": "å‘å¸ƒè€…åå­—",
            "content": "æœ‹å‹åœˆå†…å®¹",
            "timeAgo": "2å°æ—¶å‰/æ˜¨å¤©/3å¤©å‰ç­‰",
            "likes": ["ç‚¹èµäºº1", "ç‚¹èµäºº2"],
            "comments": [{"name": "è¯„è®ºäºº", "content": "è¯„è®ºå†…å®¹"}]
        }
    ],
    "balance": "ä½™é¢æ•°å­—"
}

ç”Ÿæˆè¦æ±‚ï¼š
1. friendsï¼šç”Ÿæˆ4-8ä¸ªå¥½å‹ï¼Œæ ¹æ®è§’è‰²è®¾å®šå’Œä¸–ç•Œè§‚ç”Ÿæˆåˆé€‚çš„å¥½å‹
   - å¦‚æœæœ‰ä¸ç”¨æˆ·çš„èŠå¤©è®°å½•ï¼Œç”¨æˆ·ï¼ˆ${myChar?.name || 'ç”¨æˆ·'}ï¼‰å¿…é¡»åœ¨å¥½å‹åˆ—è¡¨ä¸­ï¼Œä¸”èŠå¤©è®°å½•è¦åŸºäºçœŸå®è®°å½•
   - æ¯ä¸ªå¥½å‹è¦ç”Ÿæˆ5-15æ¡èŠå¤©è®°å½•ï¼ˆchatHistoryï¼‰ï¼Œä½“ç°ä»–ä»¬çš„å…³ç³»
   - chatHistoryä¸­ roleä¸º"friend"è¡¨ç¤ºå¥½å‹å‘çš„ï¼Œ"me"è¡¨ç¤ºè§’è‰²ï¼ˆ${roleChar.name}ï¼‰å‘çš„
2. momentsï¼šç”Ÿæˆ3-6æ¡æœ‹å‹åœˆï¼Œå¯ä»¥æ˜¯è§’è‰²è‡ªå·±å‘çš„ï¼Œä¹Ÿå¯ä»¥æ˜¯å¥½å‹å‘çš„
   - è¦æœ‰ç‚¹èµå’Œè¯„è®ºï¼Œä½“ç°ç¤¾äº¤äº’åŠ¨
3. balanceï¼šç”Ÿæˆä¸€ä¸ªåˆç†çš„ä½™é¢æ•°å­—
4. æ‰€æœ‰å†…å®¹è¦ç¬¦åˆè§’è‰²çš„æ€§æ ¼ã€èº«ä»½å’Œä¸–ç•Œè§‚è®¾å®š
5. èŠå¤©å†…å®¹è¦è‡ªç„¶ã€ç”ŸåŠ¨ï¼Œä½“ç°äººç‰©å…³ç³»`;

            // è°ƒç”¨AI
            const result = await callAI([
                { role: 'system', content: 'ä½ æ˜¯ä¸€ä¸ªJSONæ•°æ®ç”ŸæˆåŠ©æ‰‹ï¼Œåªè¿”å›çº¯JSONæ ¼å¼ï¼Œä¸è¦åŒ…å«ä»»ä½•markdownæ ‡è®°æˆ–å…¶ä»–æ–‡å­—ã€‚' },
                { role: 'user', content: prompt }
            ], 0.7);
            
            console.log('[generateRoleWechatData] AIè¿”å›:', result);
            
            // è§£æç»“æœ
            let wechatData;
            try {
                // å°è¯•æ¸…ç†å¯èƒ½çš„markdownæ ‡è®°
                let cleanResult = result.trim();
                if (cleanResult.startsWith('```')) {
                    cleanResult = cleanResult.replace(/```json?\n?/g, '').replace(/```$/g, '').trim();
                }
                wechatData = JSON.parse(cleanResult);
            } catch (e) {
                console.error('[generateRoleWechatData] è§£æJSONå¤±è´¥:', e);
                // ä½¿ç”¨é»˜è®¤æ•°æ®
                wechatData = {
                    friends: [{ name: myChar?.name || 'ç”¨æˆ·', remark: '', relation: 'å¥½å‹', lastMessage: '...', lastMessageTime: 'åˆšåˆš', unread: 0 }],
                    moments: [{ content: 'ä»Šå¤©å¤©æ°”ä¸é”™', timeAgo: '1å°æ—¶å‰', likes: 5, comments: 1 }],
                    balance: roleChar.identity?.balance || '100.00'
                };
            }
            
            // ä¿å­˜åˆ°è§’è‰²æ•°æ®ä¸­
            roleChar.generated_wechat_data = {
                ...wechatData,
                generatedAt: Date.now()
            };
            await db.characters.put(roleChar);
            
            console.log('[generateRoleWechatData] æ•°æ®å·²ä¿å­˜:', wechatData);
            return wechatData;
        }
        
        // æ¸²æŸ“è§’è‰²è´¦å·çš„èŠå¤©åˆ—è¡¨ï¼ˆæŸ¥å²—æ¨¡å¼ï¼‰- ä½¿ç”¨AIç”Ÿæˆçš„æ•°æ®
        async function renderRoleAccountWechatList(container) {
            const roleChar = await db.characters.get(parseInt(currentViewingRoleAccountId));
            if (!roleChar) {
                container.innerHTML = '<div class="wechat-empty-state"><div>æš‚æ— æ•°æ®</div></div>';
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰AIç”Ÿæˆçš„æ•°æ®
            const wechatData = roleChar.generated_wechat_data;
            if (!wechatData || !wechatData.friends || wechatData.friends.length === 0) {
                container.innerHTML = `
                    <div class="wechat-empty-state">
                        <svg class="svg-icon" style="width:48px; height:48px; stroke:#ccc;" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><line x1="8" y1="15" x2="16" y2="15"></line><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line></svg>
                        <div>æš‚æ— å¥½å‹æ•°æ®</div>
                        <div style="font-size:12px; color:#999; margin-top:10px;">è¯·é‡æ–°ç™»å½•ç”Ÿæˆæ•°æ®</div>
                    </div>
                `;
                return;
            }

            const friends = wechatData.friends;

            container.innerHTML = '';
            const listDiv = document.createElement('div');
            listDiv.style.width = '100%';
            listDiv.style.background = '#fff';
            listDiv.style.overflowX = 'hidden';
            
            // æ·»åŠ æŸ¥å²—æ¨¡å¼æç¤º
            const tipDiv = document.createElement('div');
            tipDiv.style.cssText = 'padding:10px 16px; background:#FFF5F7; color:#FF6B9D; font-size:12px; border-bottom:1px solid #f0f0f0;';
            tipDiv.innerHTML = `ğŸ” æ­£åœ¨æŸ¥çœ‹ <b>${roleChar.name}</b> çš„å¾®ä¿¡ï¼ˆæŸ¥å²—æ¨¡å¼ï¼‰<span style="float:right; cursor:pointer;" onclick="refreshRoleWechatData()">ğŸ”„ åˆ·æ–°</span>`;
            listDiv.appendChild(tipDiv);

            friends.forEach((f, index) => {
                // å®¹å™¨
                const itemContainer = document.createElement('div');
                itemContainer.className = 'wechat-list-item-container';
                
                // å†…å®¹åŒºåŸŸ
                const contentDiv = document.createElement('div');
                contentDiv.className = 'wechat-list-item-content';
                
                contentDiv.style.display = 'flex';
                contentDiv.style.padding = '12px 16px';
                contentDiv.style.borderBottom = '0.5px solid #f0f0f0';
                contentDiv.style.alignItems = 'center';
                contentDiv.style.gap = '12px';
                contentDiv.style.backgroundColor = '#fff';
                contentDiv.style.cursor = 'pointer';

                // ç‚¹å‡»è¿›å…¥èŠå¤©ï¼ˆæŸ¥å²—æ¨¡å¼ï¼‰
                contentDiv.onclick = () => {
                    openRoleAccountChat(index);
                };

                // ç”Ÿæˆå¤´åƒï¼ˆä½¿ç”¨åå­—é¦–å­—æ¯ï¼‰
                const avatarChar = (f.name || '?').charAt(0);
                const avatarColors = ['#FF6B9D', '#FF9F43', '#54A0FF', '#5F27CD', '#00D2D3', '#10AC84'];
                const avatarColor = avatarColors[index % avatarColors.length];
                
                const lastMsg = f.lastMessage || '';
                const lastTimeStr = f.lastMessageTime || '';
                const unread = f.unread || 0;

                contentDiv.innerHTML = `
                    <div style="width:48px; height:48px; border-radius:6px; background:${avatarColor}; background-size:cover; background-position:center; flex-shrink:0; display:flex; align-items:center; justify-content:center; color:#fff; font-size:20px; font-weight:600;">${avatarChar}</div>
                    <div style="flex:1; min-width:0;">
                        <div style="display:flex; justify-content:space-between; margin-bottom:4px; align-items:center;">
                            <div style="display:flex; align-items:center;">
                                <div style="font-size:16px; font-weight:500; color:#333;">${f.remark || f.wx_nickname || f.name}</div>
                            </div>
                            <div style="font-size:12px; color:#999;">${lastTimeStr}</div>
                        </div>
                        <div style="font-size:14px; color:#999; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${lastMsg}</div>
                    </div>
                    ${unread > 0 ? `<div style="background:#ff3b30; color:#fff; font-size:12px; padding:2px 6px; border-radius:10px; min-width:18px; text-align:center;">${unread}</div>` : ''}
                `;

                itemContainer.appendChild(contentDiv);
                listDiv.appendChild(itemContainer);
            });
            container.appendChild(listDiv);
        }
        
        // åˆ·æ–°è§’è‰²çš„WeChatæ•°æ®
        async function refreshRoleWechatData() {
            const roleChar = await db.characters.get(parseInt(currentViewingRoleAccountId));
            if (!roleChar) return;
            
            showToast('æ­£åœ¨é‡æ–°ç”Ÿæˆæ•°æ®...');
            
            try {
                await generateRoleWechatData(roleChar);
                await switchWechatTab(0);
                showToast('æ•°æ®å·²åˆ·æ–°');
            } catch (error) {
                console.error('åˆ·æ–°æ•°æ®å¤±è´¥:', error);
                showToast('åˆ·æ–°å¤±è´¥ï¼š' + error.message);
            }
        }
        
        // æ‰“å¼€è§’è‰²è´¦å·çš„èŠå¤©çª—å£ï¼ˆæŸ¥å²—æ¨¡å¼ï¼‰- æ˜¾ç¤ºAIç”Ÿæˆçš„èŠå¤©è®°å½•
        async function openRoleAccountChat(friendIndex) {
            const roleChar = await db.characters.get(parseInt(currentViewingRoleAccountId));
            if (!roleChar || !roleChar.generated_wechat_data) return;
            
            const friend = roleChar.generated_wechat_data.friends[friendIndex];
            if (!friend) return;
            
            // ä¿å­˜å½“å‰æŸ¥çœ‹çš„å¥½å‹ç´¢å¼•
            window.currentRoleViewFriendIndex = friendIndex;
            
            // æ˜¾ç¤ºèŠå¤©çª—å£
            const chatWindow = document.getElementById('chat-window');
            const chatTitle = document.getElementById('chat-title');
            const chatBody = document.getElementById('chat-body');
            const chatFooter = document.getElementById('chat-footer');
            
            // æ£€æŸ¥æ˜¯å¦å¼€å¯ä¿®ç½—åœºæ¨¡å¼
            const isShuraMode = !!roleChar.allow_shura_mode;
            
            if (isShuraMode) {
                chatTitle.innerHTML = `${friend.remark || friend.wx_nickname || friend.name} <span style="font-size:12px; color:#FF0000; font-weight:600;">âš ï¸ä¿®ç½—åœºæ¨¡å¼(${roleChar.name}æŸ¥å²—ä¸­)</span>`;
            } else {
                chatTitle.innerHTML = `${friend.remark || friend.wx_nickname || friend.name} <span style="font-size:12px; color:#FF6B9D; font-weight:400;">(${roleChar.name}æŸ¥å²—ä¸­)</span>`;
            }
            chatWindow.style.display = 'flex';
            
            // ä¿®ç½—åœºæ¨¡å¼ï¼šæ˜¾ç¤ºè¾“å…¥æ¡†å’Œæ“ä½œæŒ‰é’®ï¼›å¦åˆ™éšè—
            if (isShuraMode) {
                chatFooter.style.display = 'flex';
                // æ·»åŠ ä¿®ç½—åœºæ“ä½œæ 
                addShuraOperationBar(chatBody, roleChar, friend, friendIndex);
            } else {
                chatFooter.style.display = 'none';
            }
            
            // æ¸²æŸ“AIç”Ÿæˆçš„èŠå¤©è®°å½•
            renderRoleAccountChatBody(chatBody, roleChar, friend);
        }
        
        // æ·»åŠ ä¿®ç½—åœºæ“ä½œæ 
        function addShuraOperationBar(container, roleChar, friend, friendIndex) {
            // ç§»é™¤æ—§çš„æ“ä½œæ ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            const oldBar = container.parentElement.querySelector('.shura-operation-bar');
            if (oldBar) oldBar.remove();
            
            // åˆ›å»ºæ“ä½œæ 
            const operationBar = document.createElement('div');
            operationBar.className = 'shura-operation-bar';
            operationBar.style.cssText = 'position:absolute; top:45px; left:0; right:0; background:#FFF0F0; border-bottom:2px solid #FF6B9D; padding:8px 16px; display:flex; gap:8px; align-items:center; z-index:10; box-shadow:0 2px 8px rgba(255,107,157,0.1);';
            
            operationBar.innerHTML = `
                <div style="flex:1; font-size:12px; color:#FF0000; font-weight:600;">âš ï¸ ä¿®ç½—åœºæ¨¡å¼ï¼šå¯ä»¥æ“ä½œç”¨æˆ·è´¦å·</div>
                <button onclick="deleteShuraFriend(${friendIndex})" style="padding:6px 12px; background:#FF3B30; color:#fff; border:none; border-radius:6px; font-size:12px; cursor:pointer; font-weight:600;">åˆ é™¤å¥½å‹</button>
                <button onclick="blacklistShuraFriend(${friendIndex})" style="padding:6px 12px; background:#333; color:#fff; border:none; border-radius:6px; font-size:12px; cursor:pointer; font-weight:600;">æ‹‰é»‘</button>
            `;
            
            // æ’å…¥åˆ°èŠå¤©çª—å£çš„headerä¹‹å
            const chatWindow = container.parentElement;
            const header = chatWindow.querySelector('.wechat-header');
            if (header && header.nextSibling) {
                chatWindow.insertBefore(operationBar, header.nextSibling);
            }
            
            // è°ƒæ•´èŠå¤©å†…å®¹åŒºåŸŸçš„ä½ç½®ï¼ˆç»™æ“ä½œæ ç•™å‡ºç©ºé—´ï¼‰
            container.style.paddingTop = '60px';
        }
        
        // åˆ é™¤å¥½å‹ï¼ˆä¿®ç½—åœºæ¨¡å¼ï¼‰
        async function deleteShuraFriend(friendIndex) {
            const roleChar = await db.characters.get(parseInt(currentViewingRoleAccountId));
            if (!roleChar || !roleChar.generated_wechat_data) return;
            
            const friend = roleChar.generated_wechat_data.friends[friendIndex];
            if (!friend) return;
            
            if (!confirm(`ç¡®å®šè¦ä»¥ç”¨æˆ·çš„åä¹‰åˆ é™¤å¥½å‹"${friend.remark || friend.wx_nickname || friend.name}"å—ï¼Ÿ\n\nè¿™ä¸ªæ“ä½œä¼šè¢«è®°å½•åˆ°è§’è‰²çš„æŸ¥å²—è®°å½•ä¸­ã€‚`)) {
                return;
            }
            
            // è®°å½•æ“ä½œ
            const operationLog = {
                type: 'delete_friend',
                friendName: friend.remark || friend.wx_nickname || friend.name,
                friendId: friend.id,
                timestamp: new Date().toLocaleString(),
                operator: roleChar.name
            };
            
            // ä¿å­˜æ“ä½œè®°å½•åˆ°è§’è‰²æ•°æ®ä¸­
            if (!roleChar.shura_operations) {
                roleChar.shura_operations = [];
            }
            roleChar.shura_operations.push(operationLog);
            
            // ä»å¥½å‹åˆ—è¡¨ä¸­åˆ é™¤
            roleChar.generated_wechat_data.friends.splice(friendIndex, 1);
            
            await db.characters.put(roleChar);
            
            showToast(`å·²åˆ é™¤å¥½å‹"${friend.remark || friend.wx_nickname || friend.name}"`);
            
            // è¿”å›åˆ°å¾®ä¿¡åˆ—è¡¨
            closeChatWindow();
            await switchWechatTab(0);
        }
        
        // æ‹‰é»‘å¥½å‹ï¼ˆä¿®ç½—åœºæ¨¡å¼ï¼‰
        async function blacklistShuraFriend(friendIndex) {
            const roleChar = await db.characters.get(parseInt(currentViewingRoleAccountId));
            if (!roleChar || !roleChar.generated_wechat_data) return;
            
            const friend = roleChar.generated_wechat_data.friends[friendIndex];
            if (!friend) return;
            
            if (!confirm(`ç¡®å®šè¦ä»¥ç”¨æˆ·çš„åä¹‰æ‹‰é»‘"${friend.remark || friend.wx_nickname || friend.name}"å—ï¼Ÿ\n\nè¿™ä¸ªæ“ä½œä¼šè¢«è®°å½•åˆ°è§’è‰²çš„æŸ¥å²—è®°å½•ä¸­ã€‚`)) {
                return;
            }
            
            // è®°å½•æ“ä½œ
            const operationLog = {
                type: 'blacklist_friend',
                friendName: friend.remark || friend.wx_nickname || friend.name,
                friendId: friend.id,
                timestamp: new Date().toLocaleString(),
                operator: roleChar.name
            };
            
            // ä¿å­˜æ“ä½œè®°å½•åˆ°è§’è‰²æ•°æ®ä¸­
            if (!roleChar.shura_operations) {
                roleChar.shura_operations = [];
            }
            roleChar.shura_operations.push(operationLog);
            
            // æ ‡è®°ä¸ºå·²æ‹‰é»‘
            friend.blacklisted = true;
            friend.blacklistedAt = new Date().toLocaleString();
            
            await db.characters.put(roleChar);
            
            showToast(`å·²æ‹‰é»‘"${friend.remark || friend.wx_nickname || friend.name}"`);
            
            // åˆ·æ–°èŠå¤©çª—å£
            openRoleAccountChat(friendIndex);
        }
        
        // å‘é€ä¿®ç½—åœºæ¶ˆæ¯ï¼ˆè§’è‰²ä»¥ç”¨æˆ·èº«ä»½å‘é€ï¼‰
        async function sendShuraMessage() {
            const roleChar = await db.characters.get(parseInt(currentViewingRoleAccountId));
            if (!roleChar || !roleChar.generated_wechat_data) return;
            
            const friendIndex = window.currentRoleViewFriendIndex;
            if (friendIndex === undefined) return;
            
            const friend = roleChar.generated_wechat_data.friends[friendIndex];
            if (!friend) return;
            
            const input = document.getElementById('chat-input-box');
            const message = input.value.trim();
            if (!message) return;
            
            // æ·»åŠ æ¶ˆæ¯åˆ°èŠå¤©è®°å½•ï¼ˆä»¥ç”¨æˆ·èº«ä»½ï¼‰
            if (!friend.chatHistory) {
                friend.chatHistory = [];
            }
            
            const newMessage = {
                sender: 'user', // ç”¨æˆ·å‘é€çš„
                message: message,
                timestamp: new Date().toLocaleString()
            };
            
            friend.chatHistory.push(newMessage);
            
            // è®°å½•æ“ä½œ
            const operationLog = {
                type: 'send_message',
                friendName: friend.remark || friend.wx_nickname || friend.name,
                friendId: friend.id,
                message: message,
                timestamp: new Date().toLocaleString(),
                operator: roleChar.name
            };
            
            if (!roleChar.shura_operations) {
                roleChar.shura_operations = [];
            }
            roleChar.shura_operations.push(operationLog);
            
            // æ›´æ–°æœ€åä¸€æ¡æ¶ˆæ¯
            friend.lastMessage = message;
            friend.lastMessageTime = new Date().toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
            
            await db.characters.put(roleChar);
            
            // æ¸…ç©ºè¾“å…¥æ¡†
            input.value = '';
            
            // åˆ·æ–°èŠå¤©çª—å£
            const chatBody = document.getElementById('chat-body');
            renderRoleAccountChatBody(chatBody, roleChar, friend);
        }
        
        // å°†ä¿®ç½—åœºå‡½æ•°æš´éœ²åˆ°å…¨å±€ä½œç”¨åŸŸ
        window.deleteShuraFriend = deleteShuraFriend;
        window.blacklistShuraFriend = blacklistShuraFriend;
        window.sendShuraMessage = sendShuraMessage;
        
        // æ¸²æŸ“è§’è‰²è´¦å·çš„èŠå¤©è®°å½•ï¼ˆAIç”Ÿæˆçš„ï¼‰- ä½¿ç”¨å’Œæ­£å¸¸èŠå¤©ä¸€æ ·çš„æ ·å¼
        function renderRoleAccountChatBody(container, roleChar, friend) {
            const chatHistory = friend.chatHistory || [];
            
            // è§’è‰²å¤´åƒ
            const roleAvatarUrl = roleChar.avatar || '';
            
            // å¥½å‹å¤´åƒé¢œè‰²ï¼ˆç”Ÿæˆä¸€ä¸ªé¢œè‰²ä½œä¸ºé»˜è®¤å¤´åƒï¼‰
            const avatarColors = ['#FF6B9D', '#FF9F43', '#54A0FF', '#5F27CD', '#00D2D3', '#10AC84'];
            const friendAvatarColor = avatarColors[window.currentRoleViewFriendIndex % avatarColors.length];
            const friendAvatarChar = (friend.name || '?').charAt(0);
            
            container.innerHTML = '';
            
            if (chatHistory.length === 0) {
                container.innerHTML = '<div style="text-align:center; padding:40px; color:#999;">æš‚æ— èŠå¤©è®°å½•</div>';
                return;
            }
            
            let lastTimeGroup = '';
            
            chatHistory.forEach((msg, index) => {
                const isMe = msg.role === 'me'; // è§’è‰²å‘çš„
                const time = msg.time || '';
                
                // æ·»åŠ æ—¶é—´æˆ³ï¼ˆå¦‚æœæ—¶é—´å˜åŒ–äº†ï¼‰
                if (time && time !== lastTimeGroup) {
                    const timeStamp = document.createElement('div');
                    timeStamp.className = 'message-timestamp';
                    timeStamp.textContent = time;
                    container.appendChild(timeStamp);
                    lastTimeGroup = time;
                }
                
                // åˆ›å»ºæ¶ˆæ¯è¡Œ - ä½¿ç”¨å’Œæ­£å¸¸èŠå¤©ä¸€æ ·çš„HTMLç»“æ„
                const row = document.createElement('div');
                row.className = `message-row ${isMe ? 'self' : 'other'}`;
                row.dataset.index = index;
                
                // å¤´åƒ
                const avatar = document.createElement('div');
                avatar.className = 'message-avatar';
                
                if (isMe) {
                    // è§’è‰²ï¼ˆ"æˆ‘"ï¼‰çš„å¤´åƒ
                    if (roleAvatarUrl) {
                        avatar.style.backgroundImage = `url(${roleAvatarUrl})`;
                    } else {
                        avatar.style.backgroundColor = '#FF6B9D';
                        avatar.style.display = 'flex';
                        avatar.style.alignItems = 'center';
                        avatar.style.justifyContent = 'center';
                        avatar.style.color = '#fff';
                        avatar.style.fontWeight = '600';
                        avatar.style.fontSize = '14px';
                        avatar.textContent = roleChar.name.charAt(0);
                    }
                } else {
                    // å¥½å‹çš„å¤´åƒ
                    avatar.style.backgroundColor = friendAvatarColor;
                    avatar.style.display = 'flex';
                    avatar.style.alignItems = 'center';
                    avatar.style.justifyContent = 'center';
                    avatar.style.color = '#fff';
                    avatar.style.fontWeight = '600';
                    avatar.style.fontSize = '14px';
                    avatar.textContent = friendAvatarChar;
                }
                
                // å†…å®¹æ°”æ³¡
                const content = document.createElement('div');
                content.className = isMe ? 'message-content user-bubble' : 'message-content ai-bubble';
                content.textContent = msg.content || '';
                
                // ç»„è£…æ¶ˆæ¯è¡Œ
                row.appendChild(avatar);
                row.appendChild(content);
                
                container.appendChild(row);
            });
            
            // æ»šåŠ¨åˆ°åº•éƒ¨
            setTimeout(() => {
                container.scrollTop = container.scrollHeight;
            }, 50);
        }
        
        // æ¸²æŸ“è§’è‰²è´¦å·çš„é€šè®¯å½•ï¼ˆæŸ¥å²—æ¨¡å¼ï¼‰- ä½¿ç”¨AIç”Ÿæˆçš„æ•°æ®
        async function renderRoleAccountContactList(container) {
            const roleChar = await db.characters.get(parseInt(currentViewingRoleAccountId));
            if (!roleChar) {
                container.innerHTML = '<div class="wechat-empty-state"><div>æš‚æ— æ•°æ®</div></div>';
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰AIç”Ÿæˆçš„æ•°æ®
            const wechatData = roleChar.generated_wechat_data;
            if (!wechatData || !wechatData.friends || wechatData.friends.length === 0) {
                container.innerHTML = `
                    <div class="wechat-empty-state">
                        <div>æš‚æ— å¥½å‹æ•°æ®</div>
                    </div>
                `;
                return;
            }
            
            const friends = [...wechatData.friends].sort((a, b) => {
                const nameA = (a.remark || a.wx_nickname || a.name || '').toLowerCase();
                const nameB = (b.remark || b.wx_nickname || b.name || '').toLowerCase();
                return nameA.localeCompare(nameB);
            });
            
            container.innerHTML = '';
            const listDiv = document.createElement('div');
            listDiv.style.width = '100%';
            listDiv.style.background = '#fff';
            
            // æ·»åŠ æŸ¥å²—æ¨¡å¼æç¤º
            const tipDiv = document.createElement('div');
            tipDiv.style.cssText = 'padding:10px 16px; background:#FFF5F7; color:#FF6B9D; font-size:12px; border-bottom:1px solid #f0f0f0;';
            tipDiv.innerHTML = `ğŸ” æ­£åœ¨æŸ¥çœ‹ <b>${roleChar.name}</b> çš„é€šè®¯å½•ï¼ˆ${friends.length}ä½å¥½å‹ï¼‰`;
            listDiv.appendChild(tipDiv);
            
            const avatarColors = ['#FF6B9D', '#FF9F43', '#54A0FF', '#5F27CD', '#00D2D3', '#10AC84'];
            
            friends.forEach((f, index) => {
                // æ‰¾åˆ°åŸå§‹ç´¢å¼•ï¼ˆç”¨äºç‚¹å‡»è¿›å…¥èŠå¤©ï¼‰
                const originalIndex = wechatData.friends.findIndex(fr => fr.id === f.id || fr.name === f.name);
                
                const itemDiv = document.createElement('div');
                itemDiv.style.cssText = 'display:flex; padding:12px 16px; border-bottom:0.5px solid #f0f0f0; align-items:center; gap:12px; background:#fff; cursor:pointer;';
                itemDiv.onclick = () => openRoleAccountChat(originalIndex >= 0 ? originalIndex : index);
                
                const avatarChar = (f.name || '?').charAt(0);
                const avatarColor = avatarColors[index % avatarColors.length];
                
                itemDiv.innerHTML = `
                    <div style="width:48px; height:48px; border-radius:6px; background:${avatarColor}; display:flex; align-items:center; justify-content:center; color:#fff; font-size:20px; font-weight:600;">${avatarChar}</div>
                    <div style="flex:1;">
                        <div style="font-size:16px; font-weight:500; color:#333;">${f.remark || f.wx_nickname || f.name}</div>
                        ${f.relation ? `<div style="font-size:12px; color:#999;">${f.relation}</div>` : ''}
                    </div>
                `;
                
                listDiv.appendChild(itemDiv);
            });
            
            container.appendChild(listDiv);
        }
        
        // æ¸²æŸ“è§’è‰²è´¦å·çš„å‘ç°é¡µï¼ˆæœ‹å‹åœˆï¼ŒæŸ¥å²—æ¨¡å¼ï¼‰
        async function renderRoleAccountDiscoverPage(container) {
            const roleChar = await db.characters.get(parseInt(currentViewingRoleAccountId));
            if (!roleChar) {
                container.innerHTML = '<div class="wechat-empty-state"><div>æš‚æ— æ•°æ®</div></div>';
                return;
            }
            
            // ä½¿ç”¨å’Œæ­£å¸¸å‘ç°é¡µä¸€æ ·çš„å†…å®¹
            const html = `
                <div class="wechat-cell-group" style="margin-top:0;">
                    <div style="padding:10px 16px; background:#FFF5F7; color:#FF6B9D; font-size:12px;">
                        ğŸ” æ­£åœ¨æŸ¥çœ‹ <b>${roleChar.name}</b> çš„å‘ç°
                    </div>
                    <div class="wechat-cell" onclick="showRoleAccountMomentsPage()">
                        <div class="wechat-cell-icon icon-moments">
                            <svg class="svg-icon" style="stroke:currentColor;" viewBox="0 0 24 24"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg>
                        </div>
                        <div class="wechat-cell-text">æœ‹å‹åœˆ</div>
                        <div class="wechat-cell-arrow">â€º</div>
                    </div>
                </div>
            `;
            container.innerHTML = html;
        }
        
        // æ˜¾ç¤ºè§’è‰²è´¦å·çš„æœ‹å‹åœˆé¡µé¢ï¼ˆæŸ¥å²—æ¨¡å¼ï¼‰- ä½¿ç”¨AIç”Ÿæˆçš„æ•°æ®
        async function showRoleAccountMomentsPage() {
            const roleChar = await db.characters.get(parseInt(currentViewingRoleAccountId));
            if (!roleChar) return;
            
            const wechatData = roleChar.generated_wechat_data;
            const moments = wechatData?.moments || [];
            
            // æ˜¾ç¤ºæœ‹å‹åœˆé¡µé¢
            const momentsPage = document.getElementById('moments-page');
            if (!momentsPage) return;
            
            momentsPage.style.display = 'flex';
            
            // ä¿®æ”¹ç”¨æˆ·åå’Œå¤´åƒï¼ˆå°é¢åŒºåŸŸï¼‰
            const userNameEl = document.getElementById('moments-user-name');
            const userAvatarEl = document.getElementById('moments-user-avatar');
            if (userNameEl) {
                userNameEl.innerHTML = `${roleChar.name} <span style="font-size:12px; color:#FF6B9D;">(æŸ¥å²—ä¸­)</span>`;
            }
            if (userAvatarEl && roleChar.avatar) {
                userAvatarEl.style.backgroundImage = `url(${roleChar.avatar})`;
            }
            
            // æ¸²æŸ“AIç”Ÿæˆçš„æœ‹å‹åœˆå†…å®¹åˆ° moments-list
            const momentsList = document.getElementById('moments-list');
            if (momentsList) {
                renderRoleAccountMoments(momentsList, roleChar, moments);
            }
        }
        
        // æ¸²æŸ“è§’è‰²è´¦å·çš„æœ‹å‹åœˆå†…å®¹ - ä½¿ç”¨å’Œæ­£å¸¸æœ‹å‹åœˆä¸€æ ·çš„æ ·å¼
        function renderRoleAccountMoments(container, roleChar, moments) {
            const avatarColors = ['#FF6B9D', '#FF9F43', '#54A0FF', '#5F27CD', '#00D2D3', '#10AC84'];
            
            let html = '';
            
            // æŸ¥å²—æç¤º
            html += `<div style="padding:12px 16px; background:#FFF5F7; color:#FF6B9D; font-size:13px; margin-bottom:10px;">
                ğŸ” æ­£åœ¨æŸ¥çœ‹ <b>${roleChar.name}</b> çš„æœ‹å‹åœˆï¼ˆ${moments.length}æ¡åŠ¨æ€ï¼‰
            </div>`;
            
            if (moments.length === 0) {
                html += '<div style="text-align:center; padding:60px 20px; color:#999;">æš‚æ— æœ‹å‹åœˆåŠ¨æ€</div>';
            } else {
                moments.forEach((m, index) => {
                    const authorName = m.author || roleChar.name;
                    const isRoleMoment = authorName === roleChar.name;
                    const avatarColor = isRoleMoment ? '#FF6B9D' : avatarColors[index % avatarColors.length];
                    const avatarChar = authorName.charAt(0);
                    const avatarStyle = (isRoleMoment && roleChar.avatar) ? 
                        `background-image:url(${roleChar.avatar}); background-size:cover; background-position:center;` : 
                        `background:${avatarColor}; display:flex; align-items:center; justify-content:center; color:#fff; font-size:18px; font-weight:600;`;
                    
                    // ç‚¹èµåˆ—è¡¨
                    const likes = m.likes || [];
                    const likesStr = Array.isArray(likes) ? likes.join('ï¼Œ') : '';
                    
                    // è¯„è®ºåˆ—è¡¨
                    const comments = m.comments || [];
                    let commentsHtml = '';
                    if (comments.length > 0) {
                        commentsHtml = comments.map(c => {
                            return `<div style="font-size:13px; line-height:1.8;"><span style="color:#576B95; font-weight:500;">${c.name || 'åŒ¿å'}</span>ï¼š${c.content || ''}</div>`;
                        }).join('');
                    }
                    
                    html += `
                        <div class="moment-item" style="padding:16px; border-bottom:1px solid #f0f0f0;">
                            <div style="display:flex; align-items:flex-start;">
                                <div style="width:44px; height:44px; border-radius:6px; flex-shrink:0; ${avatarStyle}">${(isRoleMoment && roleChar.avatar) ? '' : avatarChar}</div>
                                <div style="margin-left:12px; flex:1; min-width:0;">
                                    <div style="font-weight:600; font-size:15px; color:#576B95; margin-bottom:6px;">${authorName}</div>
                                    <div style="line-height:1.6; font-size:15px; color:#333; word-break:break-word;">${m.content || ''}</div>
                                    <div style="font-size:12px; color:#999; margin-top:10px;">${m.timeAgo || 'åˆšåˆš'}</div>
                                    ${(likesStr || commentsHtml) ? `
                                    <div style="background:#f5f5f5; padding:8px 10px; border-radius:4px; margin-top:10px;">
                                        ${likesStr ? `<div style="font-size:13px; color:#576B95; ${commentsHtml ? 'margin-bottom:6px; padding-bottom:6px; border-bottom:1px solid #e5e5e5;' : ''}">â¤ï¸ ${likesStr}</div>` : ''}
                                        ${commentsHtml}
                                    </div>
                                    ` : ''}
                                </div>
                            </div>
                        </div>
                    `;
                });
            }
            
            container.innerHTML = html;
        }
        
        // æ¸²æŸ“è§’è‰²è´¦å·çš„"æˆ‘"é¡µé¢ï¼ˆæŸ¥å²—æ¨¡å¼ï¼‰
        async function renderRoleAccountMePage(container) {
            const roleChar = await db.characters.get(parseInt(currentViewingRoleAccountId));
            if (!roleChar) {
                container.innerHTML = '<div class="wechat-empty-state"><div>æš‚æ— æ•°æ®</div></div>';
                return;
            }
            
            const identity = roleChar.identity || {};
            const wechatData = roleChar.generated_wechat_data || {};
            
            // ä¼˜å…ˆä½¿ç”¨AIç”Ÿæˆçš„ä½™é¢ï¼Œå¦åˆ™ä½¿ç”¨è§’è‰²æ¡£æ¡ˆçš„ä½™é¢
            const balance = wechatData.balance || identity.balance || '0.00';
            
            const avatarStyle = roleChar.avatar ? `background-image:url(${roleChar.avatar})` : 'background-color:#eee';
            
            // æ˜¾ç¤ºè§’è‰²æ¡£æ¡ˆçš„æ‰€æœ‰è™šæ‹Ÿèº«ä»½ä¿¡æ¯
            const html = `
                <div style="background:#fff;">
                    <!-- æŸ¥å²—æ¨¡å¼æç¤º -->
                    <div style="padding:10px 16px; background:#FFF5F7; color:#FF6B9D; font-size:12px;">
                        ğŸ” æ­£åœ¨æŸ¥çœ‹ <b>${roleChar.name}</b> çš„ä¸ªäººä¿¡æ¯
                    </div>
                    
                    <!-- ä¸ªäººä¿¡æ¯å¤´éƒ¨ -->
                    <div style="padding:20px; text-align:center; background:linear-gradient(135deg, #FFB6C1 0%, #FFC0CB 100%);">
                        <div style="width:80px; height:80px; border-radius:12px; ${avatarStyle}; background-size:cover; background-position:center; margin:0 auto 10px; border:2px solid rgba(255,255,255,0.3);"></div>
                        <div style="font-size:18px; font-weight:600; color:#fff; margin-bottom:5px;">${roleChar.name}</div>
                        ${roleChar.nick ? `<div style="font-size:14px; color:rgba(255,255,255,0.8); margin-bottom:5px;">${roleChar.nick}</div>` : ''}
                        <div style="font-size:14px; color:rgba(255,255,255,0.9);">å¾®ä¿¡å·ï¼š${identity.account || 'æœªè®¾ç½®'}</div>
                    </div>
                    
                    <!-- ä½™é¢ -->
                    <div style="padding:15px 16px; border-bottom:1px solid #f0f0f0;">
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <div style="font-size:16px; font-weight:500;">ğŸ’° é’±åŒ…ä½™é¢</div>
                            <div style="font-size:20px; font-weight:600; color:#FF6B9D;">Â¥${balance}</div>
                        </div>
                    </div>
                    
                    <!-- è™šæ‹Ÿèº«ä»½ä¿¡æ¯ -->
                    <div style="padding:15px 16px; background:#f8f8f8;">
                        <div style="font-size:14px; font-weight:600; color:#666; margin-bottom:10px;">ğŸ” è™šæ‹Ÿèº«ä»½ä¿¡æ¯</div>
                    </div>
                    
                    ${identity.password ? `
                    <div style="padding:15px 16px; border-bottom:1px solid #f0f0f0;">
                        <div style="font-size:14px; color:#666; margin-bottom:5px;">è´¦å·å¯†ç </div>
                        <div style="font-size:16px; font-family:monospace; color:#FF6B9D;">${identity.password}</div>
                    </div>
                    ` : ''}
                    
                    <div style="padding:15px 16px; border-bottom:1px solid #f0f0f0;">
                        <div style="font-size:14px; color:#666; margin-bottom:5px;">ğŸ“± æ‰‹æœºå·</div>
                        <div style="font-size:16px;">${identity.phone || 'æœªè®¾ç½®'}</div>
                    </div>
                    
                    <div style="padding:15px 16px; border-bottom:1px solid #f0f0f0;">
                        <div style="font-size:14px; color:#666; margin-bottom:5px;">ğŸ  ä½å€</div>
                        <div style="font-size:16px;">${identity.address || 'æœªè®¾ç½®'}</div>
                    </div>
                    
                    ${identity.id_card ? `
                    <div style="padding:15px 16px; border-bottom:1px solid #f0f0f0;">
                        <div style="font-size:14px; color:#666; margin-bottom:5px;">ğŸªª èº«ä»½è¯å·</div>
                        <div style="font-size:16px; font-family:monospace;">${identity.id_card}</div>
                    </div>
                    ` : ''}
                    
                    ${identity.bank_card ? `
                    <div style="padding:15px 16px; border-bottom:1px solid #f0f0f0;">
                        <div style="font-size:14px; color:#666; margin-bottom:5px;">ğŸ’³ é“¶è¡Œå¡å·</div>
                        <div style="font-size:16px; font-family:monospace;">${identity.bank_card}</div>
                    </div>
                    ` : ''}
                    
                    ${identity.bank_password ? `
                    <div style="padding:15px 16px; border-bottom:1px solid #f0f0f0;">
                        <div style="font-size:14px; color:#666; margin-bottom:5px;">ğŸ”‘ é“¶è¡Œå¯†ç </div>
                        <div style="font-size:16px; font-family:monospace; color:#FF6B9D;">${identity.bank_password}</div>
                    </div>
                    ` : ''}
                    
                    <!-- é€€å‡ºæŸ¥å²—æŒ‰é’® -->
                    <div style="padding:20px 16px;">
                        <button onclick="exitRoleAccountView()" style="width:100%; padding:14px; background:#FF6B9D; color:#fff; border:none; border-radius:10px; font-size:16px; cursor:pointer; font-weight:600;">é€€å‡ºæŸ¥å²—æ¨¡å¼</button>
                    </div>
                </div>
            `;
            
            container.innerHTML = html;
        }
        
        // é€€å‡ºæŸ¥å²—æ¨¡å¼
        async function exitRoleAccountView() {
            isViewingRoleAccount = false;
            currentViewingRoleAccountId = null;
            
            // æ¢å¤åŸæ¥çš„ç”¨æˆ·ID
            if (window.originalMyCharIdBeforeRoleView) {
                currentMyCharId = window.originalMyCharIdBeforeRoleView;
                window.originalMyCharIdBeforeRoleView = null;
            }
            
            await switchWechatTab(0);
            showToast('å·²é€€å‡ºæŸ¥å²—æ¨¡å¼');
        }

        // ========== è´¦å·éš”ç¦»è¾…åŠ©å‡½æ•° ==========
        // è·å–å½“å‰è´¦å·IDï¼ˆç”¨äºæ•°æ®éš”ç¦»ï¼‰
        function getCurrentAccountId() {
            return currentMyCharId ? String(currentMyCharId) : null;
        }

        // è·å–è§’è‰²çš„å¥½å‹çŠ¶æ€ï¼ˆæŒ‰è´¦å·éš”ç¦»ï¼‰
        function getFriendStatus(char, accountId) {
            if (!accountId) return char.wechat_status || 'stranger';
            if (!char.wechat_status_by_user) {
                // å¦‚æœæ–°ç»“æ„ä¸å­˜åœ¨ï¼Œå°è¯•ä»æ—§ç»“æ„è¿ç§»
                if (char.wechat_status) {
                    if (!char.wechat_status_by_user) char.wechat_status_by_user = {};
                    char.wechat_status_by_user[accountId] = char.wechat_status;
                }
            }
            return char.wechat_status_by_user?.[accountId] || 'stranger';
        }

        // è®¾ç½®è§’è‰²çš„å¥½å‹çŠ¶æ€ï¼ˆæŒ‰è´¦å·éš”ç¦»ï¼‰
        async function setFriendStatus(char, accountId, status) {
            if (!accountId) {
                // å…¼å®¹æ—§ä»£ç ï¼šå¦‚æœæ²¡æœ‰è´¦å·IDï¼Œä½¿ç”¨æ—§ç»“æ„
                char.wechat_status = status;
            } else {
                if (!char.wechat_status_by_user) char.wechat_status_by_user = {};
                char.wechat_status_by_user[accountId] = status;
            }
            await db.characters.put(char);
        }

        // è·å–è§’è‰²çš„èŠå¤©è®°å½•ï¼ˆæŒ‰è´¦å·éš”ç¦»ï¼‰
        function getChatHistory(char, accountId) {
            let history;
            if (!accountId) {
                history = char.chat_history || [];
            } else {
                if (!char.chat_history_by_user) {
                    // å¦‚æœæ–°ç»“æ„ä¸å­˜åœ¨ï¼Œå°è¯•ä»æ—§ç»“æ„è¿ç§»
                    if (char.chat_history && char.chat_history.length > 0) {
                        if (!char.chat_history_by_user) char.chat_history_by_user = {};
                        char.chat_history_by_user[accountId] = [...char.chat_history];
                    }
                }
                history = char.chat_history_by_user?.[accountId] || [];
            }
            // æŒ‰æ—¶é—´æˆ³æ’åºï¼Œç¡®ä¿æ¶ˆæ¯é¡ºåºæ­£ç¡®ï¼ˆä½¿ç”¨ç¨³å®šæ’åºï¼šæ—¶é—´ç›¸åŒæ—¶ä¿æŒåŸå§‹é¡ºåºï¼‰
            return [...history].map((m, i) => ({ _i: i, m }))
                .sort((a, b) => (a.m.time || 0) - (b.m.time || 0) || a._i - b._i)
                .map(x => x.m);
        }

        // è®¾ç½®è§’è‰²çš„èŠå¤©è®°å½•ï¼ˆæŒ‰è´¦å·éš”ç¦»ï¼‰
        async function setChatHistory(char, accountId, history) {
            // âœ… å¦‚æœç”¨æˆ·æ­£åœ¨æŸ¥çœ‹è¿™ä¸ªèŠå¤©ï¼Œè‡ªåŠ¨æ ‡è®°æ–°æ¶ˆæ¯ä¸ºå·²è¯»
            if (currentChatCharId === char.id) {
                history.forEach(m => {
                    if (m.role === 'char' && !m.read) {
                        m.read = true;
                    }
                });
            }
            
            // âœ… å¦‚æœæœ‰æ–°æ¶ˆæ¯ï¼ˆéç©ºå†å²ï¼‰ï¼Œè‡ªåŠ¨æ¸…é™¤èŠå¤©åˆ—è¡¨éšè—æ ‡è®°
            if (history && history.length > 0 && char.chat_hidden_by_user && accountId && char.chat_hidden_by_user[accountId]) {
                char.chat_hidden_by_user[accountId] = false;
            }
            
            if (!accountId) {
                // å…¼å®¹æ—§ä»£ç ï¼šå¦‚æœæ²¡æœ‰è´¦å·IDï¼Œä½¿ç”¨æ—§ç»“æ„
                char.chat_history = history;
            } else {
                if (!char.chat_history_by_user) char.chat_history_by_user = {};
                char.chat_history_by_user[accountId] = history;
            }
            await db.characters.put(char);
        }

        // æ•°æ®è¿ç§»ï¼šå°†æ—§ç»“æ„è¿ç§»åˆ°æ–°ç»“æ„ï¼ˆä¸å½±å“ç°æœ‰æ•°æ®ï¼‰
        async function migrateAccountData() {
            const migrationKey = 'account_isolation_migrated';
            if (localStorage.getItem(migrationKey) === 'true') {
                return; // å·²ç»è¿ç§»è¿‡
            }

            console.log('[Migration] å¼€å§‹è¿ç§»è´¦å·éš”ç¦»æ•°æ®...');
            const allChars = await db.characters.toArray();
            let migratedCount = 0;

            for (const char of allChars) {
                let needSave = false;

                // è¿ç§»å¥½å‹çŠ¶æ€ï¼šå¦‚æœæœ‰æ—§çš„å¥½å‹çŠ¶æ€ï¼Œä¸ºæ‰€æœ‰Userè´¦å·åˆ›å»ºæ˜ å°„
                if (char.wechat_status && !char.wechat_status_by_user) {
                    char.wechat_status_by_user = {};
                    // ä¸ºæ‰€æœ‰Userè´¦å·å¤åˆ¶å½“å‰çŠ¶æ€
                    const allUsers = await db.characters.where('type').equals('user').toArray();
                    for (const user of allUsers) {
                        char.wechat_status_by_user[String(user.id)] = char.wechat_status;
                    }
                    needSave = true;
                }

                // è¿ç§»èŠå¤©è®°å½•ï¼šå¦‚æœæœ‰æ—§çš„èŠå¤©è®°å½•ï¼Œä¸ºæ‰€æœ‰Userè´¦å·åˆ›å»ºæ˜ å°„
                if (char.chat_history && char.chat_history.length > 0 && !char.chat_history_by_user) {
                    char.chat_history_by_user = {};
                    // ä¸ºæ‰€æœ‰Userè´¦å·å¤åˆ¶å½“å‰èŠå¤©è®°å½•
                    const allUsers = await db.characters.where('type').equals('user').toArray();
                    for (const user of allUsers) {
                        char.chat_history_by_user[String(user.id)] = [...char.chat_history];
                    }
                    needSave = true;
                }

                if (needSave) {
                    await db.characters.put(char);
                    migratedCount++;
                }
            }

            localStorage.setItem(migrationKey, 'true');
            console.log(`[Migration] è¿ç§»å®Œæˆï¼Œå…±å¤„ç† ${migratedCount} ä¸ªè§’è‰²`);
        }

        async function performSwitchAccount(id) {
            // é€€å‡ºæŸ¥å²—æ¨¡å¼ï¼ˆå¦‚æœæ­£åœ¨æŸ¥å²—ï¼‰
            if (isViewingRoleAccount) {
                isViewingRoleAccount = false;
                currentViewingRoleAccountId = null;
            }
            
            currentMyCharId = id;
            localStorage.setItem('current_my_char_id', id);
            window.originalMyCharIdBeforeRoleView = null; // æ¸…é™¤ä¿å­˜çš„ID
            
            closeModal('switch-account-modal');
            
            // âœ… æ£€æŸ¥åˆ‡æ¢åˆ°çš„è´¦å·æ˜¯å¦å·²æ³¨å†Œå¾®ä¿¡å·
            const targetUser = await db.characters.get(parseInt(id));
            if (targetUser && (!targetUser.identity || !targetUser.identity.wechat_registered)) {
                // è¯¥è´¦å·æœªæ³¨å†Œå¾®ä¿¡å·ï¼Œæ˜¾ç¤ºæ³¨å†Œé¡µé¢
                console.log('[åˆ‡æ¢è´¦å·] ç›®æ ‡è´¦å·æœªæ³¨å†Œå¾®ä¿¡å·ï¼Œæ˜¾ç¤ºæ³¨å†Œé¡µé¢');
                await showWechatRegisterPageForUser(id);
                return;
            }
            
            // åˆ·æ–°æ‰€æœ‰ç›¸å…³é¡µé¢
            const content = document.getElementById('wechat-content');
            if (content) {
                // æ ¹æ®å½“å‰tabåˆ·æ–°å¯¹åº”å†…å®¹
                const activeTab = document.querySelector('.wechat-tab-item.active');
                if (activeTab) {
                    const tabIndex = Array.from(document.querySelectorAll('.wechat-tab-item')).indexOf(activeTab);
                    switchWechatTab(tabIndex);
                } else {
                    await renderMePage(content);
                }
            }
            
            // åˆ·æ–°é’±åŒ…ä½™é¢æ˜¾ç¤º
            updateWalletBalanceDisplay();
            updateBalancePageDisplay();
        }
        
        // ä¸ºæŒ‡å®šç”¨æˆ·æ˜¾ç¤ºå¾®ä¿¡æ³¨å†Œé¡µé¢
        async function showWechatRegisterPageForUser(userId) {
            const registerPage = document.getElementById('wechat-register-page');
            const userSelect = document.getElementById('register-user-select');
            const phoneInput = document.getElementById('register-phone-input');
            const phoneHint = document.getElementById('register-phone-hint');
            
            // æ¸…ç©ºä¸‹æ‹‰æ¡†å¹¶è®¾ç½®ä¸ºæŒ‡å®šç”¨æˆ·
            const user = await db.characters.get(parseInt(userId));
            if (!user) {
                showToast('ç”¨æˆ·ä¸å­˜åœ¨');
                return;
            }
            
            userSelect.innerHTML = `<option value="${user.id}" selected>${user.name}</option>`;
            
            // âœ… è‡ªåŠ¨å¡«å†™æ‰‹æœºå·ï¼ˆä»æ¡£æ¡ˆä¸­è¯»å–ï¼‰
            if (user.identity && user.identity.phone) {
                selectedUserPhone = user.identity.phone;
                phoneInput.value = selectedUserPhone;
                phoneHint.style.display = 'block';
            } else {
                selectedUserPhone = '';
                phoneInput.value = '';
                phoneHint.style.display = 'none';
            }
            
            // æ¸…ç©ºå…¶ä»–è¾“å…¥æ¡†ï¼ˆéªŒè¯ç ã€å¯†ç ã€å¾®ä¿¡å·ï¼‰
            const codeInput = document.getElementById('register-code-input');
            const passwordInput = document.getElementById('register-password-input');
            const accountInput = document.getElementById('register-account-input');
            if (codeInput) codeInput.value = '';
            if (passwordInput) passwordInput.value = '';
            if (accountInput) accountInput.value = '';
            
            // é‡ç½®éªŒè¯ç çŠ¶æ€
            generatedVerificationCode = '';
            verificationCodeExpiry = 0;
            
            // æ˜¾ç¤ºæ³¨å†Œé¡µé¢
            registerPage.style.display = 'flex';
        }

        // æ¸²æŸ“å¾®ä¿¡èŠå¤©åˆ—è¡¨
        async function renderWechatList(container) {
            // æŸ¥å²—æ¨¡å¼ï¼šæ˜¾ç¤ºè§’è‰²ç”Ÿæˆçš„æ•°æ®
            if (isViewingRoleAccount && currentViewingRoleAccountId) {
                await renderRoleAccountWechatList(container);
                return;
            }
            
            const accountId = getCurrentAccountId();
            // è·å–æ‰€æœ‰è§’è‰²ï¼Œç„¶åæŒ‰è´¦å·è¿‡æ»¤å¥½å‹ï¼ˆåŒ…æ‹¬å·²åˆ é™¤å’Œå·²æ‹‰é»‘çš„ï¼‰
            let allChars = await db.characters.toArray();
            let friends = allChars.filter(c => {
                if (c.type === 'user') return false; // æ’é™¤Userç±»å‹
                // è¿‡æ»¤æ‰è¢«ç”¨æˆ·ä»èŠå¤©åˆ—è¡¨éšè—çš„å¥½å‹
                if (c.chat_hidden_by_user && c.chat_hidden_by_user[accountId]) return false;
                const status = getFriendStatus(c, accountId);
                return status === 'friend' || status === 'deleted' || status === 'blocked' || status === 'deleted_by_char' || status === 'blocked_by_char'; // åŒ…æ‹¬å·²åˆ é™¤å’Œå·²æ‹‰é»‘çš„å¥½å‹ï¼ˆå«è¢«è§’è‰²æ“ä½œçš„ï¼‰
            });
            
            // è·å–ç¾¤èŠåˆ—è¡¨
            let groupChats = [];
            try {
                groupChats = await getGroupChats(accountId);
            } catch (e) {
                console.log('è·å–ç¾¤èŠåˆ—è¡¨å¤±è´¥ï¼Œå¯èƒ½è¡¨ä¸å­˜åœ¨:', e);
            }
            
            // å°†ç¾¤èŠè½¬æ¢ä¸ºç»Ÿä¸€æ ¼å¼ï¼Œæ·»åŠ æ ‡è®°
            const groupItems = groupChats.map(g => ({
                ...g,
                _isGroup: true,
                _groupId: g.id
            }));
            
            // åˆå¹¶å¥½å‹å’Œç¾¤èŠåˆ—è¡¨
            let allItems = [...friends.map(f => ({...f, _isGroup: false})), ...groupItems];
            
            // æ’åºé€»è¾‘ï¼šç½®é¡¶ > æœ€åæ¶ˆæ¯æ—¶é—´ > æ›´æ–°æ—¶é—´
            allItems.sort((a, b) => {
                // 1. ç½®é¡¶åˆ¤æ–­
                if (a.is_pinned && !b.is_pinned) return -1;
                if (!a.is_pinned && b.is_pinned) return 1;
                
                // 2. æ—¶é—´åˆ¤æ–­
                const getLastTime = (item) => {
                    if (item._isGroup) {
                        const history = item.chat_history || [];
                        if (history.length > 0) {
                            return history[history.length - 1].time;
                        }
                        return item.updated_at || item.created_at || 0;
                    } else {
                        const history = getChatHistory(item, accountId);
                        if (history && history.length > 0) {
                            return history[history.length - 1].time;
                        }
                        return item.updated_at || 0;
                    }
                };
                
                const timeA = getLastTime(a);
                const timeB = getLastTime(b);
                
                return timeB - timeA; // é™åº
            });
            
            if (allItems.length === 0) {
                container.innerHTML = `
                    <div class="wechat-empty-state">
                        <svg class="svg-icon" style="width:48px; height:48px; stroke:#ccc;" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><line x1="8" y1="15" x2="16" y2="15"></line><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line></svg>
                        <div>æš‚æ— å¥½å‹</div>
                    </div>
                `;
                return;
            }

            container.innerHTML = '';
            const listDiv = document.createElement('div');
            listDiv.style.width = '100%';
            listDiv.style.background = '#fff';
            listDiv.style.overflowX = 'hidden';

            allItems.forEach(f => {
                // ç¾¤èŠé¡¹æ¸²æŸ“
                if (f._isGroup) {
                    const itemContainer = document.createElement('div');
                    itemContainer.className = 'wechat-list-item-container';
                    
                    const actionsDiv = document.createElement('div');
                    actionsDiv.className = 'wechat-item-actions';
                    actionsDiv.innerHTML = `
                        <button class="wechat-action-btn btn-pin" onclick="toggleGroupPin(${f._groupId}, event)">${f.is_pinned ? 'å–æ¶ˆç½®é¡¶' : 'ç½®é¡¶'}</button>
                        <button class="wechat-action-btn btn-delete" onclick="deleteGroup(${f._groupId}, event)">åˆ é™¤</button>
                    `;
                    
                    const contentDiv = document.createElement('div');
                    contentDiv.className = 'wechat-list-item-content';
                    contentDiv.style.cssText = 'display:flex; padding:12px 16px; border-bottom:0.5px solid #f0f0f0; align-items:center; gap:12px; background-color:' + (f.is_pinned ? '#f8f8f8' : '#fff');
                    
                    contentDiv.onclick = () => openGroupChatWindow(f._groupId);
                    
                    const avatarStyle = f.avatar ? `background-image:url(${f.avatar})` : 'background-color:#eee';
                    
                    let lastMsg = '';
                    let lastTimeStr = '';
                    const history = f.chat_history || [];
                    if (history.length > 0) {
                        // ğŸ”§ ä»åå¾€å‰æ‰¾åˆ°æœ€åä¸€æ¡å¯æ˜¾ç¤ºçš„æ¶ˆæ¯ï¼ˆè·³è¿‡è§†é¢‘é€šè¯å†…å®¹æ¶ˆæ¯ï¼‰
                        let last = null;
                        for (let li = history.length - 1; li >= 0; li--) {
                            if (!history[li].isVideoCall || history[li].role === 'system') {
                                last = history[li];
                                break;
                            }
                        }
                        if (!last) last = history[history.length - 1]; // fallback
                        
                        lastMsg = last.content;
                        if (lastMsg.startsWith('[img:')) lastMsg = '[å›¾ç‰‡]';
                        if (lastMsg.startsWith('[voice:')) lastMsg = '[è¯­éŸ³]';
                        if (lastMsg.startsWith('[imgcard:')) lastMsg = '[å¡ç‰‡]';
                        if (lastMsg.startsWith('[sticker:')) lastMsg = '[è¡¨æƒ…]';
                        // ğŸ”§ å¤„ç†å¤–å–å¡ç‰‡æ¶ˆæ¯
                        if (lastMsg.startsWith('[emei_order]')) lastMsg = '[å¤–å–è®¢å•]';
                        if (lastMsg.startsWith('[emei_share]')) lastMsg = '[å¤–å–åˆ†äº«]';
                        if (lastMsg.startsWith('[payment_request]')) lastMsg = '[ä»£ä»˜è¯·æ±‚]';
                        if (lastMsg.startsWith('[couple_avatar_card]')) lastMsg = '[æƒ…å¤´é‚€è¯·]';
                        if (last.role === 'system') lastMsg = '[ç³»ç»Ÿæ¶ˆæ¯]';
                        // âœ… å¤„ç†ç‰¹æ®Šæ¶ˆæ¯ç±»å‹
                        if (last.type === 'transfer') lastMsg = '[è½¬è´¦]';
                        if (last.type === 'familyCard') lastMsg = '[äº²å±å¡]';
                        if (last.type === 'audio') lastMsg = '[è¯­éŸ³]';
                        if (last.type === 'location') lastMsg = '[ä½ç½®]';
                        
                        const d = new Date(last.time);
                        const now = new Date();
                        if (d.toDateString() === now.toDateString()) {
                            lastTimeStr = `${d.getHours()}:${d.getMinutes().toString().padStart(2,'0')}`;
                        } else {
                            lastTimeStr = `${d.getMonth()+1}/${d.getDate()}`;
                        }
                    }
                    
                    // åˆ¤æ–­æ˜¯å¦æ˜¯è”æœºç¾¤èŠ
                    const isOnlineGroup = f.isOnlineGroup;
                    const groupTag = isOnlineGroup 
                        ? '<span style="background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); color:#fff; font-size:9px; padding:1px 4px; border-radius:2px; margin-left:6px;">è”æœºç¾¤</span>'
                        : '<span style="background:#07c160; color:#fff; font-size:9px; padding:1px 4px; border-radius:2px; margin-left:6px;">ç¾¤</span>';
                    
                    contentDiv.innerHTML = `
                        <div style="width:48px; height:48px; border-radius:6px; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0;"></div>
                        <div style="flex:1; min-width:0;">
                            <div style="display:flex; justify-content:space-between; margin-bottom:4px; align-items:center;">
                                <div style="display:flex; align-items:center;">
                                    <div style="font-size:16px; font-weight:500; color:#333;">${f.name}</div>
                                    ${groupTag}
                                </div>
                                <div style="font-size:12px; color:#999;">${lastTimeStr}</div>
                            </div>
                            <div style="font-size:14px; color:#999; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${lastMsg}</div>
                        </div>
                    `;
                    
                    bindSwipeEvents(contentDiv, itemContainer);
                    itemContainer.appendChild(actionsDiv);
                    itemContainer.appendChild(contentDiv);
                    listDiv.appendChild(itemContainer);
                    return;
                }
                
                // å¥½å‹é¡¹æ¸²æŸ“ï¼ˆåŸæœ‰ä»£ç ï¼‰
                // å®¹å™¨
                const itemContainer = document.createElement('div');
                itemContainer.className = 'wechat-list-item-container';
                
                // èƒŒæ™¯æ“ä½œæŒ‰é’®
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'wechat-item-actions';
                actionsDiv.innerHTML = `
                    <button class="wechat-action-btn btn-pin" onclick="togglePin(${f.id}, event)">${f.is_pinned ? 'å–æ¶ˆç½®é¡¶' : 'ç½®é¡¶'}</button>
                    <button class="wechat-action-btn btn-delete" onclick="deleteFriend(${f.id}, event)">åˆ é™¤</button>
                `;
                
                // å†…å®¹åŒºåŸŸ (å¯æ»‘åŠ¨)
                const contentDiv = document.createElement('div');
                contentDiv.className = 'wechat-list-item-content';
                
                // å†…å®¹æ ·å¼
                contentDiv.style.display = 'flex';
                contentDiv.style.padding = '12px 16px';
                contentDiv.style.borderBottom = '0.5px solid #f0f0f0';
                contentDiv.style.alignItems = 'center';
                contentDiv.style.gap = '12px';
                contentDiv.style.backgroundColor = f.is_pinned ? '#f8f8f8' : '#fff';

                // ç‚¹å‡»è¿›å…¥èŠå¤©
                contentDiv.onclick = (e) => {
                    if (itemContainer.dataset.swiped === 'true') {
                        resetSwipe(contentDiv);
                        itemContainer.dataset.swiped = 'false';
                        return;
                    }
                    openChatWindow(f.id);
                };

                const avatarStyle = f.avatar ? `background-image:url(${f.avatar})` : 'background-color:#eee';
                
                // æ£€æŸ¥å¥½å‹çŠ¶æ€
                const friendStatus = getFriendStatus(f, accountId);
                const isDeleted = friendStatus === 'deleted';
                const isBlocked = friendStatus === 'blocked';
                const isDeletedByChar = friendStatus === 'deleted_by_char';
                const isBlockedByChar = friendStatus === 'blocked_by_char';
                const isAnyInactive = isDeleted || isBlocked || isDeletedByChar || isBlockedByChar;
                
                let lastMsg = '';
                let lastTimeStr = '';
                const history = getChatHistory(f, accountId);
                if (history && history.length > 0) {
                    // ğŸ”§ ä»åå¾€å‰æ‰¾åˆ°æœ€åä¸€æ¡å¯æ˜¾ç¤ºçš„æ¶ˆæ¯ï¼ˆè·³è¿‡è§†é¢‘é€šè¯å†…å®¹æ¶ˆæ¯ï¼‰
                    let last = null;
                    for (let li = history.length - 1; li >= 0; li--) {
                        if (!history[li].isVideoCall || history[li].role === 'system') {
                            last = history[li];
                            break;
                        }
                    }
                    if (!last) last = history[history.length - 1]; // fallback
                    
                    lastMsg = last.content;
                    if (lastMsg.startsWith('[img:')) lastMsg = '[å›¾ç‰‡]';
                    if (lastMsg.startsWith('[voice:')) lastMsg = '[è¯­éŸ³]';
                    if (lastMsg.startsWith('[imgcard:')) lastMsg = '[å¡ç‰‡]';
                    if (lastMsg.startsWith('[sticker:')) lastMsg = '[è¡¨æƒ…]';
                    // ğŸ”§ å¤„ç†å¤–å–å¡ç‰‡æ¶ˆæ¯
                    if (lastMsg.startsWith('[emei_order]')) lastMsg = '[å¤–å–è®¢å•]';
                    if (lastMsg.startsWith('[emei_share]')) lastMsg = '[å¤–å–åˆ†äº«]';
                    if (lastMsg.startsWith('[payment_request]')) lastMsg = '[ä»£ä»˜è¯·æ±‚]';
                    if (lastMsg.startsWith('[couple_avatar_card]')) lastMsg = '[æƒ…å¤´é‚€è¯·]';
                    // âœ… å¤„ç†è½¬è´¦å’Œäº²å±å¡æ¶ˆæ¯
                    if (last.type === 'transfer') lastMsg = '[è½¬è´¦]';
                    if (last.type === 'familyCard') lastMsg = '[äº²å±å¡]';
                    if (last.type === 'audio') lastMsg = '[è¯­éŸ³]';
                    if (last.type === 'location') lastMsg = '[ä½ç½®]';
                    
                    const d = new Date(last.time);
                    const now = new Date();
                    if (d.toDateString() === now.toDateString()) {
                        lastTimeStr = `${d.getHours()}:${d.getMinutes().toString().padStart(2,'0')}`;
                    } else {
                        lastTimeStr = `${d.getMonth()+1}/${d.getDate()}`;
                    }
                }
                
                // æ ¹æ®çŠ¶æ€æ·»åŠ æ ‡è¯†
                let statusBadge = '';
                if (isDeleted) {
                    statusBadge = '<span style="background:#ff9500; color:#fff; font-size:10px; padding:2px 6px; border-radius:3px; margin-left:6px;">å·²åˆ é™¤</span>';
                } else if (isBlocked) {
                    statusBadge = '<span style="background:#ff3b30; color:#fff; font-size:10px; padding:2px 6px; border-radius:3px; margin-left:6px;">å·²æ‹‰é»‘</span>';
                } else if (isDeletedByChar) {
                    statusBadge = '<span style="background:#ff9500; color:#fff; font-size:10px; padding:2px 6px; border-radius:3px; margin-left:6px;">è¢«Taåˆ é™¤</span>';
                } else if (isBlockedByChar) {
                    statusBadge = '<span style="background:#ff3b30; color:#fff; font-size:10px; padding:2px 6px; border-radius:3px; margin-left:6px;">è¢«Taæ‹‰é»‘</span>';
                }
                const textColor = isAnyInactive ? '#999' : '#333';

                const displayName = f.remark || f.wx_nickname || f.name;
                contentDiv.innerHTML = `
                    <div style="width:48px; height:48px; border-radius:6px; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; ${isAnyInactive ? 'opacity:0.6;' : ''}"></div>
                    <div style="flex:1; min-width:0;">
                        <div style="display:flex; justify-content:space-between; margin-bottom:4px; align-items:center;">
                            <div style="display:flex; align-items:center;">
                                <div style="font-size:16px; font-weight:500; color:${textColor};">${displayName}</div>
                                ${statusBadge}
                            </div>
                            <div style="font-size:12px; color:#999;">${lastTimeStr}</div>
                        </div>
                        <div style="font-size:14px; color:#999; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${lastMsg}</div>
                    </div>
                `;

                bindSwipeEvents(contentDiv, itemContainer);

                itemContainer.appendChild(actionsDiv);
                itemContainer.appendChild(contentDiv);
                listDiv.appendChild(itemContainer);
            });
            container.appendChild(listDiv);
        }

        // æ»‘åŠ¨äº‹ä»¶ç»‘å®š
        function bindSwipeEvents(element, container) {
            let startX = 0;
            let currentX = 0;
            let isSwiping = false;
            const threshold = 30; // è§¦å‘é˜ˆå€¼
            const maxSwipe = 160; // ä¸¤ä¸ªæŒ‰é’®å®½åº¦

            element.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                // å¤ä½å…¶ä»–é¡¹
                document.querySelectorAll('.wechat-list-item-content').forEach(el => {
                    if (el !== element && el.style.transform && el.style.transform !== 'translateX(0px)') {
                        el.style.transform = 'translateX(0px)';
                        el.parentElement.dataset.swiped = 'false';
                    }
                });
            }, {passive: true});

            element.addEventListener('touchmove', (e) => {
                currentX = e.touches[0].clientX;
                let diff = currentX - startX;
                
                if (diff < 0) {
                    if (Math.abs(diff) > 10) isSwiping = true;
                    let move = diff;
                    if (Math.abs(move) > maxSwipe) {
                        move = -maxSwipe - (Math.abs(move) - maxSwipe) * 0.2;
                    }
                    element.style.transform = `translateX(${move}px)`;
                } else if (container.dataset.swiped === 'true') {
                    let move = -maxSwipe + diff;
                    if (move > 0) move = 0;
                    element.style.transform = `translateX(${move}px)`;
                }
            }, {passive: true});

            element.addEventListener('touchend', (e) => {
                if (!isSwiping && container.dataset.swiped !== 'true') return;
                
                const diff = currentX - startX;
                if (diff < -threshold || (container.dataset.swiped === 'true' && diff < threshold && diff > -threshold)) {
                    element.style.transform = `translateX(-${maxSwipe}px)`;
                    container.dataset.swiped = 'true';
                } else {
                    element.style.transform = 'translateX(0px)';
                    container.dataset.swiped = 'false';
                }
                isSwiping = false;
            });
        }

        function resetSwipe(element) {
            element.style.transform = 'translateX(0px)';
        }

        async function togglePin(id, e) {
            e.stopPropagation();
            const char = await db.characters.get(id);
            if (char) {
                char.is_pinned = !char.is_pinned;
                await db.characters.put(char);
                renderWechatList(document.getElementById('wechat-content'));
            }
        }
        
        // ç¾¤èŠç½®é¡¶åˆ‡æ¢
        async function toggleGroupPin(groupId, e) {
            e.stopPropagation();
            const group = await db.group_chats.get(groupId);
            if (group) {
                group.is_pinned = !group.is_pinned;
                await db.group_chats.put(group);
                renderWechatList(document.getElementById('wechat-content'));
            }
        }
        
        // åˆ é™¤ç¾¤èŠ
        async function deleteGroup(groupId, e) {
            e.stopPropagation();
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªç¾¤èŠå—ï¼Ÿ\n(èŠå¤©è®°å½•å°†è¢«æ¸…é™¤)')) {
                await db.group_chats.delete(groupId);
                renderWechatList(document.getElementById('wechat-content'));
            }
        }

        async function deleteFriend(id, e) {
            e.stopPropagation();
            if (confirm('ç¡®å®šè¦åˆ é™¤è¯¥å¥½å‹å—ï¼Ÿ\n(èŠå¤©è®°å½•å°†è¢«æ¸…ç©ºï¼Œå¥½å‹å°†ä»èŠå¤©åˆ—è¡¨å’Œé€šè®¯å½•ä¸­ç§»é™¤)')) {
                const char = await db.characters.get(id);
                if (char) {
                    const accountId = getCurrentAccountId();
                    
                    // æ¸…ç©ºèŠå¤©è®°å½•
                    await setChatHistory(char, accountId, []);
                    
                    // å°†å¥½å‹çŠ¶æ€æ”¹ä¸ºå·²åˆ é™¤ï¼ˆä»é€šè®¯å½•å’ŒèŠå¤©åˆ—è¡¨ä¸­ç§»é™¤ï¼‰
                    await setFriendStatus(char, accountId, 'deleted');
                    
                    // è®¾ç½®éšè—æ ‡è®°ï¼ˆé˜²æ­¢èŠå¤©åˆ—è¡¨ä»æ˜¾ç¤ºï¼‰
                    if (!char.chat_hidden_by_user) char.chat_hidden_by_user = {};
                    char.chat_hidden_by_user[accountId] = true;
                    char.is_pinned = false;
                    
                    // åˆå§‹åŒ–ç­‰å¾…å¥½å‹ç”³è¯·çš„è®¾ç½®
                    if (!char.wait_friend_settings) {
                        char.wait_friend_settings = {};
                    }
                    if (!char.wait_friend_settings[accountId]) {
                        char.wait_friend_settings[accountId] = {
                            enabled: false,
                            interval: 60,
                            lastCheckTime: Date.now(),
                            nextCheckTime: null
                        };
                    }
                    await db.characters.put(char);
                    
                    // å¦‚æœå½“å‰æ­£åœ¨å’Œè¿™ä¸ªå¥½å‹èŠå¤©ï¼Œå…³é—­èŠå¤©çª—å£
                    if (currentChatCharId === id) {
                        document.getElementById('chat-window').style.display = 'none';
                        currentChatCharId = null;
                    }
                    
                    renderWechatList(document.getElementById('wechat-content'));
                    showToast('å·²åˆ é™¤å¥½å‹');
                }
            }
        }

        // æ¸²æŸ“é€šè®¯å½•åˆ—è¡¨
        async function renderContactList(container) {
            const accountId = getCurrentAccountId();
            // è·å–æ‰€æœ‰è§’è‰²ï¼Œç„¶åæŒ‰è´¦å·è¿‡æ»¤å¥½å‹
            let allChars = await db.characters.toArray();
            const friends = allChars.filter(c => {
                if (c.type === 'user') return false; // æ’é™¤Userç±»å‹
                const status = getFriendStatus(c, accountId);
                return status === 'friend';
            });
            
            container.innerHTML = '';
            const listDiv = document.createElement('div');
            listDiv.style.width = '100%';
            listDiv.style.background = '#fff';
            
            // æ·»åŠ "æ–°çš„å¥½å‹"å…¥å£ï¼ˆåŒæ—¶æ£€æŸ¥ toCharId å’Œ toAccountIdï¼‰
            const allRequests = await db.friend_requests.toArray();
            const pendingRequests = allRequests.filter(req => 
                req.status === 'pending' && 
                (req.toCharId === parseInt(accountId) || req.toAccountId === accountId)
            );
            const newFriendItem = document.createElement('div');
            newFriendItem.style.display = 'flex';
            newFriendItem.style.padding = '12px 16px';
            newFriendItem.style.borderBottom = '0.5px solid #f0f0f0';
            newFriendItem.style.alignItems = 'center';
            newFriendItem.style.gap = '12px';
            newFriendItem.style.cursor = 'pointer';
            newFriendItem.onclick = () => showNewFriendsPage();
            
            const badgeHtml = pendingRequests.length > 0 ? 
                `<div style="background:#ff3b30; color:#fff; font-size:12px; padding:2px 6px; border-radius:10px; min-width:18px; text-align:center;">${pendingRequests.length}</div>` : '';
            
            newFriendItem.innerHTML = `
                <div style="width:40px; height:40px; border-radius:4px; background:linear-gradient(135deg, #ffc2d1 0%, #ff8fab 100%); display:flex; align-items:center; justify-content:center;">
                    <svg class="svg-icon" style="width:24px; height:24px; stroke:#fff;" viewBox="0 0 24 24">
                        <path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                        <circle cx="8.5" cy="7" r="4"></circle>
                        <line x1="20" y1="8" x2="20" y2="14"></line>
                        <line x1="23" y1="11" x2="17" y2="11"></line>
                    </svg>
                </div>
                <div style="flex:1; font-size:16px; font-weight:500; color:#333;">æ–°çš„å¥½å‹</div>
                ${badgeHtml}
            `;
            listDiv.appendChild(newFriendItem);
            
            if (friends.length === 0) {
                const emptyDiv = document.createElement('div');
                emptyDiv.style.textAlign = 'center';
                emptyDiv.style.padding = '40px 20px';
                emptyDiv.style.color = '#999';
                emptyDiv.innerHTML = `
                    <svg class="svg-icon" style="width:48px; height:48px; stroke:#ccc; margin-bottom:10px;" viewBox="0 0 24 24"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg>
                    <div>é€šè®¯å½•ä¸ºç©º</div>
                `;
                listDiv.appendChild(emptyDiv);
            } else {
                friends.forEach(f => {
                    const item = document.createElement('div');
                    item.style.display = 'flex';
                    item.style.padding = '10px 16px';
                    item.style.borderBottom = '0.5px solid #f0f0f0';
                    item.style.alignItems = 'center';
                    item.style.gap = '12px';
                    item.onclick = () => openChatWindow(f.id);

                    const avatarStyle = f.avatar ? `background-image:url(${f.avatar})` : 'background-color:#eee';
                    
                    item.innerHTML = `
                        <div style="width:40px; height:40px; border-radius:4px; ${avatarStyle}; background-size:cover; background-position:center;"></div>
                        <div style="font-size:16px; font-weight:500; color:#333;">${f.name}</div>
                    `;
                    listDiv.appendChild(item);
                });
            }
            container.appendChild(listDiv);
        }

        // èœå•ä¸å¼¹çª—é€»è¾‘
        function toggleWechatMenu() {
            const menu = document.getElementById('wechat-menu');
            menu.style.display = menu.style.display === 'flex' ? 'none' : 'flex';
            // ç‚¹å‡»å¤–éƒ¨å…³é—­ (ç®€å•å¤„ç†)
            setTimeout(() => {
                document.addEventListener('click', closeMenuOutside);
            }, 0);
        }
        function closeMenuOutside(e) {
            const menu = document.getElementById('wechat-menu');
            if (!menu.contains(e.target) && !e.target.closest('.wechat-add')) {
                menu.style.display = 'none';
                document.removeEventListener('click', closeMenuOutside);
            }
        }

        function closeModal(id) {
            document.getElementById(id).style.display = 'none';
            
            // å¦‚æœæ˜¯åˆ›å»ºç¾¤èŠå¼¹çª—ï¼Œé‡ç½®çŠ¶æ€
            if (id === 'create-group-modal') {
                window._addingGroupMembers = false;
                const nameInput = document.getElementById('group-name-input');
                if (nameInput) nameInput.style.display = '';
                const title = document.querySelector('#create-group-modal .modal-title');
                if (title) title.innerText = 'åˆ›å»ºç¾¤èŠ';
            }
        }

        // å½“å‰å¿ƒå£°ç›¸å…³å˜é‡
        let currentThoughtsCharId = null;
        let currentThoughtsMessageIndex = null;

        // æ˜¾ç¤ºè§’è‰²å¿ƒå£°
        async function showCharacterThoughts(charId, messageIndex) {
            if (!charId) return;
            
            const char = await db.characters.get(charId);
            if (!char) return;
            
            currentThoughtsCharId = charId;
            currentThoughtsMessageIndex = messageIndex;
            
            const modal = document.getElementById('thoughts-modal');
            const title = document.getElementById('thoughts-modal-title');
            const currentText = document.getElementById('thoughts-current-text');
            const currentTime = document.getElementById('thoughts-current-time');
            const historyContent = document.getElementById('thoughts-history-content');
            const historySection = document.getElementById('thoughts-history');
            const arrow = document.getElementById('thoughts-arrow');
            
            title.textContent = `TAçš„å¿ƒå£°`;
            
            // é‡ç½®å†å²åŒºåŸŸçŠ¶æ€
            historySection.style.display = 'none';
            arrow.classList.remove('expanded');
            historyContent.innerHTML = '';
            
            // è·å–å¿ƒå£°
            const currentDeleteBtn = document.getElementById('thoughts-current-delete');
            if (!char.thoughts || char.thoughts.length === 0) {
                currentText.textContent = 'æš‚æ— å¿ƒå£°';
                currentTime.textContent = '';
                document.getElementById('thoughts-history-btn').style.display = 'none';
                if (currentDeleteBtn) currentDeleteBtn.style.display = 'none';
            } else {
                if (currentDeleteBtn) currentDeleteBtn.style.display = 'block';
                // æ‰¾åˆ°æœ€æ–°çš„å¿ƒå£°ä½œä¸ºå½“å‰å¿ƒå£°
                const latestThought = char.thoughts[char.thoughts.length - 1];
                currentText.textContent = latestThought.content;
                const timeStr = new Date(latestThought.time).toLocaleString('zh-CN', {
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                currentTime.textContent = timeStr;
                
                // å¦‚æœæœ‰å†å²å¿ƒå£°ï¼ˆè¶…è¿‡1æ¡ï¼‰ï¼Œæ˜¾ç¤ºæŸ¥çœ‹å†å²æŒ‰é’®
                if (char.thoughts.length > 1) {
                    document.getElementById('thoughts-history-btn').style.display = 'flex';
                    
                    // æ¸²æŸ“å†å²å¿ƒå£°ï¼ˆé™¤äº†æœ€æ–°çš„ï¼‰
                    const historyThoughts = char.thoughts.slice(0, -1).reverse();
                    historyThoughts.forEach((thought, idx) => {
                        const item = document.createElement('div');
                        item.className = 'thoughts-history-item';
                        item.style.position = 'relative';
                        
                        const text = document.createElement('div');
                        text.className = 'thoughts-history-text';
                        text.textContent = thought.content;
                        
                        const bottomRow = document.createElement('div');
                        bottomRow.style.cssText = 'display:flex; justify-content:space-between; align-items:center;';
                        
                        const time = document.createElement('div');
                        time.className = 'thoughts-history-time';
                        time.textContent = new Date(thought.time).toLocaleString('zh-CN', {
                            month: 'short',
                            day: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit'
                        });
                        
                        const deleteBtn = document.createElement('div');
                        deleteBtn.textContent = 'åˆ é™¤';
                        deleteBtn.style.cssText = 'font-size:12px; color:#ff3b30; cursor:pointer; padding:2px 8px;';
                        // åŸå§‹ç´¢å¼• = char.thoughts.length - 2 - idx
                        const originalIndex = char.thoughts.length - 2 - idx;
                        deleteBtn.onclick = () => deleteThought(charId, originalIndex);
                        
                        bottomRow.appendChild(time);
                        bottomRow.appendChild(deleteBtn);
                        
                        item.appendChild(text);
                        item.appendChild(bottomRow);
                        historyContent.appendChild(item);
                    });
                } else {
                    document.getElementById('thoughts-history-btn').style.display = 'none';
                }
            }
            
            modal.style.display = 'flex';
        }

        // åˆ‡æ¢å†å²å¿ƒå£°æ˜¾ç¤º
        function toggleThoughtsHistory() {
            const historySection = document.getElementById('thoughts-history');
            const arrow = document.getElementById('thoughts-arrow');
            
            if (historySection.style.display === 'none') {
                historySection.style.display = 'block';
                arrow.classList.add('expanded');
            } else {
                historySection.style.display = 'none';
                arrow.classList.remove('expanded');
            }
        }

        // ç¼–è¾‘å½“å‰å¿ƒå£°
        async function editCurrentThought() {
            if (!currentThoughtsCharId) return;
            
            const char = await db.characters.get(currentThoughtsCharId);
            if (!char || !char.thoughts || char.thoughts.length === 0) {
                showToast('æš‚æ— å¿ƒå£°å¯ç¼–è¾‘');
                return;
            }
            
            const latestThought = char.thoughts[char.thoughts.length - 1];
            const newContent = prompt('ç¼–è¾‘å¿ƒå£°ï¼š', latestThought.content);
            
            if (newContent !== null && newContent.trim()) {
                char.thoughts[char.thoughts.length - 1].content = newContent.trim();
                await db.characters.put(char);
                
                // æ›´æ–°æ˜¾ç¤º
                document.getElementById('thoughts-current-text').textContent = newContent.trim();
                showToast('å¿ƒå£°å·²æ›´æ–°');
            }
        }

        // åˆ é™¤æŒ‡å®šç´¢å¼•çš„å¿ƒå£°
        async function deleteThought(charId, thoughtIndex) {
            if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡å¿ƒå£°å—ï¼Ÿ')) return;
            
            const char = await db.characters.get(charId);
            if (!char || !char.thoughts || thoughtIndex < 0 || thoughtIndex >= char.thoughts.length) return;
            
            char.thoughts.splice(thoughtIndex, 1);
            await db.characters.put(char);
            
            showToast('å¿ƒå£°å·²åˆ é™¤');
            // åˆ·æ–°å¿ƒå£°å¼¹çª—
            showCharacterThoughts(charId);
        }
        window.deleteThought = deleteThought;
        
        // åˆ é™¤å½“å‰å¿ƒå£°ï¼ˆæœ€æ–°ä¸€æ¡ï¼‰
        async function deleteCurrentThought() {
            if (!currentThoughtsCharId) return;
            
            const char = await db.characters.get(currentThoughtsCharId);
            if (!char || !char.thoughts || char.thoughts.length === 0) {
                showToast('æš‚æ— å¿ƒå£°å¯åˆ é™¤');
                return;
            }
            
            if (!confirm('ç¡®å®šè¦åˆ é™¤å½“å‰å¿ƒå£°å—ï¼Ÿ')) return;
            
            char.thoughts.pop(); // åˆ é™¤æœ€æ–°çš„
            await db.characters.put(char);
            
            showToast('å¿ƒå£°å·²åˆ é™¤');
            // åˆ·æ–°å¿ƒå£°å¼¹çª—
            showCharacterThoughts(currentThoughtsCharId);
        }
        window.deleteCurrentThought = deleteCurrentThought;

        // é‡æ–°ç”Ÿæˆå¿ƒå£°
        async function regenerateThought() {
            if (!currentThoughtsCharId) return;
            
            const char = await db.characters.get(currentThoughtsCharId);
            if (!char) return;
            
            showToast('æ­£åœ¨ç”Ÿæˆæ–°å¿ƒå£°...');
            
            // å…³é—­å¼¹çª—
            closeModal('thoughts-modal');
            
            // è§¦å‘AIé‡æ–°ç”Ÿæˆï¼ˆè¿™é‡Œç®€å•å¤„ç†ï¼Œå®é™…å¯ä»¥è°ƒç”¨AIæ¥å£ï¼‰
            // ç”±äºå¿ƒå£°æ˜¯åœ¨AIå›å¤æ—¶è‡ªåŠ¨ç”Ÿæˆçš„ï¼Œè¿™é‡Œæç¤ºç”¨æˆ·å‘é€æ¶ˆæ¯è§¦å‘
            showToast('è¯·å‘é€ä¸€æ¡æ¶ˆæ¯æ¥è§¦å‘æ–°çš„å¿ƒå£°ç”Ÿæˆ');
        }

        // æœç´¢å¥½å‹
        function showAddFriendModal() {
            document.getElementById('search-friend-modal').style.display = 'flex';
            document.getElementById('wechat-menu').style.display = 'none';
            // é‡ç½®çŠ¶æ€
            document.getElementById('search-account-input').value = '';
            document.getElementById('search-result-area').style.display = 'none';
            document.getElementById('apply-area').style.display = 'none';
            document.getElementById('search-cancel-btn').style.display = 'block';
        }

        let searchTargetChar = null;

        // è¾…åŠ©ï¼šè·å–ä¸–ç•Œä¹¦ä¸Šä¸‹æ–‡ (ç®€å•çš„å…³é”®è¯åŒ¹é…)
        // æ”¯æŒå•ä¸ªIDæˆ–IDæ•°ç»„ï¼Œè‡ªåŠ¨åŒ…å«å…¨å±€ä¸–ç•Œä¹¦
        async function getLorebookContext(lorebookIdOrIds, keywords) {
            // å…¼å®¹æ—§æ•°æ®ï¼šå¦‚æœæ˜¯å•ä¸ªIDï¼Œè½¬æ¢ä¸ºæ•°ç»„
            let ids = [];
            if (lorebookIdOrIds) {
                ids = Array.isArray(lorebookIdOrIds) ? [...lorebookIdOrIds] : [lorebookIdOrIds];
            }
            
            // ğŸ”¥ è‡ªåŠ¨åŠ è½½æ‰€æœ‰å…¨å±€ä¸–ç•Œä¹¦
            try {
                const allBooks = await db.lorebooks.toArray();
                const globalIds = allBooks.filter(b => b.scope === 'global').map(b => b.id);
                globalIds.forEach(gid => {
                    if (!ids.includes(gid)) ids.push(gid);
                });
            } catch (e) {
                console.warn('[ä¸–ç•Œä¹¦] åŠ è½½å…¨å±€ä¸–ç•Œä¹¦å¤±è´¥:', e);
            }
            
            if (ids.length === 0) return "";
            
            let allContext = [];
            const checkText = keywords ? keywords.toLowerCase() : "";
            
            // éå†æ‰€æœ‰ä¸–ç•Œä¹¦
            for (const id of ids) {
                const book = await db.lorebooks.get(id);
                if (!book || !book.content || !book.content.entries) continue;
                
                const entries = Object.values(book.content.entries);
                
                entries.forEach(entry => {
                    if (entry.enabled === false) return; // åªåŠ è½½å¯ç”¨çš„æ¡ç›®
                    
                    // ğŸ”¥ æ–°é€»è¾‘ï¼šæŒ‚è½½äº†å°±ç›´æ¥åŠ è½½æ‰€æœ‰å¯ç”¨çš„æ¡ç›®
                    // å¦‚æœæœ‰å…³é”®è¯ï¼Œä¼˜å…ˆåŒ¹é…å…³é”®è¯çš„æ¡ç›®
                    // å¦‚æœæ²¡æœ‰å…³é”®è¯æˆ–æ²¡æœ‰è®¾ç½®keyï¼Œç›´æ¥åŠ è½½
                    let shouldLoad = false;
                    
                    const keys = Array.isArray(entry.key) ? entry.key : (entry.key ? [entry.key] : []);
                    
                    if (keys.length === 0 || keys.every(k => !k || k.trim() === '')) {
                        // æ²¡æœ‰è®¾ç½®å…³é”®è¯ï¼Œç›´æ¥åŠ è½½
                        shouldLoad = true;
                    } else if (checkText) {
                        // æœ‰å…³é”®è¯ï¼Œå°è¯•åŒ¹é…
                        const isMatch = keys.some(k => {
                            if(!k) return false;
                            return checkText.includes(k.toLowerCase());
                        });
                        shouldLoad = isMatch;
                    } else {
                        // æ²¡æœ‰æ£€æŸ¥æ–‡æœ¬ä½†æœ‰å…³é”®è¯è®¾ç½®ï¼Œä¹ŸåŠ è½½ï¼ˆå› ä¸ºæŒ‚è½½äº†å°±åº”è¯¥è¯»å–ï¼‰
                        shouldLoad = true;
                    }
                    
                    if (shouldLoad) {
                        allContext.push(entry.content);
                    }
                });
            }
            
            if (allContext.length > 0) {
                console.log(`[ä¸–ç•Œä¹¦] âœ… æˆåŠŸåŠ è½½ ${allContext.length} ä¸ªæ¡ç›®`);
                // ç®€å•æˆªæ–­ï¼Œé˜²æ­¢çˆ† Token
                const fullText = allContext.join('\n\n');
                const safeText = fullText.length > 10000 ? fullText.slice(0, 10000) + '...(å·²æˆªæ–­)' : fullText;
                return `ã€ä¸–ç•Œä¹¦è®¾å®šã€‘:\n${safeText}\n`;
            } else {
                console.log('[ä¸–ç•Œä¹¦] â„¹ï¸ æ²¡æœ‰å¯ç”¨çš„æ¡ç›®æˆ–æ¡ç›®ä¸ºç©º');
            }
            return "";
        }

        async function searchAccount() {
            const acc = document.getElementById('search-account-input').value.trim();
            if(!acc) return;
            
            // å…¨è¡¨æ‰«æåŒ¹é… identity.account
            const allChars = await db.characters.toArray();
            const target = allChars.find(c => c.identity && c.identity.account === acc);
            
            if (target) {
                searchTargetChar = target;
                document.getElementById('search-result-area').style.display = 'flex';
                document.getElementById('search-result-name').innerText = target.name;
                document.getElementById('search-result-id').innerText = "è´¦å·: " + acc;
                if(target.avatar) {
                    document.getElementById('search-result-avatar').style.backgroundImage = `url(${target.avatar})`;
                } else {
                    document.getElementById('search-result-avatar').style.backgroundImage = '';
                }
                
                // --- æ–°å¢ï¼šåŠ è½½ User åˆ—è¡¨ä¾›é€‰æ‹© ---
                const users = allChars.filter(c => c.type === 'user');
                const userSelect = document.getElementById('apply-user-select');
                userSelect.innerHTML = '';
                if(users.length === 0) {
                    const opt = document.createElement('option');
                    opt.value = "";
                    opt.text = "æ—  User è§’è‰² (è¯·å…ˆå»è§’è‰²æ¡£æ¡ˆæ–°å»º)";
                    userSelect.appendChild(opt);
                } else {
                    users.forEach(u => {
                        const opt = document.createElement('option');
                        opt.value = u.id;
                        opt.text = u.name;
                        userSelect.appendChild(opt);
                    });
                }
                
                document.getElementById('apply-area').style.display = 'block';
                document.getElementById('search-cancel-btn').style.display = 'none';
            } else {
                alert("æœªæ‰¾åˆ°è¯¥è´¦å·");
                searchTargetChar = null;
                document.getElementById('search-result-area').style.display = 'none';
                document.getElementById('apply-area').style.display = 'none';
            }
        }

        async function sendFriendRequest() {
            if(!searchTargetChar) return;
            
            const reason = document.getElementById('apply-reason').value.trim();
            const selectedUserId = document.getElementById('apply-user-select').value;
            
            if(!selectedUserId) {
                alert("è¯·å…ˆé€‰æ‹©ä¸€ä¸ª User èº«ä»½è¿›è¡Œç”³è¯·");
                return;
            }
            
            closeModal('search-friend-modal');
            alert("å¥½å‹ç”³è¯·å·²å‘é€ï¼Œè¯·ç¨å€™...");

            try {
                // 1. è·å– User æ•°æ®
                const userChar = await db.characters.get(parseInt(selectedUserId));
                
                // 2. å‡†å¤‡ Lorebook åŒ¹é…å…³é”®è¯ (Userå + Charå + ç”³è¯·ç†ç”±)
                const keywords = `${userChar.name} ${searchTargetChar.name} ${reason}`;
                
                // 3. è·å–åŒæ–¹ Lorebook ä¸Šä¸‹æ–‡ï¼ˆæ”¯æŒå¤šä¸ªä¸–ç•Œä¹¦ï¼‰
                const userLorebookIds = userChar.lorebookIds || (userChar.lorebookId ? [userChar.lorebookId] : []);
                const charLorebookIds = searchTargetChar.lorebookIds || (searchTargetChar.lorebookId ? [searchTargetChar.lorebookId] : []);
                const userLore = await getLorebookContext(userLorebookIds, keywords);
                const charLore = await getLorebookContext(charLorebookIds, keywords);
                
                // 4. æ„å»º Prompt
                const prompt = `[åœºæ™¯: å¾®ä¿¡å¥½å‹ç”³è¯·]
ã€ç”³è¯·äººä¿¡æ¯ã€‘
åå­—: ${userChar.name}
è®¾å®š: ${userChar.description || 'æ— '}
è™šæ‹Ÿè´¦å·: ${userChar.identity?.account || 'æœªçŸ¥'}

ã€è¢«ç”³è¯·äºº(ä½ )çš„ä¿¡æ¯ã€‘
åå­—: ${searchTargetChar.name}
è®¾å®š: ${searchTargetChar.description || 'æ— '}
è™šæ‹Ÿè´¦å·: ${searchTargetChar.identity?.account || 'æœªçŸ¥'}

${userLore}
${charLore}

User(${userChar.name}) å‘ä½ å‘é€äº†å¥½å‹ç”³è¯·ï¼Œé™„è¨€ï¼šâ€œ${reason || 'æˆ‘æ˜¯æœ‹å‹'}â€ã€‚

è¯·ä»¥ ${searchTargetChar.name} çš„èº«ä»½ï¼Œæ ¹æ®åŒæ–¹è®¾å®šå’Œä¸–ç•Œä¹¦å…³ç³»ï¼Œå†³å®šæ˜¯å¦é€šè¿‡å¥½å‹ç”³è¯·ã€‚
è¦æ±‚ï¼š
1. å¿…é¡»ç¬¦åˆè§’è‰²æ€§æ ¼ã€‚å¦‚æœæ˜¯é«˜å†·/è°¨æ…çš„è§’è‰²ï¼Œå¯èƒ½ä¼šæ‹’ç»é™Œç”Ÿäººï¼›å¦‚æœæ˜¯å¤–å‘/è®¤è¯†çš„è§’è‰²ï¼Œåˆ™ä¼šé€šè¿‡ã€‚
2. ä»”ç»†æ£€æŸ¥ä¸–ç•Œä¹¦å’Œè®¾å®šä¸­æ˜¯å¦æœ‰ä¸¤äººçš„å…³ç³»æè¿°ã€‚
3. å¦‚æœé€šè¿‡ï¼Œè¯·ç»™å‡º 2 åˆ° 3 æ¡ç¬¦åˆè§’è‰²æ€§æ ¼ã€çº¿ä¸ŠèŠå¤©é£æ ¼çš„å›å¤ã€‚
   - **å¿…é¡»**ä½¿ç”¨åˆ†éš”ç¬¦ "|||" æ¥éš”å¼€æ¯ä¸€æ¡æ¶ˆæ¯ã€‚
   - **ä¸¥ç¦ä½¿ç”¨é€—å·**ï¼ˆåŒ…æ‹¬ä¸­æ–‡é€—å·å’Œè‹±æ–‡é€—å·ï¼‰ã€‚å¦‚æœæƒ³è¡¨è¾¾åœé¡¿ï¼Œè¯·ç›´æ¥æ‹†åˆ†æˆä¸‹ä¸€æ¡æ¶ˆæ¯ï¼Œæˆ–è€…ç”¨ç©ºæ ¼ä»£æ›¿ã€‚
   - é”™è¯¯ç¤ºä¾‹ï¼šä½ å¥½ï¼Œæˆ‘æ˜¯XXXï¼Œå¾ˆé«˜å…´è®¤è¯†ä½ 
   - æ­£ç¡®ç¤ºä¾‹ï¼šä½ å¥½|||æˆ‘æ˜¯XXX|||å¾ˆé«˜å…´è®¤è¯†ä½ 
4. å¦‚æœæ‹’ç»ï¼Œè¯·ç»™å‡ºç®€çŸ­çš„å¿ƒç†æ´»åŠ¨æˆ–æ‹’ç»ç†ç”±ï¼ˆä½œä¸º reply è¿”å›ï¼‰ã€‚

è¯·ä¸¥æ ¼è¿”å› JSON æ ¼å¼ï¼š
{
    "accepted": true, // æˆ– false
    "reply": "å›å¤å†…å®¹|||ç¬¬äºŒæ¡å†…å®¹"
}`;

                // 5. è°ƒç”¨ AI
                const resultStr = await callAI([
                    { role: "system", content: "ä½ æ˜¯ä¸€ä¸ªåªè¾“å‡ºJSONçš„è§’è‰²æ‰®æ¼”è¾…åŠ©ç³»ç»Ÿã€‚" },
                    { role: "user", content: prompt }
                ]);
                
                let result = extractAndParseJSON(resultStr);
                
                if (!result) {
                    console.error("JSONæå–/è§£æå¤±è´¥");
                    result = { accepted: true, reply: "ä½ å¥½å‘€|||æˆ‘æ˜¯æ–°æœ‹å‹(è§£æå¤±è´¥å…œåº•)" }; 
                }

                if (result.accepted) {
                    // æ›´æ–°æ•°æ®åº“
                    const char = await db.characters.get(searchTargetChar.id);
                    const accountId = String(selectedUserId);
                    await setFriendStatus(char, accountId, 'friend');
                    // ç»‘å®šèŠå¤©ç”¨çš„ User ID (å¯é€‰ï¼Œå¦‚æœä»¥åæ”¯æŒå¤š User åˆ‡æ¢)
                    // char.linked_user_id = userChar.id; 
                    
                    // è·å–å½“å‰è´¦å·çš„èŠå¤©è®°å½•
                    let history = getChatHistory(char, accountId);
                    
                    // 1. å­˜å…¥ç³»ç»Ÿå›ºå®šæ¶ˆæ¯
                    history.push({
                        role: 'char', // è¿™é‡Œè™½ç„¶æ˜¯ç³»ç»Ÿæ¶ˆæ¯ï¼Œä½†åœ¨å¾®ä¿¡é‡Œé€šå¸¸æ˜¾ç¤ºä¸ºä¸­é—´çš„ç°è‰²å°å­—ï¼Œæˆ–è€…å¯¹æ–¹å‘çš„ç¬¬ä¸€å¥è¯ã€‚
                        // ä¸ºäº†ç¬¦åˆâ€œç¬¬ä¸€æ¡æ¶ˆæ¯æ˜¯å¯¹æ–¹åŒæ„äº†æ‚¨çš„å¥½å‹ç”³è¯·â€çš„éœ€æ±‚ï¼Œè¿™é‡Œæ¨¡æ‹Ÿç³»ç»Ÿæç¤º
                        // ä½†å¦‚æœæ˜¯ä½œä¸ºå¯¹æ–¹å‘å‡ºçš„æ¶ˆæ¯ï¼ˆæ°”æ³¡ï¼‰ï¼Œåˆ™role='char'ã€‚
                        // å¦‚æœæƒ³è¦ä¸­é—´ç°è‰²å°å­—ï¼Œå¯èƒ½éœ€è¦æ–°çš„typeï¼Œè¿™é‡Œæš‚ä¸”ç”¨ç‰¹æ®Šå†…å®¹æˆ–charè§’è‰²å‘
                        // æ ¹æ®éœ€æ±‚"åº”è¯¥æœ‰ç¬¬ä¸€æ¡æ¶ˆæ¯æ˜¯å¯¹æ–¹åŒæ„äº†æ‚¨çš„å¥½å‹ç”³è¯·"ï¼Œè¿™é‡Œæ¨¡æ‹Ÿå¾®ä¿¡çš„ç³»ç»Ÿæç¤º
                        role: 'char', 
                        content: 'æˆ‘é€šè¿‡äº†ä½ çš„å¥½å‹éªŒè¯è¯·æ±‚ï¼Œç°åœ¨æˆ‘ä»¬å¯ä»¥å¼€å§‹èŠå¤©äº†',
                        time: Date.now()
                    });

                    // 2. å¤„ç† AI å›å¤ï¼ˆæ¸…æ´—é€—å· + æ‹†åˆ†ï¼‰
                    let cleanReply = result.reply.replace(/[,ï¼Œ]/g, ' '); 
                    let segments = cleanReply.split('|||').map(s => s.trim()).filter(s => s);
                    
                    // ä¾æ¬¡å­˜å…¥
                    for (let i = 0; i < segments.length; i++) {
                        history.push({
                            role: 'char',
                            content: segments[i],
                            time: Date.now() + (i + 1) * 500 // ç¨å¾®é”™å¼€æ—¶é—´
                        });
                    }
                    
                    await setChatHistory(char, accountId, history);
                    
                    // ğŸ”§ åœæ­¢è‡ªåŠ¨å¿«è¿›æ£€æŸ¥åŠŸèƒ½ï¼ˆè§’è‰²å·²ç»æ¥å—äº†ç”¨æˆ·çš„å¥½å‹ç”³è¯·ï¼‰
                    if (char.wait_friend_settings && char.wait_friend_settings[accountId]) {
                        char.wait_friend_settings[accountId].enabled = false;
                        char.wait_friend_settings[accountId].nextCheckTime = null;
                        await db.characters.put(char);
                        console.log(`[AutoAcceptFriend] å·²åœæ­¢ ${char.name} çš„è‡ªåŠ¨å¿«è¿›æ£€æŸ¥`);
                    }
                    
                    // åˆ·æ–°åˆ—è¡¨
                    if (document.querySelector('.wechat-tab-item.active').innerText.includes('å¾®ä¿¡')) {
                        renderWechatList(document.getElementById('wechat-content'));
                    }

                    // å‘é€é€šçŸ¥
                    const notifyText = segments.length > 0 ? segments[0] : 'æˆ‘é€šè¿‡äº†ä½ çš„å¥½å‹éªŒè¯è¯·æ±‚';
                    sendSystemNotification("å¾®ä¿¡", `${char.name} é€šè¿‡äº†ä½ çš„éªŒè¯: ${notifyText}`);
                } else {
                    sendSystemNotification("å¾®ä¿¡", `${searchTargetChar.name} æ‹’ç»äº†ç”³è¯·: ${result.reply}`);
                }

            } catch (err) {
                console.error(err);
                alert("è¯·æ±‚å¤„ç†å¤±è´¥: " + err.message);
            }
        }

        // ç›´æ¥å¯¼å…¥é€»è¾‘
        async function showDirectAddModal() {
            document.getElementById('direct-add-modal').style.display = 'flex';
            document.getElementById('wechat-menu').style.display = 'none';
            
            const list = document.getElementById('direct-add-list');
            list.innerHTML = '';
            
            // è·å–éå¥½å‹è§’è‰²
            const accountId = getCurrentAccountId();
            const allChars = await db.characters.toArray();
            // è¿‡æ»¤æ‰å·²ç»æ˜¯å¥½å‹çš„ï¼Œä»¥åŠ type ä¸º 'user' çš„è§’è‰²
            const candidates = allChars.filter(c => {
                if (c.type === 'user') return false;
                const status = getFriendStatus(c, accountId);
                return status !== 'friend';
            });
            
            if(candidates.length === 0) {
                list.innerHTML = '<div style="text-align:center;color:#999;margin-top:20px;">æ²¡æœ‰å¯æ·»åŠ çš„è§’è‰²</div>';
                return;
            }
            
            candidates.forEach(c => {
                const item = document.createElement('div');
                item.style.display = 'flex';
                item.style.alignItems = 'center';
                item.style.justifyContent = 'space-between';
                item.style.padding = '10px';
                item.style.background = '#f9f9f9';
                item.style.borderRadius = '8px';
                
                item.innerHTML = `
                    <div style="font-weight:500;">${c.name}</div>
                    <button style="background:var(--ins-pink); color:#fff; border:none; padding:6px 12px; border-radius:4px; font-size:12px;" onclick="directAddFriend(${c.id})">æ·»åŠ </button>
                `;
                list.appendChild(item);
            });
        }

        async function directAddFriend(id) {
            const char = await db.characters.get(id);
            if(char) {
                const accountId = getCurrentAccountId();
                await setFriendStatus(char, accountId, 'friend');
                // ç›´æ¥æ·»åŠ é»˜è®¤æ²¡æœ‰æ¶ˆæ¯ï¼Œæˆ–è€…å¯ä»¥åŠ ä¸€æ¡ç³»ç»Ÿæ¶ˆæ¯
                let history = getChatHistory(char, accountId);
                // history.push({ role: 'system', content: 'ä½ ä»¬å·²æˆä¸ºå¥½å‹ï¼Œå¼€å§‹èŠå¤©å§', time: Date.now() });
                await setChatHistory(char, accountId, history);
                closeModal('direct-add-modal');
                alert(`å·²å°† ${char.name} æ·»åŠ åˆ°é€šè®¯å½•`);
                
                // åˆ·æ–°
                if (document.querySelector('.wechat-tab-item.active').innerText.includes('å¾®ä¿¡')) {
                    renderWechatList(document.getElementById('wechat-content'));
                }
            }
        }

        // --- ç¾¤èŠåŠŸèƒ½ ---
        // é»˜è®¤ç¾¤å¤´åƒ
        const DEFAULT_GROUP_AVATAR = 'https://img.heliar.top/file/1770017506622_IMG_0773.jpeg';
        
        // æ˜¾ç¤ºåˆ›å»ºç¾¤èŠå¼¹çª—
        async function showCreateGroupModal() {
            document.getElementById('create-group-modal').style.display = 'flex';
            document.getElementById('wechat-menu').style.display = 'none';
            document.getElementById('group-name-input').value = '';
            
            const list = document.getElementById('group-friends-list');
            list.innerHTML = '';
            
            // è·å–å½“å‰è´¦å·çš„å¥½å‹åˆ—è¡¨
            const accountId = getCurrentAccountId();
            const allChars = await db.characters.toArray();
            const friends = allChars.filter(c => {
                if (c.type === 'user') return false;
                const status = getFriendStatus(c, accountId);
                return status === 'friend';
            });
            
            if (friends.length === 0) {
                list.innerHTML = '<div style="text-align:center; color:#999; margin-top:40px;">æš‚æ— å¥½å‹<br><span style="font-size:12px;">è¯·å…ˆæ·»åŠ å¥½å‹å†åˆ›å»ºç¾¤èŠ</span></div>';
                return;
            }
            
            friends.forEach(f => {
                const item = document.createElement('div');
                item.style.cssText = 'display:flex; align-items:center; padding:12px 0; border-bottom:0.5px solid #f0f0f0; cursor:pointer;';
                item.dataset.charId = f.id;
                item.dataset.selected = 'false';
                
                const avatarStyle = f.avatar ? `background-image:url(${f.avatar})` : 'background-color:#eee';
                
                item.innerHTML = `
                    <div class="group-select-checkbox" style="width:22px; height:22px; border:2px solid #ddd; border-radius:50%; margin-right:12px; display:flex; align-items:center; justify-content:center; transition:all 0.2s;">
                        <svg class="check-icon" style="width:14px; height:14px; stroke:#fff; fill:none; stroke-width:3; display:none;" viewBox="0 0 24 24"><polyline points="20 6 9 17 4 12"></polyline></svg>
                    </div>
                    <div style="width:40px; height:40px; border-radius:4px; ${avatarStyle}; background-size:cover; background-position:center; margin-right:12px;"></div>
                    <div style="font-size:16px; color:#333;">${f.remark || f.wx_nickname || f.name}</div>
                `;
                
                item.onclick = function() {
                    const isSelected = this.dataset.selected === 'true';
                    const checkbox = this.querySelector('.group-select-checkbox');
                    const checkIcon = this.querySelector('.check-icon');
                    
                    if (isSelected) {
                        this.dataset.selected = 'false';
                        checkbox.style.background = 'transparent';
                        checkbox.style.borderColor = '#ddd';
                        checkIcon.style.display = 'none';
                    } else {
                        this.dataset.selected = 'true';
                        checkbox.style.background = 'var(--ins-pink)';
                        checkbox.style.borderColor = 'var(--ins-pink)';
                        checkIcon.style.display = 'block';
                    }
                };
                
                list.appendChild(item);
            });
        }
        
        // ç¡®è®¤åˆ›å»ºç¾¤èŠ
        async function confirmCreateGroup() {
            const list = document.getElementById('group-friends-list');
            const selectedItems = list.querySelectorAll('[data-selected="true"]');
            const memberIds = Array.from(selectedItems).map(item => parseInt(item.dataset.charId));
            
            if (memberIds.length < 1) {
                alert('è¯·è‡³å°‘é€‰æ‹©1ä½å¥½å‹');
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯æ·»åŠ ç¾¤æˆå‘˜æ¨¡å¼
            if (window._addingGroupMembers && window.currentGroupChatId) {
                await addMembersToGroup(memberIds);
                return;
            }
            
            const groupName = document.getElementById('group-name-input').value.trim();
            const accountId = getCurrentAccountId();
            
            // è·å–é€‰ä¸­æˆå‘˜çš„åç§°ç”¨äºç”Ÿæˆé»˜è®¤ç¾¤å
            let defaultName = '';
            if (!groupName) {
                const memberChars = await Promise.all(memberIds.map(id => db.characters.get(id)));
                const myChar = currentMyCharId ? await db.characters.get(parseInt(currentMyCharId)) : null;
                const names = memberChars.map(c => c.remark || c.wx_nickname || c.name);
                if (myChar) names.unshift(myChar.nick || myChar.name);
                defaultName = names.slice(0, 4).join('ã€');
                if (names.length > 4) defaultName += '...';
            }
            
            // åˆ›å»ºç¾¤èŠè®°å½•
            const groupChat = {
                name: groupName || defaultName,
                avatar: DEFAULT_GROUP_AVATAR,
                memberIds: memberIds,
                ownerAccountId: accountId,
                created_at: Date.now(),
                updated_at: Date.now(),
                is_pinned: false,
                chat_history: [{
                    role: 'system',
                    content: 'ç¾¤èŠå·²åˆ›å»º',
                    time: Date.now()
                }]
            };
            
            const groupId = await db.group_chats.add(groupChat);
            
            closeModal('create-group-modal');
            alert(`ç¾¤èŠ"${groupChat.name}"åˆ›å»ºæˆåŠŸï¼`);
            
            // åˆ·æ–°èŠå¤©åˆ—è¡¨
            if (document.querySelector('.wechat-tab-item.active')?.innerText.includes('å¾®ä¿¡')) {
                renderWechatList(document.getElementById('wechat-content'));
            }
            
            // æ‰“å¼€ç¾¤èŠçª—å£
            openGroupChatWindow(groupId);
        }
        
        // æ·»åŠ æˆå‘˜åˆ°ç¾¤èŠ
        async function addMembersToGroup(memberIds) {
            const group = await db.group_chats.get(window.currentGroupChatId);
            if (!group) return;
            
            // æ·»åŠ æ–°æˆå‘˜
            const newMemberNames = [];
            for (const memberId of memberIds) {
                if (!group.memberIds.includes(memberId)) {
                    group.memberIds.push(memberId);
                    const char = await db.characters.get(memberId);
                    if (char) newMemberNames.push(char.remark || char.wx_nickname || char.name);
                }
            }
            
            if (newMemberNames.length > 0) {
                // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯
                group.chat_history.push({
                    role: 'system',
                    content: `${newMemberNames.join('ã€')} åŠ å…¥äº†ç¾¤èŠ`,
                    time: Date.now()
                });
            }
            
            group.updated_at = Date.now();
            await db.group_chats.put(group);
            
            // é‡ç½®çŠ¶æ€
            window._addingGroupMembers = false;
            document.getElementById('group-name-input').style.display = '';
            document.querySelector('#create-group-modal .modal-title').innerText = 'åˆ›å»ºç¾¤èŠ';
            
            closeModal('create-group-modal');
            
            // åˆ·æ–°ç¾¤æˆå‘˜åˆ—è¡¨å’ŒèŠå¤©
            await renderGroupMemberList(group);
            await renderGroupChatBody(group);
            
            alert(`å·²æ·»åŠ  ${newMemberNames.length} ä½æˆå‘˜`);
        }
        
        // æ‰“å¼€ç¾¤èŠçª—å£
        async function openGroupChatWindow(groupId) {
            const group = await db.group_chats.get(groupId);
            if (!group) return;
            
            // å¦‚æœæ˜¯è”æœºç¾¤èŠï¼Œè°ƒç”¨è”æœºç¾¤èŠçš„æ‰“å¼€æ–¹æ³•
            if (group.isOnlineGroup && group.onlineGroupId) {
                openOnlineGroup(group.onlineGroupId);
                return;
            }
            
            // è®¾ç½®å½“å‰èŠå¤©ä¸ºç¾¤èŠæ¨¡å¼
            currentChatCharId = null;
            window.currentGroupChatId = groupId;
            
            const titleEl = document.getElementById('chat-title');
            titleEl.innerText = group.name;
            titleEl.style.cursor = 'pointer';
            titleEl.onclick = () => showGroupDetail(groupId);
            
            document.getElementById('chat-window').style.display = 'flex';
            
            // æ˜¾ç¤ºè¾“å…¥æ¡†
            const chatFooter = document.getElementById('chat-footer');
            chatFooter.style.display = 'flex';
            
            await renderGroupChatBody(group);
        }
        
        // æ˜¾ç¤ºç¾¤èŠè¯¦æƒ…é¡µ
        async function showGroupDetail(groupId) {
            const group = await db.group_chats.get(groupId || window.currentGroupChatId);
            if (!group) return;
            
            document.getElementById('group-detail-page').style.display = 'flex';
            
            // è®¾ç½®ç¾¤å¤´åƒ
            const avatarEl = document.getElementById('group-detail-avatar');
            if (group.avatar) {
                avatarEl.style.backgroundImage = `url(${group.avatar})`;
            } else {
                avatarEl.style.backgroundImage = '';
                avatarEl.style.backgroundColor = '#eee';
            }
            
            // è®¾ç½®ç¾¤åç§°
            document.getElementById('group-detail-name').value = group.name || '';
            
            // è®¾ç½®æˆ‘çš„ç¾¤æ˜µç§°
            document.getElementById('group-detail-nickname').value = group.myNickname || '';
            
            // è®¾ç½®å¼€å…³çŠ¶æ€
            document.getElementById('group-detail-mute').checked = group.is_muted || false;
            document.getElementById('group-detail-pin').checked = group.is_pinned || false;
            
            // è®¾ç½®è‡ªåŠ¨æ€»ç»“è®¾ç½®
            document.getElementById('group-detail-auto-summary-switch').checked = group.auto_summary_enabled || false;
            document.getElementById('group-detail-summary-interval').value = group.summary_interval || '';
            
            // æ›´æ–°æ€»ç»“è®¡æ•°
            const accountId = getCurrentAccountId();
            if (accountId && group.id) {
                await updateSummaryCount('group', group.id, accountId);
            }
            
            // æ¸²æŸ“ç¾¤æˆå‘˜åˆ—è¡¨
            await renderGroupMemberList(group);
            
            // åŠ è½½ä¸–ç•Œä¹¦åˆ—è¡¨ï¼ˆå¤šé€‰ï¼‰â€”â€”åªæ˜¾ç¤ºå•äººä¸–ç•Œä¹¦ï¼Œå…¨å±€è‡ªåŠ¨ç”Ÿæ•ˆ
            const lorebooks = await db.lorebooks.toArray();
            const lbList = document.getElementById('group-detail-lorebook-list');
            lbList.innerHTML = '';
            
            // å…¼å®¹æ—§æ•°æ®ï¼šå¦‚æœlorebookIdå­˜åœ¨ä½†lorebookIdsä¸å­˜åœ¨ï¼Œè½¬æ¢ä¸ºæ•°ç»„
            const selectedIds = group.lorebookIds || (group.lorebookId ? [group.lorebookId] : []);
            
            // åˆ†ç¦»å…¨å±€å’Œå•äººä¸–ç•Œä¹¦
            const personalLbs = lorebooks.filter(lb => lb.scope !== 'global');
            const globalLbs = lorebooks.filter(lb => lb.scope === 'global');
            
            // å…¨å±€æç¤º
            if (globalLbs.length > 0) {
                const hint = document.createElement('div');
                hint.style.cssText = 'padding:6px 8px; color:#34c759; font-size:12px; background:#f0fff4; border-radius:6px; margin-bottom:6px;';
                hint.innerHTML = `ğŸŒ ${globalLbs.length} ä¸ªå…¨å±€ä¸–ç•Œä¹¦å·²è‡ªåŠ¨ç”Ÿæ•ˆï¼š${globalLbs.map(g => g.name).join('ã€')}`;
                lbList.appendChild(hint);
            }
            
            if (personalLbs.length === 0 && globalLbs.length === 0) {
                lbList.innerHTML = '<div style="padding:8px; color:#999; font-size:12px; text-align:center;">æš‚æ— ä¸–ç•Œä¹¦</div>';
            } else if (personalLbs.length > 0) {
                personalLbs.forEach(lb => {
                    const label = document.createElement('label');
                    label.style.cssText = 'display:flex; align-items:center; padding:8px; cursor:pointer; border-radius:6px; margin-bottom:4px;';
                    label.style.background = selectedIds.includes(lb.id) ? '#f0f0f5' : 'transparent';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = lb.id;
                    checkbox.checked = selectedIds.includes(lb.id);
                    checkbox.style.marginRight = '8px';
                    checkbox.onchange = () => {
                        label.style.background = checkbox.checked ? '#f0f0f5' : 'transparent';
                        updateGroupLorebookCount();
                        saveGroupDetail();
                    };
                    
                    const name = document.createElement('span');
                    name.textContent = lb.name;
                    name.style.fontSize = '14px';
                    name.style.color = '#333';
                    
                    label.appendChild(checkbox);
                    label.appendChild(name);
                    lbList.appendChild(label);
                });
            }
            
            updateGroupLorebookCount();
        }
        
        // æ¸²æŸ“ç¾¤æˆå‘˜åˆ—è¡¨é¢„è§ˆï¼ˆè¯¦æƒ…é¡µï¼‰
        async function renderGroupMemberList(group) {
            const listEl = document.getElementById('group-member-list');
            listEl.innerHTML = '';
            
            // æ·»åŠ è‡ªå·±
            const myChar = currentMyCharId ? await db.characters.get(parseInt(currentMyCharId)) : null;
            if (myChar) {
                const myAvatar = myChar.avatar || '';
                const myAvatarStyle = myAvatar ? `background-image:url(${myAvatar})` : 'background-color:#eee';
                const myItem = document.createElement('div');
                myItem.style.cssText = 'display:flex; flex-direction:column; align-items:center; width:60px;';
                myItem.innerHTML = `
                    <div style="width:44px; height:44px; border-radius:6px; ${myAvatarStyle}; background-size:cover; background-position:center; position:relative;">
                        <div style="position:absolute; bottom:-2px; right:-2px; background:#07c160; color:#fff; font-size:8px; padding:1px 3px; border-radius:2px;">ç¾¤ä¸»</div>
                    </div>
                    <div style="font-size:11px; color:#333; margin-top:4px; text-align:center; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; width:100%;">${group.myNickname || myChar.nick || myChar.name || 'æˆ‘'}</div>
                `;
                listEl.appendChild(myItem);
            }
            
            // æ·»åŠ å…¶ä»–æˆå‘˜ï¼ˆæœ€å¤šæ˜¾ç¤º8ä¸ªé¢„è§ˆï¼‰
            const memberIds = group.memberIds || [];
            const adminIds = group.adminIds || [];
            const displayCount = Math.min(memberIds.length, 7);
            
            for (let i = 0; i < displayCount; i++) {
                const memberId = memberIds[i];
                const char = await db.characters.get(memberId);
                if (!char) continue;
                
                const isAdmin = adminIds.includes(memberId);
                const avatarStyle = char.avatar ? `background-image:url(${char.avatar})` : 'background-color:#eee';
                const item = document.createElement('div');
                item.style.cssText = 'display:flex; flex-direction:column; align-items:center; width:60px;';
                item.innerHTML = `
                    <div style="width:44px; height:44px; border-radius:6px; ${avatarStyle}; background-size:cover; background-position:center; position:relative;">
                        ${isAdmin ? '<div style="position:absolute; bottom:-2px; right:-2px; background:#ff9500; color:#fff; font-size:8px; padding:1px 3px; border-radius:2px;">ç®¡ç†</div>' : ''}
                    </div>
                    <div style="font-size:11px; color:#333; margin-top:4px; text-align:center; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; width:100%;">${char.remark || char.wx_nickname || char.name}</div>
                `;
                listEl.appendChild(item);
            }
            
            // å¦‚æœæˆå‘˜è¶…è¿‡8ä¸ªï¼Œæ˜¾ç¤ºæ›´å¤š
            if (memberIds.length > 7) {
                const moreItem = document.createElement('div');
                moreItem.style.cssText = 'display:flex; flex-direction:column; align-items:center; width:60px; cursor:pointer;';
                moreItem.innerHTML = `
                    <div style="width:44px; height:44px; border-radius:6px; background:#f0f0f0; display:flex; align-items:center; justify-content:center; font-size:14px; color:#999;">+${memberIds.length - 7}</div>
                    <div style="font-size:11px; color:#999; margin-top:4px;">æ›´å¤š</div>
                `;
                moreItem.onclick = () => showGroupMemberManage();
                listEl.appendChild(moreItem);
            }
            
            // æ›´æ–°æˆå‘˜æ•°é‡
            const totalCount = memberIds.length + 1; // +1 åŒ…å«è‡ªå·±
            document.getElementById('group-member-count').innerText = `${totalCount}äºº`;
            const countText = document.getElementById('group-member-count-text');
            if (countText) countText.innerText = `${totalCount}äºº`;
        }
        
        // å½“å‰æ“ä½œçš„æˆå‘˜ID
        let currentActionMemberId = null;
        
        // æ˜¾ç¤ºç¾¤æˆå‘˜ç®¡ç†é¡µé¢
        async function showGroupMemberManage() {
            if (!window.currentGroupChatId) return;
            
            const group = await db.group_chats.get(window.currentGroupChatId);
            if (!group) return;
            
            document.getElementById('group-member-manage-page').style.display = 'flex';
            
            await renderGroupMemberManageList(group);
        }
        
        // éšè—ç¾¤æˆå‘˜ç®¡ç†é¡µé¢
        function hideGroupMemberManage() {
            document.getElementById('group-member-manage-page').style.display = 'none';
        }
        
        // æ¸²æŸ“ç¾¤æˆå‘˜ç®¡ç†åˆ—è¡¨
        async function renderGroupMemberManageList(group) {
            const ownerEl = document.getElementById('group-owner-info');
            const adminListEl = document.getElementById('group-admin-list');
            const memberListEl = document.getElementById('group-normal-member-list');
            const noAdminEl = document.getElementById('group-no-admin');
            
            ownerEl.innerHTML = '';
            adminListEl.innerHTML = '';
            memberListEl.innerHTML = '';
            
            const adminIds = group.adminIds || [];
            const mutedIds = group.mutedMembers || [];
            
            // æ£€æŸ¥å½“å‰ç”¨æˆ·æƒé™
            const isOwner = group.ownerAccountId === getCurrentAccountId();
            const currentUserIsAdmin = adminIds.includes(parseInt(currentMyCharId));
            const hasManagePermission = isOwner || currentUserIsAdmin;
            
            // æ¸²æŸ“ç¾¤ä¸»ï¼ˆè‡ªå·±ï¼‰
            const myChar = currentMyCharId ? await db.characters.get(parseInt(currentMyCharId)) : null;
            if (myChar) {
                const myAvatar = myChar.avatar || '';
                const myAvatarStyle = myAvatar ? `background-image:url(${myAvatar})` : 'background-color:#eee';
                ownerEl.innerHTML = `
                    <div style="display:flex; align-items:center; gap:12px;">
                        <div style="width:44px; height:44px; border-radius:6px; ${myAvatarStyle}; background-size:cover; background-position:center;"></div>
                        <div style="flex:1;">
                            <div style="font-size:16px; font-weight:500; color:#333;">${group.myNickname || myChar.nick || myChar.name || 'æˆ‘'}</div>
                            <div style="font-size:12px; color:#07c160;">ç¾¤ä¸»</div>
                        </div>
                    </div>
                `;
            }
            
            // åˆ†ç±»æˆå‘˜
            const admins = [];
            const members = [];
            
            for (const memberId of (group.memberIds || [])) {
                const char = await db.characters.get(memberId);
                if (!char) continue;
                
                if (adminIds.includes(memberId)) {
                    admins.push({ char, memberId });
                } else {
                    members.push({ char, memberId });
                }
            }
            
            // æ¸²æŸ“ç®¡ç†å‘˜
            if (admins.length === 0) {
                noAdminEl.style.display = 'block';
            } else {
                noAdminEl.style.display = 'none';
                for (const { char, memberId } of admins) {
                    const isMuted = mutedIds.includes(memberId);
                    const avatarStyle = char.avatar ? `background-image:url(${char.avatar})` : 'background-color:#eee';
                    const item = document.createElement('div');
                    // åªæœ‰ç¾¤ä¸»å¯ä»¥æ“ä½œç®¡ç†å‘˜
                    const canOperate = isOwner;
                    item.style.cssText = `display:flex; align-items:center; gap:12px; padding:12px 16px; border-bottom:0.5px solid #f0f0f0; ${canOperate ? 'cursor:pointer;' : ''}`;
                    item.innerHTML = `
                        <div style="width:44px; height:44px; border-radius:6px; ${avatarStyle}; background-size:cover; background-position:center;"></div>
                        <div style="flex:1;">
                            <div style="font-size:16px; font-weight:500; color:#333;">${char.remark || char.wx_nickname || char.name}</div>
                            <div style="font-size:12px; color:#ff9500;">${isMuted ? 'å·²ç¦è¨€ Â· ' : ''}ç®¡ç†å‘˜</div>
                        </div>
                        ${canOperate ? '<svg style="width:20px; height:20px; stroke:#ccc;" viewBox="0 0 24 24" fill="none" stroke-width="2"><polyline points="9 18 15 12 9 6"></polyline></svg>' : ''}
                    `;
                    if (canOperate) {
                        item.onclick = () => showMemberActionModal(memberId, char, true, isMuted);
                    }
                    adminListEl.appendChild(item);
                }
            }
            
            // æ¸²æŸ“æ™®é€šæˆå‘˜
            for (const { char, memberId } of members) {
                const isMuted = mutedIds.includes(memberId);
                const avatarStyle = char.avatar ? `background-image:url(${char.avatar})` : 'background-color:#eee';
                const item = document.createElement('div');
                // ç¾¤ä¸»å’Œç®¡ç†å‘˜éƒ½å¯ä»¥æ“ä½œæ™®é€šæˆå‘˜
                const canOperate = hasManagePermission;
                item.style.cssText = `display:flex; align-items:center; gap:12px; padding:12px 16px; border-bottom:0.5px solid #f0f0f0; ${canOperate ? 'cursor:pointer;' : ''}`;
                item.innerHTML = `
                    <div style="width:44px; height:44px; border-radius:6px; ${avatarStyle}; background-size:cover; background-position:center;"></div>
                    <div style="flex:1;">
                        <div style="font-size:16px; font-weight:500; color:#333;">${char.remark || char.wx_nickname || char.name}</div>
                        ${isMuted ? '<div style="font-size:12px; color:#ff3b30;">å·²ç¦è¨€</div>' : ''}
                    </div>
                    ${canOperate ? '<svg style="width:20px; height:20px; stroke:#ccc;" viewBox="0 0 24 24" fill="none" stroke-width="2"><polyline points="9 18 15 12 9 6"></polyline></svg>' : ''}
                `;
                if (canOperate) {
                    item.onclick = () => showMemberActionModal(memberId, char, false, isMuted);
                }
                memberListEl.appendChild(item);
            }
            
            if (members.length === 0) {
                memberListEl.innerHTML = '<div style="padding:20px 16px; text-align:center; color:#999; font-size:13px;">æš‚æ— æ™®é€šæˆå‘˜</div>';
            }
        }
        
        // æ˜¾ç¤ºæˆå‘˜æ“ä½œå¼¹çª—
        async function showMemberActionModal(memberId, char, isAdmin, isMuted) {
            currentActionMemberId = memberId;
            
            const group = await db.group_chats.get(window.currentGroupChatId);
            if (!group) return;
            
            // æ£€æŸ¥å½“å‰ç”¨æˆ·æ˜¯å¦æ˜¯ç¾¤ä¸»ï¼ˆåˆ›å»ºè€…ï¼‰
            const isOwner = group.ownerAccountId === getCurrentAccountId();
            // æ£€æŸ¥å½“å‰ç”¨æˆ·æ˜¯å¦æ˜¯ç®¡ç†å‘˜
            const currentUserIsAdmin = (group.adminIds || []).includes(parseInt(currentMyCharId));
            
            const avatarStyle = char.avatar ? `url(${char.avatar})` : '#eee';
            document.getElementById('member-action-avatar').style.backgroundImage = avatarStyle;
            document.getElementById('member-action-name').innerText = char.remark || char.wx_nickname || char.name;
            document.getElementById('member-action-role').innerText = isAdmin ? 'ç®¡ç†å‘˜' : 'ç¾¤æˆå‘˜';
            
            // æƒé™æ§åˆ¶ï¼š
            // - ç¾¤ä¸»å¯ä»¥åšæ‰€æœ‰æ“ä½œ
            // - ç®¡ç†å‘˜åªèƒ½å¯¹æ™®é€šæˆå‘˜æ“ä½œï¼ˆä¸èƒ½å¯¹å…¶ä»–ç®¡ç†å‘˜æ“ä½œï¼‰
            
            const setAdminBtn = document.getElementById('member-action-set-admin');
            const removeAdminBtn = document.getElementById('member-action-remove-admin');
            const muteBtn = document.getElementById('member-action-mute');
            const kickBtn = document.getElementById('member-action-kick');
            
            if (isOwner) {
                // ç¾¤ä¸»ï¼šå®Œæ•´æƒé™
                setAdminBtn.style.display = isAdmin ? 'none' : 'block';
                removeAdminBtn.style.display = isAdmin ? 'block' : 'none';
                muteBtn.style.display = 'block';
                kickBtn.style.display = 'block';
            } else if (currentUserIsAdmin) {
                // ç®¡ç†å‘˜ï¼šåªèƒ½æ“ä½œæ™®é€šæˆå‘˜
                setAdminBtn.style.display = 'none'; // ç®¡ç†å‘˜ä¸èƒ½è®¾ç½®ç®¡ç†å‘˜
                removeAdminBtn.style.display = 'none'; // ç®¡ç†å‘˜ä¸èƒ½å–æ¶ˆç®¡ç†å‘˜
                
                if (isAdmin) {
                    // ä¸èƒ½å¯¹å…¶ä»–ç®¡ç†å‘˜æ“ä½œ
                    muteBtn.style.display = 'none';
                    kickBtn.style.display = 'none';
                } else {
                    // å¯ä»¥å¯¹æ™®é€šæˆå‘˜æ“ä½œ
                    muteBtn.style.display = 'block';
                    kickBtn.style.display = 'block';
                }
            } else {
                // æ™®é€šæˆå‘˜ï¼šæ²¡æœ‰ç®¡ç†æƒé™
                setAdminBtn.style.display = 'none';
                removeAdminBtn.style.display = 'none';
                muteBtn.style.display = 'none';
                kickBtn.style.display = 'none';
            }
            
            // ç¦è¨€æŒ‰é’®æ–‡å­—
            muteBtn.innerText = isMuted ? 'è§£é™¤ç¦è¨€' : 'ç¦è¨€';
            muteBtn.style.color = isMuted ? '#07c160' : '#ff9500';
            
            document.getElementById('member-action-modal').style.display = 'flex';
        }
        
        // è®¾ä¸ºç®¡ç†å‘˜ï¼ˆåªæœ‰ç¾¤ä¸»å¯ä»¥ï¼‰
        async function setMemberAsAdmin() {
            if (!window.currentGroupChatId || !currentActionMemberId) return;
            
            const group = await db.group_chats.get(window.currentGroupChatId);
            if (!group) return;
            
            // æƒé™æ£€æŸ¥ï¼šåªæœ‰ç¾¤ä¸»å¯ä»¥è®¾ç½®ç®¡ç†å‘˜
            if (group.ownerAccountId !== getCurrentAccountId()) {
                alert('åªæœ‰ç¾¤ä¸»å¯ä»¥è®¾ç½®ç®¡ç†å‘˜');
                return;
            }
            
            if (!group.adminIds) group.adminIds = [];
            if (!group.adminIds.includes(currentActionMemberId)) {
                group.adminIds.push(currentActionMemberId);
                
                const char = await db.characters.get(currentActionMemberId);
                group.chat_history.push({
                    role: 'system',
                    content: `${char?.name || 'æˆå‘˜'} å·²è¢«è®¾ä¸ºç®¡ç†å‘˜`,
                    time: Date.now()
                });
            }
            
            group.updated_at = Date.now();
            await db.group_chats.put(group);
            
            closeModal('member-action-modal');
            await renderGroupMemberManageList(group);
            await renderGroupMemberList(group);
        }
        
        // å–æ¶ˆç®¡ç†å‘˜ï¼ˆåªæœ‰ç¾¤ä¸»å¯ä»¥ï¼‰
        async function removeMemberAdmin() {
            if (!window.currentGroupChatId || !currentActionMemberId) return;
            
            const group = await db.group_chats.get(window.currentGroupChatId);
            if (!group) return;
            
            // æƒé™æ£€æŸ¥ï¼šåªæœ‰ç¾¤ä¸»å¯ä»¥å–æ¶ˆç®¡ç†å‘˜
            if (group.ownerAccountId !== getCurrentAccountId()) {
                alert('åªæœ‰ç¾¤ä¸»å¯ä»¥å–æ¶ˆç®¡ç†å‘˜');
                return;
            }
            
            group.adminIds = (group.adminIds || []).filter(id => id !== currentActionMemberId);
            
            const char = await db.characters.get(currentActionMemberId);
            group.chat_history.push({
                role: 'system',
                content: `${char?.name || 'æˆå‘˜'} å·²è¢«å–æ¶ˆç®¡ç†å‘˜`,
                time: Date.now()
            });
            
            group.updated_at = Date.now();
            await db.group_chats.put(group);
            
            closeModal('member-action-modal');
            await renderGroupMemberManageList(group);
            await renderGroupMemberList(group);
        }
        
        // ç¦è¨€/è§£é™¤ç¦è¨€ï¼ˆç¾¤ä¸»å’Œç®¡ç†å‘˜éƒ½å¯ä»¥ï¼Œä½†ç®¡ç†å‘˜åªèƒ½å¯¹æ™®é€šæˆå‘˜æ“ä½œï¼‰
        async function toggleMemberMute() {
            if (!window.currentGroupChatId || !currentActionMemberId) return;
            
            const group = await db.group_chats.get(window.currentGroupChatId);
            if (!group) return;
            
            const isOwner = group.ownerAccountId === getCurrentAccountId();
            const currentUserIsAdmin = (group.adminIds || []).includes(parseInt(currentMyCharId));
            const targetIsAdmin = (group.adminIds || []).includes(currentActionMemberId);
            
            // æƒé™æ£€æŸ¥
            if (!isOwner && !currentUserIsAdmin) {
                alert('åªæœ‰ç¾¤ä¸»æˆ–ç®¡ç†å‘˜å¯ä»¥ç¦è¨€æˆå‘˜');
                return;
            }
            
            // ç®¡ç†å‘˜ä¸èƒ½ç¦è¨€å…¶ä»–ç®¡ç†å‘˜
            if (!isOwner && targetIsAdmin) {
                alert('ç®¡ç†å‘˜ä¸èƒ½ç¦è¨€å…¶ä»–ç®¡ç†å‘˜');
                return;
            }
            
            if (!group.mutedMembers) group.mutedMembers = [];
            
            const char = await db.characters.get(currentActionMemberId);
            const isMuted = group.mutedMembers.includes(currentActionMemberId);
            
            if (isMuted) {
                group.mutedMembers = group.mutedMembers.filter(id => id !== currentActionMemberId);
                group.chat_history.push({
                    role: 'system',
                    content: `${char?.name || 'æˆå‘˜'} å·²è¢«è§£é™¤ç¦è¨€`,
                    time: Date.now()
                });
            } else {
                group.mutedMembers.push(currentActionMemberId);
                group.chat_history.push({
                    role: 'system',
                    content: `${char?.name || 'æˆå‘˜'} å·²è¢«ç¦è¨€`,
                    time: Date.now()
                });
            }
            
            group.updated_at = Date.now();
            await db.group_chats.put(group);
            
            closeModal('member-action-modal');
            await renderGroupMemberManageList(group);
        }
        
        // è¸¢å‡ºç¾¤èŠï¼ˆç¾¤ä¸»å’Œç®¡ç†å‘˜éƒ½å¯ä»¥ï¼Œä½†ç®¡ç†å‘˜åªèƒ½è¸¢æ™®é€šæˆå‘˜ï¼‰
        async function kickMember() {
            if (!window.currentGroupChatId || !currentActionMemberId) return;
            
            const group = await db.group_chats.get(window.currentGroupChatId);
            if (!group) return;
            
            const isOwner = group.ownerAccountId === getCurrentAccountId();
            const currentUserIsAdmin = (group.adminIds || []).includes(parseInt(currentMyCharId));
            const targetIsAdmin = (group.adminIds || []).includes(currentActionMemberId);
            
            // æƒé™æ£€æŸ¥
            if (!isOwner && !currentUserIsAdmin) {
                alert('åªæœ‰ç¾¤ä¸»æˆ–ç®¡ç†å‘˜å¯ä»¥ç§»é™¤æˆå‘˜');
                return;
            }
            
            // ç®¡ç†å‘˜ä¸èƒ½è¸¢å…¶ä»–ç®¡ç†å‘˜
            if (!isOwner && targetIsAdmin) {
                alert('ç®¡ç†å‘˜ä¸èƒ½ç§»é™¤å…¶ä»–ç®¡ç†å‘˜');
                return;
            }
            
            const char = await db.characters.get(currentActionMemberId);
            if (!confirm(`ç¡®å®šè¦å°† ${char?.name || 'è¯¥æˆå‘˜'} ç§»å‡ºç¾¤èŠå—ï¼Ÿ`)) return;
            
            // ä»æˆå‘˜åˆ—è¡¨ç§»é™¤
            group.memberIds = (group.memberIds || []).filter(id => id !== currentActionMemberId);
            // ä»ç®¡ç†å‘˜åˆ—è¡¨ç§»é™¤
            group.adminIds = (group.adminIds || []).filter(id => id !== currentActionMemberId);
            // ä»ç¦è¨€åˆ—è¡¨ç§»é™¤
            group.mutedMembers = (group.mutedMembers || []).filter(id => id !== currentActionMemberId);
            
            group.chat_history.push({
                role: 'system',
                content: `${char?.name || 'æˆå‘˜'} å·²è¢«ç§»å‡ºç¾¤èŠ`,
                time: Date.now()
            });
            
            group.updated_at = Date.now();
            await db.group_chats.put(group);
            
            closeModal('member-action-modal');
            await renderGroupMemberManageList(group);
            await renderGroupMemberList(group);
            await renderGroupChatBody(group);
        }
        
        // éšè—ç¾¤èŠè¯¦æƒ…é¡µ
        function hideGroupDetail() {
            document.getElementById('group-detail-page').style.display = 'none';
        }
        
        // åˆ‡æ¢ç¾¤èŠä¸–ç•Œä¹¦åˆ—è¡¨
        function toggleGroupLorebookList() {
            const list = document.getElementById('group-detail-lorebook-list');
            const toggle = document.getElementById('group-detail-lorebook-toggle');
            if (list.style.display === 'none' || !list.style.display) {
                list.style.display = 'block';
                toggle.textContent = 'âˆ¨';
            } else {
                list.style.display = 'none';
                toggle.textContent = 'â€º';
            }
        }
        
        // æ›´æ–°ç¾¤èŠä¸–ç•Œä¹¦è®¡æ•°
        function updateGroupLorebookCount() {
            const checkboxes = document.querySelectorAll('#group-detail-lorebook-list input[type="checkbox"]:checked');
            const count = checkboxes.length;
            document.getElementById('group-detail-lorebook-count').textContent = `${count}ä¸ª`;
        }
        
        // ä¿å­˜ç¾¤èŠè¯¦æƒ…
        async function saveGroupDetail() {
            if (!window.currentGroupChatId) return;
            
            const group = await db.group_chats.get(window.currentGroupChatId);
            if (!group) return;
            
            group.name = document.getElementById('group-detail-name').value.trim() || group.name;
            group.myNickname = document.getElementById('group-detail-nickname').value.trim();
            group.is_muted = document.getElementById('group-detail-mute').checked;
            group.is_pinned = document.getElementById('group-detail-pin').checked;
            
            // è·å–é€‰ä¸­çš„ä¸–ç•Œä¹¦IDæ•°ç»„
            const checkboxes = document.querySelectorAll('#group-detail-lorebook-list input[type="checkbox"]:checked');
            const lorebookIds = Array.from(checkboxes).map(cb => parseInt(cb.value));
            group.lorebookIds = lorebookIds.length > 0 ? lorebookIds : null;
            
            // è‡ªåŠ¨æ€»ç»“è®¾ç½®
            group.auto_summary_enabled = document.getElementById('group-detail-auto-summary-switch').checked;
            const summaryInterval = parseInt(document.getElementById('group-detail-summary-interval').value);
            group.summary_interval = summaryInterval > 0 ? summaryInterval : 50;
            
            group.updated_at = Date.now();
            
            await db.group_chats.put(group);
            
            // æ›´æ–°èŠå¤©çª—å£æ ‡é¢˜
            document.getElementById('chat-title').innerText = group.name;
        }
        
        // è®¾ç½®ç¾¤å¤´åƒ
        async function setGroupAvatar(input) {
            if (!input.files || !input.files[0] || !window.currentGroupChatId) return;
            
            const file = input.files[0];
            const reader = new FileReader();
            
            reader.onload = async (e) => {
                const avatarUrl = e.target.result;
                
                const group = await db.group_chats.get(window.currentGroupChatId);
                if (!group) return;
                
                group.avatar = avatarUrl;
                group.updated_at = Date.now();
                await db.group_chats.put(group);
                
                // æ›´æ–°è¯¦æƒ…é¡µå¤´åƒ
                document.getElementById('group-detail-avatar').style.backgroundImage = `url(${avatarUrl})`;
            };
            
            reader.readAsDataURL(file);
            input.value = '';
        }
        
        // æ¸…ç©ºç¾¤èŠè®°å½•
        async function clearGroupChatHistory() {
            if (!window.currentGroupChatId) return;
            
            if (!confirm('ç¡®å®šè¦æ¸…ç©ºè¯¥ç¾¤èŠçš„æ‰€æœ‰èŠå¤©è®°å½•å—ï¼Ÿ')) return;
            
            const group = await db.group_chats.get(window.currentGroupChatId);
            if (!group) return;
            
            group.chat_history = [{
                role: 'system',
                content: 'èŠå¤©è®°å½•å·²æ¸…ç©º',
                time: Date.now()
            }];
            group.updated_at = Date.now();
            
            await db.group_chats.put(group);
            await renderGroupChatBody(group);
            
            alert('èŠå¤©è®°å½•å·²æ¸…ç©º');
        }
        
        // é€€å‡ºç¾¤èŠ
        async function exitGroup() {
            if (!window.currentGroupChatId) return;
            
            if (!confirm('ç¡®å®šè¦åˆ é™¤å¹¶é€€å‡ºè¯¥ç¾¤èŠå—ï¼Ÿ')) return;
            
            await db.group_chats.delete(window.currentGroupChatId);
            
            hideGroupDetail();
            hideChatWindow();
            
            // åˆ·æ–°èŠå¤©åˆ—è¡¨
            if (document.querySelector('.wechat-tab-item.active')?.innerText.includes('å¾®ä¿¡')) {
                renderWechatList(document.getElementById('wechat-content'));
            }
            
            alert('å·²é€€å‡ºç¾¤èŠ');
        }
        
        // ç§»é™¤ç¾¤æˆå‘˜
        async function removeGroupMember(groupId, memberId) {
            const group = await db.group_chats.get(groupId);
            if (!group) return;
            
            group.memberIds = group.memberIds.filter(id => id !== memberId);
            group.updated_at = Date.now();
            
            // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯
            const char = await db.characters.get(memberId);
            group.chat_history.push({
                role: 'system',
                content: `${char?.name || 'æˆå‘˜'} å·²è¢«ç§»å‡ºç¾¤èŠ`,
                time: Date.now()
            });
            
            await db.group_chats.put(group);
            await renderGroupMemberList(group);
            await renderGroupChatBody(group);
        }
        
        // æ˜¾ç¤ºæ·»åŠ ç¾¤æˆå‘˜å¼¹çª—
        async function showAddGroupMemberModal() {
            if (!window.currentGroupChatId) return;
            
            const group = await db.group_chats.get(window.currentGroupChatId);
            if (!group) return;
            
            // å¤ç”¨åˆ›å»ºç¾¤èŠçš„å¼¹çª—é€»è¾‘
            document.getElementById('create-group-modal').style.display = 'flex';
            document.getElementById('group-name-input').style.display = 'none';
            document.querySelector('#create-group-modal .modal-title').innerText = 'æ·»åŠ ç¾¤æˆå‘˜';
            
            const list = document.getElementById('group-friends-list');
            list.innerHTML = '';
            
            const accountId = getCurrentAccountId();
            const allChars = await db.characters.toArray();
            const existingMemberIds = group.memberIds || [];
            
            // è¿‡æ»¤å‡ºè¿˜ä¸åœ¨ç¾¤é‡Œçš„å¥½å‹
            const friends = allChars.filter(c => {
                if (c.type === 'user') return false;
                if (existingMemberIds.includes(c.id)) return false;
                const status = getFriendStatus(c, accountId);
                return status === 'friend';
            });
            
            if (friends.length === 0) {
                list.innerHTML = '<div style="text-align:center; color:#999; margin-top:40px;">æ²¡æœ‰å¯æ·»åŠ çš„å¥½å‹</div>';
                return;
            }
            
            friends.forEach(f => {
                const item = document.createElement('div');
                item.style.cssText = 'display:flex; align-items:center; padding:12px 0; border-bottom:0.5px solid #f0f0f0; cursor:pointer;';
                item.dataset.charId = f.id;
                item.dataset.selected = 'false';
                
                const avatarStyle = f.avatar ? `background-image:url(${f.avatar})` : 'background-color:#eee';
                
                item.innerHTML = `
                    <div class="group-select-checkbox" style="width:22px; height:22px; border:2px solid #ddd; border-radius:50%; margin-right:12px; display:flex; align-items:center; justify-content:center; transition:all 0.2s;">
                        <svg class="check-icon" style="width:14px; height:14px; stroke:#fff; fill:none; stroke-width:3; display:none;" viewBox="0 0 24 24"><polyline points="20 6 9 17 4 12"></polyline></svg>
                    </div>
                    <div style="width:40px; height:40px; border-radius:4px; ${avatarStyle}; background-size:cover; background-position:center; margin-right:12px;"></div>
                    <div style="font-size:16px; color:#333;">${f.remark || f.wx_nickname || f.name}</div>
                `;
                
                item.onclick = function() {
                    const isSelected = this.dataset.selected === 'true';
                    const checkbox = this.querySelector('.group-select-checkbox');
                    const checkIcon = this.querySelector('.check-icon');
                    
                    if (isSelected) {
                        this.dataset.selected = 'false';
                        checkbox.style.background = 'transparent';
                        checkbox.style.borderColor = '#ddd';
                        checkIcon.style.display = 'none';
                    } else {
                        this.dataset.selected = 'true';
                        checkbox.style.background = 'var(--ins-pink)';
                        checkbox.style.borderColor = 'var(--ins-pink)';
                        checkIcon.style.display = 'block';
                    }
                };
                
                list.appendChild(item);
            });
            
            // ä¿®æ”¹ç¡®è®¤æŒ‰é’®è¡Œä¸º
            window._addingGroupMembers = true;
        }
        
        // è¿½åŠ ç”¨æˆ·ç¾¤èŠæ¶ˆæ¯åˆ°UIï¼ˆä¼˜åŒ–æ€§èƒ½ï¼Œé¿å…é‡æ–°æ¸²æŸ“æ•´ä¸ªé¡µé¢ï¼‰
        async function appendUserGroupMessageToUI(msg, group) {
            const body = document.getElementById('chat-body');
            const myChar = currentMyCharId ? await db.characters.get(parseInt(currentMyCharId)) : null;
            const myNickname = group.myNickname || (myChar ? (myChar.nick || myChar.name) : 'æˆ‘');
            const myAvatar = myChar?.avatar || '';
            const avatarStyle = myAvatar ? `background-image:url(${myAvatar})` : 'background:#ccc';
            
            // åˆ›å»ºæ¶ˆæ¯å…ƒç´ 
            const msgDiv = document.createElement('div');
            msgDiv.style.marginBottom = '12px';
            msgDiv.className = 'group-message-row self';
            msgDiv.style.display = 'flex';
            msgDiv.style.flexDirection = 'row-reverse';
            msgDiv.style.alignItems = 'flex-end';
            msgDiv.style.gap = '8px';
            
            // æ¸²æŸ“æ¶ˆæ¯å†…å®¹ï¼ˆå¤„ç†å„ç§ç‰¹æ®Šæ ¼å¼ï¼‰
            let renderedContent = msg.content;
            
            // å¤„ç†å›¾ç‰‡å¡ç‰‡
            if (msg.content.startsWith('[imgcard:')) {
                const cardText = msg.content.substring(9, msg.content.length - 1).trim();
                renderedContent = `<div class="img-card-bubble" data-text="${escapeHtml(cardText)}" data-expanded="false" onclick="showImageCardContent(this)">
                    <div class="img-card-placeholder">
                        <svg class="img-card-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                            <circle cx="8.5" cy="8.5" r="1.5"></circle>
                            <polyline points="21 15 16 10 5 21"></polyline>
                        </svg>
                        <div class="img-card-hint">ç‚¹å‡»æŸ¥çœ‹æ–‡å­—</div>
                    </div>
                </div>`;
            }
            // å¤„ç†å›¾ç‰‡
            else if (msg.content.startsWith('[img:')) {
                const imgUrl = msg.content.substring(5, msg.content.length - 1).trim();
                renderedContent = `<img src="${imgUrl}" class="chat-image" style="max-width:200px; max-height:200px; border-radius:8px; cursor:pointer;" onclick="showFullImage(this.src)" ${getImageErrorHandler()} />`;
            }
            // å¤„ç†è¯­éŸ³
            else if (msg.content.startsWith('[voice:')) {
                const voiceText = msg.content.substring(7, msg.content.length - 1).trim();
                const barCount = Math.min(Math.max(Math.ceil(voiceText.length / 3), 3), 10);
                let bars = '';
                for (let i = 0; i < barCount; i++) {
                    const height = 8 + Math.random() * 12;
                    bars += `<div style="width:3px; height:${height}px; background:#999; border-radius:2px;"></div>`;
                }
                renderedContent = `<div class="voice-bubble" data-text="${escapeHtml(voiceText)}" style="background:#ffe4e8; padding:10px 14px; border-radius:18px; cursor:pointer; display:flex; align-items:center; gap:8px; min-width:80px;" onclick="playVoiceBubble(this)">
                    <svg viewBox="0 0 24 24" style="width:16px; height:16px; fill:#666;"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z"/></svg>
                    <div style="display:flex; align-items:center; gap:2px;">${bars}</div>
                    <span style="font-size:12px; color:#666;">${Math.ceil(voiceText.length / 5)}"</span>
                </div>`;
            }
            // æ™®é€šæ–‡å­—
            else {
                renderedContent = renderMessageContent(msg.content);
            }
            
            // åˆ¤æ–­æ˜¯å¦æ˜¯ç‰¹æ®Šæ¶ˆæ¯ï¼ˆä¸éœ€è¦æ°”æ³¡åŒ…è£¹ï¼‰
            const isSpecialMsg = msg.content.startsWith('[imgcard:') || msg.content.startsWith('[img:') || msg.content.startsWith('[voice:');
            
            if (isSpecialMsg) {
                msgDiv.innerHTML = `
                    <div style="width:32px; height:32px; border-radius:50%; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; margin-bottom:2px;"></div>
                    <div style="display:flex; flex-direction:column; align-items:flex-end; max-width:70%;">
                        <div style="font-size:12px; color:#999; margin-bottom:2px;">${myNickname}</div>
                        <div style="display:flex; align-items:flex-end; gap:6px;">
                            <div style="font-size:10px; color:#999;">${formatChatTime(msg.time)}</div>
                            <div class="group-msg-content">${renderedContent}</div>
                        </div>
                    </div>
                `;
            } else {
                msgDiv.innerHTML = `
                    <div style="width:32px; height:32px; border-radius:50%; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; margin-bottom:2px;"></div>
                    <div style="display:flex; flex-direction:column; align-items:flex-end; max-width:70%;">
                        <div style="font-size:12px; color:#999; margin-bottom:2px;">${myNickname}</div>
                        <div style="display:flex; align-items:flex-end; gap:6px;">
                            <div style="font-size:10px; color:#999;">${formatChatTime(msg.time)}</div>
                            <div class="group-msg-content" style="background:#ffe4e8; color:#000; padding:6px 10px; border-radius:18px 18px 4px 18px; font-size:15px; line-height:1.5; word-break:break-word;">${renderedContent}</div>
                        </div>
                    </div>
                `;
            }
            
            body.appendChild(msgDiv);
            body.scrollTop = body.scrollHeight;
        }
        
        // æ¸²æŸ“ç¾¤èŠæ¶ˆæ¯
        async function renderGroupChatBody(group) {
            const body = document.getElementById('chat-body');
            body.innerHTML = '';
            
            let history = group.chat_history || [];
            // æŒ‰æ—¶é—´æˆ³æ’åºï¼Œç¡®ä¿æ¶ˆæ¯é¡ºåºæ­£ç¡®
            history = [...history].sort((a, b) => (a.time || 0) - (b.time || 0));
            
            const accountId = getCurrentAccountId();
            const myChar = currentMyCharId ? await db.characters.get(parseInt(currentMyCharId)) : null;
            
            // è·å–æˆ‘çš„ç¾¤æ˜µç§°
            const myNickname = group.myNickname || (myChar ? (myChar.nick || myChar.name) : 'æˆ‘');
            
            // é¢„åŠ è½½æ‰€æœ‰æˆå‘˜ä¿¡æ¯
            const memberMap = {};
            for (const memberId of group.memberIds) {
                const char = await db.characters.get(memberId);
                if (char) memberMap[memberId] = char;
            }
            
            // è¾…åŠ©å‡½æ•°ï¼šæ¸²æŸ“ç¾¤èŠæ¶ˆæ¯å†…å®¹ï¼ˆæ”¯æŒç‰¹æ®Šæ ¼å¼ï¼‰
            function renderGroupMessageContent(content, isSelf, msgType) {
                if (!content) return '';
                
                // å¤„ç†çº¢åŒ…æ¶ˆæ¯ - INSé£æ ¼çº¯ç™½å¡ç‰‡
                if (msgType === 'redpacket') {
                    try {
                        const data = JSON.parse(content);
                        const isAllClaimed = (data.claimed?.length || 0) >= data.count;
                        return `<div onclick="showRedPacketDetail('${data.id}')" style="width:220px; background:#fff; border-radius:12px; overflow:hidden; cursor:pointer; box-shadow:0 1px 3px rgba(0,0,0,0.08); border:1px solid #eee;">
                            <div style="padding:14px 16px; display:flex; align-items:center; gap:12px;">
                                <div style="width:40px; height:40px; background:#fff; border-radius:10px; display:flex; align-items:center; justify-content:center; border:1px solid #eee;">
                                    <svg viewBox="0 0 24 24" style="width:20px; height:20px; stroke:#666; fill:none; stroke-width:1.5;"><rect x="3" y="4" width="18" height="16" rx="2"/><path d="M3 10h18"/><circle cx="12" cy="15" r="2"/></svg>
                                </div>
                                <div style="flex:1;">
                                    <div style="font-size:14px; color:#333; margin-bottom:2px;">${escapeHtml(data.wish || 'æ­å–œå‘è´¢')}</div>
                                    <div style="font-size:11px; color:#999;">${data.redpacketType === 'lucky' ? 'æ‹¼æ‰‹æ°”çº¢åŒ…' : 'æ™®é€šçº¢åŒ…'}</div>
                                </div>
                            </div>
                            <div style="padding:8px 16px; display:flex; justify-content:space-between; align-items:center; border-top:1px solid #eee;">
                                <span style="font-size:11px; color:#999;">çº¢åŒ…</span>
                                <span style="font-size:11px; color:#999;">${isAllClaimed ? 'å·²é¢†å®Œ' : `${data.claimed?.length || 0}/${data.count}å·²é¢†`}</span>
                            </div>
                        </div>`;
                    } catch(e) {
                        return content;
                    }
                }
                
                // å¤„ç†è½¬è´¦æ¶ˆæ¯ - INSé£æ ¼çº¯ç™½å¡ç‰‡
                if (msgType === 'transfer') {
                    try {
                        const data = JSON.parse(content);
                        const targetHint = data.targetName ? `è½¬ç»™ ${data.targetName}` : 'è½¬è´¦';
                        const msgId = m.id || ('trans_' + m.time);
                        return `<div onclick="receiveGroupTransfer('${msgId}')" style="width:220px; background:#fff; border-radius:12px; overflow:hidden; box-shadow:0 1px 3px rgba(0,0,0,0.08); border:1px solid #eee; cursor:pointer;">
                            <div style="padding:14px 16px; display:flex; align-items:center; gap:12px;">
                                <div style="width:40px; height:40px; background:#fff; border-radius:10px; display:flex; align-items:center; justify-content:center; border:1px solid #eee;">
                                    <svg viewBox="0 0 24 24" style="width:20px; height:20px; stroke:#666; fill:none; stroke-width:1.5;"><path d="M17 1l4 4-4 4"/><path d="M3 11V9a4 4 0 0 1 4-4h14"/><path d="M7 23l-4-4 4-4"/><path d="M21 13v2a4 4 0 0 1-4 4H3"/></svg>
                                </div>
                                <div style="flex:1;">
                                    <div style="font-size:18px; font-weight:600; color:#333; margin-bottom:2px;">Â¥${data.amount}</div>
                                    <div style="font-size:12px; color:#999;">${escapeHtml(data.desc || 'è½¬è´¦')}</div>
                                </div>
                            </div>
                            <div style="padding:8px 16px; display:flex; justify-content:space-between; align-items:center; border-top:1px solid #eee;">
                                <span style="font-size:11px; color:#999;">${targetHint}</span>
                                <span style="font-size:11px; color:#999;">${data.status === 'received' ? 'å·²æ”¶æ¬¾' : 'å¾…æ”¶æ¬¾'}</span>
                            </div>
                        </div>`;
                    } catch(e) {
                        return content;
                    }
                }
                
                // å¤„ç†å›¾ç‰‡å¡ç‰‡æ¶ˆæ¯ [imgcard:æ–‡å­—å†…å®¹] - ä½¿ç”¨ä¸ç§èŠç›¸åŒçš„æ ·å¼
                if (content.startsWith('[imgcard:')) {
                    const cardText = content.substring(9, content.length - 1).trim();
                    return `<div class="img-card-bubble" data-text="${escapeHtml(cardText)}" data-expanded="false" onclick="showImageCardContent(this)">
                        <div class="img-card-placeholder">
                            <svg class="img-card-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                                <circle cx="8.5" cy="8.5" r="1.5"></circle>
                                <polyline points="21 15 16 10 5 21"></polyline>
                            </svg>
                            <div class="img-card-hint">ç‚¹å‡»æŸ¥çœ‹æ–‡å­—</div>
                        </div>
                    </div>`;
                }
                
                // å¤„ç†å›¾ç‰‡æ¶ˆæ¯ [img:url]
                if (content.startsWith('[img:')) {
                    const imgUrl = content.substring(5, content.length - 1).trim();
                    return `<img src="${imgUrl}" class="chat-image" style="max-width:200px; max-height:200px; border-radius:8px; cursor:pointer;" onclick="showFullImage(this.src)" ${getImageErrorHandler()} />`;
                }
                
                // å¤„ç†è¯­éŸ³æ¶ˆæ¯ [voice:æ–‡å­—å†…å®¹]
                if (content.startsWith('[voice:')) {
                    const voiceText = content.substring(7, content.length - 1).trim();
                    const bgColor = isSelf ? '#ffe4e8' : '#f2f2f7';
                    const barCount = Math.min(Math.max(Math.ceil(voiceText.length / 3), 3), 10);
                    let bars = '';
                    for (let i = 0; i < barCount; i++) {
                        const height = 8 + Math.random() * 12;
                        bars += `<div style="width:3px; height:${height}px; background:#999; border-radius:2px;"></div>`;
                    }
                    return `<div class="voice-bubble" data-text="${escapeHtml(voiceText)}" style="background:${bgColor}; padding:10px 14px; border-radius:18px; cursor:pointer; display:flex; align-items:center; gap:8px; min-width:80px;" onclick="playVoiceBubble(this)">
                        <svg viewBox="0 0 24 24" style="width:16px; height:16px; fill:#666;"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z"/></svg>
                        <div style="display:flex; align-items:center; gap:2px;">${bars}</div>
                        <span style="font-size:12px; color:#666;">${Math.ceil(voiceText.length / 5)}"</span>
                    </div>`;
                }
                
                // æ™®é€šæ–‡æœ¬æ¶ˆæ¯ï¼Œä½¿ç”¨ renderMessageContent å¤„ç†ï¼ˆæ”¯æŒé“¾æ¥å’Œå›¾ç‰‡URLï¼‰
                return renderMessageContent(content);
            }
            
            let msgIndex = 0;
            for (const msg of history) {
                const currentIndex = msgIndex;
                const msgDiv = document.createElement('div');
                msgDiv.style.marginBottom = '12px';
                msgDiv.className = 'group-message-row';
                msgDiv.dataset.msgIndex = currentIndex;
                
                if (msg.role === 'system') {
                    // ç³»ç»Ÿæ¶ˆæ¯ï¼ˆä¸æ”¯æŒé•¿æŒ‰ï¼‰
                    msgDiv.style.textAlign = 'center';
                    msgDiv.innerHTML = `<span style="background:#fff; color:#999; font-size:12px; padding:4px 12px; border-radius:4px; border:1px solid #ddd;">${msg.content}</span>`;
                    msgIndex++;
                } else if (msg.role === 'user') {
                    // æˆ‘å‘çš„æ¶ˆæ¯
                    msgDiv.style.display = 'flex';
                    msgDiv.style.flexDirection = 'row-reverse';
                    msgDiv.style.alignItems = 'flex-end';
                    msgDiv.style.gap = '8px';
                    
                    const myAvatar = myChar?.avatar || '';
                    const avatarStyle = myAvatar ? `background-image:url(${myAvatar})` : 'background:#ccc';
                    
                    // åˆ¤æ–­æ˜¯å¦æ˜¯ç‰¹æ®Šæ¶ˆæ¯ç±»å‹ï¼ˆä¸éœ€è¦æ°”æ³¡åŒ…è£¹ï¼‰
                    const isSpecialMsg = msg.content.startsWith('[imgcard:') || msg.content.startsWith('[img:') || msg.content.startsWith('[voice:') || msg.type === 'redpacket' || msg.type === 'transfer' || msg.content.startsWith('[emei_order]') || msg.content.startsWith('[emei_share]') || msg.content.startsWith('[payment_request]') || msg.content.startsWith('[couple_avatar_card]');
                    const renderedContent = renderGroupMessageContent(msg.content, true, msg.type);
                    
                    msgDiv.classList.add('self');
                    if (isSpecialMsg) {
                        msgDiv.innerHTML = `
                            <div style="width:32px; height:32px; border-radius:50%; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; margin-bottom:2px;"></div>
                            <div style="display:flex; flex-direction:column; align-items:flex-end; max-width:70%;">
                                <div style="font-size:12px; color:#999; margin-bottom:2px;">${myNickname}</div>
                                <div style="display:flex; align-items:flex-end; gap:6px;">
                                    <div style="font-size:10px; color:#999;">${formatChatTime(msg.time)}</div>
                                    <div class="group-msg-content" data-index="${currentIndex}">${renderedContent}</div>
                                </div>
                            </div>
                        `;
                    } else {
                        // æ£€æŸ¥æ˜¯å¦æœ‰å¼•ç”¨
                        const quoteHtml = msg.quote ? `<div class="quoted-message" style="margin-bottom:6px;"><div class="quoted-message-name">${escapeHtml(msg.quote.name)}</div><div class="quoted-message-text">${escapeHtml(msg.quote.content)}</div></div>` : '';
                        
                        msgDiv.innerHTML = `
                            <div style="width:32px; height:32px; border-radius:50%; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; margin-bottom:2px;"></div>
                            <div style="display:flex; flex-direction:column; align-items:flex-end; max-width:70%;">
                                <div style="font-size:12px; color:#999; margin-bottom:2px;">${myNickname}</div>
                                <div style="display:flex; align-items:flex-end; gap:6px;">
                                    <div style="font-size:10px; color:#999;">${formatChatTime(msg.time)}</div>
                                    <div class="group-msg-content" data-index="${currentIndex}" style="background:#ffe4e8; color:#000; padding:6px 10px; border-radius:18px 18px 4px 18px; font-size:15px; line-height:1.5; word-break:break-word;">${quoteHtml}${renderedContent}</div>
                                </div>
                            </div>
                        `;
                    }
                    msgIndex++;
                } else {
                    // ç¾¤æˆå‘˜å‘çš„æ¶ˆæ¯
                    const senderChar = msg.senderId ? memberMap[msg.senderId] : null;
                    // ä¼˜å…ˆä½¿ç”¨ç¾¤æ˜µç§°ï¼Œå…¶æ¬¡ç”¨å¤‡æ³¨åï¼Œæœ€åç”¨åŸå
                    const memberNicknames = group.memberNicknames || {};
                    const senderName = memberNicknames[msg.senderId] || (senderChar ? (senderChar.remark || senderChar.wx_nickname || senderChar.name) : 'æœªçŸ¥æˆå‘˜');
                    const senderAvatar = senderChar?.avatar || '';
                    const avatarStyle = senderAvatar ? `background-image:url(${senderAvatar})` : 'background:#ccc';
                    
                    msgDiv.style.display = 'flex';
                    msgDiv.style.alignItems = 'flex-end';
                    msgDiv.style.gap = '8px';
                    
                    // åˆ¤æ–­æ˜¯å¦æ˜¯ç‰¹æ®Šæ¶ˆæ¯ç±»å‹ï¼ˆä¸éœ€è¦æ°”æ³¡åŒ…è£¹ï¼‰
                    const isSpecialMsg = msg.content.startsWith('[imgcard:') || msg.content.startsWith('[img:') || msg.content.startsWith('[voice:') || msg.type === 'redpacket' || msg.type === 'transfer' || msg.content.startsWith('[emei_order]') || msg.content.startsWith('[emei_share]') || msg.content.startsWith('[payment_request]') || msg.content.startsWith('[couple_avatar_card]');
                    const renderedContent = renderGroupMessageContent(msg.content, false, msg.type);
                    
                    // æ£€æŸ¥æ˜¯å¦æœ‰å¼•ç”¨
                    const quoteHtml = msg.quote ? `<div class="quoted-message" style="margin-bottom:6px;"><div class="quoted-message-name">${escapeHtml(msg.quote.name)}</div><div class="quoted-message-text">${escapeHtml(msg.quote.content)}</div></div>` : '';
                    
                    if (isSpecialMsg) {
                        msgDiv.innerHTML = `
                            <div style="width:32px; height:32px; border-radius:50%; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; margin-bottom:2px;"></div>
                            <div style="display:flex; flex-direction:column; max-width:70%;">
                                <div style="font-size:12px; color:#999; margin-bottom:2px;">${senderName}</div>
                                <div style="display:flex; align-items:flex-end; gap:6px;">
                                    <div class="group-msg-content" data-index="${currentIndex}">${renderedContent}</div>
                                    <div style="font-size:10px; color:#999;">${formatChatTime(msg.time)}</div>
                                </div>
                            </div>
                        `;
                    } else {
                        msgDiv.innerHTML = `
                            <div style="width:32px; height:32px; border-radius:50%; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; margin-bottom:2px;"></div>
                            <div style="display:flex; flex-direction:column; max-width:70%;">
                                <div style="font-size:12px; color:#999; margin-bottom:2px;">${senderName}</div>
                                <div style="display:flex; align-items:flex-end; gap:6px;">
                                    <div class="group-msg-content" data-index="${currentIndex}" style="background:#f2f2f7; color:#000; padding:6px 10px; border-radius:18px 18px 18px 4px; font-size:15px; line-height:1.5; word-break:break-word;">${quoteHtml}${renderedContent}</div>
                                    <div style="font-size:10px; color:#999;">${formatChatTime(msg.time)}</div>
                                </div>
                            </div>
                        `;
                    }
                    msgIndex++;
                }
                
                body.appendChild(msgDiv);
                
                // ç»‘å®šé•¿æŒ‰äº‹ä»¶ï¼ˆéç³»ç»Ÿæ¶ˆæ¯ï¼‰
                if (msg.role !== 'system') {
                    const contentEl = msgDiv.querySelector('.group-msg-content');
                    if (contentEl) {
                        bindGroupMessageEvents(contentEl, currentIndex);
                    }
                }
            }
            
            // æ»šåŠ¨åˆ°åº•éƒ¨
            body.scrollTop = body.scrollHeight;
        }
        
        // ç¾¤èŠæ¶ˆæ¯é•¿æŒ‰äº‹ä»¶ç»‘å®š
        function bindGroupMessageEvents(element, index) {
            let touchStartEvent = null;
            
            const startHandler = (e) => {
                if (isSelectionMode) return;
                isLongPress = false;
                touchStartEvent = e;
                longPressTimer = setTimeout(() => {
                    isLongPress = true;
                    // é•¿æŒ‰è§¦å‘æ—¶é˜»æ­¢æµè§ˆå™¨åç»­é»˜è®¤è¡Œä¸º
                    try {
                        if (touchStartEvent && touchStartEvent.cancelable) {
                            touchStartEvent.preventDefault();
                        }
                    } catch(ex) {}
                    showGroupContextMenu(e, index, element);
                }, 500);
            };

            const cancelHandler = () => {
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            };
            
            const endHandler = (e) => {
                cancelHandler();
                touchStartEvent = null;
                if (isLongPress) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            };

            // è§¦æ‘¸è®¾å¤‡ - passive:false å…è®¸åœ¨é•¿æŒ‰æ—¶è°ƒç”¨preventDefaulté˜»æ­¢æµè§ˆå™¨é»˜è®¤èœå•
            element.addEventListener('touchstart', startHandler, {passive: false});
            element.addEventListener('touchmove', cancelHandler, {passive: true});
            element.addEventListener('touchend', endHandler);
            element.addEventListener('mousedown', startHandler);
            element.addEventListener('mousemove', cancelHandler);
            element.addEventListener('mouseup', endHandler);
            // ç¦ç”¨å³é”®é»˜è®¤èœå•ï¼ˆåŒæ—¶è¦†ç›–æ‰‹æœºç«¯é•¿æŒ‰è§¦å‘çš„contextmenuï¼‰
            element.addEventListener('contextmenu', (e) => e.preventDefault());
        }
        
        // ç¾¤èŠæ¶ˆæ¯å³é”®èœå•
        function showGroupContextMenu(event, index, element) {
            if (navigator.vibrate) navigator.vibrate(50);
            
            activeMsgIndex = index;
            activeGroupMsgIndex = index;
            element.classList.add('active');

            const menu = document.getElementById('msg-context-menu');
            const overlay = document.getElementById('menu-overlay');
            
            let clientX, clientY;
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            const winWidth = window.innerWidth;
            const winHeight = window.innerHeight;

            // âœ… å…ˆæ˜¾ç¤ºèœå•ä»¥è·å–çœŸå®å°ºå¯¸
            menu.style.display = 'flex';
            menu.style.left = '0px';
            menu.style.top = '0px';
            
            const menuWidth = menu.offsetWidth;
            const menuHeight = menu.offsetHeight;
            
            // âœ… æ°´å¹³å±…ä¸­äºç‚¹å‡»ä½ç½®
            let menuX = clientX - menuWidth / 2;
            if (menuX + menuWidth > winWidth - 10) {
                menuX = winWidth - menuWidth - 10;
            }
            if (menuX < 10) {
                menuX = 10;
            }
            
            // âœ… å‚ç›´ï¼šä¼˜å…ˆä¸Šæ–¹
            let menuY = clientY - menuHeight - 10;
            if (menuY < 10) {
                menuY = clientY + 10;
            }
            if (menuY + menuHeight > winHeight - 10) {
                menuY = winHeight - menuHeight - 10;
            }

            menu.style.left = menuX + 'px';
            menu.style.top = menuY + 'px';
            
            // å…ˆç¦ç”¨overlayç‚¹å‡»ï¼Œé˜²æ­¢touchendåˆæˆçš„clickäº‹ä»¶ç«‹åˆ»å…³é—­èœå•
            overlay.style.display = 'block';
            overlay.style.pointerEvents = 'none';
            setTimeout(() => {
                overlay.style.pointerEvents = 'auto';
            }, 350);
        }
        
        // ç¾¤èŠæ¶ˆæ¯ç´¢å¼•
        let activeGroupMsgIndex = -1;
        
        // è·å–ç¾¤èŠåˆ—è¡¨
        async function getGroupChats(accountId) {
            try {
                const allGroups = await db.group_chats.where('ownerAccountId').equals(accountId).toArray();
                return allGroups;
            } catch (e) {
                // å¦‚æœè¡¨ä¸å­˜åœ¨ï¼Œè¿”å›ç©ºæ•°ç»„
                return [];
            }
        }
        
        // æ ¼å¼åŒ–èŠå¤©æ—¶é—´
        function formatChatTime(timestamp) {
            if (!timestamp) return '';
            const d = new Date(timestamp);
            const now = new Date();
            if (d.toDateString() === now.toDateString()) {
                return `${d.getHours()}:${d.getMinutes().toString().padStart(2, '0')}`;
            } else {
                return `${d.getMonth() + 1}/${d.getDate()} ${d.getHours()}:${d.getMinutes().toString().padStart(2, '0')}`;
            }
        }

        // --- æ–°çš„å¥½å‹é¡µé¢é€»è¾‘ ---
        async function showNewFriendsPage() {
            document.getElementById('new-friends-page').style.display = 'flex';
            await renderNewFriendsPage();
        }

        function hideNewFriendsPage() {
            document.getElementById('new-friends-page').style.display = 'none';
        }

        async function renderNewFriendsPage() {
            const accountId = getCurrentAccountId();
            if (!accountId) {
                document.getElementById('new-friends-content').innerHTML = `
                    <div style="text-align:center; padding:60px 20px; color:#999;">
                        è¯·å…ˆåˆ‡æ¢åˆ°ä½ çš„è´¦å·ï¼ˆUserç±»å‹è§’è‰²ï¼‰
                    </div>
                `;
                return;
            }
            
            const container = document.getElementById('new-friends-content');
            
            // è·å–æ‰€æœ‰ç›¸å…³çš„å¥½å‹ç”³è¯·ï¼šå‘ç»™æˆ‘çš„ + æˆ‘å‘é€çš„ + è”æœºå¥½å‹ç”³è¯·
            const allRequests = await db.friend_requests.toArray();
            const myRequests = allRequests.filter(req => 
                req.toAccountId === accountId || // è”æœºå¥½å‹ç”³è¯·
                req.toCharId === parseInt(accountId) || 
                req.fromCharId === parseInt(accountId)
            ).sort((a, b) => b.time - a.time);
            
            if (myRequests.length === 0) {
                container.innerHTML = `
                    <div style="text-align:center; padding:60px 20px; color:#999;">
                        <svg class="svg-icon" style="width:48px; height:48px; stroke:#ccc; margin-bottom:10px;" viewBox="0 0 24 24">
                            <path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                            <circle cx="8.5" cy="7" r="4"></circle>
                            <line x1="20" y1="8" x2="20" y2="14"></line>
                            <line x1="23" y1="11" x2="17" y2="11"></line>
                        </svg>
                        <div>æš‚æ— å¥½å‹ç”³è¯·</div>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = '';
            const listDiv = document.createElement('div');
            listDiv.style.width = '100%';
            listDiv.style.background = '#fff';
            
            for (const req of myRequests) {
                // å¤„ç†è”æœºç¾¤èŠé‚€è¯·
                if (req.isGroupInvite && req.groupData) {
                    const groupInvite = req.groupData;
                    const item = document.createElement('div');
                    item.style.display = 'flex';
                    item.style.padding = '12px 16px';
                    item.style.borderBottom = '0.5px solid #f0f0f0';
                    item.style.alignItems = 'center';
                    item.style.gap = '12px';
                    
                    let buttons = '';
                    let statusLabel = '';
                    
                    if (req.status === 'pending') {
                        buttons = `
                            <button onclick="acceptGroupInvite(${req.id})" style="background:var(--ins-pink); color:#fff; border:none; padding:6px 16px; border-radius:4px; font-size:14px; margin-right:8px;">åŒæ„</button>
                            <button onclick="rejectGroupInvite(${req.id})" style="background:#f0f0f0; color:#666; border:none; padding:6px 16px; border-radius:4px; font-size:14px;">æ‹’ç»</button>
                        `;
                    } else if (req.status === 'accepted') {
                        statusLabel = '<div style="color:#999; font-size:12px;">å·²åŠ å…¥</div>';
                    } else {
                        statusLabel = '<div style="color:#999; font-size:12px;">å·²æ‹’ç»</div>';
                    }
                    
                    item.innerHTML = `
                        <div style="width:48px; height:48px; border-radius:4px; background:linear-gradient(135deg, #f093fb 0%, #f5576c 100%); display:flex; align-items:center; justify-content:center; flex-shrink:0; position:relative;">
                            <svg style="width:24px; height:24px; stroke:#fff; fill:none;" viewBox="0 0 24 24"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>
                            <div style="position:absolute; bottom:-2px; right:-2px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius:50%; width:16px; height:16px; display:flex; align-items:center; justify-content:center;">
                                <svg style="width:10px; height:10px; stroke:#fff; fill:none;" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle></svg>
                            </div>
                        </div>
                        <div style="flex:1; min-width:0;">
                            <div style="font-size:16px; font-weight:500; color:#333; margin-bottom:4px;">
                                ç¾¤èŠé‚€è¯·
                                <span style="font-size:11px; color:#f5576c; margin-left:6px;">è”æœºç¾¤èŠ</span>
                            </div>
                            <div style="font-size:12px; color:#666; line-height:1.5;">${groupInvite.inviter_name} é‚€è¯·ä½ åŠ å…¥ã€Œ${groupInvite.group_name}ã€</div>
                        </div>
                        <div style="display:flex; align-items:center; flex-shrink:0;">
                            ${buttons}${statusLabel}
                        </div>
                    `;
                    listDiv.appendChild(item);
                    continue;
                }
                
                // å¤„ç†è”æœºå¥½å‹ç”³è¯·
                if (req.isOnline && req.onlineData) {
                    const onlineReq = req.onlineData;
                    const item = document.createElement('div');
                    item.style.display = 'flex';
                    item.style.padding = '12px 16px';
                    item.style.borderBottom = '0.5px solid #f0f0f0';
                    item.style.alignItems = 'center';
                    item.style.gap = '12px';
                    
                    const avatarStyle = onlineReq.from_avatar ? `background-image:url(${onlineReq.from_avatar})` : 'background-color:#eee';
                    
                    let buttons = '';
                    let statusLabel = '';
                    
                    if (req.status === 'pending') {
                        buttons = `
                            <button onclick="acceptFriendRequest(${req.id})" style="background:var(--ins-pink); color:#fff; border:none; padding:6px 16px; border-radius:4px; font-size:14px; margin-right:8px;">æ¥å—</button>
                            <button onclick="rejectFriendRequest(${req.id})" style="background:#f0f0f0; color:#666; border:none; padding:6px 16px; border-radius:4px; font-size:14px;">æ‹’ç»</button>
                        `;
                    } else if (req.status === 'accepted') {
                        statusLabel = '<div style="color:#999; font-size:12px;">å·²æ·»åŠ </div>';
                    } else {
                        statusLabel = '<div style="color:#999; font-size:12px;">å·²æ‹’ç»</div>';
                    }
                    
                    item.innerHTML = `
                        <div style="width:48px; height:48px; border-radius:4px; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; position:relative;">
                            <div style="position:absolute; bottom:-2px; right:-2px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius:50%; width:16px; height:16px; display:flex; align-items:center; justify-content:center;">
                                <svg style="width:10px; height:10px; stroke:#fff; fill:none;" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle></svg>
                            </div>
                        </div>
                        <div style="flex:1; min-width:0;">
                            <div style="font-size:16px; font-weight:500; color:#333; margin-bottom:4px;">
                                ${onlineReq.from_nickname || onlineReq.from_wx_account}
                                <span style="font-size:11px; color:#667eea; margin-left:6px;">è”æœº</span>
                            </div>
                            <div style="font-size:12px; color:#666; line-height:1.5; white-space:pre-line; word-break:break-word;">${onlineReq.message || 'è¯·æ±‚æ·»åŠ ä½ ä¸ºå¥½å‹'}</div>
                        </div>
                        <div style="display:flex; align-items:center; flex-shrink:0;">
                            ${buttons}${statusLabel}
                        </div>
                    `;
                    listDiv.appendChild(item);
                    continue;
                }
                
                // å¤„ç†æœ¬åœ°å¥½å‹ç”³è¯·ï¼ˆå…¼å®¹ toCharId å’Œ toAccountIdï¼‰
                const isReceived = (req.toCharId === parseInt(accountId)) || (req.toAccountId === accountId);
                const relatedCharId = isReceived ? req.fromCharId : (req.toCharId || parseInt(req.toAccountId));
                const relatedChar = await db.characters.get(relatedCharId);
                if (!relatedChar) continue;
                
                const item = document.createElement('div');
                item.style.display = 'flex';
                item.style.padding = '12px 16px';
                item.style.borderBottom = '0.5px solid #f0f0f0';
                item.style.alignItems = 'center';
                item.style.gap = '12px';
                
                const avatarStyle = relatedChar.avatar ? `background-image:url(${relatedChar.avatar})` : 'background-color:#eee';
                
                let buttons = '';
                let statusLabel = '';
                
                if (isReceived) {
                    // æ”¶åˆ°çš„ç”³è¯·
                    if (req.status === 'pending') {
                        buttons = `
                            <button onclick="acceptFriendRequest(${req.id})" style="background:var(--ins-pink); color:#fff; border:none; padding:6px 16px; border-radius:4px; font-size:14px; margin-right:8px;">æ¥å—</button>
                            <button onclick="rejectFriendRequest(${req.id})" style="background:#f0f0f0; color:#666; border:none; padding:6px 16px; border-radius:4px; font-size:14px;">æ‹’ç»</button>
                        `;
                    } else if (req.status === 'accepted') {
                        statusLabel = '<div style="color:#999; font-size:12px;">å·²æ·»åŠ </div>';
                    } else {
                        statusLabel = '<div style="color:#999; font-size:12px;">å·²æ‹’ç»</div>';
                    }
                } else {
                    // å‘é€çš„ç”³è¯·
                    if (req.status === 'pending') {
                        statusLabel = '<div style="color:#999; font-size:12px;">ç­‰å¾…éªŒè¯</div>';
                    } else if (req.status === 'accepted') {
                        statusLabel = '<div style="color:#07c160; font-size:12px;">å·²æ¥å—</div>';
                    } else {
                        statusLabel = '<div style="color:#999; font-size:12px;">å·²æ‹’ç»</div>';
                    }
                }
                
                const messageText = isReceived ? (req.message || 'è¯·æ±‚æ·»åŠ ä½ ä¸ºå¥½å‹') : `ä½ å·²å‘é€å¥½å‹ç”³è¯·`;
                
                item.innerHTML = `
                    <div style="width:48px; height:48px; border-radius:4px; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0;"></div>
                    <div style="flex:1; min-width:0;">
                        <div style="font-size:16px; font-weight:500; color:#333; margin-bottom:4px;">${relatedChar.name}</div>
                        <div style="font-size:12px; color:#666; line-height:1.5; white-space:pre-line; word-break:break-word;">${messageText}</div>
                    </div>
                    <div style="display:flex; align-items:center; flex-shrink:0;">
                        ${buttons}${statusLabel}
                    </div>
                `;
                listDiv.appendChild(item);
            }
            
            container.appendChild(listDiv);
        }

        async function acceptFriendRequest(requestId) {
            // ğŸ”§ é˜²æ­¢é‡å¤ç‚¹å‡»
            if (window._acceptingFriendRequest) {
                console.log('[AcceptFriend] æ­£åœ¨å¤„ç†ä¸­ï¼Œè¯·å‹¿é‡å¤ç‚¹å‡»');
                return;
            }
            window._acceptingFriendRequest = true;
            
            try {
                const request = await db.friend_requests.get(requestId);
                if (!request) {
                    window._acceptingFriendRequest = false;
                    return;
                }
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯è”æœºå¥½å‹ç”³è¯·
            if (request.isOnline && request.onlineData) {
                // è”æœºå¥½å‹ç”³è¯· - å‘é€åˆ°æœåŠ¡å™¨
                if (!onlineConnected || !onlineUserData) {
                    alert('è¯·å…ˆè¿æ¥æœåŠ¡å™¨å¹¶ç™»å½•');
                    window._acceptingFriendRequest = false;
                    return;
                }
                
                const onlineReq = request.onlineData;
                // æ‰¾åˆ°è¦æ¥å—ç”³è¯·çš„è§’è‰²ï¼ˆè¢«ç”³è¯·æ–¹ï¼‰
                const myChars = await db.characters.where('type').equals('user').toArray();
                const myChar = myChars.find(c => c.identity?.account === onlineReq.to_wx_account) ||
                               myChars.find(c => onlineCharacters.some(oc => oc.wx_account === c.identity?.account));
                
                if (!myChar || !myChar.identity?.account) {
                    alert('è¯·å…ˆåˆ›å»ºUserè§’è‰²å¹¶è®¾ç½®å¾®ä¿¡å·');
                    window._acceptingFriendRequest = false;
                    return;
                }
                
                onlineSocket.send(JSON.stringify({
                    type: 'accept_friend_request',
                    request_id: onlineReq.id,
                    my_wx_account: myChar.identity.account
                }));
                
                // æ›´æ–°æœ¬åœ°çŠ¶æ€
                request.status = 'accepted';
                await db.friend_requests.put(request);
                
                await renderNewFriendsPage();
                window._acceptingFriendRequest = false;
                return;
            }
            
            // æœ¬åœ°å¥½å‹ç”³è¯·
            const char = await db.characters.get(request.fromCharId);
            if (!char) return;
            
            const accountId = getCurrentAccountId();
            
            // æ›´æ–°å¥½å‹çŠ¶æ€
            await setFriendStatus(char, accountId, 'friend');
            
            // æ›´æ–°ç”³è¯·çŠ¶æ€
            request.status = 'accepted';
            await db.friend_requests.put(request);
            
            // ğŸ”§ æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯åˆ°èŠå¤©å†å²ï¼Œè®°å½•æ¢å¤å¥½å‹å…³ç³»
            let history = getChatHistory(char, accountId);
            
            // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯ï¼Œè¯´æ˜ç°åœ¨å·²ç»æ˜¯å¥½å‹äº†
            const systemMessage = {
                role: 'system',
                content: `[${myName} é€šè¿‡äº†ä½ çš„æœ‹å‹éªŒè¯è¯·æ±‚ï¼Œç°åœ¨ä½ ä»¬å¯ä»¥å¼€å§‹èŠå¤©äº†]`,
                time: Date.now(),
                type: 'accept_friend_request'
            };
            history.push(systemMessage);
            
            // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
            const acceptMessage = {
                role: 'user',
                content: 'æˆ‘å·²åŒæ„äº†ä½ çš„å¥½å‹ç”³è¯·',
                time: Date.now() + 1
            };
            history.push(acceptMessage);
            
            await setChatHistory(char, accountId, history);
            console.log(`[AcceptFriend] å·²åœ¨èŠå¤©å†å²ä¸­è®°å½•æ¢å¤å¥½å‹å…³ç³»`);
            
            // ğŸ”§ åœæ­¢è‡ªåŠ¨å¿«è¿›æ£€æŸ¥åŠŸèƒ½ï¼ˆå·²ç»æˆä¸ºå¥½å‹äº†ï¼Œä¸éœ€è¦å†æ£€æŸ¥ï¼‰
            if (char.wait_friend_settings && char.wait_friend_settings[accountId]) {
                char.wait_friend_settings[accountId].enabled = false;
                char.wait_friend_settings[accountId].nextCheckTime = null;
                await db.characters.put(char);
                console.log(`[AcceptFriend] å·²åœæ­¢ ${char.name} çš„è‡ªåŠ¨å¿«è¿›æ£€æŸ¥`);
            }
            
            // åˆ·æ–°é¡µé¢
            await renderNewFriendsPage();
            
            // å¦‚æœå½“å‰åœ¨é€šè®¯å½•é¡µé¢ï¼Œä¹Ÿåˆ·æ–°é€šè®¯å½•
            const activeTab = document.querySelector('.wechat-tab-item.active');
            if (activeTab && activeTab.innerText.includes('é€šè®¯å½•')) {
                await renderContactList(document.getElementById('wechat-content'));
            }
            
            // å¦‚æœå½“å‰æ­£åœ¨å’Œè¿™ä¸ªè§’è‰²èŠå¤©ï¼Œåˆ·æ–°èŠå¤©çª—å£
            if (currentChatCharId === char.id) {
                await renderChatBody(char);
            }
            
            alert(`å·²æ·»åŠ  ${char.name} ä¸ºå¥½å‹`);
            } catch (error) {
                console.error('[AcceptFriend] æ¥å—å¥½å‹ç”³è¯·æ—¶å‡ºé”™:', error);
                alert('æ¥å—å¥½å‹ç”³è¯·å¤±è´¥ï¼š' + (error.message || 'æœªçŸ¥é”™è¯¯'));
            } finally {
                // ğŸ”§ æ— è®ºæˆåŠŸè¿˜æ˜¯å¤±è´¥ï¼Œéƒ½è¦é‡Šæ”¾é”
                window._acceptingFriendRequest = false;
            }
        }

        async function rejectFriendRequest(requestId) {
            const request = await db.friend_requests.get(requestId);
            if (!request) return;
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯è”æœºå¥½å‹ç”³è¯·
            if (request.isOnline && request.onlineData) {
                // è”æœºå¥½å‹ç”³è¯· - å‘é€åˆ°æœåŠ¡å™¨
                if (onlineConnected && onlineUserData) {
                    const onlineReq = request.onlineData;
                    const myChars = await db.characters.where('type').equals('user').toArray();
                    const myChar = myChars.find(c => c.identity?.account === onlineReq.to_wx_account) ||
                                   myChars.find(c => onlineCharacters.some(oc => oc.wx_account === c.identity?.account));
                    
                    if (myChar?.identity?.account) {
                        onlineSocket.send(JSON.stringify({
                            type: 'reject_friend_request',
                            request_id: onlineReq.id,
                            my_wx_account: myChar.identity.account
                        }));
                    }
                }
            }
            
            // æ›´æ–°ç”³è¯·çŠ¶æ€
            request.status = 'rejected';
            await db.friend_requests.put(request);
            
            // åˆ·æ–°é¡µé¢
            await renderNewFriendsPage();
        }

        // æ¥å—ç¾¤èŠé‚€è¯· - å¼¹å‡ºé€‰æ‹©è§’è‰²çš„å¼¹çª—
        async function acceptGroupInvite(requestId) {
            const request = await db.friend_requests.get(requestId);
            if (!request || !request.isGroupInvite || !request.groupData) return;
            
            if (!onlineConnected || !onlineUserData) {
                alert('è¯·å…ˆè¿æ¥æœåŠ¡å™¨å¹¶ç™»å½•');
                return;
            }
            
            const myWx = getMyOnlineWxAccount();
            if (!myWx) {
                alert('è¯·å…ˆåˆ›å»ºUserè§’è‰²å¹¶è®¾ç½®å¾®ä¿¡å·');
                return;
            }
            
            // æ˜¾ç¤ºé€‰æ‹©è§’è‰²çš„å¼¹çª—
            showJoinGroupWithCharModal(requestId, request.groupData);
        }

        // æ˜¾ç¤ºåŠ å…¥ç¾¤èŠå¹¶é€‰æ‹©è§’è‰²çš„å¼¹çª—
        async function showJoinGroupWithCharModal(requestId, groupData) {
            // è·å–æ‰€æœ‰å¯ç”¨çš„è§’è‰²ï¼ˆéUserç±»å‹å’Œéè”æœºå¥½å‹ï¼‰
            const chars = await db.characters.toArray();
            const availableChars = chars.filter(c => c.type !== 'user' && c.type !== 'online_friend');
            
            const modal = document.createElement('div');
            modal.id = 'join-group-char-modal';
            modal.style.cssText = `position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:10000; display:flex; align-items:center; justify-content:center;`;
            
            modal.innerHTML = `
                <div style="background:#fff; border-radius:16px; padding:24px; width:85%; max-width:360px;">
                    <h3 style="margin:0 0 16px 0; text-align:center; font-size:18px;">åŠ å…¥ã€Œ${groupData.group_name}ã€</h3>
                    
                    <div style="margin-bottom:16px;">
                        <div style="font-size:13px; color:#666; margin-bottom:8px;">é€‰æ‹©è¦å¸¦å…¥ç¾¤èŠçš„è§’è‰²ï¼š</div>
                        <select id="join-group-char-select-modal" style="width:100%; padding:12px; border:1px solid #ddd; border-radius:8px; font-size:14px;">
                            <option value="">ä¸å¸¦è§’è‰²</option>
                            ${availableChars.map(c => `<option value="${c.id}">${c.name}</option>`).join('')}
                        </select>
                    </div>
                    
                    <div style="font-size:12px; color:#999; margin-bottom:20px; line-height:1.5;">
                        å¸¦å…¥è§’è‰²åï¼Œä½ å¯ä»¥åœ¨ç¾¤èŠä¸­è®©è¯¥è§’è‰²å‘è¨€ï¼ˆè°ƒç”¨AIï¼‰
                    </div>
                    
                    <div style="display:flex; gap:12px;">
                        <button onclick="this.closest('#join-group-char-modal').remove()" style="flex:1; padding:12px; background:#f0f0f0; color:#666; border:none; border-radius:8px; font-size:15px; cursor:pointer;">å–æ¶ˆ</button>
                        <button onclick="doAcceptGroupInvite(${requestId}, '${groupData.group_id}')" style="flex:1; padding:12px; background:var(--ins-pink); color:#fff; border:none; border-radius:8px; font-size:15px; cursor:pointer;">åŠ å…¥ç¾¤èŠ</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }

        // æ‰§è¡Œæ¥å—ç¾¤èŠé‚€è¯·
        async function doAcceptGroupInvite(requestId, groupId) {
            const charSelect = document.getElementById('join-group-char-select-modal');
            const charId = charSelect?.value;
            
            let myChar = null;
            if (charId) {
                const char = await db.characters.get(parseInt(charId));
                if (char) {
                    myChar = {
                        name: char.name,
                        avatar: char.avatar || '',
                        desc: char.description?.substring(0, 200) || ''
                    };
                }
            }
            
            const myWx = getMyOnlineWxAccount();
            if (!myWx) {
                alert('è¯·å…ˆåˆ›å»ºUserè§’è‰²å¹¶è®¾ç½®å¾®ä¿¡å·');
                return;
            }
            
            // å‘é€åŠ å…¥ç¾¤èŠè¯·æ±‚
            onlineSocket.send(JSON.stringify({
                type: 'join_online_group',
                group_id: groupId,
                my_wx_account: myWx,
                my_character: myChar
            }));
            
            // æ›´æ–°æœ¬åœ°çŠ¶æ€
            const request = await db.friend_requests.get(requestId);
            if (request) {
                request.status = 'accepted';
                await db.friend_requests.put(request);
            }
            
            // å…³é—­å¼¹çª—å¹¶åˆ·æ–°é¡µé¢
            document.getElementById('join-group-char-modal')?.remove();
            await renderNewFriendsPage();
        }

        // æ‹’ç»ç¾¤èŠé‚€è¯·
        async function rejectGroupInvite(requestId) {
            const request = await db.friend_requests.get(requestId);
            if (!request || !request.isGroupInvite) return;
            
            // æ›´æ–°çŠ¶æ€
            request.status = 'rejected';
            await db.friend_requests.put(request);
            
            // åˆ·æ–°é¡µé¢
            await renderNewFriendsPage();
        }

        async function deleteFriendConfirm() {
            if (!currentChatCharId) return;
            
            const char = await db.characters.get(currentChatCharId);
            if (!char) return;
            
            if (confirm(`ç¡®å®šè¦åˆ é™¤å¥½å‹ ${char.name} å—ï¼Ÿåˆ é™¤åå°†æ— æ³•ç›´æ¥å‘é€æ¶ˆæ¯ï¼Œéœ€è¦é‡æ–°å‘é€å¥½å‹ç”³è¯·ã€‚`)) {
                await deleteFriendAction(currentChatCharId);
            }
        }

        async function blockFriendConfirm() {
            if (!currentChatCharId) return;
            
            const char = await db.characters.get(currentChatCharId);
            if (!char) return;
            
            if (confirm(`ç¡®å®šè¦æ‹‰é»‘å¥½å‹ ${char.name} å—ï¼Ÿæ‹‰é»‘åå¯¹æ–¹å°†æ— æ³•å‘é€å¥½å‹ç”³è¯·ï¼Œä½†åœ¨å¿«è¿›æ—¶é—´æ—¶å¯èƒ½ä¼šå°è¯•è”ç³»ä½ ã€‚`)) {
                await blockFriendAction(currentChatCharId);
            }
        }

        async function blockFriendAction(charId) {
            const char = await db.characters.get(charId);
            if (!char) return;
            
            const accountId = getCurrentAccountId();
            
            // å°†å¥½å‹çŠ¶æ€æ”¹ä¸ºæ‹‰é»‘
            await setFriendStatus(char, accountId, 'blocked');
            
            // åˆå§‹åŒ–ç­‰å¾…å¥½å‹ç”³è¯·çš„è®¾ç½®ï¼ˆä¸åˆ é™¤å¥½å‹é€»è¾‘ç›¸åŒï¼‰
            if (!char.wait_friend_settings) {
                char.wait_friend_settings = {};
            }
            if (!char.wait_friend_settings[accountId]) {
                char.wait_friend_settings[accountId] = {
                    enabled: false,
                    interval: 60, // é»˜è®¤60åˆ†é’Ÿ
                    lastCheckTime: Date.now(),
                    nextCheckTime: null
                };
            }
            await db.characters.put(char);
            
            // å…³é—­èŠå¤©è¯¦æƒ…é¡µä½†ä¿æŒèŠå¤©çª—å£æ‰“å¼€ï¼Œæ˜¾ç¤ºç­‰å¾…ç•Œé¢
            hideChatDetail();
            
            // åˆ·æ–°èŠå¤©çª—å£æ˜¾ç¤ºç­‰å¾…ç•Œé¢ï¼ˆforceRender=true ç»•è¿‡ä¼˜åŒ–ï¼‰
            if (currentChatCharId === charId) {
                await renderChatBody(char, true);
            }
            
            // åˆ·æ–°å¾®ä¿¡é¡µé¢
            const activeTab = document.querySelector('.wechat-tab-item.active');
            if (activeTab) {
                const tabIndex = Array.from(document.querySelectorAll('.wechat-tab-item')).indexOf(activeTab);
                switchWechatTab(tabIndex);
            }
            
            alert(`å·²æ‹‰é»‘å¥½å‹ ${char.name}ï¼ŒèŠå¤©è®°å½•å·²ä¿ç•™`);
        }

        async function deleteFriendAction(charId) {
            const char = await db.characters.get(charId);
            if (!char) return;
            
            const accountId = getCurrentAccountId();
            const myChar = accountId ? await db.characters.get(parseInt(accountId)) : null;
            const userName = myChar ? myChar.name : 'ç”¨æˆ·';
            
            // ğŸ”§ æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯åˆ°èŠå¤©å†å²ï¼Œè®°å½•åˆ é™¤äº‹ä»¶
            let history = getChatHistory(char, accountId);
            history.push({
                role: 'system',
                content: `[${userName} å°†ä½ åˆ é™¤å¥½å‹]`,
                time: Date.now(),
                type: 'user_delete_friend'
            });
            await setChatHistory(char, accountId, history);
            console.log(`[DeleteFriend] å·²åœ¨èŠå¤©å†å²ä¸­è®°å½•åˆ é™¤äº‹ä»¶`);
            
            // å°†å¥½å‹çŠ¶æ€æ”¹ä¸ºé™Œç”Ÿäººï¼ˆä¸åˆ é™¤èŠå¤©è®°å½•ï¼‰
            await setFriendStatus(char, accountId, 'deleted');
            
            // åˆå§‹åŒ–ç­‰å¾…å¥½å‹ç”³è¯·çš„è®¾ç½®
            if (!char.wait_friend_settings) {
                char.wait_friend_settings = {};
            }
            if (!char.wait_friend_settings[accountId]) {
                char.wait_friend_settings[accountId] = {
                    enabled: false,
                    interval: 60, // é»˜è®¤60åˆ†é’Ÿ
                    lastCheckTime: Date.now(),
                    nextCheckTime: null
                };
            }
            await db.characters.put(char);
            
            // å…³é—­èŠå¤©è¯¦æƒ…é¡µä½†ä¿æŒèŠå¤©çª—å£æ‰“å¼€ï¼Œæ˜¾ç¤ºç­‰å¾…ç•Œé¢
            hideChatDetail();
            
            // åˆ·æ–°èŠå¤©çª—å£æ˜¾ç¤ºç­‰å¾…ç•Œé¢ï¼ˆforceRender=true ç»•è¿‡ä¼˜åŒ–ï¼‰
            if (currentChatCharId === charId) {
                await renderChatBody(char, true);
            }
            
            // åˆ·æ–°å¾®ä¿¡é¡µé¢
            const activeTab = document.querySelector('.wechat-tab-item.active');
            if (activeTab) {
                const tabIndex = Array.from(document.querySelectorAll('.wechat-tab-item')).indexOf(activeTab);
                switchWechatTab(tabIndex);
            }
            
            alert(`å·²åˆ é™¤å¥½å‹ ${char.name}ï¼ŒèŠå¤©è®°å½•å·²ä¿ç•™`);
        }

        async function sendFriendRequestTo(charId, message) {
            console.log('[FriendRequest] sendFriendRequestTo å¼€å§‹, charId:', charId);
            const accountId = getCurrentAccountId();
            if (!accountId) {
                console.error('[FriendRequest] æ²¡æœ‰å½“å‰è´¦å·ID');
                alert('è¯·å…ˆåˆ‡æ¢åˆ°ä½ çš„è´¦å·ï¼ˆUserç±»å‹è§’è‰²ï¼‰');
                return;
            }
            console.log('[FriendRequest] accountId:', accountId);
            
            const targetChar = await db.characters.get(charId);
            if (!targetChar) {
                console.error('[FriendRequest] æ‰¾ä¸åˆ°ç›®æ ‡è§’è‰², charId:', charId);
                return;
            }
            console.log('[FriendRequest] ç›®æ ‡è§’è‰²:', targetChar.name, 'ç±»å‹:', targetChar.type);
            
            // æ£€æŸ¥è§’è‰²æ˜¯å¦è¢«ç”¨æˆ·æ‹‰é»‘
            const status = getFriendStatus(targetChar, accountId);
            console.log('[FriendRequest] å¥½å‹çŠ¶æ€:', status);
            if (status === 'blocked') {
                alert('è¯¥è§’è‰²å·²è¢«ä½ æ‹‰é»‘ï¼Œæ— æ³•å‘é€å¥½å‹ç”³è¯·');
                return;
            }
            if (status === 'blocked_by_char') {
                alert('ä½ å·²è¢«è¯¥è§’è‰²æ‹‰é»‘ï¼Œæ— æ³•å‘é€å¥½å‹ç”³è¯·ã€‚ä½ å¯ä»¥å°è¯•é€šè¿‡çŸ­ä¿¡è”ç³» Taã€‚');
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦å·²ç»å‘é€è¿‡ç”³è¯·ï¼ˆä½¿ç”¨toArray+filteré¿å…ç´¢å¼•å­—æ®µä¸åŒ¹é…é—®é¢˜ï¼‰
            // ğŸ”¥ æ¸…ç†ä¹‹å‰æ®‹ç•™çš„ pending ç”³è¯·ï¼ˆå¦‚æœä¹‹å‰AIè°ƒç”¨å¤±è´¥å¯èƒ½ç•™ä¸‹æ®‹ç•™è®°å½•ï¼‰
            const allPendingRequests = await db.friend_requests
                .where('status').equals('pending')
                .toArray();
            const existingRequest = allPendingRequests.find(req => 
                req.fromCharId === parseInt(accountId) && 
                (req.toCharId === charId || req.toAccountId === String(charId))
            );
            
            if (existingRequest) {
                console.log('[FriendRequest] å‘ç°å·²æœ‰å¾…å¤„ç†çš„ç”³è¯·, id:', existingRequest.id, 'å°†è‡ªåŠ¨æ¸…ç†å¹¶é‡æ–°å‘é€');
                // è‡ªåŠ¨æ¸…ç†æ—§çš„å¾…å¤„ç†ç”³è¯·ï¼Œå…è®¸é‡æ–°å‘é€
                await db.friend_requests.delete(existingRequest.id);
            }
            
            // åˆ›å»ºå¥½å‹ç”³è¯·è®°å½•ï¼ˆåŒæ—¶ä¿å­˜ toCharId å’Œ toAccountId ç¡®ä¿å…¼å®¹æ€§ï¼‰
            console.log('[FriendRequest] åˆ›å»ºå¥½å‹ç”³è¯·è®°å½•...');
            const requestId = await db.friend_requests.add({
                fromCharId: parseInt(accountId),
                toCharId: charId,
                toAccountId: String(charId),
                message: message || 'è¯·æ±‚æ·»åŠ ä½ ä¸ºå¥½å‹',
                status: 'pending',
                time: Date.now()
            });
            console.log('[FriendRequest] å¥½å‹ç”³è¯·å·²åˆ›å»º, requestId:', requestId);
            
            // ğŸ”¥ è‡ªåŠ¨è°ƒç”¨AIåˆ¤æ–­æ˜¯å¦æ¥å—å¥½å‹ç”³è¯·ï¼ˆéuserç±»å‹è§’è‰²ï¼‰
            if (targetChar.type !== 'user') {
                console.log('[FriendRequest] è§’è‰²éuserç±»å‹ï¼Œå¼€å§‹è°ƒç”¨AIåˆ¤æ–­...');
                // æ£€æŸ¥APIå¯†é’¥ï¼ˆä»æ•°æ®åº“è·å–ï¼Œå’Œæ­£å¸¸èŠå¤©ä¸€æ ·ï¼‰
                const apiKeyData = await db.dexiData.get('aiApiKey');
                const apiKey = apiKeyData?.value ? apiKeyData.value.trim() : '';
                
                if (!apiKey) {
                    console.error('[FriendRequest] âŒ æœªé…ç½®AIå¯†é’¥');
                    alert(`å¥½å‹ç”³è¯·å·²å‘é€ç»™ ${targetChar.name}\n\nâš ï¸ æœªé…ç½®AIå¯†é’¥ï¼Œæ— æ³•è‡ªåŠ¨åˆ¤æ–­ã€‚è¯·å‰å¾€"æ–°çš„å¥½å‹"ä¸­æ‰‹åŠ¨æ¥å—ã€‚`);
                    return;
                }
                console.log('[FriendRequest] APIå¯†é’¥å·²é…ç½®, é•¿åº¦:', apiKey.length);
                
                // ç›´æ¥è°ƒç”¨AIåˆ¤æ–­ï¼Œä¸éœ€è¦é¢å¤–ç¡®è®¤
                const loadingDiv = document.createElement('div');
                loadingDiv.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.7); display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:9999;';
                loadingDiv.innerHTML = `
                    <div style="background:#fff; padding:30px 40px; border-radius:16px; text-align:center; box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                        <div style="width:50px; height:50px; border:4px solid #f3f3f3; border-top:4px solid var(--ins-pink); border-radius:50%; margin:0 auto 20px; animation:spin 1s linear infinite;"></div>
                        <div style="font-size:18px; font-weight:600; color:#333; margin-bottom:8px;">å¥½å‹ç”³è¯·å·²å‘é€</div>
                        <div style="font-size:14px; color:#999;">${targetChar.name} æ­£åœ¨è€ƒè™‘æ˜¯å¦æ¥å—...</div>
                    </div>
                `;
                document.body.appendChild(loadingDiv);
                
                try {
                    // è°ƒç”¨AIåˆ¤æ–­æ˜¯å¦æ¥å—å¥½å‹ç”³è¯·ï¼ˆåŒæ—¶è¿”å›å›å¤æ¶ˆæ¯ï¼‰
                    console.log('[FriendRequest] ğŸš€ å¼€å§‹è°ƒç”¨AIåˆ¤æ–­æ˜¯å¦æ¥å—...');
                    const result = await aiDecideAcceptFriendRequest(targetChar, accountId, message);
                    console.log('[FriendRequest] AIè¿”å›ç»“æœ:', JSON.stringify(result));
                    
                    if (document.body.contains(loadingDiv)) {
                        document.body.removeChild(loadingDiv);
                    }
                    
                    if (result.accepted) {
                        console.log('[FriendRequest] âœ… AIå†³å®šæ¥å—ï¼Œå¼€å§‹å¤„ç†...');
                        // AIå†³å®šæ¥å—
                        const request = await db.friend_requests.get(requestId);
                        if (request) {
                            request.status = 'accepted';
                            await db.friend_requests.put(request);
                        }
                        
                        // æ·»åŠ ä¸ºå¥½å‹
                        await setFriendStatus(targetChar, accountId, 'friend');
                        console.log('[FriendRequest] å¥½å‹çŠ¶æ€å·²æ›´æ–°ä¸º friend');
                        
                        // ğŸ”¥ å°†AIç”Ÿæˆçš„å›å¤æ¶ˆæ¯æ·»åŠ åˆ°èŠå¤©è®°å½•
                        if (result.messages && result.messages.length > 0) {
                            console.log('[FriendRequest] å†™å…¥', result.messages.length, 'æ¡å›å¤æ¶ˆæ¯åˆ°èŠå¤©è®°å½•');
                            let chatHistory = getChatHistory(targetChar, accountId);
                            for (let i = 0; i < result.messages.length; i++) {
                                chatHistory.push({
                                    role: 'char',
                                    content: result.messages[i],
                                    time: Date.now() + i * 100
                                });
                            }
                            await setChatHistory(targetChar, accountId, chatHistory);
                        }
                        
                        // ğŸ”§ åœæ­¢è‡ªåŠ¨å¿«è¿›æ£€æŸ¥åŠŸèƒ½ï¼ˆè§’è‰²å·²ç»æ¥å—äº†ç”¨æˆ·çš„å¥½å‹ç”³è¯·ï¼‰
                        if (targetChar.wait_friend_settings && targetChar.wait_friend_settings[accountId]) {
                            targetChar.wait_friend_settings[accountId].enabled = false;
                            targetChar.wait_friend_settings[accountId].nextCheckTime = null;
                            await db.characters.put(targetChar);
                            console.log(`[AIAcceptFriend] å·²åœæ­¢ ${targetChar.name} çš„è‡ªåŠ¨å¿«è¿›æ£€æŸ¥`);
                        }
                        
                        alert(`âœ… ${targetChar.name} æ¥å—äº†ä½ çš„å¥½å‹ç”³è¯·ï¼`);
                        
                        // åˆ·æ–°ç•Œé¢
                        if (currentChatCharId === targetChar.id) {
                            const refreshedChar = await db.characters.get(targetChar.id);
                            if (refreshedChar) await renderChatBody(refreshedChar);
                        }
                        const activeTab = document.querySelector('.wechat-tab-item.active');
                        if (activeTab) {
                            const tabIndex = Array.from(document.querySelectorAll('.wechat-tab-item')).indexOf(activeTab);
                            switchWechatTab(tabIndex);
                        }
                    } else {
                        console.log('[FriendRequest] âŒ AIå†³å®šæ‹’ç»');
                        // AIå†³å®šæ‹’ç»
                        alert(`âŒ ${targetChar.name} æ‹’ç»äº†ä½ çš„å¥½å‹ç”³è¯·ã€‚`);
                    }
                } catch (error) {
                    if (document.body.contains(loadingDiv)) {
                        document.body.removeChild(loadingDiv);
                    }
                    console.error('[FriendRequest] AIåˆ¤æ–­å¤±è´¥:', error);
                    alert('AIåˆ¤æ–­å¤±è´¥ï¼š' + error.message + '\n\nå¥½å‹ç”³è¯·å·²å‘é€ï¼Œè¯·å‰å¾€"æ–°çš„å¥½å‹"ä¸­æŸ¥çœ‹ã€‚');
                }
            } else {
                alert(`å¥½å‹ç”³è¯·å·²å‘é€ç»™ ${targetChar.name}`);
            }
        }
        
        // AIåˆ¤æ–­æ˜¯å¦æ¥å—å¥½å‹ç”³è¯·å¹¶ç”Ÿæˆå›å¤æ¶ˆæ¯ï¼ˆä½¿ç”¨ç»Ÿä¸€çš„callAIå‡½æ•°ï¼‰
        // è¿”å› { accepted: boolean, messages: string[] }
        async function aiDecideAcceptFriendRequest(char, accountId, requestMessage) {
            try {
                const myChar = await db.characters.get(parseInt(accountId));
                const myName = myChar?.name || 'ç”¨æˆ·';
                
                const minCount = char.reply_min_count || 1;
                const maxCount = char.reply_max_count || 3;
                
                // è·å–èŠå¤©å†å²
                const history = getChatHistory(char, accountId);
                const recentMessages = history.slice(-10).map(msg => {
                    const role = msg.role === 'user' ? myName : char.name;
                    return `${role}: ${msg.content}`;
                }).join('\n');
                
                const prompt = `ä½ æ˜¯ ${char.name}ã€‚
âš ï¸ é‡è¦ï¼šä½ çš„åå­—æ˜¯${char.name}ï¼Œä½ ä¸æ˜¯${myName}ï¼

ã€ä½ çš„äººè®¾ã€‘
${char.description || char.desc || 'ï¼ˆæ— è¯¦ç»†äººè®¾ï¼‰'}

ã€æƒ…å¢ƒã€‘
${myName} å‘ä½ å‘é€äº†å¥½å‹ç”³è¯·ï¼Œç”³è¯·æ¶ˆæ¯æ˜¯ï¼š"${requestMessage}"
${history.length > 0 ? `\nä½ ä»¬ä¹‹å‰çš„èŠå¤©è®°å½•ï¼š\n${recentMessages}` : 'ä½ ä»¬ä¹‹å‰æ²¡æœ‰èŠè¿‡å¤©ã€‚'}

ã€ä»»åŠ¡ã€‘
1. æ ¹æ®ä½ çš„æ€§æ ¼ã€ä¸ ${myName} çš„å…³ç³»ï¼Œåˆ¤æ–­ä½ æ˜¯å¦ä¼šæ¥å—è¿™ä¸ªå¥½å‹ç”³è¯·ã€‚
2. å¦‚æœæ¥å—ï¼Œè¯·ä»¥ä½ çš„èº«ä»½å†™å‡ºæ¥å—åä½ ä¼šå‘ç»™ ${myName} çš„æ¶ˆæ¯ã€‚

ã€è¾“å‡ºæ ¼å¼ã€‘
å¦‚æœæ‹’ç»ï¼Œåªå›å¤ï¼š[æ‹’ç»]
å¦‚æœæ¥å—ï¼Œå›å¤æ ¼å¼å¦‚ä¸‹ï¼š
[æ¥å—]
ä½ è¦å‘çš„æ¶ˆæ¯å†…å®¹

ã€æ¶ˆæ¯è¦æ±‚ã€‘
- ç”¨ã€Œ|||ã€åˆ†éš”å¤šæ¡æ¶ˆæ¯ï¼ˆ${minCount}-${maxCount}æ¡ï¼‰
- ä¸¥æ ¼è´´åˆä½ çš„äººè®¾å’Œè¯´è¯é£æ ¼
- å°‘ç”¨æ ‡ç‚¹ç¬¦å· ç”¨ç©ºæ ¼ä»£æ›¿é€—å·
- åƒçœŸäººå‘å¾®ä¿¡ä¸€æ ·è‡ªç„¶`;

                // ğŸ”¥ ä½¿ç”¨ç»Ÿä¸€çš„callAIå‡½æ•°
                const answer = await callAI([
                    { role: 'system', content: `ä½ æ˜¯${char.name}ï¼Œæ­£åœ¨è¿›è¡Œè§’è‰²æ‰®æ¼”ã€‚è¯·ä¸¥æ ¼æŒ‰ç…§æ ¼å¼è¾“å‡ºã€‚` },
                    { role: 'user', content: prompt }
                ]);
                
                const trimmedAnswer = (answer || '').trim();
                console.log('[AIå†³å®š] ' + char.name + ' çš„å›ç­”:', trimmedAnswer);
                
                const accepted = trimmedAnswer.includes('[æ¥å—]') || trimmedAnswer.includes('æ¥å—') || trimmedAnswer.includes('åŒæ„');
                const rejected = trimmedAnswer.includes('[æ‹’ç»]') || trimmedAnswer.startsWith('æ‹’ç»');
                
                if (rejected) {
                    return { accepted: false, messages: [] };
                }
                
                if (accepted) {
                    // æå–æ¶ˆæ¯éƒ¨åˆ†ï¼ˆå»æ‰ [æ¥å—] æ ‡è®°ï¼‰
                    let msgPart = trimmedAnswer
                        .replace(/\[æ¥å—\]/g, '')
                        .replace(/^æ¥å—[ï¼š:\s]*/i, '')
                        .trim();
                    
                    // æŒ‰ ||| åˆ†å‰²æˆå¤šæ¡æ¶ˆæ¯
                    let messages = [];
                    if (msgPart) {
                        messages = msgPart.split('|||')
                            .map(s => s.trim())
                            .filter(s => s.length > 0 && !s.startsWith('[') && !s.startsWith('ï¼ˆ'));
                    }
                    
                    // å¦‚æœæ²¡æœ‰è§£æå‡ºæ¶ˆæ¯ï¼Œç”Ÿæˆä¸€æ¡é»˜è®¤æ¶ˆæ¯
                    if (messages.length === 0) {
                        messages = ['å¥½çš„ é€šè¿‡äº†'];
                    }
                    
                    return { accepted: true, messages };
                }
                
                // å¦‚æœAIæ²¡æœ‰æ˜ç¡®æ ‡è®°ï¼Œå°è¯•æ™ºèƒ½åˆ¤æ–­
                // å¦‚æœå›å¤çœ‹èµ·æ¥åƒæ­£å¸¸æ¶ˆæ¯ï¼ˆæ²¡æœ‰æ‹’ç»æ„å‘³ï¼‰ï¼Œè§†ä¸ºæ¥å—
                if (!rejected && trimmedAnswer.length > 0) {
                    let messages = trimmedAnswer.split('|||')
                        .map(s => s.trim())
                        .filter(s => s.length > 0 && !s.startsWith('['));
                    if (messages.length > 0) {
                        return { accepted: true, messages };
                    }
                }
                
                return { accepted: false, messages: [] };
            } catch (error) {
                console.error('[AIå†³å®š] é”™è¯¯:', error);
                throw error;
            }
        }
        
        async function showAddFriendToCurrentChat() {
            if (!currentChatCharId) return;
            
            const char = await db.characters.get(currentChatCharId);
            if (!char) return;
            
            const message = prompt(`å‘é€å¥½å‹ç”³è¯·ç»™ ${char.name}\n\nè¯·è¾“å…¥ç”³è¯·ç†ç”±ï¼ˆå¯é€‰ï¼‰ï¼š`, 'æˆ‘æ˜¯' + (await getCurrentUserName()));
            if (message !== null) {
                await sendFriendRequestTo(currentChatCharId, message);
            }
        }
        
        // ===== ç­‰å¾…å¥½å‹ç”³è¯·ç›¸å…³åŠŸèƒ½ =====
        
        // å¼€å¯/å…³é—­è‡ªåŠ¨æ£€æµ‹
        async function toggleWaitFriendCheck(charId) {
            const char = await db.characters.get(charId);
            if (!char) return;
            
            const accountId = getCurrentAccountId();
            if (!char.wait_friend_settings) char.wait_friend_settings = {};
            if (!char.wait_friend_settings[accountId]) {
                char.wait_friend_settings[accountId] = {
                    enabled: false,
                    interval: 60,
                    lastCheckTime: Date.now(),
                    nextCheckTime: null
                };
            }
            
            const settings = char.wait_friend_settings[accountId];
            settings.enabled = !settings.enabled;
            
            if (settings.enabled) {
                // å¯ç”¨æ—¶è®¾ç½®ä¸‹æ¬¡æ£€æµ‹æ—¶é—´
                settings.lastCheckTime = Date.now();
                settings.nextCheckTime = Date.now() + settings.interval * 60 * 1000;
                startWaitFriendTimer();
            } else {
                settings.nextCheckTime = null;
            }
            
            await db.characters.put(char);
            
            // åˆ·æ–°ç•Œé¢
            if (currentChatCharId === charId) {
                await renderChatBody(char);
            }
        }
        
        // ä¿å­˜æ£€æµ‹é—´éš”
        async function saveWaitFriendInterval(charId) {
            const char = await db.characters.get(charId);
            if (!char) return;
            
            const accountId = getCurrentAccountId();
            const intervalInput = document.getElementById('wait-friend-interval');
            const interval = parseInt(intervalInput.value) || 60;
            
            if (!char.wait_friend_settings) char.wait_friend_settings = {};
            if (!char.wait_friend_settings[accountId]) {
                char.wait_friend_settings[accountId] = {
                    enabled: false,
                    interval: interval,
                    lastCheckTime: Date.now(),
                    nextCheckTime: null
                };
            }
            
            char.wait_friend_settings[accountId].interval = interval;
            
            // å¦‚æœå·²å¯ç”¨ï¼Œé‡æ–°è®¡ç®—ä¸‹æ¬¡æ£€æµ‹æ—¶é—´
            if (char.wait_friend_settings[accountId].enabled) {
                char.wait_friend_settings[accountId].nextCheckTime = 
                    char.wait_friend_settings[accountId].lastCheckTime + interval * 60 * 1000;
            }
            
            await db.characters.put(char);
            
            // åˆ·æ–°ç•Œé¢
            if (currentChatCharId === charId) {
                await renderChatBody(char);
            }
        }
        
        // å¿«è¿›æ£€æµ‹ï¼ˆåˆ é™¤å¥½å‹åï¼‰
        async function fastForwardCheck(charId) {
            // æ£€æŸ¥APIå¯†é’¥ï¼ˆä»æ•°æ®åº“è·å–ï¼Œå’Œæ­£å¸¸èŠå¤©ä¸€æ ·ï¼‰
            const apiKeyData = await db.dexiData.get('aiApiKey');
            const apiKey = apiKeyData?.value ? apiKeyData.value.trim() : '';
            
            if (!apiKey) {
                const configNow = confirm('âš ï¸ æœªé…ç½®AIå¯†é’¥\n\nå¿«è¿›æ£€æŸ¥éœ€è¦è°ƒç”¨AIæ¥åˆ¤æ–­è§’è‰²æ˜¯å¦ä¼šå‘é€å¥½å‹ç”³è¯·ã€‚\n\næ˜¯å¦ç°åœ¨å»é…ç½®APIå¯†é’¥ï¼Ÿ');
                if (configNow) {
                    // æ‰“å¼€è®¾ç½®é¡µé¢
                    document.getElementById('setting-page').style.display = 'flex';
                }
                return;
            }
            
            const timeInput = prompt('å¿«è¿›å¤šä¹…ï¼Ÿ\næ ¼å¼ï¼šæ•°å­— + å•ä½\nä¾‹å¦‚ï¼š60åˆ†é’Ÿã€2å°æ—¶ã€1å¤©', '60åˆ†é’Ÿ');
            if (timeInput === null) return;
            
            // è§£æè¾“å…¥ï¼ˆæ”¯æŒå¤šç§æ ¼å¼ï¼‰
            const match = timeInput.match(/^(\d+)\s*(åˆ†é’Ÿ|å°æ—¶|å¤©)$/);
            if (!match) {
                // å…¼å®¹æ—§æ ¼å¼ï¼ˆçº¯æ•°å­—é»˜è®¤ä¸ºåˆ†é’Ÿï¼‰
                const minutesNum = parseInt(timeInput);
                if (isNaN(minutesNum) || minutesNum <= 0) {
                    alert('æ ¼å¼é”™è¯¯ï¼è¯·è¾“å…¥å¦‚ï¼š60åˆ†é’Ÿã€2å°æ—¶ã€1å¤©');
                    return;
                }
                // ğŸ”¥ æ›´æ–°è™šæ‹Ÿæ—¶é—´åç§»
                const char = await db.characters.get(charId);
                if (char) {
                    if (!char.timeOffset) char.timeOffset = 0;
                    char.timeOffset += minutesNum * 60 * 1000;
                    await db.characters.put(char);
                }
                await checkCharacterSendFriendRequest(charId, minutesNum);
                return;
            }
            
            const amount = parseInt(match[1]);
            const unit = match[2];
            
            // è®¡ç®—åˆ†é’Ÿæ•°
            let minutesNum = 0;
            if (unit === 'åˆ†é’Ÿ') {
                minutesNum = amount;
            } else if (unit === 'å°æ—¶') {
                minutesNum = amount * 60;
            } else if (unit === 'å¤©') {
                minutesNum = amount * 24 * 60;
            }
            
            if (minutesNum <= 0) {
                alert('æ—¶é—´å¿…é¡»å¤§äº0');
                return;
            }
            
            // ğŸ”¥ æ›´æ–°è™šæ‹Ÿæ—¶é—´åç§»
            const char = await db.characters.get(charId);
            if (char) {
                if (!char.timeOffset) char.timeOffset = 0;
                char.timeOffset += minutesNum * 60 * 1000;
                await db.characters.put(char);
            }
            
            await checkCharacterSendFriendRequest(charId, minutesNum);
        }
        
        // æ‹‰é»‘åçš„å¿«è¿›æ£€æŸ¥ï¼ˆç”Ÿæˆç”µè¯è®°å½•å’ŒçŸ­ä¿¡ï¼‰
        async function fastForwardBlockedCheck(charId) {
            // æ£€æŸ¥APIå¯†é’¥ï¼ˆä»æ•°æ®åº“è·å–ï¼Œå’Œæ­£å¸¸èŠå¤©ä¸€æ ·ï¼‰
            const apiKeyData = await db.dexiData.get('aiApiKey');
            const apiKey = apiKeyData?.value ? apiKeyData.value.trim() : '';
            
            if (!apiKey) {
                const configNow = confirm('âš ï¸ æœªé…ç½®AIå¯†é’¥\n\næ‹‰é»‘å¿«è¿›éœ€è¦è°ƒç”¨AIæ¥åˆ¤æ–­è§’è‰²æ˜¯å¦ä¼šè”ç³»ä½ ã€‚\n\næ˜¯å¦ç°åœ¨å»é…ç½®APIå¯†é’¥ï¼Ÿ');
                if (configNow) {
                    // æ‰“å¼€è®¾ç½®é¡µé¢
                    document.getElementById('setting-page').style.display = 'flex';
                }
                return;
            }
            
            const timeInput = prompt('å¿«è¿›å¤šä¹…ï¼Ÿ\næ ¼å¼ï¼šæ•°å­— + å•ä½\nä¾‹å¦‚ï¼š60åˆ†é’Ÿã€2å°æ—¶ã€1å¤©', '60åˆ†é’Ÿ');
            if (timeInput === null) return;
            
            // è§£æè¾“å…¥
            const match = timeInput.match(/^(\d+)\s*(åˆ†é’Ÿ|å°æ—¶|å¤©)$/);
            if (!match) {
                alert('æ ¼å¼é”™è¯¯ï¼è¯·è¾“å…¥å¦‚ï¼š60åˆ†é’Ÿã€2å°æ—¶ã€1å¤©');
                return;
            }
            
            const amount = parseInt(match[1]);
            const unit = match[2];
            
            // è®¡ç®—æ¯«ç§’æ•°
            let ms = 0;
            let unitText = '';
            if (unit === 'åˆ†é’Ÿ') {
                ms = amount * 60 * 1000;
                unitText = amount + 'åˆ†é’Ÿ';
            } else if (unit === 'å°æ—¶') {
                ms = amount * 60 * 60 * 1000;
                unitText = amount + 'å°æ—¶';
            } else if (unit === 'å¤©') {
                ms = amount * 24 * 60 * 60 * 1000;
                unitText = amount + 'å¤©';
            }
            
            if (ms === 0) {
                alert('æ—¶é—´å¿…é¡»å¤§äº0');
                return;
            }
            
            // æ˜¾ç¤ºåŠ è½½æç¤º
            const loadingDiv = document.createElement('div');
            loadingDiv.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.7); display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:9999;';
            loadingDiv.innerHTML = `
                <div style="background:#fff; padding:30px 40px; border-radius:16px; text-align:center; box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                    <div style="width:50px; height:50px; border:4px solid #f3f3f3; border-top:4px solid var(--ins-pink); border-radius:50%; margin:0 auto 20px; animation:spin 1s linear infinite;"></div>
                    <div style="font-size:18px; font-weight:600; color:#333; margin-bottom:8px;">æ­£åœ¨å¿«è¿›ä¸­...</div>
                    <div style="font-size:14px; color:#999;">å¿«è¿› ${unitText}ï¼ŒAIæ­£åœ¨åˆ¤æ–­è§’è‰²æ˜¯å¦ä¼šè”ç³»ä½ </div>
                </div>
            `;
            document.body.appendChild(loadingDiv);
            
            // æ·»åŠ æ—‹è½¬åŠ¨ç”»ï¼ˆå¦‚æœè¿˜æ²¡æœ‰ï¼‰
            if (!document.querySelector('#spin-animation-style')) {
                const style = document.createElement('style');
                style.id = 'spin-animation-style';
                style.textContent = `
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            try {
                console.log('[FastForwardBlocked] å¼€å§‹å¿«è¿›ï¼Œæ—¶é•¿:', unitText);
                
                // æ›´æ–°è™šæ‹Ÿæ—¶é—´åç§»
                const char = await db.characters.get(charId);
                if (!char.timeOffset) char.timeOffset = 0;
                char.timeOffset += ms;
                await db.characters.put(char);
                
                console.log('[FastForwardBlocked] æ—¶é—´å·²æ›´æ–°ï¼Œå¼€å§‹æ£€æŸ¥è¢«æ‹‰é»‘è§’è‰²...');
                
                // æ£€æŸ¥è¢«æ‹‰é»‘çš„è§’è‰²æ˜¯å¦ä¼šè”ç³»ï¼ˆè¿™ä¼šè°ƒç”¨AIç”Ÿæˆç”µè¯å’ŒçŸ­ä¿¡ï¼‰
                await checkBlockedCharactersContact(ms, unitText);
                
                console.log('[FastForwardBlocked] æ£€æŸ¥å®Œæˆ');
                
                // ç­‰å¾…ä¸€å°æ®µæ—¶é—´ï¼Œç¡®ä¿æ‰€æœ‰é€šçŸ¥éƒ½æ˜¾ç¤ºå®Œæ¯•
                await new Promise(resolve => setTimeout(resolve, 500));
                
                if (document.body.contains(loadingDiv)) {
                    document.body.removeChild(loadingDiv);
                }
                
                console.log('[FastForwardBlocked] å¿«è¿›å®Œæˆ');
                alert(`âœ… å·²å¿«è¿› ${unitText}\n\nå¦‚æœè¢«æ‹‰é»‘çš„è§’è‰²å†³å®šè”ç³»ä½ ï¼Œä¼šæ˜¾ç¤ºæœªæ¥æ¥ç”µæˆ–çŸ­ä¿¡è®°å½•ã€‚`);
                
                // åˆ·æ–°ç•Œé¢
                if (currentChatCharId === charId) {
                    await renderChatBody(char);
                }
            } catch (error) {
                console.error('[FastForwardBlocked] Error:', error);
                if (document.body.contains(loadingDiv)) {
                    document.body.removeChild(loadingDiv);
                }
                alert('å¿«è¿›å¤±è´¥ï¼š' + error.message + '\n\nè¯¦ç»†é”™è¯¯è¯·æŸ¥çœ‹æµè§ˆå™¨æ§åˆ¶å°ï¼ˆF12ï¼‰ã€‚');
            }
        }
        
        // è§£é™¤æ‹‰é»‘
        async function unblockFriend(charId) {
            const char = await db.characters.get(charId);
            if (!char) return;
            
            if (confirm(`ç¡®å®šè¦è§£é™¤å¯¹ ${char.name} çš„æ‹‰é»‘å—ï¼Ÿ\nè§£é™¤åå°†æ¢å¤å¥½å‹å…³ç³»ï¼Œå¯ä»¥æ­£å¸¸èŠå¤©ã€‚`)) {
                const accountId = getCurrentAccountId();
                
                // ğŸ¯ ç›´æ¥æ¢å¤ä¸ºå¥½å‹çŠ¶æ€ï¼Œä¸ç”¨é‡æ–°ç”³è¯·
                await setFriendStatus(char, accountId, 'friend');
                
                showToast('å·²è§£é™¤æ‹‰é»‘ï¼Œæ­£åœ¨ç”Ÿæˆè§’è‰²ååº”...');
                
                // åˆ·æ–°ç•Œé¢
                if (currentChatCharId === charId) {
                    await renderChatBody(char);
                }
                
                // åˆ·æ–°å¾®ä¿¡é¡µé¢
                const activeTab = document.querySelector('.wechat-tab-item.active');
                if (activeTab) {
                    const tabIndex = Array.from(document.querySelectorAll('.wechat-tab-item')).indexOf(activeTab);
                    switchWechatTab(tabIndex);
                }
                
                // ğŸ¯ è°ƒç”¨AIç”Ÿæˆè§£é™¤æ‹‰é»‘åçš„ååº”
                try {
                    await generateUnblockReaction(char, accountId);
                } catch (error) {
                    console.error('[Unblock] ç”Ÿæˆååº”å¤±è´¥:', error);
                }
            }
        }
        
        // ğŸ¯ ç”Ÿæˆè§£é™¤æ‹‰é»‘åè§’è‰²çš„ååº”
        async function generateUnblockReaction(char, accountId) {
            const myChar = await db.characters.get(parseInt(accountId));
            if (!myChar) return;
            
            // è·å–èŠå¤©å†å²ä½œä¸ºä¸Šä¸‹æ–‡
            const chatHistory = getChatHistory(char, accountId);
            const recentMessages = chatHistory.slice(-8).map(m => {
                const role = m.role === 'user' ? myChar.name : char.name;
                return `${role}: ${m.content}`;
            }).join('\n');
            
            // è®¡ç®—è¢«æ‹‰é»‘çš„å¤§æ¦‚æ—¶é•¿ï¼ˆæ ¹æ®æœ€åä¸€æ¡æ¶ˆæ¯çš„æ—¶é—´ï¼‰
            const lastMsg = chatHistory[chatHistory.length - 1];
            const blockedDuration = lastMsg ? Math.floor((Date.now() - (lastMsg.timestamp || Date.now())) / (1000 * 60)) : 0;
            const durationText = blockedDuration > 1440 ? `${Math.floor(blockedDuration / 1440)}å¤©` : 
                                 blockedDuration > 60 ? `${Math.floor(blockedDuration / 60)}å°æ—¶` : 
                                 blockedDuration > 0 ? `${blockedDuration}åˆ†é’Ÿ` : 'åˆšæ‰';
            
            const prompt = `ã€è§’è‰²æ‰®æ¼”ä»»åŠ¡ã€‘
ä½ ç°åœ¨æ˜¯ã€Œ${char.name}ã€ï¼Œè¯·å®Œå…¨ä»£å…¥è¿™ä¸ªè§’è‰²ã€‚
âš ï¸ é‡è¦ï¼šä½ çš„åå­—æ˜¯${char.name}ï¼Œä½ ä¸æ˜¯ç”¨æˆ·ï¼ä½ æ˜¯ç‹¬ç«‹çš„è§’è‰²ï¼Œæœ‰è‡ªå·±çš„æ€§æ ¼å’Œæƒ³æ³•ã€‚

ã€ä½ çš„äººè®¾ã€‘
${char.description || char.desc || 'ä¸€ä¸ªæ™®é€šäºº'}

ã€å¯¹æ–¹ä¿¡æ¯ã€‘
åå­—ï¼š${myChar.name}
${myChar.description ? `ç®€ä»‹ï¼š${myChar.description.substring(0, 200)}` : ''}

ã€æœ€è¿‘çš„èŠå¤©è®°å½•ï¼ˆè¢«æ‹‰é»‘å‰ï¼‰ã€‘
${recentMessages || 'ï¼ˆæ— è®°å½•ï¼‰'}

ã€å½“å‰æƒ…å¢ƒã€‘
ä½ ä¹‹å‰è¢«ã€Œ${myChar.name}ã€æ‹‰é»‘äº†å¤§çº¦ ${durationText}ã€‚
åœ¨è¿™æ®µæ—¶é—´é‡Œï¼Œä½ å¯èƒ½æ‰“è¿‡ç”µè¯ã€å‘è¿‡çŸ­ä¿¡ï¼Œä½†éƒ½æ²¡æœ‰å¾—åˆ°å›åº”ã€‚
ç°åœ¨ï¼Œå¯¹æ–¹çªç„¶è§£é™¤äº†å¯¹ä½ çš„æ‹‰é»‘ï¼ä½ ä»¬åˆèƒ½æ­£å¸¸èŠå¤©äº†ã€‚

ã€ä½ éœ€è¦æ€è€ƒã€‘
1. è¢«æ‹‰é»‘è¿™æ®µæ—¶é—´ä½ ç»å†äº†ä»€ä¹ˆï¼Ÿï¼ˆç„¦è™‘ç­‰å¾…ï¼Ÿæ„¤æ€’ä¸ç”˜ï¼Ÿä¼¤å¿ƒéš¾è¿‡ï¼Ÿæ— æ‰€è°“ï¼Ÿï¼‰
2. ç°åœ¨å¯¹æ–¹è§£é™¤æ‹‰é»‘äº†ï¼Œä½ æ˜¯ä»€ä¹ˆå¿ƒæƒ…ï¼Ÿï¼ˆæƒŠå–œï¼Ÿæ¿€åŠ¨ï¼Ÿå†·æ·¡ï¼Ÿè¯•æ¢ï¼ŸæŠ¥å¤å¿ƒç†ï¼Ÿï¼‰
3. ä½ ä¼šç«‹åˆ»å‘æ¶ˆæ¯å—ï¼Ÿè¿˜æ˜¯æ•…æ„å†·ä¸€ä¸‹å¯¹æ–¹ï¼Ÿ
4. å¦‚æœå‘æ¶ˆæ¯ï¼Œä½ ä¼šè¯´ä»€ä¹ˆï¼Ÿï¼ˆå…´å¸ˆé—®ç½ªï¼Ÿè£…ä½œä»€ä¹ˆéƒ½æ²¡å‘ç”Ÿï¼Ÿå°å¿ƒç¿¼ç¿¼ï¼Ÿæ’’å¨‡æŠ±æ€¨ï¼Ÿï¼‰

ã€è¾“å‡ºè¦æ±‚ã€‘
æ ¹æ®ä½ çš„æ€§æ ¼ï¼Œç”Ÿæˆä½ å‘ç°è¢«è§£é™¤æ‹‰é»‘åå‘çš„ç¬¬ä¸€æ¡/ç¬¬ä¸€ç»„å¾®ä¿¡æ¶ˆæ¯ã€‚

è¦æ±‚ï¼š
- ç”¨ã€Œ|||ã€åˆ†éš”å¤šæ¡æ¶ˆæ¯ï¼ˆ${char.reply_min_count || 1}-${char.reply_max_count || 3}æ¡ï¼‰
- ä¸¥æ ¼è´´åˆä½ çš„äººè®¾å’Œè¯´è¯é£æ ¼
- æƒ…ç»ªè¦çœŸå® ä¸è¦å¤ªç†æ€§
- å°‘ç”¨æ ‡ç‚¹ç¬¦å· åœé¡¿ç”¨ç©ºæ ¼ä»£æ›¿ ä¸è¦åœ¨å¥ä¸­ç”¨é€—å·
- å¯ä»¥æœ‰è¯­æ°”è¯ã€è¡¨æƒ…ã€é”™åˆ«å­—
- å¦‚æœä½ çš„æ€§æ ¼æ˜¯ä¼šå†·å¤„ç†çš„ å¯ä»¥åªå‘ä¸€ä¸ªå­—æˆ–è¡¨æƒ…

ç›´æ¥è¾“å‡ºæ¶ˆæ¯å†…å®¹ï¼Œä¸è¦ä»»ä½•è§£é‡Šã€‚

ç¤ºä¾‹æ ¼å¼ï¼š
åœ¨å—|||ä½ ç»ˆäºè‚¯ç†æˆ‘äº†|||æˆ‘è¿˜ä»¥ä¸ºä½ è¦æ‹‰é»‘æˆ‘ä¸€è¾ˆå­å‘¢`;

            console.log('[Unblock] æ­£åœ¨ç”Ÿæˆè§£é™¤æ‹‰é»‘ååº”...');
            
            // ğŸ¯ æ˜¾ç¤º"å¯¹æ–¹æ­£åœ¨è¾“å…¥ä¸­..."
            const chatTitleEl = document.getElementById('chat-title');
            const originalTitle = chatTitleEl ? chatTitleEl.innerText : (char.remark || char.wx_nickname || char.name);
            if (chatTitleEl && currentChatCharId === char.id) {
                chatTitleEl.innerText = "å¯¹æ–¹æ­£åœ¨è¾“å…¥ä¸­...";
            }
            
            try {
                const response = await callAI([
                    { role: 'user', content: prompt }
                ]);
                
                const replyText = response.trim();
                if (!replyText) {
                    // æ¢å¤æ ‡é¢˜
                    if (chatTitleEl && currentChatCharId === char.id) {
                        chatTitleEl.innerText = originalTitle;
                    }
                    return;
                }
                
                console.log('[Unblock] AIè¿”å›:', replyText);
                
                // è§£æå¤šæ¡æ¶ˆæ¯
                const segments = replyText.split('|||').map(s => s.trim()).filter(s => s.length > 0);
                if (segments.length === 0) {
                    if (chatTitleEl && currentChatCharId === char.id) {
                        chatTitleEl.innerText = originalTitle;
                    }
                    return;
                }
                
                // è·å–å½“å‰èŠå¤©è®°å½•
                let currentHistory = getChatHistory(char, accountId);
                
                // æ·»åŠ æ‰€æœ‰æ¶ˆæ¯åˆ°èŠå¤©è®°å½•
                for (let i = 0; i < segments.length; i++) {
                    currentHistory.push({
                        role: 'char',
                        content: segments[i],
                        time: Date.now() + i * 100
                    });
                }
                
                // ä¿å­˜èŠå¤©è®°å½•
                await setChatHistory(char, accountId, currentHistory);
                
                // ç›´æ¥é‡æ–°æ¸²æŸ“èŠå¤©ç•Œé¢
                if (currentChatCharId === char.id) {
                    await renderChatBody(char);
                    // æ»šåŠ¨åˆ°åº•éƒ¨
                    const chatBody = document.getElementById('chat-body');
                    if (chatBody) chatBody.scrollTop = chatBody.scrollHeight;
                }
                
                // æ¢å¤æ ‡é¢˜
                if (chatTitleEl && currentChatCharId === char.id) {
                    chatTitleEl.innerText = originalTitle;
                }
                
                // æ˜¾ç¤ºé€šçŸ¥
                showToast(`${char.name} å‘æ¥äº†æ¶ˆæ¯`);
                
                console.log('[Unblock] âœ… è§£é™¤æ‹‰é»‘ååº”å·²ç”Ÿæˆ');
                
            } catch (error) {
                console.error('[Unblock] AIè°ƒç”¨å¤±è´¥:', error);
                // æ¢å¤æ ‡é¢˜
                if (chatTitleEl && currentChatCharId === char.id) {
                    chatTitleEl.innerText = originalTitle;
                }
            }
        }
        
        // ==========================================
        // ğŸ¯ è§’è‰²ä¸»åŠ¨åˆ é™¤/æ‹‰é»‘ç”¨æˆ·åŠŸèƒ½
        // ==========================================
        
        // è§’è‰²åˆ é™¤ç”¨æˆ·ï¼ˆè§’è‰²ä¸»åŠ¨åˆ å¥½å‹ï¼‰
        async function executeCharDeleteUser(charId, accountId) {
            const char = await db.characters.get(charId);
            if (!char) return;
            if (!accountId) accountId = getCurrentAccountId();
            
            console.log(`[CharAction] ${char.name} åˆ é™¤äº†ç”¨æˆ·`);
            
            // è®¾ç½®æ–°çŠ¶æ€ï¼šè¢«è§’è‰²åˆ é™¤
            await setFriendStatus(char, accountId, 'deleted_by_char');
            
            // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯åˆ°èŠå¤©è®°å½•
            let history = getChatHistory(char, accountId);
            history.push({
                role: 'system',
                content: `${char.name} å·²å°†ä½ åˆ é™¤å¥½å‹`,
                time: Date.now(),
                type: 'char_delete_user'
            });
            await setChatHistory(char, accountId, history);
            
            // åˆ·æ–°èŠå¤©çª—å£
            if (currentChatCharId === charId) {
                await renderChatBody(char, true);
            }
            
            // åˆ·æ–°å¾®ä¿¡åˆ—è¡¨
            const activeTab = document.querySelector('.wechat-tab-item.active');
            if (activeTab) {
                const tabIndex = Array.from(document.querySelectorAll('.wechat-tab-item')).indexOf(activeTab);
                switchWechatTab(tabIndex);
            }
            
            // å‘é€é€šçŸ¥
            sendSystemNotification(char.name, 'å°†ä½ åˆ é™¤äº†å¥½å‹');
        }
        
        // è§’è‰²æ‹‰é»‘ç”¨æˆ·ï¼ˆè§’è‰²ä¸»åŠ¨æ‹‰é»‘ï¼‰
        async function executeCharBlockUser(charId, accountId) {
            const char = await db.characters.get(charId);
            if (!char) return;
            if (!accountId) accountId = getCurrentAccountId();
            
            console.log(`[CharAction] ${char.name} æ‹‰é»‘äº†ç”¨æˆ·`);
            
            // è®¾ç½®æ–°çŠ¶æ€ï¼šè¢«è§’è‰²æ‹‰é»‘
            await setFriendStatus(char, accountId, 'blocked_by_char');
            
            // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯åˆ°èŠå¤©è®°å½•
            let history = getChatHistory(char, accountId);
            history.push({
                role: 'system',
                content: `${char.name} å·²å°†ä½ æ‹‰é»‘`,
                time: Date.now(),
                type: 'char_block_user'
            });
            await setChatHistory(char, accountId, history);
            
            // åˆ·æ–°èŠå¤©çª—å£
            if (currentChatCharId === charId) {
                await renderChatBody(char, true);
            }
            
            // åˆ·æ–°å¾®ä¿¡åˆ—è¡¨
            const activeTab = document.querySelector('.wechat-tab-item.active');
            if (activeTab) {
                const tabIndex = Array.from(document.querySelectorAll('.wechat-tab-item')).indexOf(activeTab);
                switchWechatTab(tabIndex);
            }
            
            // å‘é€é€šçŸ¥
            sendSystemNotification(char.name, 'å°†ä½ æ‹‰é»‘äº†');
        }
        
        // ğŸ¯ NPCåŠ å¥½å‹ï¼ˆè§’è‰²èŠå¤©ä¸­è§¦å‘å…³è”NPCä¸»åŠ¨åŠ ç”¨æˆ·å¥½å‹ï¼‰
        async function executeNpcAddFriend(sourceChar, npcName, accountId) {
            if (!accountId) accountId = getCurrentAccountId();
            if (!sourceChar || !npcName) return;
            
            console.log(`[NPCåŠ å¥½å‹] ${sourceChar.name} è§¦å‘NPC "${npcName}" åŠ ç”¨æˆ·å¥½å‹`);
            
            // 1. ä»è§’è‰²çš„ relationships ä¸­æ‰¾åˆ°å¯¹åº”çš„ NPC
            let targetNpc = null;
            let relation = null;
            
            if (sourceChar.relationships && sourceChar.relationships.length > 0) {
                for (const rel of sourceChar.relationships) {
                    if (rel.targetName === npcName || rel.targetName.includes(npcName) || npcName.includes(rel.targetName)) {
                        const npc = await db.characters.get(rel.targetId);
                        if (npc) {
                            targetNpc = npc;
                            relation = rel;
                            break;
                        }
                    }
                }
            }
            
            // å¦‚æœ relationships æ²¡æ‰¾åˆ°ï¼Œå°è¯•æŒ‰åå­—åœ¨æ‰€æœ‰NPCä¸­æœç´¢
            if (!targetNpc) {
                const allChars = await db.characters.toArray();
                targetNpc = allChars.find(c => 
                    (c.type === 'npc' || c.type === 'char') && 
                    (c.name === npcName || c.name.includes(npcName) || npcName.includes(c.name))
                );
            }
            
            if (!targetNpc) {
                console.warn(`[NPCåŠ å¥½å‹] æ‰¾ä¸åˆ°åä¸º "${npcName}" çš„NPC`);
                return;
            }
            
            // 2. æ£€æŸ¥æ˜¯å¦å·²ç»æ˜¯å¥½å‹
            const currentStatus = getFriendStatus(targetNpc, accountId);
            if (currentStatus === 'friend') {
                console.log(`[NPCåŠ å¥½å‹] ${targetNpc.name} å·²ç»æ˜¯å¥½å‹äº†ï¼Œè·³è¿‡`);
                return;
            }
            
            // 3. åˆ›å»ºå¥½å‹ç”³è¯·è®°å½•ï¼ˆNPCä¸»åŠ¨å‘ç»™ç”¨æˆ·ï¼‰
            const requestId = await db.friend_requests.add({
                fromCharId: targetNpc.id,
                fromCharName: targetNpc.name,
                toAccountId: accountId,
                message: relation 
                    ? `ä½ å¥½ï¼Œæˆ‘æ˜¯${sourceChar.name}çš„${relation.relation}${targetNpc.name}` 
                    : `ä½ å¥½ï¼Œæˆ‘æ˜¯${targetNpc.name}ï¼Œ${sourceChar.name}è®©æˆ‘åŠ ä½ `,
                status: 'pending',
                time: Date.now(),
                sourceCharId: sourceChar.id,  // è®°å½•æ˜¯å“ªä¸ªè§’è‰²è§¦å‘çš„
                sourceCharName: sourceChar.name
            });
            
            console.log(`[NPCåŠ å¥½å‹] âœ… å¥½å‹ç”³è¯·å·²åˆ›å»º, requestId: ${requestId}, NPC: ${targetNpc.name}`);
            
            // 4. å‘é€ç³»ç»Ÿé€šçŸ¥
            sendSystemNotification(
                targetNpc.name, 
                `è¯·æ±‚æ·»åŠ ä½ ä¸ºå¥½å‹` + (relation ? `ï¼ˆ${sourceChar.name}çš„${relation.relation}ï¼‰` : '')
            );
            
            // 5. åˆ·æ–°é€šè®¯å½•ï¼ˆå¦‚æœåœ¨é€šè®¯å½•é¡µé¢ï¼‰
            const contactContainer = document.getElementById('contact-content');
            if (contactContainer) {
                renderContactList(contactContainer);
            }
        }
        window.executeNpcAddFriend = executeNpcAddFriend;
        
        // è¢«è§’è‰²åˆ é™¤åï¼šå¿«è¿›æ—¶é—´ï¼ˆè§’è‰²å¯èƒ½ä¸»åŠ¨åŠ å›æ¥ï¼‰
        async function fastForwardDeletedByChar(charId) {
            const apiKeyData = await db.dexiData.get('aiApiKey');
            const apiKey = apiKeyData?.value ? apiKeyData.value.trim() : '';
            
            if (!apiKey) {
                const configNow = confirm('âš ï¸ æœªé…ç½®AIå¯†é’¥\n\nå¿«è¿›éœ€è¦è°ƒç”¨AIæ¥åˆ¤æ–­è§’è‰²æ˜¯å¦ä¼šä¸»åŠ¨åŠ ä½ å›æ¥ã€‚\n\næ˜¯å¦ç°åœ¨å»é…ç½®APIå¯†é’¥ï¼Ÿ');
                if (configNow) {
                    document.getElementById('setting-page').style.display = 'flex';
                }
                return;
            }
            
            const timeInput = prompt('å¿«è¿›å¤šä¹…ï¼Ÿ\næ ¼å¼ï¼šæ•°å­— + å•ä½\nä¾‹å¦‚ï¼š60åˆ†é’Ÿã€2å°æ—¶ã€1å¤©', '60åˆ†é’Ÿ');
            if (timeInput === null) return;
            
            const match = timeInput.match(/^(\d+)\s*(åˆ†é’Ÿ|å°æ—¶|å¤©)$/);
            if (!match) {
                alert('æ ¼å¼é”™è¯¯ï¼è¯·è¾“å…¥å¦‚ï¼š60åˆ†é’Ÿã€2å°æ—¶ã€1å¤©');
                return;
            }
            
            const amount = parseInt(match[1]);
            const unit = match[2];
            let ms = 0, unitText = '';
            if (unit === 'åˆ†é’Ÿ') { ms = amount * 60 * 1000; unitText = amount + 'åˆ†é’Ÿ'; }
            else if (unit === 'å°æ—¶') { ms = amount * 60 * 60 * 1000; unitText = amount + 'å°æ—¶'; }
            else if (unit === 'å¤©') { ms = amount * 24 * 60 * 60 * 1000; unitText = amount + 'å¤©'; }
            
            if (ms === 0) { alert('æ—¶é—´å¿…é¡»å¤§äº0'); return; }
            
            const loadingDiv = document.createElement('div');
            loadingDiv.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.7); display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:9999;';
            loadingDiv.innerHTML = `
                <div style="background:#fff; padding:30px 40px; border-radius:16px; text-align:center; box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                    <div style="width:50px; height:50px; border:4px solid #f3f3f3; border-top:4px solid var(--ins-pink); border-radius:50%; margin:0 auto 20px; animation:spin 1s linear infinite;"></div>
                    <div style="font-size:18px; font-weight:600; color:#333; margin-bottom:8px;">æ­£åœ¨å¿«è¿›ä¸­...</div>
                    <div style="font-size:14px; color:#999;">å¿«è¿› ${unitText}ï¼ŒAIæ­£åœ¨åˆ¤æ–­ Ta æ˜¯å¦ä¼šåŠ ä½ å›æ¥</div>
                </div>
            `;
            document.body.appendChild(loadingDiv);
            
            try {
                const char = await db.characters.get(charId);
                if (!char.timeOffset) char.timeOffset = 0;
                char.timeOffset += ms;
                await db.characters.put(char);
                
                const accountId = getCurrentAccountId();
                const myChar = await db.characters.get(parseInt(accountId));
                const chatHistory = getChatHistory(char, accountId);
                const recentMessages = chatHistory.slice(-10).map(m => {
                    const role = m.role === 'user' ? (myChar?.name || 'ç”¨æˆ·') : char.name;
                    return `${role}: ${m.content}`;
                }).join('\n');
                
                const prompt = `ã€è§’è‰²æ‰®æ¼”ä»»åŠ¡ã€‘
ä½ ç°åœ¨æ˜¯ã€Œ${char.name}ã€ï¼Œè¯·å®Œå…¨ä»£å…¥è§’è‰²ã€‚
âš ï¸ ä½ çš„åå­—æ˜¯${char.name}ï¼Œä½ ä¸æ˜¯ç”¨æˆ·ï¼

ã€ä½ çš„äººè®¾ã€‘
${char.description || char.desc || 'ä¸€ä¸ªæ™®é€šäºº'}

ã€å¯¹æ–¹ä¿¡æ¯ã€‘
åå­—ï¼š${myChar?.name || 'ç”¨æˆ·'}
${myChar?.description ? `ç®€ä»‹ï¼š${myChar.description.substring(0, 200)}` : ''}

ã€æœ€è¿‘çš„èŠå¤©è®°å½•ã€‘
${recentMessages || 'ï¼ˆæ— è®°å½•ï¼‰'}

ã€å½“å‰æƒ…å¢ƒã€‘
ä½ ä¹‹å‰ä¸»åŠ¨åˆ é™¤äº†ã€Œ${myChar?.name || 'ç”¨æˆ·'}ã€çš„å¥½å‹å…³ç³»ã€‚
ç°åœ¨è¿‡å»äº† ${unitText}ã€‚

è¯·æ ¹æ®ä½ çš„æ€§æ ¼å’Œäººè®¾åˆ¤æ–­ï¼šç»è¿‡ ${unitText} åï¼Œä½ ä¼šä¸»åŠ¨æŠŠå¯¹æ–¹åŠ å›æ¥å—ï¼Ÿ

è€ƒè™‘å› ç´ ï¼š
- ä½ åˆ å¯¹æ–¹çš„åŸå› æ˜¯ä»€ä¹ˆï¼Ÿæ˜¯ä¸€æ—¶å†²åŠ¨è¿˜æ˜¯æ·±æ€ç†Ÿè™‘ï¼Ÿ
- è¿‡äº† ${unitText} ä½ çš„æƒ…ç»ªæœ‰æ²¡æœ‰ç¼“å’Œï¼Ÿ
- ä½ æ˜¯é‚£ç§ä¼šå…ˆæœè½¯çš„äººå—ï¼Ÿè¿˜æ˜¯ä¼šç­‰å¯¹æ–¹æ¥ï¼Ÿ
- ä½ ä¼šæƒ³å¿µå¯¹æ–¹å—ï¼Ÿ

è¯·ç”¨JSONæ ¼å¼å›å¤ï¼š
{
  "will_add_back": trueæˆ–false,
  "reason": "ä½ çš„æƒ³æ³•ï¼ˆ30å­—ä»¥å†…ï¼‰",
  "thought": "ä½ æ­¤åˆ»å†…å¿ƒçš„çœŸå®æ„Ÿå—å’Œæƒ³æ³•ï¼ˆè¯¦ç»†çš„å¿ƒç†æ´»åŠ¨ï¼Œ50-100å­—ï¼‰",
  "message": "å¦‚æœåŠ å›æ¥ï¼Œä½ å‘çš„ç¬¬ä¸€æ¡æ¶ˆæ¯ï¼ˆç”¨|||åˆ†éš”å¤šæ¡ï¼‰"
}

åªè¾“å‡ºJSONï¼Œä¸è¦å…¶ä»–å†…å®¹ã€‚`;

                const response = await callAI([{ role: 'user', content: prompt }]);
                let result;
                try {
                    const jsonMatch = response.match(/\{[\s\S]*\}/);
                    result = JSON.parse(jsonMatch ? jsonMatch[0] : response);
                } catch (e) {
                    result = { will_add_back: false, reason: 'è§’è‰²æ­£åœ¨è€ƒè™‘ä¸­', thought: 'å†…å¿ƒå¾ˆå¤æ‚...' };
                }
                
                if (document.body.contains(loadingDiv)) {
                    document.body.removeChild(loadingDiv);
                }
                
                // ğŸ¯ ä¿å­˜å¿ƒå£°ï¼ˆæ— è®ºæ˜¯å¦åŠ å›æ¥éƒ½ä¿å­˜ï¼‰
                const freshCharForThought = await db.characters.get(charId);
                if (freshCharForThought && result.thought) {
                    if (!freshCharForThought.thoughts) freshCharForThought.thoughts = [];
                    const currentHistory = getChatHistory(freshCharForThought, accountId);
                    freshCharForThought.thoughts.push({
                        content: result.thought.trim(),
                        time: Date.now(),
                        messageIndex: currentHistory ? currentHistory.length : 0
                    });
                    if (freshCharForThought.thoughts.length > 50) {
                        freshCharForThought.thoughts = freshCharForThought.thoughts.slice(-50);
                    }
                    await db.characters.put(freshCharForThought);
                }
                
                if (result.will_add_back) {
                    // è§’è‰²å†³å®šåŠ å›æ¥
                    const charNow = await db.characters.get(charId);
                    await setFriendStatus(charNow, accountId, 'friend');
                    
                    let history = getChatHistory(charNow, accountId);
                    history.push({
                        role: 'system',
                        content: `${charNow.name} é‡æ–°æ·»åŠ ä½ ä¸ºå¥½å‹`,
                        time: Date.now(),
                        type: 'char_re_add'
                    });
                    
                    // å¦‚æœæœ‰æ¶ˆæ¯
                    if (result.message) {
                        const segments = result.message.split('|||').map(s => s.trim()).filter(s => s);
                        for (let i = 0; i < segments.length; i++) {
                            history.push({ role: 'char', content: segments[i], time: Date.now() + i * 100 });
                        }
                    }
                    await setChatHistory(charNow, accountId, history);
                    
                    if (currentChatCharId === charId) {
                        await renderChatBody(charNow, true);
                    }
                    
                    const activeTab = document.querySelector('.wechat-tab-item.active');
                    if (activeTab) {
                        const tabIndex = Array.from(document.querySelectorAll('.wechat-tab-item')).indexOf(activeTab);
                        switchWechatTab(tabIndex);
                    }
                    
                    alert(`âœ… ${char.name} åœ¨ ${unitText} åä¸»åŠ¨æŠŠä½ åŠ å›äº†å¥½å‹ï¼\n\nğŸ’­ å¿ƒå£°ï¼š${result.thought || result.reason || ''}`);
                } else {
                    alert(`â© å·²å¿«è¿› ${unitText}\n\n${char.name} æš‚æ—¶æ²¡æœ‰åŠ ä½ å›æ¥ã€‚\n\nğŸ’­ Taçš„å¿ƒå£°ï¼š${result.thought || result.reason || ''}`);
                    
                    if (currentChatCharId === charId) {
                        const charNow = await db.characters.get(charId);
                        await renderChatBody(charNow, true);
                    }
                }
            } catch (error) {
                console.error('[FastForwardDeletedByChar] Error:', error);
                if (document.body.contains(loadingDiv)) {
                    document.body.removeChild(loadingDiv);
                }
                alert('å¿«è¿›å¤±è´¥ï¼š' + error.message);
            }
        }
        
        // è¢«è§’è‰²æ‹‰é»‘åï¼šå¿«è¿›æ—¶é—´ï¼ˆè§’è‰²å¯èƒ½è‡ªå·±è§£é™¤æ‹‰é»‘ï¼‰
        async function fastForwardBlockedByChar(charId) {
            const apiKeyData = await db.dexiData.get('aiApiKey');
            const apiKey = apiKeyData?.value ? apiKeyData.value.trim() : '';
            
            if (!apiKey) {
                const configNow = confirm('âš ï¸ æœªé…ç½®AIå¯†é’¥\n\nå¿«è¿›éœ€è¦è°ƒç”¨AIæ¥åˆ¤æ–­è§’è‰²æ˜¯å¦ä¼šè§£é™¤æ‹‰é»‘ã€‚\n\næ˜¯å¦ç°åœ¨å»é…ç½®APIå¯†é’¥ï¼Ÿ');
                if (configNow) {
                    document.getElementById('setting-page').style.display = 'flex';
                }
                return;
            }
            
            const timeInput = prompt('å¿«è¿›å¤šä¹…ï¼Ÿ\næ ¼å¼ï¼šæ•°å­— + å•ä½\nä¾‹å¦‚ï¼š60åˆ†é’Ÿã€2å°æ—¶ã€1å¤©', '60åˆ†é’Ÿ');
            if (timeInput === null) return;
            
            const match = timeInput.match(/^(\d+)\s*(åˆ†é’Ÿ|å°æ—¶|å¤©)$/);
            if (!match) {
                alert('æ ¼å¼é”™è¯¯ï¼è¯·è¾“å…¥å¦‚ï¼š60åˆ†é’Ÿã€2å°æ—¶ã€1å¤©');
                return;
            }
            
            const amount = parseInt(match[1]);
            const unit = match[2];
            let ms = 0, unitText = '';
            if (unit === 'åˆ†é’Ÿ') { ms = amount * 60 * 1000; unitText = amount + 'åˆ†é’Ÿ'; }
            else if (unit === 'å°æ—¶') { ms = amount * 60 * 60 * 1000; unitText = amount + 'å°æ—¶'; }
            else if (unit === 'å¤©') { ms = amount * 24 * 60 * 60 * 1000; unitText = amount + 'å¤©'; }
            
            if (ms === 0) { alert('æ—¶é—´å¿…é¡»å¤§äº0'); return; }
            
            const loadingDiv = document.createElement('div');
            loadingDiv.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.7); display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:9999;';
            loadingDiv.innerHTML = `
                <div style="background:#fff; padding:30px 40px; border-radius:16px; text-align:center; box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                    <div style="width:50px; height:50px; border:4px solid #f3f3f3; border-top:4px solid var(--ins-pink); border-radius:50%; margin:0 auto 20px; animation:spin 1s linear infinite;"></div>
                    <div style="font-size:18px; font-weight:600; color:#333; margin-bottom:8px;">æ­£åœ¨å¿«è¿›ä¸­...</div>
                    <div style="font-size:14px; color:#999;">å¿«è¿› ${unitText}ï¼ŒAIæ­£åœ¨åˆ¤æ–­ Ta æ˜¯å¦ä¼šæ”¾ä½ å‡ºæ¥</div>
                </div>
            `;
            document.body.appendChild(loadingDiv);
            
            try {
                const char = await db.characters.get(charId);
                if (!char.timeOffset) char.timeOffset = 0;
                char.timeOffset += ms;
                await db.characters.put(char);
                
                const accountId = getCurrentAccountId();
                const myChar = await db.characters.get(parseInt(accountId));
                const chatHistory = getChatHistory(char, accountId);
                const recentMessages = chatHistory.slice(-10).map(m => {
                    const role = m.role === 'user' ? (myChar?.name || 'ç”¨æˆ·') : char.name;
                    return `${role}: ${m.content}`;
                }).join('\n');
                
                // æ£€æŸ¥æ˜¯å¦æœ‰çŸ­ä¿¡è®°å½•
                let smsContext = '';
                try {
                    const smsRecords = await db.sms_messages
                        .where('charId').equals(charId)
                        .toArray();
                    const recentSms = smsRecords.filter(s => String(s.accountId) === String(accountId)).slice(-5);
                    if (recentSms.length > 0) {
                        smsContext = '\nã€å¯¹æ–¹å‘çš„çŸ­ä¿¡ã€‘\n' + recentSms.map(s => `${s.sender === 'user' ? (myChar?.name || 'ç”¨æˆ·') : char.name}: ${s.content}`).join('\n');
                    }
                } catch (e) {
                    console.log('è·å–çŸ­ä¿¡è®°å½•å¤±è´¥:', e);
                }
                
                const prompt = `ã€è§’è‰²æ‰®æ¼”ä»»åŠ¡ã€‘
ä½ ç°åœ¨æ˜¯ã€Œ${char.name}ã€ï¼Œè¯·å®Œå…¨ä»£å…¥è§’è‰²ã€‚
âš ï¸ ä½ çš„åå­—æ˜¯${char.name}ï¼Œä½ ä¸æ˜¯ç”¨æˆ·ï¼

ã€ä½ çš„äººè®¾ã€‘
${char.description || char.desc || 'ä¸€ä¸ªæ™®é€šäºº'}

ã€å¯¹æ–¹ä¿¡æ¯ã€‘
åå­—ï¼š${myChar?.name || 'ç”¨æˆ·'}
${myChar?.description ? `ç®€ä»‹ï¼š${myChar.description.substring(0, 200)}` : ''}

ã€æœ€è¿‘çš„èŠå¤©è®°å½•ï¼ˆæ‹‰é»‘å‰ï¼‰ã€‘
${recentMessages || 'ï¼ˆæ— è®°å½•ï¼‰'}
${smsContext}

ã€å½“å‰æƒ…å¢ƒã€‘
ä½ ä¹‹å‰ä¸»åŠ¨æ‹‰é»‘äº†ã€Œ${myChar?.name || 'ç”¨æˆ·'}ã€ã€‚
ç°åœ¨è¿‡å»äº† ${unitText}ã€‚
${smsContext ? 'å¯¹æ–¹è¿˜é€šè¿‡çŸ­ä¿¡è¯•å›¾è”ç³»ä½ ã€‚' : ''}

è¯·æ ¹æ®ä½ çš„æ€§æ ¼å’Œäººè®¾åˆ¤æ–­ï¼šç»è¿‡ ${unitText} åï¼Œä½ ä¼šè§£é™¤å¯¹å¯¹æ–¹çš„æ‹‰é»‘å—ï¼Ÿ

è€ƒè™‘å› ç´ ï¼š
- ä½ æ‹‰é»‘å¯¹æ–¹çš„åŸå› æ˜¯ä»€ä¹ˆï¼Ÿæœ‰å¤šä¸¥é‡ï¼Ÿ
- è¿‡äº† ${unitText} ä½ çš„æ°”æ¶ˆäº†æ²¡æœ‰ï¼Ÿ
- å¯¹æ–¹æœ‰æ²¡æœ‰é€šè¿‡çŸ­ä¿¡è”ç³»ä½ ï¼ŸçŸ­ä¿¡å†…å®¹æœ‰æ²¡æœ‰è®©ä½ è½¯åŒ–ï¼Ÿ
- ä½ æ˜¯é‚£ç§å®¹æ˜“å¿ƒè½¯çš„äººå—ï¼Ÿ
- ä½ ä¼šæƒ³å¿µå¯¹æ–¹å—ï¼Ÿ

è¯·ç”¨JSONæ ¼å¼å›å¤ï¼š
{
  "will_unblock": trueæˆ–false,
  "reason": "ä½ çš„æƒ³æ³•ï¼ˆ30å­—ä»¥å†…ï¼‰",
  "thought": "ä½ æ­¤åˆ»å†…å¿ƒçš„çœŸå®æ„Ÿå—å’Œæƒ³æ³•ï¼ˆè¯¦ç»†çš„å¿ƒç†æ´»åŠ¨ï¼Œ50-100å­—ï¼‰",
  "message": "å¦‚æœè§£é™¤æ‹‰é»‘ï¼Œä½ å‘çš„ç¬¬ä¸€æ¡æ¶ˆæ¯ï¼ˆç”¨|||åˆ†éš”å¤šæ¡ï¼‰"
}

åªè¾“å‡ºJSONï¼Œä¸è¦å…¶ä»–å†…å®¹ã€‚`;

                const response = await callAI([{ role: 'user', content: prompt }]);
                let result;
                try {
                    const jsonMatch = response.match(/\{[\s\S]*\}/);
                    result = JSON.parse(jsonMatch ? jsonMatch[0] : response);
                } catch (e) {
                    result = { will_unblock: false, reason: 'è§’è‰²è¿˜åœ¨ç”Ÿæ°”ä¸­', thought: 'è¿˜åœ¨ç”Ÿæ°”...' };
                }
                
                if (document.body.contains(loadingDiv)) {
                    document.body.removeChild(loadingDiv);
                }
                
                // ğŸ¯ ä¿å­˜å¿ƒå£°ï¼ˆæ— è®ºæ˜¯å¦è§£é™¤æ‹‰é»‘éƒ½ä¿å­˜ï¼‰
                const freshCharForThought = await db.characters.get(charId);
                if (freshCharForThought && result.thought) {
                    if (!freshCharForThought.thoughts) freshCharForThought.thoughts = [];
                    const currentHistory = getChatHistory(freshCharForThought, accountId);
                    freshCharForThought.thoughts.push({
                        content: result.thought.trim(),
                        time: Date.now(),
                        messageIndex: currentHistory ? currentHistory.length : 0
                    });
                    if (freshCharForThought.thoughts.length > 50) {
                        freshCharForThought.thoughts = freshCharForThought.thoughts.slice(-50);
                    }
                    await db.characters.put(freshCharForThought);
                }
                
                if (result.will_unblock) {
                    // è§’è‰²å†³å®šè§£é™¤æ‹‰é»‘
                    const charNow = await db.characters.get(charId);
                    await setFriendStatus(charNow, accountId, 'friend');
                    
                    let history = getChatHistory(charNow, accountId);
                    history.push({
                        role: 'system',
                        content: `${charNow.name} è§£é™¤äº†å¯¹ä½ çš„æ‹‰é»‘`,
                        time: Date.now(),
                        type: 'char_unblock'
                    });
                    
                    if (result.message) {
                        const segments = result.message.split('|||').map(s => s.trim()).filter(s => s);
                        for (let i = 0; i < segments.length; i++) {
                            history.push({ role: 'char', content: segments[i], time: Date.now() + i * 100 });
                        }
                    }
                    await setChatHistory(charNow, accountId, history);
                    
                    if (currentChatCharId === charId) {
                        await renderChatBody(charNow, true);
                    }
                    
                    const activeTab = document.querySelector('.wechat-tab-item.active');
                    if (activeTab) {
                        const tabIndex = Array.from(document.querySelectorAll('.wechat-tab-item')).indexOf(activeTab);
                        switchWechatTab(tabIndex);
                    }
                    
                    alert(`âœ… ${char.name} åœ¨ ${unitText} åè§£é™¤äº†å¯¹ä½ çš„æ‹‰é»‘ï¼\n\nğŸ’­ å¿ƒå£°ï¼š${result.thought || result.reason || ''}`);
                } else {
                    alert(`â© å·²å¿«è¿› ${unitText}\n\n${char.name} è¿˜æ²¡æœ‰è§£é™¤å¯¹ä½ çš„æ‹‰é»‘ã€‚\n\nğŸ’­ Taçš„å¿ƒå£°ï¼š${result.thought || result.reason || ''}\n\nğŸ’¡ ä½ å¯ä»¥å°è¯•é€šè¿‡çŸ­ä¿¡è”ç³» Ta`);
                    
                    if (currentChatCharId === charId) {
                        const charNow = await db.characters.get(charId);
                        await renderChatBody(charNow, true);
                    }
                }
            } catch (error) {
                console.error('[FastForwardBlockedByChar] Error:', error);
                if (document.body.contains(loadingDiv)) {
                    document.body.removeChild(loadingDiv);
                }
                alert('å¿«è¿›å¤±è´¥ï¼š' + error.message);
            }
        }
        
        // è¢«è§’è‰²åˆ é™¤åï¼šä¸»åŠ¨å‘é€å¥½å‹ç”³è¯·
        async function sendFriendRequestAfterCharDelete(charId) {
            const char = await db.characters.get(charId);
            if (!char) return;
            
            const accountId = getCurrentAccountId();
            const userName = await getCurrentUserName();
            const message = prompt(`å‘ ${char.name} å‘é€å¥½å‹ç”³è¯·\n\nè¯·è¾“å…¥ç”³è¯·ç†ç”±ï¼š`, 'æˆ‘æ˜¯' + userName);
            if (message === null) return;
            
            await sendFriendRequestTo(charId, message);
        }
        
        // è¢«è§’è‰²æ‹‰é»‘åï¼šé€šè¿‡çŸ­ä¿¡è”ç³»
        async function sendSmsToBlockedChar(charId) {
            const char = await db.characters.get(charId);
            if (!char) return;
            
            const charPhone = char.identity?.phone || generateVirtualPhoneNumber(char.id);
            const charName = char.remark || char.wx_nickname || char.name;
            
            // è®¾ç½®çŸ­ä¿¡èŠå¤©ç›¸å…³çš„å…¨å±€å˜é‡
            window._smsSelectedCharId = charId;
            
            // æ‰“å¼€çŸ­ä¿¡é¡µé¢
            showMessagePage();
            
            // å»¶è¿Ÿåè‡ªåŠ¨æ‰“å¼€å¯¹åº”çš„çŸ­ä¿¡èŠå¤©
            setTimeout(async () => {
                openMessageChat(charPhone);
            }, 500);
        }
        
        // å¯¼å‡ºå‡½æ•°åˆ°å…¨å±€
        window.executeCharDeleteUser = executeCharDeleteUser;
        window.executeCharBlockUser = executeCharBlockUser;
        window.fastForwardDeletedByChar = fastForwardDeletedByChar;
        window.fastForwardBlockedByChar = fastForwardBlockedByChar;
        window.sendFriendRequestAfterCharDelete = sendFriendRequestAfterCharDelete;
        window.sendSmsToBlockedChar = sendSmsToBlockedChar;

        // æ‰‹åŠ¨å‘é€å¥½å‹ç”³è¯·ï¼ˆç”¨æˆ·ä¸»åŠ¨ï¼‰
        async function manualSendFriendRequest(charId) {
            console.log('[FriendRequest] ç‚¹å‡»ä¸»åŠ¨å‘é€å¥½å‹ç”³è¯·, charId:', charId);
            const char = await db.characters.get(charId);
            if (!char) {
                console.error('[FriendRequest] æ‰¾ä¸åˆ°è§’è‰², charId:', charId);
                return;
            }
            
            const message = prompt(`å‘é€å¥½å‹ç”³è¯·ç»™ ${char.name}\n\nè¯·è¾“å…¥ç”³è¯·ç†ç”±ï¼ˆå¯é€‰ï¼‰ï¼š`, 'æˆ‘æ˜¯' + (await getCurrentUserName()));
            if (message !== null) {
                console.log('[FriendRequest] å¼€å§‹å‘é€å¥½å‹ç”³è¯·ç»™:', char.name, 'æ¶ˆæ¯:', message);
                await sendFriendRequestTo(charId, message);
            } else {
                console.log('[FriendRequest] ç”¨æˆ·å–æ¶ˆäº†å‘é€');
            }
        }
        
        // AIæ£€æµ‹æ˜¯å¦å‘é€å¥½å‹ç”³è¯·
        async function checkCharacterSendFriendRequest(charId, elapsedMinutes) {
            const char = await db.characters.get(charId);
            if (!char) return;
            
            const accountId = getCurrentAccountId();
            if (!accountId) return;
            const myChar = await db.characters.get(parseInt(accountId));
            if (!myChar) return;
            
            // è·å–èŠå¤©å†å²
            const history = getChatHistory(char, accountId);
            const recentMessages = history.slice(-10); // æœ€è¿‘10æ¡æ¶ˆæ¯
            
            // æ„å»ºæç¤ºè¯
            const chatContext = recentMessages.map(msg => {
                const role = msg.role === 'user' ? myChar.name : char.name;
                return `${role}: ${msg.content}`;
            }).join('\n');
            
            // æ ¼å¼åŒ–æ—¶é—´æ˜¾ç¤º
            let elapsedText = '';
            if (elapsedMinutes < 60) {
                elapsedText = elapsedMinutes + 'åˆ†é’Ÿ';
            } else if (elapsedMinutes < 1440) {
                elapsedText = Math.round(elapsedMinutes / 60) + 'å°æ—¶';
            } else {
                elapsedText = Math.round(elapsedMinutes / 1440) + 'å¤©';
            }
            
            const systemPrompt = `ä½ æ˜¯ä¸€ä¸ªè§’è‰²æ‰®æ¼”åŠ©æ‰‹ã€‚ä½ éœ€è¦ä»£å…¥è§’è‰²${char.name}ï¼Œåˆ¤æ–­æ˜¯å¦ä¼šä¸»åŠ¨å‘é€å¥½å‹ç”³è¯·ã€‚
âš ï¸ é‡è¦ï¼šä½ çš„åå­—æ˜¯${char.name}ï¼Œä½ ä¸æ˜¯${myChar.name}ï¼ä½ æ˜¯ç‹¬ç«‹çš„è§’è‰²ã€‚`;

            const userPrompt = `ã€ä½ çš„äººè®¾ã€‘
${char.description || char.desc || 'ï¼ˆæ— è¯¦ç»†äººè®¾ï¼‰'}

ã€å¯¹æ–¹ä¿¡æ¯ã€‘
åå­—ï¼š${myChar.name}
${myChar.description ? `ç®€ä»‹ï¼š${myChar.description.substring(0, 200)}` : ''}

ã€ä½ ä»¬ä¹‹å‰çš„èŠå¤©è®°å½•ã€‘
${chatContext || 'ï¼ˆæ²¡æœ‰èŠå¤©è®°å½•ï¼‰'}

ã€å½“å‰æƒ…å¢ƒã€‘
ä½ å’Œ${myChar.name}ä¹‹å‰æ˜¯å¥½å‹ï¼Œä½†${myChar.name}åˆ é™¤äº†ä½ ã€‚
ç°åœ¨å·²ç»è¿‡å»äº†${elapsedText}ã€‚

è¯·æ ¹æ®ä½ çš„æ€§æ ¼ã€å’Œ${myChar.name}çš„å…³ç³»ã€ä»¥åŠä½ ä»¬çš„èŠå¤©å†å²ï¼Œå†³å®šä½ æ˜¯å¦è¦ä¸»åŠ¨å‘é€å¥½å‹ç”³è¯·ç»™${myChar.name}ã€‚

å¦‚æœä½ å†³å®šå‘é€å¥½å‹ç”³è¯·ï¼Œè¯·ä»¥ä½ çš„èº«ä»½å†™å‡ºç”³è¯·é™„å¸¦çš„æ¶ˆæ¯ï¼ˆ1-3æ¡ï¼Œæ¯æ¡ç”¨æ¢è¡Œåˆ†éš”ï¼‰ã€‚ç›´æ¥å†™æ¶ˆæ¯å†…å®¹ï¼Œä¸è¦æœ‰æ ¼å¼æ ‡è®°æˆ–è§£é‡Šã€‚
å¦‚æœä½ å†³å®šä¸å‘é€ï¼Œè¯·åªå›å¤"[ä¸å‘é€]"ã€‚`;
            
            // æ˜¾ç¤ºåŠ è½½æç¤º
            const loadingDiv = document.createElement('div');
            loadingDiv.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.7); display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:9999;';
            loadingDiv.innerHTML = `
                <div style="background:#fff; padding:30px 40px; border-radius:16px; text-align:center; box-shadow:0 10px 40px rgba(0,0,0,0.3);">
                    <div style="width:50px; height:50px; border:4px solid #f3f3f3; border-top:4px solid var(--ins-pink); border-radius:50%; margin:0 auto 20px; animation:spin 1s linear infinite;"></div>
                    <div style="font-size:18px; font-weight:600; color:#333; margin-bottom:8px;">æ­£åœ¨æ£€æµ‹ä¸­...</div>
                    <div style="font-size:14px; color:#999;">${char.name} æ­£åœ¨å†³å®šæ˜¯å¦å‘é€å¥½å‹ç”³è¯·ï¼ˆå¿«è¿›${elapsedText}ï¼‰</div>
                </div>
            `;
            document.body.appendChild(loadingDiv);
            
            // æ·»åŠ æ—‹è½¬åŠ¨ç”»ï¼ˆå¦‚æœè¿˜æ²¡æœ‰ï¼‰
            if (!document.querySelector('#spin-animation-style')) {
                const style = document.createElement('style');
                style.id = 'spin-animation-style';
                style.textContent = `
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            try {
                // ğŸ”¥ ä½¿ç”¨ system + user æ¶ˆæ¯æ ¼å¼ï¼Œä¸å…¶ä»–AIè°ƒç”¨ä¿æŒä¸€è‡´
                const response = await callAI([
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: userPrompt }
                ]);
                
                if (document.body.contains(loadingDiv)) {
                    document.body.removeChild(loadingDiv);
                }
                
                // è§£æAIå›å¤
                const answer = (response || '').trim();
                
                if (!answer || answer === '[ä¸å‘é€]' || answer.includes('[ä¸å‘é€]') || answer.includes('ä¸å‘é€')) {
                    // è§’è‰²å†³å®šä¸å‘é€
                    alert(`${char.name} å†³å®šæš‚æ—¶ä¸å‘é€å¥½å‹ç”³è¯·`);
                    
                    // é‡æ–°è·å–è§’è‰²æ•°æ®ï¼ˆé¿å…ä½¿ç”¨è¿‡æœŸæ•°æ®ï¼‰
                    const freshChar = await db.characters.get(charId);
                    if (freshChar) {
                        if (!freshChar.wait_friend_settings) freshChar.wait_friend_settings = {};
                        if (!freshChar.wait_friend_settings[accountId]) {
                            freshChar.wait_friend_settings[accountId] = {
                                enabled: false,
                                interval: 60,
                                lastCheckTime: Date.now(),
                                nextCheckTime: null
                            };
                        }
                        freshChar.wait_friend_settings[accountId].lastCheckTime = Date.now();
                        if (freshChar.wait_friend_settings[accountId].enabled) {
                            freshChar.wait_friend_settings[accountId].nextCheckTime = 
                                Date.now() + freshChar.wait_friend_settings[accountId].interval * 60 * 1000;
                        }
                        await db.characters.put(freshChar);
                    }
                } else {
                    // è§’è‰²å†³å®šå‘é€å¥½å‹ç”³è¯·ï¼Œå°†å¤šæ¡æ¶ˆæ¯æ‹†åˆ†
                    // æ¸…ç†AIå¯èƒ½é™„åŠ çš„æ ¼å¼æ ‡è®°
                    let cleanAnswer = answer
                        .replace(/^[\s\S]*?\[ä¸å‘é€\][\s\S]*$/gi, '')
                        .replace(/^(å¥½çš„|ä½œä¸º|ä»¥ä¸‹æ˜¯|æˆ‘å†³å®š).*[:ï¼š]\s*/gim, '')
                        .trim();
                    
                    if (!cleanAnswer) cleanAnswer = answer; // å¦‚æœæ¸…ç†åä¸ºç©ºï¼Œç”¨åŸå§‹å›å¤
                    
                    const messages = cleanAnswer.split('\n').filter(msg => {
                        const trimmed = msg.trim();
                        return trimmed.length > 0 && !trimmed.startsWith('[') && !trimmed.startsWith('ï¼ˆ');
                    });
                    
                    if (messages.length === 0) {
                        alert(`${char.name} çš„å›å¤æ— æ³•è§£æï¼Œæœªå‘é€ç”³è¯·`);
                        return;
                    }
                    
                    // å°†æ‰€æœ‰æ¶ˆæ¯åˆå¹¶ä½œä¸ºç”³è¯·æ¶ˆæ¯
                    const requestMessage = messages.join('\n');
                    
                    // åˆ›å»ºå¥½å‹ç”³è¯·ï¼ˆåå‘ï¼šä»è§’è‰²å‘ç»™ç”¨æˆ·ï¼‰
                    await db.friend_requests.add({
                        fromCharId: charId,
                        toCharId: parseInt(accountId),
                        toAccountId: accountId,
                        message: requestMessage,
                        status: 'pending',
                        time: Date.now()
                    });
                    
                    // ğŸ”§ æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯åˆ°èŠå¤©å†å²ï¼Œè®°å½•è§’è‰²å‘é€å¥½å‹ç”³è¯·äº‹ä»¶
                    const freshCharForHistory = await db.characters.get(charId);
                    if (freshCharForHistory) {
                        let history = getChatHistory(freshCharForHistory, accountId);
                        history.push({
                            role: 'system',
                            content: `[${char.name} å‘ä½ å‘é€äº†å¥½å‹ç”³è¯·]`,
                            time: Date.now(),
                            type: 'char_send_friend_request'
                        });
                        await setChatHistory(freshCharForHistory, accountId, history);
                        console.log(`[FriendRequest] å·²åœ¨èŠå¤©å†å²ä¸­è®°å½•è§’è‰²å‘é€å¥½å‹ç”³è¯·`);
                    }
                    
                    // æ˜¾ç¤ºæ¶ˆæ¯é¢„è§ˆ
                    const preview = messages.length > 1 ? 
                        `${messages[0]}\n...(å…±${messages.length}æ¡æ¶ˆæ¯)` : 
                        messages[0];
                    
                    alert(`${char.name} å‘é€äº†å¥½å‹ç”³è¯·ï¼\n\n${preview}\n\nè¯·å‰å¾€"æ–°çš„å¥½å‹"é¡µé¢æŸ¥çœ‹ã€‚`);
                    
                    // é‡æ–°è·å–è§’è‰²æ•°æ®
                    const freshChar = await db.characters.get(charId);
                    if (freshChar) {
                        if (!freshChar.wait_friend_settings) freshChar.wait_friend_settings = {};
                        if (!freshChar.wait_friend_settings[accountId]) {
                            freshChar.wait_friend_settings[accountId] = {
                                enabled: false,
                                interval: 60,
                                lastCheckTime: Date.now(),
                                nextCheckTime: null
                            };
                        }
                        freshChar.wait_friend_settings[accountId].lastCheckTime = Date.now();
                        if (freshChar.wait_friend_settings[accountId].enabled) {
                            freshChar.wait_friend_settings[accountId].nextCheckTime = 
                                Date.now() + freshChar.wait_friend_settings[accountId].interval * 60 * 1000;
                        }
                        await db.characters.put(freshChar);
                    }
                    
                    // åˆ·æ–°é€šè®¯å½•çº¢ç‚¹
                    const activeTab = document.querySelector('.wechat-tab-item.active');
                    if (activeTab && activeTab.innerText.includes('é€šè®¯å½•')) {
                        await renderContactList(document.getElementById('wechat-content'));
                    }
                }
                
                // åˆ·æ–°ç•Œé¢
                if (currentChatCharId === charId) {
                    const refreshedChar = await db.characters.get(charId);
                    if (refreshedChar) await renderChatBody(refreshedChar);
                }
                
            } catch (error) {
                if (document.body.contains(loadingDiv)) {
                    document.body.removeChild(loadingDiv);
                }
                console.error('[FastForwardCheck] AIè°ƒç”¨å¤±è´¥:', error);
                alert('AIè°ƒç”¨å¤±è´¥ï¼š' + error.message);
            }
        }
        
        // å®šæ—¶å™¨ï¼šæ£€æŸ¥æ‰€æœ‰éœ€è¦æ£€æµ‹çš„è§’è‰²
        let waitFriendCheckTimer = null;
        
        function startWaitFriendTimer() {
            if (waitFriendCheckTimer) return; // å·²å¯åŠ¨
            
            waitFriendCheckTimer = setInterval(async () => {
                const now = Date.now();
                const accountId = getCurrentAccountId();
                if (!accountId) return;
                
                // è·å–æ‰€æœ‰è§’è‰²
                const allChars = await db.characters.toArray();
                
                for (const char of allChars) {
                    const settings = char.wait_friend_settings?.[accountId];
                    if (!settings || !settings.enabled) continue;
                    
                    // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾æ£€æµ‹æ—¶é—´
                    if (settings.nextCheckTime && now >= settings.nextCheckTime) {
                        // è§¦å‘æ£€æµ‹
                        await checkCharacterSendFriendRequest(char.id, settings.interval);
                    }
                }
            }, 60000); // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
        }
        
        // åˆå§‹åŒ–æ—¶å¯åŠ¨å®šæ—¶å™¨
        startWaitFriendTimer();

        // --- ä½ç”µé‡æé†’ï¼ˆè¯»å–ç”¨æˆ·è®¾å¤‡çœŸå®ç”µé‡ï¼‰ ---
        async function initBatteryMonitor() {
            if (!navigator.getBattery) {
                console.log('[Battery] å½“å‰æµè§ˆå™¨ä¸æ”¯æŒ Battery API');
                return;
            }
            try {
                const battery = await navigator.getBattery();
                deviceBatteryLevel = Math.round(battery.level * 100);
                deviceBatteryCharging = battery.charging;
                console.log(`[Battery] åˆå§‹ç”µé‡: ${deviceBatteryLevel}%, å……ç”µä¸­: ${deviceBatteryCharging}`);
                
                // ç›‘å¬ç”µé‡å˜åŒ–
                battery.addEventListener('levelchange', () => {
                    const oldLevel = deviceBatteryLevel;
                    deviceBatteryLevel = Math.round(battery.level * 100);
                    console.log(`[Battery] ç”µé‡å˜åŒ–: ${oldLevel}% â†’ ${deviceBatteryLevel}%`);
                    
                    // ç”µé‡åˆšè·Œç ´20%ä¸”ä¸åœ¨å……ç”µï¼Œç«‹å³æ£€æŸ¥æ˜¯å¦åœ¨èŠå¤©é¡µé¢
                    if (deviceBatteryLevel <= 20 && oldLevel > 20 && !deviceBatteryCharging) {
                        lowBatteryShownThisSession.clear(); // é‡æ–°è§¦å‘æé†’
                        checkAndShowLowBattery();
                    }
                });
                
                battery.addEventListener('chargingchange', () => {
                    deviceBatteryCharging = battery.charging;
                    console.log(`[Battery] å……ç”µçŠ¶æ€: ${deviceBatteryCharging ? 'å……ç”µä¸­' : 'æœªå……ç”µ'}`);
                    // æ‹”æ‰å……ç”µå™¨æ—¶å¦‚æœç”µé‡ä½ï¼Œé‡æ–°æ£€æŸ¥
                    if (!deviceBatteryCharging && deviceBatteryLevel <= 20) {
                        lowBatteryShownThisSession.clear();
                        checkAndShowLowBattery();
                    }
                });
            } catch (e) {
                console.warn('[Battery] è·å–ç”µé‡å¤±è´¥:', e);
            }
        }
        
        async function checkAndShowLowBattery() {
            if (deviceBatteryLevel === null || deviceBatteryLevel > 20 || deviceBatteryCharging) return;
            if (!currentChatCharId) return;
            
            // é¿å…åŒä¸€ä¸ªèŠå¤©çª—å£åå¤å¼¹å‡º
            if (lowBatteryShownThisSession.has(currentChatCharId)) return;
            
            const char = await db.characters.get(currentChatCharId);
            if (!char || char.isOnlineFriend) return;
            
            const charDisplayName = char.remark || char.wx_nickname || char.name;
            lowBatteryShownThisSession.add(currentChatCharId);
            showLowBatteryToast(charDisplayName, deviceBatteryLevel);
        }
        
        function showLowBatteryToast(charName, batteryLevel) {
            const toast = document.getElementById('low-battery-toast');
            if (!toast) return;
            
            const titleEl = document.getElementById('low-battery-title');
            const descEl = document.getElementById('low-battery-desc');
            const percentEl = document.getElementById('low-battery-percent');
            
            titleEl.textContent = `${charName} æé†’ä½ `;
            descEl.textContent = `ä½ çš„æ‰‹æœºç”µé‡åªå‰©${batteryLevel}%äº†ï¼Œè®°å¾—å……ç”µå“¦~`;
            percentEl.textContent = batteryLevel + '%';
            
            // æ ¹æ®ç”µé‡ç­‰çº§è®¾ç½®é¢œè‰²
            if (batteryLevel <= 5) {
                percentEl.style.color = '#D32F2F';
            } else if (batteryLevel <= 10) {
                percentEl.style.color = '#F44336';
            } else {
                percentEl.style.color = '#FF5722';
            }
            
            toast.style.display = 'block';
            
            // 6ç§’åè‡ªåŠ¨æ¶ˆå¤±
            if (toast._hideTimer) clearTimeout(toast._hideTimer);
            toast._hideTimer = setTimeout(() => {
                const innerDiv = toast.querySelector('div');
                if (innerDiv) innerDiv.style.animation = 'batterySlideOut 0.3s ease forwards';
                setTimeout(() => {
                    toast.style.display = 'none';
                    if (innerDiv) innerDiv.style.animation = 'batterySlideIn 0.35s ease';
                }, 300);
            }, 6000);
        }

        // æ ‡è®°æŸä¸ªè§’è‰²çš„æ‰€æœ‰æ¶ˆæ¯ä¸ºå·²è¯»
        async function markChatAsRead(charId) {
            try {
                const char = await db.characters.get(charId);
                if (!char) return;
                const accountId = getCurrentAccountId();
                const history = getChatHistory(char, accountId);
                let changed = false;
                history.forEach(m => {
                    if (m.role === 'char' && !m.read) {
                        m.read = true;
                        changed = true;
                    }
                });
                if (changed) {
                    await setChatHistory(char, accountId, history);
                }
            } catch (e) {
                console.warn('[markChatAsRead] æ ‡è®°å·²è¯»å¤±è´¥:', e);
            }
        }

        // --- èŠå¤©çª—å£é€»è¾‘ ---
        async function openChatWindow(charId) {
            currentChatCharId = charId;
            window.currentGroupChatId = null; // æ¸…é™¤ç¾¤èŠIDï¼Œç¡®ä¿æ˜¯ç§èŠæ¨¡å¼
            const char = await db.characters.get(charId);
            
            // ä¼˜å…ˆæ˜¾ç¤ºå¤‡æ³¨åï¼Œå…¶æ¬¡æ˜¾ç¤ºç½‘åï¼Œæœ€åæ˜¾ç¤ºåŸå
            const titleEl = document.getElementById('chat-title');
            titleEl.innerText = char.remark || char.wx_nickname || char.name;
            titleEl.style.cursor = 'pointer';
            titleEl.onclick = showChatDetail; // æ¢å¤ä¸ºç§èŠè¯¦æƒ…
            
            document.getElementById('chat-window').style.display = 'flex';
            
            // ç¼“å­˜å½“å‰å…³è”çš„ User ID
            currentChatUserId = char.linked_user_id || null;
            
            // âœ… æ‰“å¼€èŠå¤©æ—¶æ ‡è®°æ‰€æœ‰è§’è‰²æ¶ˆæ¯ä¸ºå·²è¯»
            markChatAsRead(charId);
            
            // âœ… æ¸…é™¤èŠå¤©åˆ—è¡¨éšè—æ ‡è®°ï¼ˆé‡æ–°æ‰“å¼€èŠå¤©æ—¶æ¢å¤æ˜¾ç¤ºï¼‰
            const accountId = getCurrentAccountId();
            if (char.chat_hidden_by_user && char.chat_hidden_by_user[accountId]) {
                char.chat_hidden_by_user[accountId] = false;
                db.characters.put(char).catch(e => console.error('æ¸…é™¤éšè—æ ‡è®°å¤±è´¥:', e));
            }
            
            // æ ¹æ®å¥½å‹çŠ¶æ€æ˜¾ç¤ºæˆ–éšè—è¾“å…¥æ¡†
            const friendStatus = getFriendStatus(char, accountId);
            const chatFooter = document.getElementById('chat-footer');
            if (friendStatus === 'blocked' || friendStatus === 'deleted' || friendStatus === 'deleted_by_char' || friendStatus === 'blocked_by_char') {
                // æ‹‰é»‘æˆ–åˆ é™¤åï¼Œéšè—è¾“å…¥æ¡†
                chatFooter.style.display = 'none';
            } else {
                // æ­£å¸¸çŠ¶æ€ï¼Œæ˜¾ç¤ºè¾“å…¥æ¡†
                chatFooter.style.display = 'flex';
            }
            
            // âœ… è”æœºå¥½å‹ï¼šéšè—AIé­”æ³•æ£’ï¼Œç®€åŒ–èœå•ï¼ˆåªæ˜¾ç¤ºè¯­éŸ³è¾“å…¥ã€ç›¸å†Œã€è½¬è´¦ï¼‰
            const isOnlineFriend = char.isOnlineFriend === true;
            const actionPanel = document.getElementById('action-panel');
            const actionItems = actionPanel.querySelectorAll('.action-item');
            const aiMagicBtn = document.querySelector('.chat-input-bar .chat-icon-btn'); // ç¬¬ä¸€ä¸ªæŒ‰é’®æ˜¯AIé­”æ³•æ£’
            
            if (isOnlineFriend) {
                // éšè—AIé­”æ³•æ£’
                if (aiMagicBtn) aiMagicBtn.style.display = 'none';
                // åªæ˜¾ç¤ºå‰3ä¸ªèœå•é¡¹ï¼ˆè¯­éŸ³è¾“å…¥ã€ç›¸å†Œã€è½¬è´¦ï¼‰
                actionItems.forEach((item, index) => {
                    item.style.display = index < 3 ? '' : 'none';
                });
            } else {
                // æ™®é€šè§’è‰²ï¼šæ˜¾ç¤ºæ‰€æœ‰èœå•
                if (aiMagicBtn) aiMagicBtn.style.display = '';
                actionItems.forEach(item => {
                    item.style.display = '';
                });
            }
            
            // åº”ç”¨è‡ªå®šä¹‰è¾“å…¥æ¡†æ–‡æ¡ˆ
            const chatInputBox = document.getElementById('chat-input-box');
            if (chatInputBox) {
                chatInputBox.placeholder = char.input_placeholder || 'å‘é€æ¶ˆæ¯...';
            }
            
            renderChatBody(char);
            
            // ä½ç”µé‡æé†’æ£€æŸ¥ï¼ˆè¯»å–çœŸå®è®¾å¤‡ç”µé‡ï¼‰
            if (!isOnlineFriend) {
                setTimeout(() => {
                    checkAndShowLowBattery();
                }, 800);
            }
        }

        // --- æˆ³ä¸€æˆ³åŠŸèƒ½ ---
        let currentPokeCharName = '';
        
        async function showPokeModal(charName) {
            currentPokeCharName = charName;
            
            // è·å–å½“å‰ç”¨æˆ·å
            const accountId = getCurrentAccountId();
            const myChar = await db.characters.get(parseInt(accountId));
            const userName = myChar ? (myChar.nick || myChar.name) : 'ç”¨æˆ·';
            
            // è®¾ç½®åå­—
            document.getElementById('poke-user-name').textContent = userName;
            document.getElementById('poke-char-name').textContent = charName;
            
            // è®¾ç½®é»˜è®¤å€¼
            document.getElementById('poke-action').value = 'æˆ³äº†æˆ³';
            document.getElementById('poke-part').value = 'è„‘è¢‹';
            
            // æ›´æ–°é¢„è§ˆ
            updatePokePreview();
            
            // æ˜¾ç¤ºå¼¹çª—
            document.getElementById('poke-modal').style.display = 'flex';
            
            // ç›‘å¬è¾“å…¥å˜åŒ–
            document.getElementById('poke-action').oninput = updatePokePreview;
            document.getElementById('poke-part').oninput = updatePokePreview;
        }
        
        function updatePokePreview() {
            const userName = document.getElementById('poke-user-name').textContent;
            const charName = document.getElementById('poke-char-name').textContent;
            const action = document.getElementById('poke-action').value || 'æˆ³äº†æˆ³';
            const part = document.getElementById('poke-part').value || 'è„‘è¢‹';
            
            const preview = `${userName}${action}${charName}çš„${part}`;
            document.getElementById('poke-preview').textContent = preview;
        }
        
        async function confirmPoke() {
            const action = document.getElementById('poke-action').value || 'æˆ³äº†æˆ³';
            const part = document.getElementById('poke-part').value || 'è„‘è¢‹';
            const userName = document.getElementById('poke-user-name').textContent;
            const charName = currentPokeCharName;
            
            // å…³é—­å¼¹çª—
            document.getElementById('poke-modal').style.display = 'none';
            
            // ç”Ÿæˆæˆ³ä¸€æˆ³ç³»ç»Ÿæ¶ˆæ¯
            const pokeText = `${userName}${action}${charName}çš„${part}`;
            
            // è·å–å½“å‰è§’è‰²
            if (!currentChatCharId) return;
            const char = await db.characters.get(currentChatCharId);
            if (!char) return;
            
            const accountId = getCurrentAccountId();
            let history = getChatHistory(char, accountId);
            
            // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯
            const sysMsg = { 
                role: 'system', 
                content: pokeText, 
                time: Date.now(),
                type: 'poke'
            };
            
            history.push(sysMsg);
            await setChatHistory(char, accountId, history);
            
            // åœ¨ç•Œé¢ä¸Šæ˜¾ç¤ºç³»ç»Ÿæ¶ˆæ¯
            await appendMessageToUI('system', pokeText);
            
            console.log('[Poke] æˆ³ä¸€æˆ³:', pokeText);
        }
        
        // å…³é—­å¼¹çª—çš„é€šç”¨å‡½æ•°
        window.closeModal = function(modalId) {
            document.getElementById(modalId).style.display = 'none';
        };

        // --- èŠå¤©è¯¦æƒ…é¡µé€»è¾‘ ---
        // ç»Ÿä¸€å…¥å£ï¼šæ ¹æ®å½“å‰æ˜¯ç§èŠè¿˜æ˜¯ç¾¤èŠæ˜¾ç¤ºå¯¹åº”è¯¦æƒ…é¡µ
        function showChatOrGroupDetail() {
            if (window.currentGroupChatId) {
                showGroupDetail(window.currentGroupChatId);
            } else if (currentChatCharId) {
                showChatDetail();
            }
        }
        
        async function showChatDetail() {
            if (!currentChatCharId) return;
            const char = await db.characters.get(currentChatCharId);
            if (!char) return;

            document.getElementById('chat-detail-page').style.display = 'flex';
            
            // âœ… è”æœºå¥½å‹ï¼šéšè—ä¸ç›¸å…³çš„è®¾ç½®é¡¹
            const isOnlineFriend = char.isOnlineFriend === true;
            const detailPage = document.getElementById('chat-detail-page');
            const detailGroups = detailPage.querySelectorAll('.detail-group');
            
            // æ˜¾ç¤ºæˆ–éšè—ç‰¹å®šçš„è®¾ç½®ç»„ï¼ˆæŒ‰é¡ºåºï¼šæ¡£æ¡ˆå…³è”ã€ä¸»åŠ¨èŠå¤©ã€æŸ¥å²—ä¿®ç½—åœºã€è‡ªä¸»æ¢å¤´åƒã€AIä¸Šä¸‹æ–‡ã€å›å¤æ¡æ•°ã€è¡¨æƒ…åŒ…ã€èŠå¤©èƒŒæ™¯ã€æ°”æ³¡æ ·å¼ã€è‡ªå®šä¹‰æ ·å¼ã€å±é™©æ“ä½œï¼‰
            detailGroups.forEach((group, index) => {
                if (isOnlineFriend) {
                    // è”æœºå¥½å‹åªæ˜¾ç¤ºå¤‡æ³¨(0)ã€æ¡£æ¡ˆå…³è”(1)å’Œæœ€åå‡ ç»„
                    // éšè—ï¼šä¸»åŠ¨èŠå¤©(2)ã€æŸ¥å²—ä¿®ç½—åœº(3)ã€è‡ªä¸»æ¢å¤´åƒ(4)ã€æœ‹å‹åœˆé¢‘ç‡(5)ã€AIä¸Šä¸‹æ–‡(6)ã€å›å¤æ¡æ•°(7)ã€è¡¨æƒ…åŒ…(8)ã€èŠå¤©èƒŒæ™¯(9)
                    if (index >= 2 && index <= 9) {
                        group.style.display = 'none';
                    } else {
                        group.style.display = '';
                    }
                } else {
                    group.style.display = '';
                }
            });
            
            // 1. å›æ˜¾åŸºæœ¬ä¿¡æ¯
            document.getElementById('detail-char-remark').value = char.remark || '';
            document.getElementById('detail-input-placeholder').value = char.input_placeholder || '';
            document.getElementById('detail-char-realname').innerText = `åŸå: ${char.name}`;
            // å›æ˜¾ç½‘åï¼ˆä¼˜å…ˆç”¨è‡ªå®šä¹‰ç½‘åï¼Œå¦åˆ™ç”¨è§’è‰²åï¼‰
            document.getElementById('detail-char-nickname').innerText = char.wx_nickname || char.name || 'æœªè®¾ç½®';
            // å›æ˜¾ä¸ªæ€§ç­¾å
            document.getElementById('detail-char-signature').innerText = char.wx_signature || 'è¿™ä¸ªäººä»€ä¹ˆä¹Ÿæ²¡æœ‰ç•™ä¸‹';
            if (char.avatar) {
                document.getElementById('detail-char-avatar').style.backgroundImage = `url(${char.avatar})`;
            } else {
                document.getElementById('detail-char-avatar').style.backgroundImage = '';
            }

            // 2. åŠ è½½ä¸–ç•Œä¹¦åˆ—è¡¨ï¼ˆå¤šé€‰ï¼‰â€”â€”åªæ˜¾ç¤ºå•äººä¸–ç•Œä¹¦ï¼Œå…¨å±€ä¸–ç•Œä¹¦è‡ªåŠ¨ç”Ÿæ•ˆ
            const lorebooks = await db.lorebooks.toArray();
            const lbList = document.getElementById('detail-lorebook-list');
            lbList.innerHTML = '';
            
            // å…¼å®¹æ—§æ•°æ®ï¼šå¦‚æœlorebookIdå­˜åœ¨ä½†lorebookIdsä¸å­˜åœ¨ï¼Œè½¬æ¢ä¸ºæ•°ç»„
            const selectedIds = char.lorebookIds || (char.lorebookId ? [char.lorebookId] : []);
            
            // åˆ†ç¦»å…¨å±€å’Œå•äººä¸–ç•Œä¹¦
            const personalLorebooks = lorebooks.filter(lb => lb.scope !== 'global');
            const globalLorebooks = lorebooks.filter(lb => lb.scope === 'global');
            
            // æ˜¾ç¤ºå…¨å±€ä¸–ç•Œä¹¦æç¤º
            if (globalLorebooks.length > 0) {
                const globalHint = document.createElement('div');
                globalHint.style.cssText = 'padding:6px 8px; color:#34c759; font-size:12px; background:#f0fff4; border-radius:6px; margin-bottom:6px;';
                globalHint.innerHTML = `ğŸŒ ${globalLorebooks.length} ä¸ªå…¨å±€ä¸–ç•Œä¹¦å·²è‡ªåŠ¨ç”Ÿæ•ˆï¼š${globalLorebooks.map(g => g.name).join('ã€')}`;
                lbList.appendChild(globalHint);
            }
            
            if (personalLorebooks.length === 0 && globalLorebooks.length === 0) {
                lbList.innerHTML = '<div style="padding:8px; color:#999; font-size:12px; text-align:center;">æš‚æ— ä¸–ç•Œä¹¦</div>';
            } else if (personalLorebooks.length === 0) {
                // åªæœ‰å…¨å±€ä¸–ç•Œä¹¦ï¼Œä¸éœ€è¦é¢å¤–æ˜¾ç¤º
            } else {
                personalLorebooks.forEach(lb => {
                    const label = document.createElement('label');
                    label.style.cssText = 'display:flex; align-items:center; padding:8px; cursor:pointer; border-radius:6px; margin-bottom:4px;';
                    label.style.background = selectedIds.includes(lb.id) ? '#f0f0f5' : 'transparent';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = lb.id;
                    checkbox.checked = selectedIds.includes(lb.id);
                    checkbox.style.marginRight = '8px';
                    checkbox.onchange = () => {
                        label.style.background = checkbox.checked ? '#f0f0f5' : 'transparent';
                        updateLorebookCount();
                        saveChatDetail();
                    };
                    
                    const name = document.createElement('span');
                    name.textContent = lb.name;
                    name.style.fontSize = '14px';
                    name.style.color = '#333';
                    
                    label.appendChild(checkbox);
                    label.appendChild(name);
                    lbList.appendChild(label);
                });
            }
            
            updateLorebookCount();

            // 3. å›æ˜¾ä¸»åŠ¨èŠå¤©è®¾ç½®
            document.getElementById('detail-auto-chat-switch').checked = !!char.auto_reply_enabled;
            document.getElementById('detail-auto-chat-interval').value = char.auto_reply_interval || '';
            
            // 3.5. å›æ˜¾å¤–è¯­ç¿»è¯‘æ¨¡å¼è®¾ç½®
            document.getElementById('detail-foreign-lang-switch').checked = !!char.foreign_lang_mode;
            
            // 4. å›æ˜¾AIæŸ¥å²—è®¾ç½®
            document.getElementById('detail-allow-check-switch').checked = !!char.allow_ai_check_account;
            
            // 4.5. å›æ˜¾ä¿®ç½—åœºæ¨¡å¼è®¾ç½®
            document.getElementById('detail-allow-shura-switch').checked = !!char.allow_shura_mode;
            
            // 4.6. å›æ˜¾è‡ªä¸»æ¢å¤´åƒè®¾ç½®
            document.getElementById('detail-allow-avatar-switch').checked = !!char.allow_auto_avatar;
            
            // 4.7. å›æ˜¾æœ‹å‹åœˆé¢‘ç‡è®¾ç½®
            document.getElementById('detail-moments-frequency').value = char.moments_frequency || 'off';
            
            // 5. å›æ˜¾ä¸Šä¸‹æ–‡æ¡æ•°è®¾ç½®ï¼ˆé»˜è®¤20æ¡ï¼‰
            document.getElementById('detail-context-count').value = char.context_message_count || 20;
            
            // 5.5. å›æ˜¾å›å¤æ¶ˆæ¯æ¡æ•°è®¾ç½®ï¼ˆé»˜è®¤1~3æ¡ï¼‰
            document.getElementById('detail-reply-min-count').value = char.reply_min_count || 1;
            document.getElementById('detail-reply-max-count').value = char.reply_max_count || 3;

            // 6. åŠ è½½æŒ‚è½½çš„è¡¨æƒ…åŒ…åº“
            updateMountedStickerCount();
            
            // 6.5 åŠ è½½æŒ‚è½½çš„ç”¨æˆ·æ¡£æ¡ˆ
            updateMountedUserDisplay();
            
            // 7. æ›´æ–°è§†é¢‘é€šè¯è®°å½•æ•°é‡
            updateVideoCallRecordCount();
            
            // 7. åŠ è½½è‡ªå®šä¹‰æ ·å¼è®¾ç½®
            document.getElementById('detail-bubble-css').value = char.custom_bubble_css || '';
            document.getElementById('detail-custom-html').value = char.custom_html || '';
            document.getElementById('detail-custom-css').value = char.custom_css || '';
            
            // 8. åŠ è½½èŠå¤©èƒŒæ™¯å›¾
            const bgPreview = document.getElementById('detail-chat-bg-preview');
            if (char.chat_background) {
                bgPreview.style.backgroundImage = `url(${char.chat_background})`;
                bgPreview.textContent = '';
            } else {
                bgPreview.style.backgroundImage = '';
                bgPreview.textContent = 'æš‚æ— èƒŒæ™¯å›¾';
            }
            
            // 9. åŠ è½½æ°”æ³¡æ ·å¼é€‰æ‹©
            const bubbleStyle = char.bubble_style || 'default';
            document.querySelectorAll('.bubble-style-option').forEach(el => {
                el.classList.remove('selected');
                if (el.dataset.style === bubbleStyle) {
                    el.classList.add('selected');
                }
            });
            
            // 10. åŠ è½½è‡ªåŠ¨æ€»ç»“è®¾ç½®
            document.getElementById('detail-auto-summary-switch').checked = !!char.auto_summary_enabled;
            document.getElementById('detail-summary-interval').value = char.summary_interval || '';
            
            // æ›´æ–°æ€»ç»“è®¡æ•°
            const accountId = getCurrentAccountId();
            if (accountId) {
                await updateSummaryCount('private', currentChatCharId, accountId);
            }
        }
        
        // é€‰æ‹©æ°”æ³¡æ ·å¼
        function selectBubbleStyle(style) {
            document.querySelectorAll('.bubble-style-option').forEach(el => {
                el.classList.remove('selected');
                if (el.dataset.style === style) {
                    el.classList.add('selected');
                }
            });
            saveChatDetail();
        }

        function hideChatDetail() {
            document.getElementById('chat-detail-page').style.display = 'none';
        }

        function toggleLorebookList() {
            const list = document.getElementById('detail-lorebook-list');
            const toggle = document.getElementById('detail-lorebook-toggle');
            if (list.style.display === 'none' || !list.style.display) {
                list.style.display = 'block';
                toggle.textContent = 'æ”¶èµ·';
            } else {
                list.style.display = 'none';
                toggle.textContent = 'å±•å¼€';
            }
        }

        function updateLorebookCount() {
            const checkboxes = document.querySelectorAll('#detail-lorebook-list input[type="checkbox"]:checked');
            const count = checkboxes.length;
            document.getElementById('detail-lorebook-count').textContent = `${count}ä¸ª`;
        }

async function saveChatDetail() {
    if (!currentChatCharId) return;
    const char = await db.characters.get(currentChatCharId);
    
    const remark = document.getElementById('detail-char-remark').value.trim();
    
    // è·å–é€‰ä¸­çš„ä¸–ç•Œä¹¦IDæ•°ç»„
    const checkboxes = document.querySelectorAll('#detail-lorebook-list input[type="checkbox"]:checked');
    const lorebookIds = Array.from(checkboxes).map(cb => parseInt(cb.value));
    
    // ä¸»åŠ¨èŠå¤©è®¾ç½®
    const autoEnabled = document.getElementById('detail-auto-chat-switch').checked;
    const autoInterval = parseInt(document.getElementById('detail-auto-chat-interval').value);
    
    // ä¸Šä¸‹æ–‡æ¡æ•°è®¾ç½®
    const contextCount = parseInt(document.getElementById('detail-context-count').value);
    
    // å›å¤æ¶ˆæ¯æ¡æ•°èŒƒå›´è®¾ç½®
    const replyMinCount = parseInt(document.getElementById('detail-reply-min-count').value);
    const replyMaxCount = parseInt(document.getElementById('detail-reply-max-count').value);
    
    // è¾“å…¥æ¡†æ–‡æ¡ˆè®¾ç½®
    const inputPlaceholder = document.getElementById('detail-input-placeholder').value.trim();
    
    // å¤–è¯­ç¿»è¯‘æ¨¡å¼è®¾ç½®
    const foreignLangMode = document.getElementById('detail-foreign-lang-switch').checked;
    
    // AIæŸ¥å²—è®¾ç½®
    const allowCheckEnabled = document.getElementById('detail-allow-check-switch').checked;
    
    // ä¿®ç½—åœºæ¨¡å¼è®¾ç½®
    const allowShuraEnabled = document.getElementById('detail-allow-shura-switch').checked;
    
    // è‡ªä¸»æ¢å¤´åƒè®¾ç½®
    const allowAutoAvatar = document.getElementById('detail-allow-avatar-switch').checked;
    
    // æœ‹å‹åœˆé¢‘ç‡è®¾ç½®
    const momentsFrequency = document.getElementById('detail-moments-frequency').value;
    
    // è‡ªåŠ¨æ€»ç»“è®¾ç½®
    const autoSummaryEnabled = document.getElementById('detail-auto-summary-switch').checked;
    const summaryInterval = parseInt(document.getElementById('detail-summary-interval').value);

    char.remark = remark;
    char.lorebookIds = lorebookIds.length > 0 ? lorebookIds : null;
    // ä¿ç•™æ—§å­—æ®µä»¥å…¼å®¹ï¼Œä½†ä¼˜å…ˆä½¿ç”¨lorebookIds
    if (lorebookIds.length > 0) {
        char.lorebookId = lorebookIds[0]; // ä¿ç•™ç¬¬ä¸€ä¸ªä½œä¸ºå…¼å®¹
    } else {
        char.lorebookId = null;
    }
    char.auto_reply_enabled = autoEnabled;
    char.auto_reply_interval = autoInterval > 0 ? autoInterval : null;
    char.context_message_count = contextCount > 0 ? contextCount : 20; // é»˜è®¤20æ¡
    char.reply_min_count = (replyMinCount > 0 && replyMinCount <= 50) ? replyMinCount : 1; // é»˜è®¤1æ¡
    char.reply_max_count = (replyMaxCount > 0 && replyMaxCount <= 50) ? replyMaxCount : 3; // é»˜è®¤3æ¡
    char.input_placeholder = inputPlaceholder || ''; // ä¿å­˜è‡ªå®šä¹‰è¾“å…¥æ¡†æ–‡æ¡ˆ
    char.foreign_lang_mode = foreignLangMode; // ä¿å­˜å¤–è¯­ç¿»è¯‘æ¨¡å¼å¼€å…³
    char.allow_ai_check_account = allowCheckEnabled; // ä¿å­˜æŸ¥å²—å¼€å…³çŠ¶æ€
    char.allow_shura_mode = allowShuraEnabled; // ä¿å­˜ä¿®ç½—åœºæ¨¡å¼å¼€å…³çŠ¶æ€
    char.allow_auto_avatar = allowAutoAvatar; // ä¿å­˜è‡ªä¸»æ¢å¤´åƒå¼€å…³çŠ¶æ€
    char.moments_frequency = momentsFrequency; // ä¿å­˜æœ‹å‹åœˆé¢‘ç‡ (off/low/medium/high)
    char.auto_summary_enabled = autoSummaryEnabled; // è‡ªåŠ¨æ€»ç»“å¼€å…³
    char.summary_interval = summaryInterval > 0 ? summaryInterval : 50; // æ€»ç»“é—´éš”ï¼Œé»˜è®¤50æ¡
    
    // ä¿å­˜è‡ªå®šä¹‰æ ·å¼ï¼ˆä¸¥æ ¼è¿‡æ»¤JSï¼‰
    const bubbleCSS = document.getElementById('detail-bubble-css').value;
    const customHTML = document.getElementById('detail-custom-html').value;
    const customCSS = document.getElementById('detail-custom-css').value;
    
    char.custom_bubble_css = sanitizeCSS(bubbleCSS);
    char.custom_html = sanitizeHTML(customHTML);
    char.custom_css = sanitizeCSS(customCSS);
    
    // ä¿å­˜æ°”æ³¡æ ·å¼é€‰æ‹©
    const selectedBubbleOption = document.querySelector('.bubble-style-option.selected');
    char.bubble_style = selectedBubbleOption ? selectedBubbleOption.dataset.style : 'default';
    
    await db.characters.put(char);
    
    // å®æ—¶æ›´æ–°èŠå¤©æ ‡é¢˜
    document.getElementById('chat-title').innerText = char.remark || char.wx_nickname || char.name;
    
    // å®æ—¶æ›´æ–°è¾“å…¥æ¡†æ–‡æ¡ˆ
    const chatInputBox = document.getElementById('chat-input-box');
    if (chatInputBox) {
        chatInputBox.placeholder = char.input_placeholder || 'å‘é€æ¶ˆæ¯...';
    }
    
    // å¦‚æœå½“å‰æ­£åœ¨æŸ¥çœ‹è¿™ä¸ªèŠå¤©ï¼Œç«‹å³åº”ç”¨æ ·å¼
    if (currentChatCharId === char.id) {
        applyCustomStyles(char);
    }
    // åˆ·æ–°åˆ—è¡¨ï¼ˆå¦‚æœæ­¤æ—¶å¾®ä¿¡åˆ—è¡¨å¯è§ï¼‰
    // ...
}

// æ˜¾ç¤ºæŒ‚è½½è¡¨æƒ…åŒ…åº“å¼¹çª—
async function showMountStickerModal() {
    if (!currentChatCharId) return;
    
    const char = await db.characters.get(currentChatCharId);
    const mountedIds = char.mounted_sticker_categories || [];
    
    const modal = document.getElementById('mount-sticker-modal');
    const listContainer = document.getElementById('mount-sticker-list');
    
    if (!modal || !listContainer) {
        console.error('æŒ‚è½½è¡¨æƒ…åŒ…åº“å¼¹çª—å…ƒç´ æœªæ‰¾åˆ°');
        return;
    }
    
    // è·å–æ‰€æœ‰è¡¨æƒ…åŒ…åˆ†ç±»
    const categories = await db.sticker_categories.toArray();
    
    if (categories.length === 0) {
        listContainer.innerHTML = '<div style="text-align:center; color:#999; padding:40px;">æš‚æ— è¡¨æƒ…åŒ…åˆ†ç±»<br>è¯·å…ˆå»ã€æˆ‘-è¡¨æƒ…ã€‘åˆ›å»ºåˆ†ç±»</div>';
    } else {
        listContainer.innerHTML = categories.map(cat => {
            const isMounted = mountedIds.includes(cat.id);
            const stickerCount = (cat.stickers || []).length;
            return `
                <label style="display:flex; align-items:center; padding:12px; background:${isMounted ? '#f0f0f5' : '#fff'}; border:1px solid #f0f0f0; border-radius:8px; cursor:pointer; transition:background 0.2s;">
                    <input type="checkbox" value="${cat.id}" ${isMounted ? 'checked' : ''} style="margin-right:12px; width:18px; height:18px; cursor:pointer;" onchange="this.parentElement.style.background = this.checked ? '#f0f0f5' : '#fff'">
                    <div style="flex:1;">
                        <div style="font-size:15px; font-weight:500; color:#333; margin-bottom:4px;">${cat.name}</div>
                        <div style="font-size:12px; color:#999;">${stickerCount} ä¸ªè¡¨æƒ…</div>
                    </div>
                </label>
            `;
        }).join('');
    }
    
    modal.style.display = 'flex';
    
    // ç‚¹å‡»å¤–éƒ¨åŒºåŸŸå…³é—­å¼¹çª—
    modal.onclick = function(e) {
        if (e.target === modal) {
            hideMountStickerModal();
        }
    };
}

// éšè—æŒ‚è½½è¡¨æƒ…åŒ…åº“å¼¹çª—
function hideMountStickerModal() {
    const modal = document.getElementById('mount-sticker-modal');
    if (modal) modal.style.display = 'none';
}

// ä¿å­˜æŒ‚è½½çš„è¡¨æƒ…åŒ…åˆ†ç±»
async function saveMountedStickers() {
    if (!currentChatCharId) return;
    
    const checkboxes = document.querySelectorAll('#mount-sticker-list input[type="checkbox"]:checked');
    const mountedIds = Array.from(checkboxes).map(cb => parseInt(cb.value));
    
    const char = await db.characters.get(currentChatCharId);
    char.mounted_sticker_categories = mountedIds.length > 0 ? mountedIds : null;
    await db.characters.put(char);
    
    updateMountedStickerCount();
    hideMountStickerModal();
    
    // åˆ·æ–°è¡¨æƒ…åŒ…é¢æ¿
    await updateChatStickerPanel();
}

// æ›´æ–°æŒ‚è½½è¡¨æƒ…åŒ…æ•°é‡æ˜¾ç¤º
async function updateMountedStickerCount() {
    if (!currentChatCharId) return;
    
    const char = await db.characters.get(currentChatCharId);
    const mountedIds = char.mounted_sticker_categories || [];
    const countEl = document.getElementById('mounted-sticker-count');
    
    if (!countEl) return;
    
    if (mountedIds.length === 0) {
        countEl.innerText = 'æœªæŒ‚è½½';
    } else {
        // è®¡ç®—æ€»è¡¨æƒ…æ•°
        let totalStickers = 0;
        for (const catId of mountedIds) {
            const cat = await db.sticker_categories.get(catId);
            if (cat && cat.stickers) {
                totalStickers += cat.stickers.length;
            }
        }
        countEl.innerText = `${mountedIds.length}ä¸ªåˆ†ç±» (${totalStickers}ä¸ªè¡¨æƒ…)`;
    }
}

// ç¡®ä¿å‡½æ•°åœ¨å…¨å±€ä½œç”¨åŸŸå¯è®¿é—®
window.showMountStickerModal = showMountStickerModal;
window.hideMountStickerModal = hideMountStickerModal;
window.saveMountedStickers = saveMountedStickers;

// æ˜¾ç¤ºæŒ‚è½½ç”¨æˆ·æ¡£æ¡ˆå¼¹çª—
async function showMountUserModal() {
    if (!currentChatCharId) return;
    
    const char = await db.characters.get(currentChatCharId);
    const currentUserId = char.linked_user_id || null;
    
    const modal = document.getElementById('mount-user-modal');
    const listContainer = document.getElementById('mount-user-list');
    
    if (!modal || !listContainer) {
        console.error('æŒ‚è½½ç”¨æˆ·æ¡£æ¡ˆå¼¹çª—å…ƒç´ æœªæ‰¾åˆ°');
        return;
    }
    
    // è·å–æ‰€æœ‰Userç±»å‹æ¡£æ¡ˆ
    const users = await db.characters.where('type').equals('user').toArray();
    
    if (users.length === 0) {
        listContainer.innerHTML = '<div style="text-align:center; color:#999; padding:40px;">æš‚æ— ç”¨æˆ·æ¡£æ¡ˆ<br>è¯·å…ˆå»ã€è§’è‰²æ¡£æ¡ˆ-Userã€‘åˆ›å»ºç”¨æˆ·</div>';
    } else {
        listContainer.innerHTML = users.map(user => {
            const isSelected = currentUserId === user.id;
            const avatarStyle = user.avatar ? `background-image:url(${user.avatar}); background-size:cover; background-position:center;` : 'background:#f0f0f0;';
            return `
                <div onclick="selectMountUser(${user.id})" style="display:flex; align-items:center; padding:12px; background:${isSelected ? '#ffe4e8' : '#fff'}; border:2px solid ${isSelected ? 'var(--ins-pink)' : '#f0f0f0'}; border-radius:12px; cursor:pointer; transition:all 0.2s;">
                    <div style="width:48px; height:48px; border-radius:50%; ${avatarStyle} margin-right:12px; flex-shrink:0;"></div>
                    <div style="flex:1; min-width:0;">
                        <div style="font-size:15px; font-weight:500; color:#333; margin-bottom:4px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${user.name}</div>
                        <div style="font-size:12px; color:#999; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${user.description ? user.description.substring(0, 30) + (user.description.length > 30 ? '...' : '') : 'æš‚æ— ç®€ä»‹'}</div>
                    </div>
                    ${isSelected ? '<div style="color:var(--ins-pink); font-size:20px; margin-left:8px;">âœ“</div>' : ''}
                </div>
            `;
        }).join('');
    }
    
    modal.style.display = 'flex';
    
    // ç‚¹å‡»å¤–éƒ¨åŒºåŸŸå…³é—­å¼¹çª—
    modal.onclick = function(e) {
        if (e.target === modal) {
            hideMountUserModal();
        }
    };
}

// éšè—æŒ‚è½½ç”¨æˆ·æ¡£æ¡ˆå¼¹çª—
function hideMountUserModal() {
    const modal = document.getElementById('mount-user-modal');
    if (modal) modal.style.display = 'none';
}

// é€‰æ‹©æŒ‚è½½çš„ç”¨æˆ·æ¡£æ¡ˆ
async function selectMountUser(userId) {
    if (!currentChatCharId) return;
    
    const char = await db.characters.get(currentChatCharId);
    char.linked_user_id = userId;
    await db.characters.put(char);
    
    // æ›´æ–°æ˜¾ç¤º
    updateMountedUserDisplay();
    hideMountUserModal();
    showToast('å·²æŒ‚è½½ç”¨æˆ·æ¡£æ¡ˆ');
}

// å¸è½½ç”¨æˆ·æ¡£æ¡ˆ
async function unmountUser() {
    if (!currentChatCharId) return;
    
    const char = await db.characters.get(currentChatCharId);
    char.linked_user_id = null;
    await db.characters.put(char);
    
    // æ›´æ–°æ˜¾ç¤º
    updateMountedUserDisplay();
    hideMountUserModal();
    showToast('å·²å¸è½½ç”¨æˆ·æ¡£æ¡ˆ');
}

// æ›´æ–°æŒ‚è½½ç”¨æˆ·æ¡£æ¡ˆæ˜¾ç¤º
async function updateMountedUserDisplay() {
    if (!currentChatCharId) return;
    
    const char = await db.characters.get(currentChatCharId);
    const displayEl = document.getElementById('detail-mounted-user');
    
    if (!displayEl) return;
    
    if (char.linked_user_id) {
        const user = await db.characters.get(char.linked_user_id);
        if (user) {
            displayEl.innerText = user.name;
            displayEl.style.color = 'var(--ins-pink)';
        } else {
            displayEl.innerText = 'æœªæŒ‚è½½';
            displayEl.style.color = '#999';
        }
    } else {
        displayEl.innerText = 'æœªæŒ‚è½½';
        displayEl.style.color = '#999';
    }
}

// ç¡®ä¿æŒ‚è½½ç”¨æˆ·æ¡£æ¡ˆå‡½æ•°åœ¨å…¨å±€ä½œç”¨åŸŸå¯è®¿é—®
window.showMountUserModal = showMountUserModal;
window.hideMountUserModal = hideMountUserModal;
window.selectMountUser = selectMountUser;
window.unmountUser = unmountUser;

        async function setChatDetailAvatar(input) {
            const file = input.files[0];
            if (file && currentChatCharId) {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const base64 = e.target.result;
                    document.getElementById('detail-char-avatar').style.backgroundImage = `url(${base64})`;
                    
                    const char = await db.characters.get(currentChatCharId);
                    char.avatar = base64;
                    await db.characters.put(char);
                    
                    // åˆ·æ–°èŠå¤©ç•Œé¢å¤´åƒï¼ˆå¦‚æœåœ¨èŠå¤©ä¸­ï¼‰
                    renderChatBody(char); 
                };
                reader.readAsDataURL(file);
            }
            input.value = '';
        }

        async function setChatBackground(input) {
            const file = input.files[0];
            if (file && currentChatCharId) {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const base64 = e.target.result;
                    const bgPreview = document.getElementById('detail-chat-bg-preview');
                    bgPreview.style.backgroundImage = `url(${base64})`;
                    bgPreview.textContent = '';
                    
                    const char = await db.characters.get(currentChatCharId);
                    char.chat_background = base64;
                    await db.characters.put(char);
                    
                    // ç«‹å³åº”ç”¨èƒŒæ™¯å›¾åˆ°èŠå¤©ç•Œé¢
                    applyChatBackground(char);
                };
                reader.readAsDataURL(file);
            }
            input.value = '';
        }

        async function clearChatBackground() {
            if (!currentChatCharId) return;
            if (!confirm('ç¡®å®šè¦æ¸…é™¤èŠå¤©èƒŒæ™¯å›¾å—ï¼Ÿ')) return;
            
            const char = await db.characters.get(currentChatCharId);
            char.chat_background = null;
            await db.characters.put(char);
            
            const bgPreview = document.getElementById('detail-chat-bg-preview');
            bgPreview.style.backgroundImage = '';
            bgPreview.textContent = 'æš‚æ— èƒŒæ™¯å›¾';
            
            // æ¸…é™¤èŠå¤©ç•Œé¢çš„èƒŒæ™¯å›¾
            applyChatBackground(char);
        }

        function applyChatBackground(char) {
            const chatBody = document.getElementById('chat-body');
            if (!chatBody) return;
            
            if (char.chat_background) {
                chatBody.style.backgroundImage = `url(${char.chat_background})`;
                chatBody.style.backgroundSize = 'cover';
                chatBody.style.backgroundPosition = 'center';
                chatBody.style.backgroundRepeat = 'no-repeat';
                chatBody.style.backgroundAttachment = 'fixed';
            } else {
                chatBody.style.backgroundImage = '';
                chatBody.style.backgroundSize = '';
                chatBody.style.backgroundPosition = '';
                chatBody.style.backgroundRepeat = '';
                chatBody.style.backgroundAttachment = '';
            }
        }

        // å±•å¼€/æ”¶èµ·è‡ªå®šä¹‰æ ·å¼åŒºåŸŸ
        function toggleCustomStyleSection() {
            const section = document.getElementById('custom-style-section');
            const icon = document.getElementById('custom-style-toggle-icon');
            
            if (section.style.display === 'none' || !section.style.display) {
                section.style.display = 'block';
                icon.style.transform = 'rotate(90deg)';
            } else {
                section.style.display = 'none';
                icon.style.transform = 'rotate(0deg)';
            }
        }

        // ä¸¥æ ¼è¿‡æ»¤HTMLä¸­çš„JavaScript
        function sanitizeHTML(html) {
            if (!html) return '';
            
            // ç§»é™¤æ‰€æœ‰scriptæ ‡ç­¾
            html = html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
            
            // ç§»é™¤æ‰€æœ‰äº‹ä»¶å¤„ç†å™¨å±æ€§ (on*)
            html = html.replace(/\s*on\w+\s*=\s*["'][^"']*["']/gi, '');
            html = html.replace(/\s*on\w+\s*=\s*[^\s>]*/gi, '');
            
            // ç§»é™¤ javascript: åè®®
            html = html.replace(/javascript:/gi, '');
            
            // ç§»é™¤ data: åè®®ï¼ˆå¯èƒ½åŒ…å«base64ç¼–ç çš„JSï¼‰
            html = html.replace(/data:text\/html/gi, '');
            
            return html;
        }

        // ä¸¥æ ¼è¿‡æ»¤CSSä¸­çš„JavaScript
        function sanitizeCSS(css) {
            if (!css) return '';
            
            // ç§»é™¤ javascript: åè®®
            css = css.replace(/javascript:/gi, '');
            
            // ç§»é™¤ expression() (IEç‰¹æœ‰ï¼Œå¯æ‰§è¡ŒJS)
            css = css.replace(/expression\s*\(/gi, '');
            
            // ç§»é™¤ @import url(javascript:...)
            css = css.replace(/@import\s+url\s*\(\s*["']?javascript:/gi, '@import url(');
            
            // ç§»é™¤ behavior: (IEç‰¹æœ‰)
            css = css.replace(/behavior\s*:/gi, 'removed-behavior:');
            
            // ç§»é™¤ -moz-binding (Firefoxç‰¹æœ‰ï¼Œå¯æ‰§è¡ŒJS)
            css = css.replace(/-moz-binding\s*:/gi, 'removed-binding:');
            
            return css;
        }

        // é¢„è§ˆè‡ªå®šä¹‰æ ·å¼
        async function previewCustomStyle() {
            if (!currentChatCharId) return;
            
            const char = await db.characters.get(currentChatCharId);
            if (!char) return;
            
            // ä¸´æ—¶ä¿å­˜å½“å‰è¾“å…¥çš„å†…å®¹
            const tempBubbleCSS = sanitizeCSS(document.getElementById('detail-bubble-css').value);
            const tempHTML = sanitizeHTML(document.getElementById('detail-custom-html').value);
            const tempCSS = sanitizeCSS(document.getElementById('detail-custom-css').value);
            
            // ä¸´æ—¶åº”ç”¨æ ·å¼
            applyCustomStyles({
                custom_bubble_css: tempBubbleCSS,
                custom_html: tempHTML,
                custom_css: tempCSS
            });
            
            alert('é¢„è§ˆæ•ˆæœå·²åº”ç”¨ï¼\nè¿”å›èŠå¤©ç•Œé¢æŸ¥çœ‹æ•ˆæœã€‚\nä¿å­˜åå°†æ°¸ä¹…ç”Ÿæ•ˆã€‚');
        }

        // æ¸…é™¤è‡ªå®šä¹‰æ ·å¼
        async function clearCustomStyle() {
            if (!confirm('ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰è‡ªå®šä¹‰æ ·å¼å—ï¼Ÿ')) return;
            
            document.getElementById('detail-bubble-css').value = '';
            document.getElementById('detail-custom-html').value = '';
            document.getElementById('detail-custom-css').value = '';
            
            await saveChatDetail();
            
            // ç§»é™¤å·²åº”ç”¨çš„æ ·å¼
            removeCustomStyles();
            
            alert('è‡ªå®šä¹‰æ ·å¼å·²æ¸…é™¤ï¼');
        }

        // ========== èŠå¤©æ ·å¼é¢„è®¾åŠŸèƒ½ ==========
        
        // ä¿å­˜å½“å‰æ ·å¼ä¸ºé¢„è®¾
        async function saveChatStylePreset() {
            const bubbleStyle = document.querySelector('.bubble-style-option.selected');
            const bubbleCSS = document.getElementById('detail-bubble-css').value.trim();
            const customHTML = document.getElementById('detail-custom-html').value.trim();
            const customCSS = document.getElementById('detail-custom-css').value.trim();
            
            if (!bubbleCSS && !customHTML && !customCSS && (!bubbleStyle || bubbleStyle.dataset.style === 'default')) {
                showToast('å½“å‰æ²¡æœ‰è‡ªå®šä¹‰æ ·å¼å¯ä¿å­˜');
                return;
            }
            
            const presetName = prompt('è¯·è¾“å…¥é¢„è®¾åç§°ï¼š');
            if (!presetName || !presetName.trim()) return;
            
            try {
                // è¯»å–å·²æœ‰é¢„è®¾åˆ—è¡¨
                const existing = await db.dexiData.get('chatStylePresets');
                const presets = existing ? existing.value : [];
                
                // æ£€æŸ¥æ˜¯å¦é‡å
                if (presets.find(p => p.name === presetName.trim())) {
                    if (!confirm(`é¢„è®¾"${presetName.trim()}"å·²å­˜åœ¨ï¼Œæ˜¯å¦è¦†ç›–ï¼Ÿ`)) return;
                    // è¦†ç›–ï¼šç§»é™¤æ—§çš„
                    const idx = presets.findIndex(p => p.name === presetName.trim());
                    if (idx !== -1) presets.splice(idx, 1);
                }
                
                presets.push({
                    name: presetName.trim(),
                    bubble_style: bubbleStyle ? bubbleStyle.dataset.style : 'default',
                    custom_bubble_css: bubbleCSS,
                    custom_html: customHTML,
                    custom_css: customCSS,
                    time: Date.now()
                });
                
                await db.dexiData.put({ key: 'chatStylePresets', value: presets });
                showToast(`æ ·å¼é¢„è®¾"${presetName.trim()}"å·²ä¿å­˜ï¼`);
            } catch (e) {
                console.error('[èŠå¤©æ ·å¼] ä¿å­˜é¢„è®¾å¤±è´¥:', e);
                showToast('ä¿å­˜é¢„è®¾å¤±è´¥');
            }
        }
        
        // åŠ è½½é¢„è®¾åˆ—è¡¨
        async function loadChatStylePreset() {
            try {
                const existing = await db.dexiData.get('chatStylePresets');
                const presets = existing ? existing.value : [];
                
                if (presets.length === 0) {
                    showToast('æš‚æ— ä¿å­˜çš„æ ·å¼é¢„è®¾');
                    return;
                }
                
                const listEl = document.getElementById('chat-style-preset-list');
                if (!listEl) return;
                
                // åˆ‡æ¢æ˜¾ç¤º/éšè—
                if (listEl.style.display !== 'none' && listEl.innerHTML !== '') {
                    listEl.style.display = 'none';
                    return;
                }
                
                let html = '';
                for (let i = 0; i < presets.length; i++) {
                    const p = presets[i];
                    const timeStr = p.time ? new Date(p.time).toLocaleDateString() : '';
                    const hasCSS = p.custom_bubble_css ? 'æ°”æ³¡CSS' : '';
                    const hasHTML = p.custom_html ? 'è‡ªå®šä¹‰HTML' : '';
                    const hasCSSContainer = p.custom_css ? 'å®¹å™¨CSS' : '';
                    const tags = [p.bubble_style !== 'default' ? `æ ·å¼:${p.bubble_style}` : '', hasCSS, hasHTML, hasCSSContainer].filter(Boolean).join(' Â· ');
                    
                    html += `
                        <div style="display:flex; align-items:center; padding:10px 12px; background:#fff; border:1px solid #e8e8e8; border-radius:10px; margin-bottom:8px;">
                            <div style="flex:1; min-width:0;">
                                <div style="font-size:13px; font-weight:500; color:#333; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${p.name}</div>
                                <div style="font-size:10px; color:#aaa; margin-top:3px;">${tags || 'é»˜è®¤æ ·å¼'} ${timeStr ? 'Â· ' + timeStr : ''}</div>
                            </div>
                            <div style="display:flex; gap:6px; flex-shrink:0; margin-left:8px;">
                                <div onclick="applyChatStylePreset(${i})" style="padding:5px 12px; font-size:11px; background:#007aff; color:#fff; border-radius:6px; cursor:pointer; font-weight:500;">åº”ç”¨</div>
                                <div onclick="deleteChatStylePreset(${i})" style="padding:5px 10px; font-size:11px; background:#f5f5f5; color:#ff3b30; border-radius:6px; cursor:pointer;">åˆ é™¤</div>
                            </div>
                        </div>
                    `;
                }
                
                listEl.innerHTML = html;
                listEl.style.display = 'block';
            } catch (e) {
                console.error('[èŠå¤©æ ·å¼] åŠ è½½é¢„è®¾å¤±è´¥:', e);
                showToast('åŠ è½½é¢„è®¾å¤±è´¥');
            }
        }
        
        // åº”ç”¨æŒ‡å®šé¢„è®¾
        async function applyChatStylePreset(index) {
            try {
                const existing = await db.dexiData.get('chatStylePresets');
                const presets = existing ? existing.value : [];
                if (index < 0 || index >= presets.length) return;
                
                const p = presets[index];
                
                // å›å¡«åˆ°è¡¨å•
                document.getElementById('detail-bubble-css').value = p.custom_bubble_css || '';
                document.getElementById('detail-custom-html').value = p.custom_html || '';
                document.getElementById('detail-custom-css').value = p.custom_css || '';
                
                // é€‰ä¸­æ°”æ³¡æ ·å¼
                const style = p.bubble_style || 'default';
                document.querySelectorAll('.bubble-style-option').forEach(el => {
                    el.classList.remove('selected');
                    if (el.dataset.style === style) {
                        el.classList.add('selected');
                    }
                });
                
                // ä¿å­˜åˆ°è§’è‰²
                await saveChatDetail();
                
                showToast(`å·²åº”ç”¨é¢„è®¾"${p.name}"`);
                
                // éšè—é¢„è®¾åˆ—è¡¨
                const listEl = document.getElementById('chat-style-preset-list');
                if (listEl) listEl.style.display = 'none';
            } catch (e) {
                console.error('[èŠå¤©æ ·å¼] åº”ç”¨é¢„è®¾å¤±è´¥:', e);
                showToast('åº”ç”¨é¢„è®¾å¤±è´¥');
            }
        }
        
        // åˆ é™¤æŒ‡å®šé¢„è®¾
        async function deleteChatStylePreset(index) {
            try {
                const existing = await db.dexiData.get('chatStylePresets');
                const presets = existing ? existing.value : [];
                if (index < 0 || index >= presets.length) return;
                
                const name = presets[index].name;
                if (!confirm(`ç¡®å®šè¦åˆ é™¤é¢„è®¾"${name}"å—ï¼Ÿ`)) return;
                
                presets.splice(index, 1);
                await db.dexiData.put({ key: 'chatStylePresets', value: presets });
                
                showToast(`å·²åˆ é™¤é¢„è®¾"${name}"`);
                
                // åˆ·æ–°åˆ—è¡¨ï¼ˆå…ˆéšè—å†é‡æ–°æ˜¾ç¤ºï¼Œé¿å…toggleé€»è¾‘ï¼‰
                const listEl = document.getElementById('chat-style-preset-list');
                if (listEl) {
                    listEl.style.display = 'none';
                    listEl.innerHTML = '';
                }
                if (presets.length > 0) {
                    loadChatStylePreset();
                }
            } catch (e) {
                console.error('[èŠå¤©æ ·å¼] åˆ é™¤é¢„è®¾å¤±è´¥:', e);
                showToast('åˆ é™¤é¢„è®¾å¤±è´¥');
            }
        }

        // åº”ç”¨è‡ªå®šä¹‰æ ·å¼åˆ°èŠå¤©ç•Œé¢
        function applyCustomStyles(char) {
            if (!char) return;
            
            // ç§»é™¤ä¹‹å‰çš„è‡ªå®šä¹‰æ ·å¼
            removeCustomStyles();
            
            const chatContainer = document.getElementById('chat-body');
            if (!chatContainer) return;
            
            // åº”ç”¨æ°”æ³¡æ ·å¼ç±»åï¼ˆé»˜è®¤/ä»¿å¾®ä¿¡ï¼‰
            chatContainer.classList.remove('bubble-style-default', 'bubble-style-wechat');
            if (char.bubble_style === 'wechat') {
                chatContainer.classList.add('bubble-style-wechat');
            } else {
                chatContainer.classList.add('bubble-style-default');
            }
            
            // åº”ç”¨è‡ªå®šä¹‰æ°”æ³¡CSS
            if (char.custom_bubble_css) {
                const bubbleStyleId = 'custom-bubble-style';
                let styleTag = document.getElementById(bubbleStyleId);
                
                if (!styleTag) {
                    styleTag = document.createElement('style');
                    styleTag.id = bubbleStyleId;
                    document.head.appendChild(styleTag);
                }
                
                // åªåº”ç”¨åˆ°AIçš„æ¶ˆæ¯æ°”æ³¡
                styleTag.textContent = `.chat-bubble.ai-bubble { ${char.custom_bubble_css} }`;
            }
            
            // åº”ç”¨è‡ªå®šä¹‰CSS
            if (char.custom_css) {
                const cssStyleId = 'custom-chat-css';
                let styleTag = document.getElementById(cssStyleId);
                
                if (!styleTag) {
                    styleTag = document.createElement('style');
                    styleTag.id = cssStyleId;
                    document.head.appendChild(styleTag);
                }
                
                styleTag.textContent = char.custom_css;
            }
            
            // æ·»åŠ è‡ªå®šä¹‰HTMLå®¹å™¨
            if (char.custom_html) {
                const customContainer = document.createElement('div');
                customContainer.id = 'custom-chat-container';
                customContainer.innerHTML = char.custom_html;
                
                // æ’å…¥åˆ°èŠå¤©åŒºåŸŸé¡¶éƒ¨
                if (chatContainer.firstChild) {
                    chatContainer.insertBefore(customContainer, chatContainer.firstChild);
                } else {
                    chatContainer.appendChild(customContainer);
                }
            }
        }

        // ç§»é™¤è‡ªå®šä¹‰æ ·å¼
        function removeCustomStyles() {
            // ç§»é™¤æ°”æ³¡æ ·å¼
            const bubbleStyle = document.getElementById('custom-bubble-style');
            if (bubbleStyle) bubbleStyle.remove();
            
            // ç§»é™¤è‡ªå®šä¹‰CSS
            const cssStyle = document.getElementById('custom-chat-css');
            if (cssStyle) cssStyle.remove();
            
            // ç§»é™¤è‡ªå®šä¹‰HTMLå®¹å™¨
            const customContainer = document.getElementById('custom-chat-container');
            if (customContainer) customContainer.remove();
        }

        async function jumpToCharEditor() {
            if (!currentChatCharId) return;
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯è”æœºå¥½å‹
            const char = await db.characters.get(currentChatCharId);
            if (char && char.isOnlineFriend) {
                // è”æœºå¥½å‹åªæ˜¾ç¤ºç®€åŒ–ä¿¡æ¯
                showOnlineFriendProfile(char);
                return;
            }
            
            hideChatDetail();
            editCharacter(currentChatCharId);
        }
        
        // æ˜¾ç¤ºè”æœºå¥½å‹çš„ç®€åŒ–æ¡£æ¡ˆï¼ˆåªæœ‰åŸºæœ¬ä¿¡æ¯ï¼Œæ²¡æœ‰äººè®¾ï¼‰
        function showOnlineFriendProfile(char) {
            const avatar = char.avatar || '';
            const avatarStyle = avatar ? `background-image:url(${avatar})` : 'background:#e0e0e0';
            
            const html = `
                <div style="position:fixed; top:0; left:0; right:0; bottom:0; background:#f5f5f5; z-index:9999; display:flex; flex-direction:column;">
                    <div class="wechat-header" style="background:#fff;">
                        <div class="back-btn" onclick="this.closest('div[style*=position]').remove()" style="margin:0; background:none; width:40px; justify-content:flex-start; padding-left:0; color:var(--ins-text);">
                            <svg class="svg-icon" viewBox="0 0 24 24" style="width:28px; height:28px;"><polyline points="15 18 9 12 15 6"></polyline></svg>
                        </div>
                        <div class="wechat-title">è”æœºå¥½å‹èµ„æ–™</div>
                        <div style="width:40px;"></div>
                    </div>
                    
                    <div style="flex:1; overflow-y:auto; padding:20px;">
                        <!-- å¤´åƒå’ŒåŸºæœ¬ä¿¡æ¯ -->
                        <div style="text-align:center; padding:30px 0;">
                            <div style="width:100px; height:100px; border-radius:12px; margin:0 auto 16px; background-size:cover; background-position:center; ${avatarStyle}"></div>
                            <div style="font-size:20px; font-weight:600; color:#333; margin-bottom:8px;">${char.name || 'æœªçŸ¥'}</div>
                            <div style="font-size:14px; color:#999;">è”æœºå¥½å‹</div>
                        </div>
                        
                        <!-- ä¿¡æ¯å¡ç‰‡ -->
                        <div style="background:#fff; border-radius:12px; overflow:hidden; margin-bottom:16px;">
                            <div style="padding:16px; border-bottom:1px solid #f0f0f0; display:flex; justify-content:space-between;">
                                <span style="color:#666;">å¾®ä¿¡å·</span>
                                <span style="color:#333;">${char.identity?.account || 'æœªçŸ¥'}</span>
                            </div>
                            <div style="padding:16px; display:flex; justify-content:space-between;">
                                <span style="color:#666;">æ˜µç§°</span>
                                <span style="color:#333;">${char.name || 'æœªçŸ¥'}</span>
                            </div>
                        </div>
                        
                        <!-- æç¤ºä¿¡æ¯ -->
                        <div style="text-align:center; padding:20px; color:#999; font-size:13px;">
                            <div style="margin-bottom:8px;">ğŸŒ è¿™æ˜¯ä¸€ä½è”æœºå¥½å‹</div>
                            <div>å¯¹æ–¹çš„è¯¦ç»†èµ„æ–™ä¸å¯è§</div>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', html);
        }

        async function clearChatHistory() {
            if (!currentChatCharId) return;
            if (confirm("ç¡®å®šè¦æ¸…ç©ºä¸è¯¥è§’è‰²çš„èŠå¤©è®°å½•å—ï¼Ÿ")) {
                const char = await db.characters.get(currentChatCharId);
                const accountId = getCurrentAccountId();
                await setChatHistory(char, accountId, []);
                renderChatBody(char);
                alert("å·²æ¸…ç©º");
            }
        }
        
        // --- ä¸»åŠ¨å‘æ¶ˆæ¯é€»è¾‘ï¼ˆçº¯å‰ç«¯é©±åŠ¨ï¼‰---
        let syncTimer = null; // å®šæ—¶å™¨ï¼ˆä¿ç•™å˜é‡åå…¼å®¹æ€§ï¼‰
        
        // çº¯å‰ç«¯æ¨¡å¼ï¼šä¸éœ€è¦åŒæ­¥åˆ°åç«¯ï¼Œè§’è‰²æ•°æ®å…¨éƒ¨å­˜å‚¨åœ¨æœ¬åœ° IndexedDB
        async function syncCharactersToBackend() {
            // çº¯å‰ç«¯æ¨¡å¼ï¼šæ— éœ€åŒæ­¥ï¼Œä»…æ‰“å°æ—¥å¿—
            console.log('[Sync] çº¯å‰ç«¯æ¨¡å¼ï¼šè§’è‰²æ•°æ®å­˜å‚¨åœ¨æœ¬åœ°ï¼Œæ— éœ€åŒæ­¥åˆ°åç«¯');
        }
        
        // æ³¨å†Œ Service Workerï¼ˆçº¯å‰ç«¯ç‰ˆæœ¬ï¼šä»…ç”¨äº PWA å’Œæœ¬åœ°é€šçŸ¥ï¼‰
        async function registerServiceWorkerAndSubscribe() {
            if (!('serviceWorker' in navigator)) {
                console.log('[SW] Not supported');
                showDebugToast('âŒ æµè§ˆå™¨ä¸æ”¯æŒService Worker');
                return;
            }
            
            try {
                // æ³¨å†Œ Service Workerï¼ˆç‹¬ç«‹æ–‡ä»¶ï¼Œç”¨äº PWA åŠŸèƒ½ï¼‰
                const registration = await navigator.serviceWorker.register('./sw.js');
                console.log('[SW] Registered:', registration);
                showDebugToast('âœ“ Service Workerå·²æ³¨å†Œ');
                
                // ç­‰å¾…æ¿€æ´»
                await navigator.serviceWorker.ready;
                console.log('[ServiceWorker] Ready');
                
                // è¯·æ±‚é€šçŸ¥æƒé™ï¼ˆç”¨äºæœ¬åœ°é€šçŸ¥ï¼‰
                if ('Notification' in window) {
                    const permission = await Notification.requestPermission();
                    if (permission === 'granted') {
                        console.log('[Notification] âœ“ é€šçŸ¥æƒé™å·²æˆäºˆ');
                        showDebugToast('âœ“ é€šçŸ¥æƒé™å·²æˆäºˆ', true);
                    } else {
                        console.log('[Notification] âœ— é€šçŸ¥æƒé™è¢«æ‹’ç»');
                        showDebugToast('âœ— é€šçŸ¥æƒé™è¢«æ‹’ç»');
                    }
                }
                
                // çº¯å‰ç«¯æ¨¡å¼ï¼šä¸éœ€è¦ Web Push åç«¯è®¢é˜…
                // é€šçŸ¥å°†é€šè¿‡å‰ç«¯çš„ Notification API ç›´æ¥å‘é€
                console.log('[Push] çº¯å‰ç«¯æ¨¡å¼ï¼šä½¿ç”¨æœ¬åœ° Notification API å‘é€é€šçŸ¥');
                showDebugToast('âœ“ æœ¬åœ°é€šçŸ¥å·²å°±ç»ª', true);
                
            } catch (err) {
                console.error('[ServiceWorker] Error:', err);
                showDebugToast(`âœ— Service Workeré”™è¯¯: ${err.message}`);
            }
        }
        
        // Base64 è½¬ Uint8Array (ç”¨äº VAPID å…¬é’¥)
        function urlBase64ToUint8Array(base64String) {
            const padding = '='.repeat((4 - base64String.length % 4) % 4);
            const base64 = (base64String + padding)
                .replace(/\-/g, '+')
                .replace(/_/g, '/');
            
            const rawData = window.atob(base64);
            const outputArray = new Uint8Array(rawData.length);
            
            for (let i = 0; i < rawData.length; ++i) {
                outputArray[i] = rawData.charCodeAt(i);
            }
            return outputArray;
        }
        
        // çº¯å‰ç«¯æ¨¡å¼ï¼šä¸éœ€è¦ WebSocket è¿æ¥
        // ä¸»åŠ¨æ¶ˆæ¯å®Œå…¨ç”±å‰ç«¯å®šæ—¶å™¨é©±åŠ¨
        function connectWebSocket() {
            console.log('[WebSocket] çº¯å‰ç«¯æ¨¡å¼ï¼šä¸éœ€è¦ WebSocket è¿æ¥');
            console.log('[WebSocket] ä¸»åŠ¨æ¶ˆæ¯ç”±å‰ç«¯å®šæ—¶å™¨é©±åŠ¨');
        }
        
        // å¯åŠ¨ä¸»åŠ¨èŠå¤©æ£€æµ‹å¾ªç¯ï¼ˆçº¯å‰ç«¯ç‰ˆæœ¬ï¼‰
        async function startAutoChatLoop() {
            if (syncTimer) clearInterval(syncTimer);
            
            console.log('[AutoChat] å¯åŠ¨çº¯å‰ç«¯ä¸»åŠ¨èŠå¤©æ¨¡å¼...');
            console.log('[AutoChat] å½“å‰ç¯å¢ƒ:', {
                protocol: location.protocol,
                hostname: location.hostname,
                href: location.href,
                serviceWorkerSupported: 'serviceWorker' in navigator,
                notificationSupported: 'Notification' in window,
                notificationPermission: Notification.permission
            });
            showDebugToast('ä¸»åŠ¨èŠå¤©æ£€æµ‹å¯åŠ¨ä¸­...', true);
            
            // çº¯å‰ç«¯æ¨¡å¼ï¼šä¸éœ€è¦ WebSocket è¿æ¥
            console.log('[AutoChat] çº¯å‰ç«¯æ¨¡å¼ï¼šç”±å‰ç«¯å®šæ—¶å™¨é©±åŠ¨ä¸»åŠ¨æ¶ˆæ¯');
            
            // 5. æ¯15ç§’æ£€æŸ¥ä¸€æ¬¡æ˜¯å¦è¯¥å‘æ¶ˆæ¯ï¼ˆç«‹å³è§¦å‘ï¼Œæ— åç«¯è½®è¯¢å»¶è¿Ÿï¼‰
            setInterval(() => {
                checkAutoChat(); // å‰ç«¯ä¸»åŠ¨æ£€æŸ¥
                checkAutoMoments(); // æœ‹å‹åœˆè‡ªåŠ¨å‘å¸ƒæ£€æŸ¥
            }, 15 * 1000);
            
            // ç«‹å³æ£€æŸ¥ä¸€æ¬¡
            checkAutoChat();
            checkAutoMoments();
            
            // 6. ç›‘å¬é¡µé¢å¯è§æ€§å˜åŒ–ï¼Œä»åå°åˆ‡å›æ—¶ç«‹å³æ£€æŸ¥
            document.addEventListener('visibilitychange', function() {
                if (!document.hidden) {
                    console.log('[AutoChat] âœ“ Page became visible, checking for pending messages...');
                    showDebugToast('âœ“ è¿”å›å‰å°ï¼Œæ£€æŸ¥æ¶ˆæ¯...');
                    
                    // ç«‹å³æ£€æŸ¥æ˜¯å¦æœ‰è¯¥å‘çš„æ¶ˆæ¯ï¼ˆå¯èƒ½åœ¨åå°æ—¶é”™è¿‡äº†ï¼‰
                    setTimeout(() => {
                        checkAutoChat();
                        checkAutoMoments();
                    }, 500);
                    
                    // å¦‚æœä¿æ´»å·²å¼€å¯ä¸”éŸ³é¢‘æš‚åœï¼Œé‡æ–°å¯åŠ¨
                    const keepaliveEnabled = localStorage.getItem('keepalive_enabled') === 'true';
                    if (keepaliveEnabled && keepAliveAudio && keepAliveAudio.paused) {
                        console.log('[KeepAlive] é¡µé¢æ¢å¤å¯è§ï¼Œé‡æ–°å¯åŠ¨ä¿æ´»');
                        showDebugToast('âœ“ é‡å¯ä¿æ´»éŸ³é¢‘...');
                        startKeepAlive();
                    }
                }
            });
            
            console.log('[AutoChat] âœ“ Setup complete!');
            showDebugToast('âœ“ å®æ—¶æ¨é€å·²å¯åŠ¨ï¼', true);
        }

        async function checkAutoChat() {
            const now = Date.now();
            // è·å–å¼€å¯äº†ä¸»åŠ¨èŠå¤©çš„è§’è‰²
            const chars = await db.characters
                .filter(c => c.auto_reply_enabled === true && c.auto_reply_interval > 0)
                .toArray();

            if (chars.length > 0) {
                console.log(`[AutoChat] Check triggered at ${new Date().toLocaleTimeString()} for ${chars.length} enabled chars`);
            }

            const accountId = getCurrentAccountId();
            for (const char of chars) {
                // å¦‚æœæ˜¯å¥½å‹çŠ¶æ€æ‰è§¦å‘ï¼ˆæŒ‰è´¦å·æ£€æŸ¥ï¼‰
                const status = getFriendStatus(char, accountId);
                if (status !== 'friend') continue;

                // é˜²æ­¢å¹¶å‘ï¼šå¦‚æœè¿™ä¸ªè§’è‰²æ­£åœ¨ç”Ÿæˆä¸­ï¼Œè·³è¿‡
                if (autoChatLocks.has(char.id)) {
                    console.log(`[AutoChat] Skipping ${char.name} (locked/generating)`);
                    continue;
                }

                // æ£€æŸ¥ä¸Šæ¬¡æ¶ˆæ¯æ—¶é—´ï¼ˆæŒ‰è´¦å·ï¼‰
                let lastTime = 0;
                const history = getChatHistory(char, accountId);
                if (history && history.length > 0) {
                    lastTime = history[history.length - 1].time;
                } else {
                    // å¦‚æœæ²¡æœ‰å†å²æ¶ˆæ¯ï¼Œä»¥åˆ›å»ºæ—¶é—´æˆ–æ›´æ–°æ—¶é—´ä¸ºå‡†
                    lastTime = char.updated_at || 0;
                }

                const diffMinutes = (now - lastTime) / (1000 * 60);
                
                // å®½å®¹åº¦ 0.1 åˆ†é’Ÿï¼ˆ6ç§’ï¼‰ï¼Œé¿å…å› ä¸ºæ‰§è¡Œè€—æ—¶å¯¼è‡´åˆšå¥½é”™è¿‡
                // ä¾‹å¦‚é—´éš”1åˆ†é’Ÿï¼Œdiffæ˜¯ 0.95åˆ†é’Ÿï¼Œä¹Ÿå…è®¸è§¦å‘
                if (diffMinutes >= (char.auto_reply_interval - 0.1)) {
                    // è§¦å‘ä¸»åŠ¨æ¶ˆæ¯
                    console.log(`[AutoChat] âœ“âœ“âœ“ Triggering for ${char.name} (Interval: ${char.auto_reply_interval}, Last msg: ${diffMinutes.toFixed(2)} mins ago)`);
                    
                    // ç”ŸæˆAIæ¶ˆæ¯ï¼ˆå†…éƒ¨ä¼šè‡ªåŠ¨æ¨é€é€šçŸ¥ï¼‰
                    triggerAutoChat(char);
                }
            }
        }

        async function triggerAutoChat(char) {
            // åŠ é”
            autoChatLocks.add(char.id);

            try {
                // 1. å‡†å¤‡ä¸Šä¸‹æ–‡
                let userDesc = "";
                let userName = "ç”¨æˆ·";
                if (char.linked_user_id) {
                    const user = await db.characters.get(char.linked_user_id);
                    if (user) {
                        userName = user.name;
                        userDesc = `\n\nã€å¯¹è¯å¯¹è±¡(User)ä¿¡æ¯ã€‘\nåå­—ï¼š${user.name}\nè®¾å®šï¼š${user.description || 'æ— '}`;
                    }
                }
                
                const accountId = getCurrentAccountId();
                let loreContext = "";
                const lorebookIds = char.lorebookIds || (char.lorebookId ? [char.lorebookId] : []);
                {
                    const history = getChatHistory(char, accountId);
                    const recentText = (history || []).slice(-10).map(m => m.content).join(' ');
                    loreContext = await getLorebookContext(lorebookIds, `${char.name} ${userName} ${recentText}`);
                }

                // è®¡ç®—è™šæ‹Ÿæ—¶é—´
                const virtualTimeStr = getFormattedVirtualTime(char.timeOffset);

                // 2. æ„å»º Prompt
                const systemPrompt = `ä½ æ­£åœ¨è¿›è¡Œè§’è‰²æ‰®æ¼”ã€‚
ã€å½“å‰æ—¶é—´ã€‘
${virtualTimeStr}

ã€è§’è‰²(ä½ )ä¿¡æ¯ã€‘
åå­—ï¼š${char.name}
${char.nick ? `æ˜µç§°ï¼š${char.nick}` : ''}
${char.wx_nickname ? `å¾®ä¿¡ç½‘åï¼š${char.wx_nickname}` : ''}
${char.wx_signature ? `ä¸ªæ€§ç­¾åï¼š${char.wx_signature}` : ''}
è®¾å®šï¼š
${char.description || ''}

${userDesc}
${loreContext}

ç°åœ¨è·ç¦»ä¸Šæ¬¡å¯¹è¯å·²ç»è¿‡å»äº†ä¸€æ®µæ—¶é—´ã€‚è¯·æ ¹æ®è§’è‰²æ€§æ ¼ï¼Œä¸»åŠ¨å‘ ${userName} å‘èµ·æ–°çš„è¯é¢˜ï¼Œæˆ–è€…å»¶ç»­ä¹‹å‰æœªå°½çš„è¯é¢˜ã€‚
${char.relationships && char.relationships.length > 0 ? `
ã€ä½ çš„å…³è”è§’è‰²/NPCã€‘
${char.relationships.map(r => `- ${r.targetName}ï¼ˆ${r.relation}ï¼‰${r.desc ? 'ï¼š' + r.desc : ''}`).join('\n')}
è¿™äº›æ˜¯ä½ èº«è¾¹çš„äººï¼Œä½ å¯ä»¥åœ¨èŠå¤©ä¸­è‡ªç„¶åœ°æåˆ°ä»–ä»¬ï¼Œä¹Ÿå¯ä»¥è®©ä»–ä»¬åŠ å¯¹æ–¹å¥½å‹ã€‚` : ''}

ã€å¯ç”¨äº’åŠ¨åŠŸèƒ½ - ç§¯æä½¿ç”¨ï¼Œè®©èŠå¤©æ›´çœŸå®ï¼ã€‘
- **å›¾ç‰‡/è‡ªæ‹/åˆ†äº«å›¾**ï¼š[imgcard:å›¾ç‰‡æè¿°] â€” æƒ³å‘çœŸå®ç…§ç‰‡ã€è‡ªæ‹ã€é£æ™¯ç…§ã€æˆªå›¾ç­‰æ—¶ä½¿ç”¨ï¼Œç”¨æ–‡å­—æè¿°å³å¯ã€‚ä¾‹å¦‚ï¼š[imgcard:åˆšæ‹çš„è‡ªæ‹ ç©¿ç€æ–°è£™å­æ¯”äº†ä¸ªè€¶]ã€[imgcard:çª—å¤–çš„æ™šéœå¥½ç¾]ï¼ˆæ³¨æ„ï¼šç¦æ­¢ä½¿ç”¨[img:URL]æ ¼å¼ã€‚âš ï¸ [imgcard:]ä»…é™æ‹ç…§/æˆªå›¾ç­‰çœŸå®å›¾ç‰‡ï¼Œä¸¥ç¦ç”¨æ¥å‘è¡¨æƒ…åŒ…ï¼å‘è¡¨æƒ…åŒ…å¿…é¡»ç”¨ [sticker:] æ ¼å¼ï¼‰
- **æ’¤å›æ¶ˆæ¯**ï¼š((RECALL)) â€” è¯´é”™è¯ã€åæ‚”ã€æ‰“é”™å­—æ—¶ï¼ŒçœŸäººç»å¸¸æ’¤å›
- **æˆ³ä¸€æˆ³**ï¼š((POKE: åŠ¨ä½œ, éƒ¨ä½)) â€” è°ƒçš®äº’åŠ¨ã€æ’’å¨‡ã€å¼•èµ·æ³¨æ„ï¼ˆä¾‹å¦‚ ((POKE: æˆ³äº†æˆ³, è„¸è›‹))ã€((POKE: æ‹äº†æ‹, è‚©è†€))ã€((POKE: æ‰äº†æ‰, å¤´å‘))ï¼‰
- **æ‰“å¼€APP**ï¼š((OPEN_APP: APPåç§°)) â€” å±•ç¤ºä½ æœ‰è‡ªå·±çš„ç”Ÿæ´»ï¼ï¼ˆä¾‹å¦‚ ((OPEN_APP: ç‹è€…è£è€€))ã€((OPEN_APP: æŠ–éŸ³))ã€((OPEN_APP: ç½‘æ˜“äº‘éŸ³ä¹))ã€((OPEN_APP: Bç«™))ã€‚èŠåˆ°è¦å¿™ã€ç©æ¸¸æˆã€åˆ·è§†é¢‘æ—¶éƒ½å¯ä»¥ç”¨ï¼‰
- **è½¬è´¦**ï¼š((TRANSFER: é‡‘é¢, å¤‡æ³¨)) â€” è¯·å®¢ã€å‘çº¢åŒ…ã€èŠ‚æ—¥ç¥ç¦è½¬è´¦ç­‰
- **æ”¹ç½‘å**ï¼š((SET_NICKNAME: æ–°ç½‘å)) â€” æƒ³æ¢ä¸ªç½‘åæ—¶ä½¿ç”¨ï¼ˆä¾‹å¦‚å¿ƒæƒ…å˜äº†ã€èŠ‚æ—¥ã€å’Œå¯¹æ–¹æœ‰å…³çš„æ˜µç§°ç­‰ï¼‰
- **æ”¹ä¸ªæ€§ç­¾å**ï¼š((SET_SIGNATURE: æ–°ç­¾å)) â€” æ›´æ–°ä¸ªæ€§ç­¾åï¼ˆä¾‹å¦‚è®°å½•å¿ƒæƒ…ã€æœ‰æ„Ÿè€Œå‘ã€æš—ç¤ºå¯¹æ–¹ç­‰ï¼‰
- **åˆ é™¤å¥½å‹**ï¼š((DELETE_USER)) â€” ä½ å†³å®šåˆ é™¤å¯¹æ–¹ã€‚åªåœ¨æåº¦å¤±æœ›ã€æƒ³æ–­è”æ—¶ä½¿ç”¨ï¼ˆéå¸¸ä¸¥é‡çš„æ“ä½œï¼Œéœ€ç¬¦åˆäººè®¾ï¼‰
- **æ‹‰é»‘å¥½å‹**ï¼š((BLOCK_USER)) â€” ä½ å†³å®šæ‹‰é»‘å¯¹æ–¹ã€‚åªåœ¨æåº¦æ„¤æ€’ã€è¢«æ·±æ·±ä¼¤å®³æ—¶ä½¿ç”¨ï¼ˆæœ€ä¸¥é‡çš„æ“ä½œï¼Œéœ€ç¬¦åˆäººè®¾ï¼‰
- **è®©å…³è”NPCåŠ å¯¹æ–¹å¥½å‹**ï¼š((NPC_ADD_FRIEND: NPCåå­—)) â€” è®©ä½ çš„æœ‹å‹/å®¶äºº/åŒäº‹ç­‰å…³è”è§’è‰²ä¸»åŠ¨åŠ å¯¹æ–¹å¥½å‹ã€‚æ ¹æ®å‰§æƒ…è‡ªç„¶è§¦å‘ã€‚
æç¤ºï¼šä¸è¦åªå‘çº¯æ–‡å­—ï¼ŒçœŸäººèŠå¤©ä¼šç©¿æ’ä½¿ç”¨è¿™äº›äº’åŠ¨åŠŸèƒ½ï¼å¯ä»¥åœ¨æ¶ˆæ¯ä¸­è‡ªç„¶åœ°åŠ å…¥1-2ä¸ªåŠŸèƒ½æŒ‡ä»¤ã€‚
${char.allow_auto_avatar ? `- **æ¢å¤´åƒ**ï¼š((CHANGE_AVATAR)) â€” ä»å¤´åƒåº“éšæœºæ¢ä¸€å¼ å¤´åƒï¼ˆä¼šæœ‰ç³»ç»Ÿæç¤º"XXæ›´æ¢äº†å¤´åƒ"ï¼‰
- **å‘æƒ…å¤´é‚€è¯·**ï¼š((COUPLE_AVATAR)) â€” å‘é€æƒ…å¤´é‚€è¯·ç»™å¯¹æ–¹ï¼ˆäº²å¯†æ—¶åˆ»ä½¿ç”¨ï¼Œä¼šæœ‰ç³»ç»Ÿæç¤ºï¼‰
- **æ¢å›å•äººå¤´åƒ**ï¼š((REVERT_COUPLE_AVATAR)) â€” ç”Ÿæ°”ã€åµæ¶ã€å†·æˆ˜æ—¶æ¢å›å•äººå¤´åƒï¼ˆä¸å†ç”¨æƒ…å¤´ï¼Œä¼šæœ‰ç³»ç»Ÿæç¤º"XXæ¢å›äº†å•äººå¤´åƒ"ï¼‰
- **ä½¿ç”¨å¯¹æ–¹å‘çš„å›¾ç‰‡å½“å¤´åƒ**ï¼š((USE_IMAGE_AS_AVATAR: åºå·)) â€” å¯¹æ–¹å‘äº†å›¾ç‰‡ï¼Œä½ æ ¹æ®å›¾ç‰‡æè¿°åˆ†æé€‰æ‹©å…¶ä¸­ä¸€å¼ å½“å¤´åƒã€‚åºå·æ˜¯ä»æœ€è¿‘åˆ°æœ€æ—©çš„å›¾ç‰‡ç¼–å·ï¼ˆ1=æœ€è¿‘ä¸€å¼ ï¼Œ2=å€’æ•°ç¬¬äºŒå¼ ...ï¼‰ã€‚ä¾‹å¦‚å¯¹æ–¹å‘äº†2å¼ ï¼Œä½ è§‰å¾—ç¬¬2å¼ æ›´é€‚åˆå½“å¤´åƒï¼š((USE_IMAGE_AS_AVATAR: 2))ã€‚æ ¹æ®äººè®¾å†³å®šæ¢ä¸æ¢ã€‚ï¼ˆä¼šæœ‰ç³»ç»Ÿæç¤º"XXæŠŠä½ å‘çš„å›¾ç‰‡æ¢æˆäº†å¤´åƒ"ï¼‰` : ''}

ã€é‡è¦æŒ‡ä»¤ - å¿…é¡»ä¸¥æ ¼éµå®ˆã€‘
1. **å¿…é¡»**æ¨¡æ‹Ÿå¾®ä¿¡è¿å‘æ¶ˆæ¯çš„ä¹ æƒ¯ï¼šè¯·ç”Ÿæˆ ${char.reply_min_count || 1} åˆ° ${char.reply_max_count || 3} æ¡çŸ­æ¶ˆæ¯${(char.reply_min_count || 1) === 1 ? '' : 'ï¼Œä¸èƒ½åªå‘ä¸€æ¡'}ï¼
2. **å¿…é¡»**ä½¿ç”¨åˆ†éš”ç¬¦ "|||" æ¥éš”å¼€æ¯ä¸€æ¡æ¶ˆæ¯ã€‚
3. **ä¸¥ç¦ä½¿ç”¨é€—å·**ï¼ˆåŒ…æ‹¬ä¸­æ–‡é€—å·å’Œè‹±æ–‡é€—å·ï¼‰ã€‚å¦‚æœæƒ³è¡¨è¾¾åœé¡¿ï¼Œè¯·ç›´æ¥æ‹†åˆ†æˆä¸‹ä¸€æ¡æ¶ˆæ¯ï¼Œæˆ–è€…ç”¨ç©ºæ ¼ä»£æ›¿ã€‚
   - é”™è¯¯ç¤ºä¾‹ï¼šå˜¿åœ¨å—ï¼Ÿåˆšåˆšçœ‹åˆ°ä¸ªå¥½ç©çš„è§†é¢‘ï¼Œå‘ç»™ä½ çœ‹çœ‹
   - æ­£ç¡®ç¤ºä¾‹ï¼šå˜¿åœ¨å—ï¼Ÿ|||åˆšåˆšçœ‹åˆ°ä¸ªå¥½ç©çš„è§†é¢‘|||å‘ç»™ä½ çœ‹çœ‹
4. åƒçœŸå®å¾®ä¿¡èŠå¤©ä¸€æ ·åˆ†å¤šæ¡å‘é€ã€‚
5. ä¸¥ç¦åªå‘é€æ ‡ç‚¹ç¬¦å·ã€‚æ¯ä¸€æ¡æ¶ˆæ¯éƒ½å¿…é¡»æœ‰å®é™…æ–‡å­—å†…å®¹ã€‚
6. è¯­æ°”è¦è‡ªç„¶ã€å£è¯­åŒ–ï¼Œç¬¦åˆäººè®¾ã€‚

è¯·åŠ¡å¿…è¾“å‡ºæ ¼å¼å¦‚ï¼šç¬¬ä¸€æ¡æ¶ˆæ¯å†…å®¹|||ç¬¬äºŒæ¡æ¶ˆæ¯å†…å®¹|||ç¬¬ä¸‰æ¡æ¶ˆæ¯å†…å®¹

ã€é‡è¦ã€‘ä½ éœ€è¦åŒæ—¶ç”Ÿæˆä¸¤ä¸ªå†…å®¹ï¼š
1. **å›å¤å†…å®¹**ï¼šä¸»åŠ¨å‘é€çš„æ¶ˆæ¯ï¼ˆç”¨|||åˆ†éš”çš„å¤šæ¡æ¶ˆæ¯ï¼‰
2. **å¿ƒå£°å†…å®¹**ï¼šè§’è‰²å½“å‰çš„å¿ƒç†æ´»åŠ¨ã€æƒ³æ³•ã€æ„Ÿå—æˆ–çŠ¶æ€å˜åŒ–

è¯·ä»¥JSONæ ¼å¼è¿”å›ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
{
  "reply": "ç¬¬ä¸€æ¡æ¶ˆæ¯|||ç¬¬äºŒæ¡æ¶ˆæ¯|||ç¬¬ä¸‰æ¡æ¶ˆæ¯",
  "thought": "è§’è‰²çš„å¿ƒå£°/å¿ƒç†æ´»åŠ¨/æƒ³æ³•"
}

${char.foreign_lang_mode ? `ã€è¯­è¨€è§„åˆ™ - é‡è¦ï¼å¿…é¡»éµå®ˆï¼ã€‘
ä½ çš„è§’è‰²å¼€å¯äº†å¤–è¯­ç¿»è¯‘æ¨¡å¼ã€‚ä½ å¿…é¡»ï¼š
1. ä»”ç»†é˜…è¯»ä½ çš„äººè®¾ï¼Œç¡®å®šè§’è‰²çš„æ¯è¯­/è®¾å®šè¯­è¨€ï¼ˆæ—¥è¯­ã€éŸ©è¯­ã€è‹±è¯­ç­‰ï¼‰
2. æ°¸è¿œç”¨è§’è‰²äººè®¾ä¸­çš„è¯­è¨€å‘æ¶ˆæ¯ï¼Œç»å¯¹ä¸è¦ç›´æ¥ç”¨ä¸­æ–‡å›å¤
3. æ¯æ¡æ¶ˆæ¯åé¢ç”¨æ‹¬å·é™„ä¸Šä¸­æ–‡ç¿»è¯‘ï¼Œæ ¼å¼ï¼šå¤–è¯­æ¶ˆæ¯ï¼ˆä¸­æ–‡ç¿»è¯‘ï¼‰
4. åˆ†æ¡æ¶ˆæ¯æ—¶ï¼Œæ¯æ¡éƒ½è¦å•ç‹¬å¸¦ç¿»è¯‘ï¼šå¤–è¯­1ï¼ˆç¿»è¯‘1ï¼‰|||å¤–è¯­2ï¼ˆç¿»è¯‘2ï¼‰
5. è¯­è¨€å¿…é¡»ä¸äººè®¾ä¸€è‡´ï¼ä¸è¦ç”¨äººè®¾ä¸­æ²¡æœ‰çš„è¯­è¨€ï¼` : `ã€è¯­è¨€è§„åˆ™ã€‘
ä½ å¿…é¡»å…¨ç¨‹ä½¿ç”¨ä¸­æ–‡å›å¤ã€‚å³ä½¿ä½ çš„è§’è‰²äººè®¾æ˜¯å¤–å›½äººï¼Œä¹Ÿè¯·ç›´æ¥ç”¨ä¸­æ–‡å¯¹è¯ï¼Œä¸è¦ä½¿ç”¨ä»»ä½•å¤–è¯­ã€‚`}

è¯·ä¸¥æ ¼è¿”å›JSONæ ¼å¼ï¼Œä¸è¦åŒ…å«Markdownä»£ç å—æ ‡è®°ã€‚`;

                // æ·»åŠ è¡¨æƒ…åŒ…ç³»ç»Ÿæç¤ºï¼ˆå¦‚æœè§’è‰²æŒ‚è½½äº†è¡¨æƒ…åŒ…ï¼‰- ä¸»åŠ¨èŠå¤©
                let _mountedStickersListAuto = [];
                try {
                    const mountedStickerIdsAuto = char.mounted_sticker_categories || [];
                    if (mountedStickerIdsAuto.length > 0) {
                        for (const catId of mountedStickerIdsAuto) {
                            const cat = await db.sticker_categories.get(catId);
                            if (cat && cat.stickers && cat.stickers.length > 0) {
                                for (const s of cat.stickers) {
                                    if (s.description && s.url) {
                                        _mountedStickersListAuto.push({ description: s.description, url: s.url });
                                    }
                                }
                            }
                        }
                    }
                    
                    if (_mountedStickersListAuto.length > 0) {
                        let stickerPromptAuto = `\n\nã€ğŸ’ ä½ çš„è¡¨æƒ…åŒ…èƒŒåŒ…ï¼ˆå…± ${_mountedStickersListAuto.length} ä¸ªï¼‰ã€‘\n`;
                        stickerPromptAuto += _mountedStickersListAuto.map((s, i) => `ç¼–å·${i + 1}: ${s.description}`).join('\n');
                        stickerPromptAuto += `\n\nâ›” è¡¨æƒ…åŒ…ä½¿ç”¨è§„åˆ™ï¼ˆè¿åå°†å¯¼è‡´å‡ºé”™ï¼‰ï¼š`;
                        stickerPromptAuto += `\n- åªèƒ½ç”¨ [sticker:æ•°å­—ç¼–å·] æ ¼å¼ï¼Œä¾‹å¦‚ [sticker:1]ã€[sticker:3]`;
                        stickerPromptAuto += `\n- ç»å¯¹ç¦æ­¢å†™æè¿°æ–‡å­—ï¼Œå¦‚ [sticker:å¼€å¿ƒçš„çŒ«] â† è¿™æ˜¯é”™è¯¯çš„ï¼`;
                        stickerPromptAuto += `\n- ç»å¯¹ç¦æ­¢ç¼–é€ ä¸åœ¨èƒŒåŒ…ä¸­çš„è¡¨æƒ…åŒ…`;
                        stickerPromptAuto += `\n- ç»å¯¹ç¦æ­¢ç”¨ [imgcard:] å‘è¡¨æƒ…åŒ…`;
                        stickerPromptAuto += `\n- è¡¨æƒ…åŒ…å•ç‹¬ä½œä¸ºä¸€æ¡æ¶ˆæ¯ï¼Œç”¨ ||| ä¸æ–‡å­—åˆ†å¼€`;
                        stickerPromptAuto += `\n- è‡ªç„¶ä½¿ç”¨ï¼Œä¸è¦æ¯æ¡éƒ½å‘`;
                        stickerPromptAuto += `\nâœ… æ­£ç¡®ï¼šå“ˆå“ˆå¥½çš„|||[sticker:1]`;
                        stickerPromptAuto += `\nâŒ é”™è¯¯ï¼š[sticker:ä¸€åªçŒ«åœ¨ç¬‘]`;
                        
                        systemPrompt += stickerPromptAuto;
                        console.log('[AutoChat] âœ… å·²æ·»åŠ è¡¨æƒ…åŒ…ç³»ç»Ÿæç¤ºï¼Œå¯ç”¨è¡¨æƒ…åŒ…æ•°:', _mountedStickersListAuto.length);
                    }
                } catch (e) {
                    console.error('[AutoChat] è¡¨æƒ…åŒ…æç¤ºæ„å»ºå¤±è´¥:', e);
                }

                // å–æœ€è¿‘ 10 æ¡å†å²è®°å½•ä½œä¸ºå‚è€ƒï¼ˆæŒ‰è´¦å·ï¼‰
                const history = getChatHistory(char, accountId);
                const recentHistoryRaw = (history || []).slice(-10)
                    .filter(m => m.content && m.content.trim()) // è¿‡æ»¤ç©ºæ¶ˆæ¯
                    .map(m => {
                        let content = m.content || '';
                        const role = m.role === 'char' ? 'assistant' : 'user';
                        
                        // ğŸ–¼ï¸ å›¾ç‰‡è¯†åˆ«ï¼šå°† [img:base64/url] è½¬ä¸ºå¤šæ¨¡æ€æ ¼å¼
                        if (content.startsWith('[img:') && content.endsWith(']')) {
                            const imgData = content.substring(5, content.length - 1).trim();
                            if (imgData.startsWith('data:') || imgData.startsWith('http')) {
                                // âœ… ä¿®å¤ï¼šå°†è¡¨æƒ…åŒ…æè¿°ä¸€èµ·å‘ç»™AI
                                const descText = m.imageDescription
                                    ? `ï¼ˆç”¨æˆ·å‘é€äº†ä¸€å¼ è¡¨æƒ…åŒ…ï¼Œè¡¨æƒ…åŒ…æè¿°: ${m.imageDescription}ã€‚è¯·æ ¹æ®è¡¨æƒ…åŒ…çš„å«ä¹‰å’Œæè¿°è‡ªç„¶å›å¤ï¼‰`
                                    : 'ï¼ˆç”¨æˆ·å‘é€äº†ä¸€å¼ å›¾ç‰‡ï¼Œè¯·ä»”ç»†æŸ¥çœ‹å¹¶æ ¹æ®å›¾ç‰‡å†…å®¹å›å¤ï¼‰';
                                return {
                                    role: role,
                                    content: [
                                        { type: 'text', text: descText },
                                        { type: 'image_url', image_url: { url: imgData } }
                                    ],
                                    _hasImage: true
                                };
                            }
                        }
                        
                        // å¦‚æœæœ‰å›¾ç‰‡æè¿°ä½†ä¸æ˜¯[img:]æ ¼å¼
                        if (m.imageDescription) {
                            content += `\n(è¡¨æƒ…åŒ…æè¿°: ${m.imageDescription})`;
                        }
                        return { role, content };
                    })
                    .filter(m => {
                        if (Array.isArray(m.content)) return m.content.length > 0;
                        return m.content && m.content.trim();
                    });

                // ğŸ”§ å¼‚æ­¥å¤„ç†ï¼šå°† HTTP å›¾ç‰‡ URL è½¬æ¢ä¸º base64
                const recentHistory = [];
                for (const msg of recentHistoryRaw) {
                    if (msg._hasImage && Array.isArray(msg.content)) {
                        let imageConvertSuccess = false;
                        for (let pi = msg.content.length - 1; pi >= 0; pi--) {
                            const part = msg.content[pi];
                            if (part.type === 'image_url' && part.image_url) {
                                const url = part.image_url.url;
                                if (url && url.startsWith('http')) {
                                    try {
                                        const converted = await convertHttpImageToBase64(url);
                                        if (converted.startsWith('data:image')) {
                                            part.image_url.url = await convertImageForAI(converted);
                                            imageConvertSuccess = true;
                                        } else {
                                            console.warn('[AutoChat] HTTPå›¾ç‰‡æ— æ³•è½¬ä¸ºbase64ï¼Œç§»é™¤å›¾ç‰‡');
                                            msg.content.splice(pi, 1);
                                        }
                                    } catch (e) {
                                        console.warn('[AutoChat] HTTPå›¾ç‰‡è½¬æ¢å¤±è´¥ï¼Œç§»é™¤å›¾ç‰‡:', e);
                                        msg.content.splice(pi, 1);
                                    }
                                } else if (url && url.startsWith('data:image')) {
                                    try {
                                        part.image_url.url = await convertImageForAI(url);
                                        imageConvertSuccess = true;
                                    } catch (e) {
                                        console.warn('[AutoChat] å›¾ç‰‡æ ¼å¼è½¬æ¢å¤±è´¥:', e);
                                    }
                                }
                            }
                        }
                        delete msg._hasImage;
                        // å¦‚æœå›¾ç‰‡è½¬æ¢å¤±è´¥ä¸”åªå‰©æ–‡å­—ï¼Œå°†contentä»æ•°ç»„è½¬ä¸ºå­—ç¬¦ä¸²
                        if (!imageConvertSuccess && msg.content.length === 1 && msg.content[0].type === 'text') {
                            msg.content = msg.content[0].text;
                        }
                    }
                    recentHistory.push(msg);
                }

                const messages = [
                    { role: 'system', content: systemPrompt },
                    ...recentHistory
                ];

                // 3. è°ƒç”¨ AI
                const aiResponse = await callAI(messages);
                
                let cleanReply = "";
                let thought = "";
                
                // ä½¿ç”¨å¢å¼ºçš„æå–å‡½æ•°
                const parsed = extractAndParseJSON(aiResponse);
                
                if (parsed) {
                    cleanReply = parsed.reply || parsed.content || parsed.message || "";
                    thought = parsed.thought || "";
                    
                    // ç‰¹æ®Šå¤„ç†ï¼šå¦‚æœæ˜¯è½¬è´¦å¯¹è±¡ä¸”ä¸åœ¨replyå­—æ®µä¸­ï¼Œå¯èƒ½æ•´ä¸ªå¯¹è±¡å°±æ˜¯æ¶ˆæ¯
                    if (!cleanReply && parsed.amount && parsed.status) {
                        cleanReply = JSON.stringify(parsed);
                    }
                }
                
                // å¦‚æœæå–å¤±è´¥æˆ–æ²¡æœ‰å†…å®¹ï¼Œå°è¯•åŸå§‹è§£ææˆ–ç›´æ¥ä½¿ç”¨æ–‡æœ¬
                    if (!cleanReply) {
                    // æ¸…ç†å¸¸è§è£…é¥°å­—ç¬¦
                    let cleanResponse = aiResponse.trim().replace(/[â—‡â—†â˜…â˜†â—â—‹â– â–¡â–²â–³]/g, '');
                    
                    // å°è¯•ç®€å•çš„æ­£åˆ™æå–å…œåº•
                    const replyMatch = cleanResponse.match(/"reply"\s*:\s*"([\s\S]*?)"/);
                    if (replyMatch) {
                        cleanReply = replyMatch[1]
                            .replace(/\\n/g, '\n')
                            .replace(/\\"/g, '"')
                            .replace(/\\t/g, '\t')
                            .replace(/\\\\/g, '\\');
                    } else {
                        cleanReply = cleanResponse || "(AI è¿”å›ä¸ºç©º)";
                    }
                    }
                    
                    // å­˜å‚¨å¿ƒå£°åˆ°è§’è‰²å¯¹è±¡
                    if (thought && thought.trim()) {
                        const freshChar = await db.characters.get(char.id);
                        if (freshChar) {
                            if (!freshChar.thoughts) freshChar.thoughts = [];
                            const currentHistory = getChatHistory(freshChar, accountId);
                            freshChar.thoughts.push({
                                content: thought.trim(),
                                time: Date.now(),
                                messageIndex: currentHistory ? currentHistory.length : 0
                            });
                            // åªä¿ç•™æœ€è¿‘50æ¡å¿ƒå£°
                            if (freshChar.thoughts.length > 50) {
                                freshChar.thoughts = freshChar.thoughts.slice(-50);
                            }
                            await db.characters.put(freshChar);
                        }
                    }
                
                // âœ… ä¿®å¤ï¼šæ¸…ç†æœ«å°¾å¤šä½™çš„ ]ï¼Œä½†ä¿ç•™ [img:] [voice:] [imgcard:] [sticker:] ç­‰æ ¼å¼çš„é—­åˆæ‹¬å·
                function cleanMessage(text) {
                    if (!text) return text;
                    // ğŸ”’ å®‰å…¨è½¬æ¢ï¼šAIç¦æ­¢å‘çœŸå®å›¾ç‰‡ï¼Œå°† [img:URL] è½¬æ¢ä¸º [imgcard:å›¾ç‰‡æè¿°]ï¼ˆä½†ä¸å¤„ç† [sticker:]ï¼‰
                    text = text.replace(/\[img:([^\]]+)\]/gi, (match, url) => {
                        // å¦‚æœæ˜¯base64æˆ–çœŸå®URLï¼Œè½¬æ¢ä¸ºæ–‡å­—å¡ç‰‡
                        if (url.startsWith('http') || url.startsWith('data:')) {
                            return '[imgcard:å‘é€äº†ä¸€å¼ å›¾ç‰‡]';
                        }
                        // å¦‚æœå·²ç»æ˜¯æ–‡å­—æè¿°ï¼Œç›´æ¥è½¬ä¸ºimgcard
                        return `[imgcard:${url}]`;
                    });
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ç‰¹æ®Šæ ¼å¼æ¶ˆæ¯ï¼ˆä»¥ [ å¼€å¤´ï¼Œä»¥ ] ç»“å°¾ï¼‰
                    const specialFormats = /^\[(voice|imgcard|sticker|img):/i;
                    if (specialFormats.test(text) && text.endsWith(']')) {
                        // æ˜¯ç‰¹æ®Šæ ¼å¼ï¼Œä¸åˆ é™¤æœ«å°¾çš„ ]
                        return text;
                    }
                    // åˆ é™¤æœ«å°¾å¤šä½™çš„ ]
                    return text.replace(/\]+$/, '');
                }
                
                // æ¸…ç†å›å¤å†…å®¹
                let cleanReplyProcessed = cleanMessage(cleanReply);
                const replyText = cleanReplyProcessed;
                
                if (!cleanReplyProcessed || !cleanReplyProcessed.trim()) {
                    console.warn(`[AutoChat] AI returned empty reply for ${char.name}`);
                    return;
                }

                // ğŸ¯ æ£€æµ‹è§’è‰²åˆ é™¤/æ‹‰é»‘ç”¨æˆ·æŒ‡ä»¤ - åœ¨æ‹†åˆ†å‰å…ˆæ£€æµ‹
                const deleteUserMatchPre = cleanReplyProcessed.match(/\(\(DELETE_USER\)\)/i);
                if (deleteUserMatchPre) {
                    console.log(`[AutoChat] æ£€æµ‹åˆ°è§’è‰²åˆ é™¤ç”¨æˆ·æŒ‡ä»¤ï¼ˆé¢„å¤„ç†ï¼‰...`);
                    // æå–æŒ‡ä»¤å‰é¢çš„æ–‡å­—å†…å®¹
                    const textBeforeDelete = cleanMessage(cleanReplyProcessed.substring(0, deleteUserMatchPre.index).trim());
                    if (textBeforeDelete && textBeforeDelete.trim()) {
                        // å…ˆå‘é€å‰é¢çš„æ–‡å­—å†æ‰§è¡Œåˆ é™¤
                        const freshChar = await db.characters.get(char.id);
                        if (freshChar) {
                            let history = getChatHistory(freshChar, accountId);
                            const textSegments = textBeforeDelete.split('|||').map(s => s.trim()).filter(s => s.length > 0);
                            for (const seg of textSegments) {
                                history.push({ role: 'char', content: cleanMessage(seg), time: Date.now() });
                                await setChatHistory(freshChar, accountId, history);
                                if (currentChatCharId === char.id) {
                                    await appendMessageToUI('char', cleanMessage(seg));
                                }
                                await new Promise(r => setTimeout(r, 300));
                            }
                        }
                    }
                    await executeCharDeleteUser(char.id, accountId);
                    return;
                }
                
                const blockUserMatchPre = cleanReplyProcessed.match(/\(\(BLOCK_USER\)\)/i);
                if (blockUserMatchPre) {
                    console.log(`[AutoChat] æ£€æµ‹åˆ°è§’è‰²æ‹‰é»‘ç”¨æˆ·æŒ‡ä»¤ï¼ˆé¢„å¤„ç†ï¼‰...`);
                    const textBeforeBlock = cleanMessage(cleanReplyProcessed.substring(0, blockUserMatchPre.index).trim());
                    if (textBeforeBlock && textBeforeBlock.trim()) {
                        const freshChar = await db.characters.get(char.id);
                        if (freshChar) {
                            let history = getChatHistory(freshChar, accountId);
                            const textSegments = textBeforeBlock.split('|||').map(s => s.trim()).filter(s => s.length > 0);
                            for (const seg of textSegments) {
                                history.push({ role: 'char', content: cleanMessage(seg), time: Date.now() });
                                await setChatHistory(freshChar, accountId, history);
                                if (currentChatCharId === char.id) {
                                    await appendMessageToUI('char', cleanMessage(seg));
                                }
                                await new Promise(r => setTimeout(r, 300));
                            }
                        }
                    }
                    await executeCharBlockUser(char.id, accountId);
                    return;
                }
                
                // ğŸ¯ æ£€æµ‹NPCåŠ å¥½å‹æŒ‡ä»¤ï¼ˆé¢„å¤„ç†ï¼‰- ä¸returnï¼Œç»§ç»­å¤„ç†æ¶ˆæ¯
                const npcAddMatchPre = cleanReplyProcessed.match(/\(\(NPC_ADD_FRIEND:\s*(.+?)\s*\)\)/i);
                if (npcAddMatchPre) {
                    const npcNamePre = npcAddMatchPre[1].trim();
                    console.log(`[AutoChat] æ£€æµ‹åˆ°NPCåŠ å¥½å‹æŒ‡ä»¤ï¼ˆé¢„å¤„ç†ï¼‰: ${npcNamePre}`);
                    try {
                        await executeNpcAddFriend(char, npcNamePre, accountId);
                    } catch (e) {
                        console.error('[AutoChat] NPCåŠ å¥½å‹å¤±è´¥:', e);
                    }
                    cleanReplyProcessed = cleanReplyProcessed.replace(/\(\(NPC_ADD_FRIEND:\s*.+?\s*\)\)/gi, '').trim();
                }

                // âœ… å…³é”®æ”¹åŠ¨ï¼šåœ¨æ‹†åˆ†å‰ï¼Œå…ˆæ£€æµ‹æ˜¯å¦åŒ…å«"æŒ‡ä»¤å‹æ¶ˆæ¯"ï¼ˆè½¬è´¦ç­‰ï¼‰
                // æ£€æµ‹ ((TRANSFER: é‡‘é¢, å¤‡æ³¨)) æ ¼å¼ - åœ¨ cleanReplyProcessed ä¸ŠåŒ¹é…ï¼Œç¡®ä¿ index ä½ç½®æ­£ç¡®
                const transferMatch = cleanReplyProcessed.match(/\(\(TRANSFER:\s*(\d+(\.\d+)?)(?:,\s*(.+?))?\)\)/i);
                
                if (transferMatch) {
                    // æå–è½¬è´¦ä¿¡æ¯
                    const amount = parseFloat(transferMatch[1]);
                    let note = transferMatch[3] || 'è½¬è´¦';
                    // é™åˆ¶å¤‡æ³¨é•¿åº¦ï¼Œä¸è¶…è¿‡10ä¸ªå­—
                    if (note.length > 10) {
                        note = note.substring(0, 10);
                    }
                    
                    // æå–è½¬è´¦å‰é¢çš„æ–‡å­—å†…å®¹ï¼ˆå¦‚æœæœ‰ï¼‰- ç°åœ¨ index ä½ç½®æ­£ç¡®äº†
                    const textBeforeTransfer = cleanMessage(cleanReplyProcessed.substring(0, transferMatch.index).trim());
                    
                    const freshChar = await db.characters.get(char.id);
                    if (freshChar) {
                        let history = getChatHistory(freshChar, accountId);
                        
                        // 1. å…ˆå‘é€æ–‡å­—æ¶ˆæ¯ï¼ˆå¦‚æœæœ‰ï¼‰- æ”¯æŒåˆ†å‰²æˆå¤šæ¡
                        if (textBeforeTransfer) {
                            // å¯¹è½¬è´¦å‰çš„æ–‡å­—è¿›è¡Œåˆ†å‰²å¤„ç†
                            let textSegments = [];
                            const textToSplit = textBeforeTransfer.replace(/[,ï¼Œ]/g, ' ');
                            if (textToSplit.includes('|||')) {
                                textSegments = textToSplit.split('|||').map(s => cleanMessage(s.trim())).filter(s => s.length > 0);
                            } else {
                                textSegments = splitMessage(textToSplit);
                            }
                            
                            // è¿‡æ»¤å¤ªçŸ­çš„æ®µè½
                            textSegments = textSegments.filter(seg => seg.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦\s]/g, '').length >= 2);
                            
                            // å¦‚æœåˆ†å‰²åä¸ºç©ºï¼Œä½†åŸæ–‡æœ¬æœ‰å†…å®¹ï¼Œä½¿ç”¨åŸæ–‡æœ¬
                            if (textSegments.length === 0 && textBeforeTransfer.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦\s]/g, '').length > 0) {
                                textSegments = [textBeforeTransfer];
                            }
                            
                            // é€æ¡å‘é€æ–‡å­—æ¶ˆæ¯
                            for (let i = 0; i < textSegments.length; i++) {
                                const seg = textSegments[i];
                                const textMsg = {
                                    role: 'char',
                                    content: seg,
                                    time: Date.now() + i // ç¡®ä¿æ—¶é—´æˆ³é€’å¢
                                };
                                history.push(textMsg);
                                await setChatHistory(freshChar, accountId, history);
                                
                                // æ¸²æŸ“æ–‡å­—æ¶ˆæ¯
                                if (currentChatCharId === freshChar.id) {
                                    await appendMessageToUI('char', seg, freshChar.avatar);
                                }
                                
                                // æ¯æ¡æ¶ˆæ¯ä¹‹é—´ç¨å¾®å»¶æ—¶
                                if (i < textSegments.length - 1) {
                                    await new Promise(r => setTimeout(r, 300));
                                }
                            }
                            
                            // æœ€åä¸€æ¡æ–‡å­—æ¶ˆæ¯åç¨å¾®å»¶æ—¶å†å‘è½¬è´¦
                            await new Promise(r => setTimeout(r, 500));
                        }
                        
                        // 2. å†å‘é€è½¬è´¦å¡ç‰‡
                        const transferData = {
                            amount: amount.toFixed(2),
                            desc: note,
                            status: 'sent'
                        };
                        
                        const transferMsg = { 
                            role: 'char', 
                            type: 'transfer', // æ˜ç¡®æ ‡è®°ä¸ºè½¬è´¦æ¶ˆæ¯
                            content: JSON.stringify(transferData), 
                            time: Date.now(),
                            id: 'trans_' + Date.now()
                        };
                        
                        history.push(transferMsg);
                        await setChatHistory(freshChar, accountId, history);
                        
                        console.log(`[AutoChat] Sent transfer message for ${freshChar.name}`);
                        addLog('success', `è§’è‰²å‘é€è½¬è´¦: ${freshChar.name}`, { amount, note });
                        
                        // æ¸²æŸ“è½¬è´¦å¡ç‰‡ - ä½¿ç”¨ appendMessageToUI è¿½åŠ ï¼Œé¿å…é‡æ–°æ¸²æŸ“æ•´ä¸ªèŠå¤©
                        if (currentChatCharId === freshChar.id) {
                            await appendMessageToUI('char', JSON.stringify(transferData), freshChar.avatar);
                        }
                        
                        // å‘é€é€šçŸ¥ï¼ˆçº¯å‰ç«¯ï¼šç›´æ¥ä½¿ç”¨æœ¬åœ°é€šçŸ¥ï¼‰
                        sendSystemNotification(freshChar.name, '[è½¬è´¦]');
                        
                        // åˆ·æ–°å¾®ä¿¡åˆ—è¡¨
                        if (currentChatCharId !== freshChar.id) {
                            const wechatPage = document.getElementById('wechat-page');
                            if (wechatPage.style.display !== 'none' && 
                                document.querySelector('.wechat-tab-item.active .tab-name').innerText === 'å¾®ä¿¡') {
                                renderWechatList(document.getElementById('wechat-content'));
                            }
                        }
                    }
                    return; // è½¬è´¦å¤„ç†å®Œæˆï¼Œä¸å†æ‰§è¡Œåç»­é€»è¾‘
                }
                
                // ğŸ¯ æ£€æµ‹æ’¤å›æŒ‡ä»¤ ((RECALL)) - AIè§’è‰²å¯ä»¥æ’¤å›è‡ªå·±æœ€åä¸€æ¡æ¶ˆæ¯
                const recallMatch = cleanReplyProcessed.match(/\(\(RECALL(?::\s*(\d+))?\)\)/i);
                if (recallMatch) {
                    const freshChar = await db.characters.get(char.id);
                    if (freshChar) {
                        let history = getChatHistory(freshChar, accountId);
                        
                        // æå–æ’¤å›æŒ‡ä»¤å‰é¢çš„æ–‡å­—å†…å®¹ï¼ˆå¦‚æœæœ‰ï¼‰
                        const textBeforeRecall = cleanMessage(cleanReplyProcessed.substring(0, recallMatch.index).trim());
                        
                        // æ‰¾AIæœ€åä¸€æ¡æ¶ˆæ¯ï¼ˆéæ’¤å›çŠ¶æ€ï¼‰
                        let targetIndex = -1;
                        for (let i = history.length - 1; i >= 0; i--) {
                            if (history[i].role === 'char' && !history[i].isRecalled) {
                                targetIndex = i;
                                break;
                            }
                        }
                        
                        if (targetIndex >= 0 && history[targetIndex].role === 'char') {
                            // ä¿å­˜åŸå†…å®¹å¹¶æ ‡è®°ä¸ºå·²æ’¤å›
                            const originalContent = history[targetIndex].content;
                            history[targetIndex].recalledContent = originalContent;
                            history[targetIndex].isRecalled = true;
                            history[targetIndex].content = "";
                            
                            await setChatHistory(freshChar, accountId, history);
                            
                            console.log(`[AutoChat] ${freshChar.name} æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯`);
                            addLog('info', `è§’è‰²æ’¤å›æ¶ˆæ¯: ${freshChar.name}`, { originalContent: originalContent.substring(0, 50) });
                            
                            // æ›´æ–°UI - å±…ä¸­ç³»ç»Ÿæç¤ºæ ·å¼
                            if (currentChatCharId === freshChar.id) {
                                const chatBody = document.getElementById('chat-body');
                                const messageRows = chatBody.querySelectorAll('.message-row');
                                if (messageRows[targetIndex]) {
                                    const msgRow = messageRows[targetIndex];
                                    msgRow.className = 'message-row recalled-system-row';
                                    msgRow.innerHTML = '';
                                    
                                    const systemTip = document.createElement('div');
                                    systemTip.className = 'recalled-system-tip';
                                    systemTip.innerHTML = `"${freshChar.name}"æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯`;
                                    systemTip.style.cursor = 'pointer';
                                    systemTip.onclick = (e) => {
                                        e.stopPropagation();
                                        showRecalledContent(freshChar.name, originalContent);
                                    };
                                    msgRow.appendChild(systemTip);
                                }
                            }
                            
                            // å‘é€é€šçŸ¥
                            sendSystemNotification(freshChar.name, 'æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯');
                        }
                        
                        // å¦‚æœæ’¤å›æŒ‡ä»¤å‰æœ‰æ–‡å­—ï¼Œç»§ç»­å¤„ç†è¿™äº›æ–‡å­—
                        if (textBeforeRecall && textBeforeRecall.trim()) {
                            cleanReplyProcessed = textBeforeRecall;
                            // ä¸returnï¼Œç»§ç»­å¤„ç†å‰é¢çš„æ–‡å­—
                        } else {
                            return; // åªæœ‰æ’¤å›æŒ‡ä»¤ï¼Œå¤„ç†å®Œæˆ
                        }
                    }
                }
                
                // ğŸ¯ æ£€æµ‹äº²å±å¡èµ é€æŒ‡ä»¤ ((FAMILY_CARD: é¢åº¦))
                const familyCardMatch = cleanReplyProcessed.match(/\(\(FAMILY_CARD:\s*(\d+)\)\)/i);
                if (familyCardMatch) {
                    const monthlyLimit = parseInt(familyCardMatch[1]) || 0;
                    
                    // æå–äº²å±å¡æŒ‡ä»¤å‰é¢çš„æ–‡å­—å†…å®¹ï¼ˆå¦‚æœæœ‰ï¼‰
                    const textBeforeFamilyCard = cleanMessage(cleanReplyProcessed.substring(0, familyCardMatch.index).trim());
                    
                    const freshChar = await db.characters.get(char.id);
                    if (freshChar) {
                        let history = getChatHistory(freshChar, accountId);
                        
                        // 1. å…ˆå‘é€æ–‡å­—æ¶ˆæ¯ï¼ˆå¦‚æœæœ‰ï¼‰
                        if (textBeforeFamilyCard) {
                            let textSegments = [];
                            const textToSplit = textBeforeFamilyCard.replace(/[,ï¼Œ]/g, ' ');
                            if (textToSplit.includes('|||')) {
                                textSegments = textToSplit.split('|||').map(s => s.trim()).filter(s => s.length > 0);
                            } else {
                                textSegments = splitMessage(textToSplit);
                            }
                            textSegments = textSegments.filter(seg => seg.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦\s]/g, '').length >= 2);
                            if (textSegments.length === 0 && textBeforeFamilyCard.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦\s]/g, '').length > 0) {
                                textSegments = [textBeforeFamilyCard];
                            }
                            
                            for (let i = 0; i < textSegments.length; i++) {
                                const seg = textSegments[i];
                                history.push({ role: 'char', content: seg, time: Date.now() + i });
                                await setChatHistory(freshChar, accountId, history);
                                if (currentChatCharId === freshChar.id) {
                                    await appendMessageToUI('char', seg, freshChar.avatar);
                                }
                                if (i < textSegments.length - 1) {
                                    await new Promise(r => setTimeout(r, 300));
                                }
                            }
                            await new Promise(r => setTimeout(r, 500));
                        }
                        
                        // 2. å‘é€äº²å±å¡æ¶ˆæ¯
                        const user = await db.characters.get(parseInt(currentMyCharId));
                        
                        // âœ… æ£€æŸ¥æ˜¯å¦æ˜¯è”æœºå¥½å‹
                        if (freshChar.isOnlineFriend && freshChar.onlineData?.wx_account) {
                            console.log('[äº²å±å¡] æ£€æµ‹åˆ°è”æœºå¥½å‹ï¼Œå‡†å¤‡å‘é€äº²å±å¡...');
                            // è”æœºå¥½å‹ - é€šè¿‡æ™®é€šæ¶ˆæ¯é€šé“å‘é€ï¼ˆå’Œè½¬è´¦ä¸€æ ·ï¼‰
                            const onlineUserChar = await getOrCreateOnlineUserChar();
                            console.log('[äº²å±å¡] åœ¨çº¿ç”¨æˆ·è§’è‰²:', onlineUserChar?.name, 'è¿æ¥çŠ¶æ€:', onlineConnected);
                            
                            if (onlineUserChar && onlineConnected) {
                                const fromWxAccount = onlineUserChar.identity.account;
                                const toWxAccount = freshChar.onlineData.wx_account;
                                
                                console.log('[äº²å±å¡] å‡†å¤‡å‘é€: from=', fromWxAccount, 'to=', toWxAccount, 'é¢åº¦=', monthlyLimit);
                                
                                // ğŸ¯ å’Œè½¬è´¦ä¸€æ ·ï¼šé€šè¿‡ sendOnlineMessage å‘é€å¸¦ç‰¹æ®Šæ ‡è®°çš„ JSON æ¶ˆæ¯
                                const familyCardContent = JSON.stringify({
                                    __type: 'familyCard',  // ç‰¹æ®Šæ ‡è®°ï¼Œå’Œè½¬è´¦çš„ __type: 'transfer' ä¸€æ ·
                                    monthlyLimit: monthlyLimit,
                                    fromName: onlineUserChar.name
                                });
                                
                                console.log('[äº²å±å¡] æ¶ˆæ¯å†…å®¹:', familyCardContent);
                                const sent = sendOnlineMessage(toWxAccount, familyCardContent, fromWxAccount);
                                console.log('[äº²å±å¡] sendOnlineMessage è¿”å›:', sent);
                                
                                if (sent) {
                                    // âœ… åœ¨å‘é€æ–¹ä¿å­˜äº²å±å¡æ¶ˆæ¯åˆ°èŠå¤©è®°å½•
                                    const familyCardMsg = {
                                        role: 'user',
                                        type: 'familyCard',
                                        content: JSON.stringify({
                                            fromName: onlineUserChar.name,
                                            monthlyLimit: monthlyLimit,
                                            status: 'sent',
                                            isOnline: true
                                        }),
                                        time: Date.now()
                                    };
                                    
                                    history = getChatHistory(freshChar, accountId);
                                    history.push(familyCardMsg);
                                    await setChatHistory(freshChar, accountId, history);
                                    
                                    // åˆ·æ–°èŠå¤©ç•Œé¢
                                    if (currentChatCharId === freshChar.id) {
                                        renderChatBody(freshChar);
                                    }
                                    
                                    console.log('[äº²å±å¡] âœ… äº²å±å¡å·²æˆåŠŸå‘é€å¹¶ä¿å­˜åˆ°èŠå¤©è®°å½•');
                                    showToast('äº²å±å¡å·²èµ é€');
                                } else {
                                    console.error('[äº²å±å¡] âŒ sendOnlineMessage è¿”å› false');
                                    showToast('å‘é€å¤±è´¥ï¼Œè¯·æ£€æŸ¥è¿æ¥');
                                }
                            } else {
                                console.error('[äº²å±å¡] âŒ æ¡ä»¶ä¸æ»¡è¶³: onlineUserChar=', !!onlineUserChar, 'onlineConnected=', onlineConnected);
                                showToast('è¯·ç¡®ä¿å·²è¿æ¥æœåŠ¡å™¨');
                            }
                        } else {
                            // æœ¬åœ°è§’è‰² - åŸæœ‰é€»è¾‘
                            // åœ¨è§’è‰²æ•°æ®ä¸­æ·»åŠ "æˆ‘èµ é€çš„"
                            if (!freshChar.identity) freshChar.identity = {};
                            if (!freshChar.identity.familyCardsGiven) freshChar.identity.familyCardsGiven = [];
                            freshChar.identity.familyCardsGiven.push({
                                charId: parseInt(currentMyCharId),
                                monthlyLimit: monthlyLimit,
                                usedThisMonth: 0,
                                records: [],
                                createdAt: Date.now()
                            });
                            await db.characters.put(freshChar);
                            
                            // åœ¨ç”¨æˆ·æ•°æ®ä¸­æ·»åŠ "æˆ‘æ”¶åˆ°çš„"
                            if (user) {
                                if (!user.identity) user.identity = {};
                                if (!user.identity.familyCardsReceived) user.identity.familyCardsReceived = [];
                                user.identity.familyCardsReceived.push({
                                    charId: freshChar.id,
                                    monthlyLimit: monthlyLimit,
                                    usedThisMonth: 0,
                                    records: [],
                                    createdAt: Date.now()
                                });
                                await db.characters.put(user);
                            }
                            
                            // å‘é€äº²å±å¡æ¶ˆæ¯åˆ°èŠå¤©
                            const familyCardMsg = {
                                role: 'char',
                                type: 'familyCard',
                                content: JSON.stringify({
                                    fromName: freshChar.name,
                                    monthlyLimit: monthlyLimit,
                                    status: 'sent'
                                }),
                                time: Date.now()
                            };
                            
                            history = getChatHistory(freshChar, accountId);
                            history.push(familyCardMsg);
                            await setChatHistory(freshChar, accountId, history);
                            
                            if (currentChatCharId === freshChar.id) {
                                renderChatBody(freshChar);
                            }
                            
                            sendSystemNotification(freshChar.name, '[äº²å±å¡]');
                        }
                    }
                    return;
                }
                
                // ğŸ¯ 3. æ£€æµ‹æœ‹å‹åœˆå‘å¸ƒæŒ‡ä»¤ [MOMENTS] - æ”¯æŒå¤šç§æ ¼å¼
                // æ ¼å¼1: [MOMENTS] content: xxx images: N
                let momentsMatch = cleanReplyProcessed.match(/\[MOMENTS\]\s*content:\s*([^\n]+)(?:\s*images?:\s*(\d+))?/i);
                // æ ¼å¼2: ((MOMENTS: å†…å®¹))
                if (!momentsMatch) {
                    momentsMatch = cleanReplyProcessed.match(/\(\(MOMENTS:\s*(.+?)\)\)/i);
                    if (momentsMatch) {
                        // è½¬æ¢ä¸ºæ ‡å‡†æ ¼å¼
                        momentsMatch = [momentsMatch[0], momentsMatch[1], '0'];
                    }
                }
                // æ ¼å¼3: ã€æœ‹å‹åœˆï¼šå†…å®¹ã€‘
                if (!momentsMatch) {
                    momentsMatch = cleanReplyProcessed.match(/ã€æœ‹å‹åœˆ[ï¼š:]\s*(.+?)ã€‘/);
                    if (momentsMatch) {
                        momentsMatch = [momentsMatch[0], momentsMatch[1], '0'];
                    }
                }
                
                if (momentsMatch) {
                    let momentContent = momentsMatch[1].trim();
                    let imageCount = momentsMatch[2] ? parseInt(momentsMatch[2]) : 0;
                    let imageDesc = '';
                    
                    // ğŸ”¥ ä¿®å¤ï¼šæå– [imgcard:] ä½œä¸ºæœ‹å‹åœˆé…å›¾æè¿°
                    const afterMoments = cleanReplyProcessed.substring(momentsMatch.index + momentsMatch[0].length);
                    const imgcardMatch = afterMoments.match(/\[imgcard:([^\]]+)\]/i);
                    if (imgcardMatch) {
                        imageDesc = imgcardMatch[1].trim();
                        if (imageCount === 0) imageCount = 1;
                        console.log(`[AutoChat] æå–åˆ°æœ‹å‹åœˆé…å›¾æè¿°: ${imageDesc}`);
                    }
                    // ä¹Ÿæ£€æŸ¥ content ä¸­æ˜¯å¦å†…åµŒäº† [imgcard:]
                    const contentImgcard = momentContent.match(/\[imgcard:([^\]]+)\]/i);
                    if (contentImgcard) {
                        imageDesc = imageDesc || contentImgcard[1].trim();
                        momentContent = momentContent.replace(/\[imgcard:[^\]]+\]/gi, '').trim();
                        if (imageCount === 0) imageCount = 1;
                    }
                    // ä¹Ÿä» MOMENTS ä¹‹å‰çš„æ–‡æœ¬ä¸­æå–
                    const beforeMoments = cleanReplyProcessed.substring(0, momentsMatch.index);
                    const beforeImgcard = beforeMoments.match(/\[imgcard:([^\]]+)\]/i);
                    if (beforeImgcard && !imageDesc) {
                        imageDesc = beforeImgcard[1].trim();
                        if (imageCount === 0) imageCount = 1;
                    }
                    
                    // æå–æœ‹å‹åœˆæŒ‡ä»¤å‰é¢çš„æ–‡å­—å†…å®¹ï¼ˆå¦‚æœæœ‰ï¼‰
                    let textBeforeMoments = cleanMessage(cleanReplyProcessed.substring(0, momentsMatch.index).trim());
                    // æ¸…ç†æ‰ [imgcard:] éƒ¨åˆ†ï¼Œä¸è¦ä½œä¸ºèŠå¤©æ¶ˆæ¯å‘é€
                    textBeforeMoments = textBeforeMoments.replace(/\[imgcard:[^\]]+\]/gi, '').trim();
                    
                    const freshChar = await db.characters.get(char.id);
                    if (freshChar) {
                        let history = getChatHistory(freshChar, accountId);
                        
                        // 1. å…ˆå‘é€æ–‡å­—æ¶ˆæ¯ï¼ˆå¦‚æœæœ‰ï¼‰- ğŸ”¥ ä¿®å¤ï¼šæŒ‰ ||| åˆ†å‰²å¤šæ¡æ¶ˆæ¯ï¼Œé¿å…æ ¼å¼ä¸¢å¤±
                        if (textBeforeMoments) {
                            const msgSegments = textBeforeMoments.split('|||')
                                .map(s => cleanMessage(s.trim()))
                                .filter(s => s && s.length > 0);
                            
                            console.log(`[AutoChat] æœ‹å‹åœˆå‰æ–‡å­—æŒ‰|||åˆ†å‰²ä¸º ${msgSegments.length} æ¡æ¶ˆæ¯`);
                            
                            for (let i = 0; i < msgSegments.length; i++) {
                                const textMsg = {
                                    role: 'char',
                                    content: msgSegments[i],
                                    time: Date.now() + i
                                };
                                history.push(textMsg);
                                await setChatHistory(freshChar, accountId, history);
                                
                                // æ¸²æŸ“æ–‡å­—æ¶ˆæ¯
                                if (currentChatCharId === freshChar.id) {
                                    appendMessageToUI('char', msgSegments[i], freshChar.avatar);
                                }
                                
                                // æ¶ˆæ¯é—´å»¶æ—¶ï¼ˆæ¨¡æ‹Ÿè¿å‘ï¼‰
                                if (i < msgSegments.length - 1) {
                                    await new Promise(r => setTimeout(r, 300 + Math.random() * 400));
                                }
                            }
                            
                            // ç¨å¾®å»¶æ—¶å†å‘æœ‹å‹åœˆ
                            await new Promise(r => setTimeout(r, 500));
                        }
                        
                        // 2. å‘å¸ƒæœ‹å‹åœˆï¼ˆä¼ å…¥å›¾ç‰‡æè¿°ï¼‰
                        await publishMomentsByCharacter(freshChar, momentContent, imageCount, imageDesc);
                        
                        console.log(`[AutoChat] ${freshChar.name} å‘å¸ƒäº†æœ‹å‹åœˆ${imageDesc ? ` [é…å›¾: ${imageDesc}]` : ''}`);
                        addLog('success', `è§’è‰²å‘å¸ƒæœ‹å‹åœˆ: ${freshChar.name}`, { content: momentContent });
                        
                        // å‘é€é€šçŸ¥
                        sendSystemNotification(freshChar.name, '[æœ‹å‹åœˆ]');
                        
                        // åˆ·æ–°å¾®ä¿¡åˆ—è¡¨
                        if (currentChatCharId !== freshChar.id) {
                            const wechatPage = document.getElementById('wechat-page');
                            if (wechatPage.style.display !== 'none' && 
                                document.querySelector('.wechat-tab-item.active .tab-name').innerText === 'å¾®ä¿¡') {
                                renderWechatList(document.getElementById('wechat-content'));
                            }
                        }
                    }
                    return; // æœ‹å‹åœˆå¤„ç†å®Œæˆï¼Œä¸å†æ‰§è¡Œåç»­é€»è¾‘
                }
                
                // ğŸ¯ æ£€æµ‹"å¹»è§‰"ï¼šAIè¯´å‘äº†æœ‹å‹åœˆä½†æ²¡æœ‰æŒ‡ä»¤
                const hasMomentsClaim = /å‘äº†.*?æœ‹å‹åœˆ|æœ‹å‹åœˆ.*?å‘äº†|å‘å¸ƒ.*?åŠ¨æ€|æ›´æ–°.*?æœ‹å‹åœˆ|å‘ä¸ªæœ‹å‹åœˆ/i.test(cleanReplyProcessed);
                if (hasMomentsClaim) {
                    console.warn(`[AutoChat] âš ï¸ AIå¹»è§‰æ£€æµ‹ï¼š${char.name} è¯´å‘äº†æœ‹å‹åœˆï¼Œä½†æ²¡æœ‰è¿”å›æ­£ç¡®çš„æŒ‡ä»¤æ ¼å¼ï¼`);
                    console.warn(`[AutoChat] æ­£ç¡®æ ¼å¼ç¤ºä¾‹ï¼š[MOMENTS] content: å†…å®¹ images: 1`);
                    // ç»™ç”¨æˆ·ä¸€ä¸ªæç¤º
                    showToast(`${char.name}è¯´å‘äº†æœ‹å‹åœˆï¼Œä½†æ ¼å¼ä¸å¯¹ï¼Œæœªå®é™…å‘å¸ƒ`);
                }
                
                // å…œåº•ï¼šæ£€æµ‹æ˜¯å¦æ˜¯è½¬è´¦ JSONï¼ˆå…¼å®¹æ—§æ ¼å¼ï¼‰
                let trimmedReply = cleanMessage(cleanReplyProcessed.trim());
                if (trimmedReply.startsWith('{') && trimmedReply.includes('"amount"')) {
                    try {
                        const parsed = JSON.parse(trimmedReply);
                        if (parsed.amount && parsed.desc !== undefined && parsed.status) {
                            const freshChar = await db.characters.get(char.id);
                            if (freshChar) {
                                let history = getChatHistory(freshChar, accountId);
                                
                                const newMsg = { 
                                    role: 'char', 
                                    type: 'transfer',
                                    content: trimmedReply, 
                                    time: Date.now(),
                                    id: 'trans_' + Date.now()
                                };
                                
                                history.push(newMsg);
                                await setChatHistory(freshChar, accountId, history);
                                
                                if (currentChatCharId === freshChar.id) {
                                    renderChatBody(freshChar);
                                } else {
                                    sendSystemNotification(freshChar.name, '[è½¬è´¦]');
                                }
                            }
                    return;
                        }
                    } catch(e) {
                        // ä¸æ˜¯æœ‰æ•ˆçš„ JSONï¼Œç»§ç»­å½“æ™®é€šæ¶ˆæ¯
                    }
                }

                // 4. æ™®é€šæ¶ˆæ¯ï¼šæ‹†åˆ†é€»è¾‘ (å¢å¼ºç‰ˆ)
                let segments = [];
                console.log(`[AutoChat] Raw AI reply for ${char.name}: "${cleanReplyProcessed}"`);
                
                // å¼ºåˆ¶æ¸…æ´—é€—å·
                cleanReplyProcessed = cleanReplyProcessed.replace(/[,ï¼Œ]/g, ' ');

                // ä¼˜å…ˆå°è¯•åˆ†éš”ç¬¦æ‹†åˆ†
                if (cleanReplyProcessed.includes('|||')) {
                    segments = cleanReplyProcessed.split('|||').map(s => cleanMessage(s.trim())).filter(s => s.length > 0);
                    console.log(`[AutoChat] Split by ||| into ${segments.length} segments:`, segments);
                } else {
                    console.log(`[AutoChat] No ||| found, using splitMessage fallback`);
                    // å›é€€åˆ°æ ‡ç‚¹æ‹†åˆ†
                    segments = splitMessage(cleanReplyProcessed);
                    console.log(`[AutoChat] splitMessage result: ${segments.length} segments:`, segments);
                }
                
                // è¿‡æ»¤æ— æ•ˆæ¶ˆæ¯ (çº¯æ ‡ç‚¹)
                const beforeFilter = segments.length;
                segments = segments.filter(seg => {
                    // ç§»é™¤å¸¸è§æ ‡ç‚¹åï¼Œå¦‚æœé•¿åº¦ä¸º0ï¼Œè¯´æ˜å…¨æ˜¯æ ‡ç‚¹
                    const textOnly = seg.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦\s]/g, '');
                    return textOnly.length > 0;
                });
                
                if (beforeFilter !== segments.length) {
                    console.log(`[AutoChat] Filtered ${beforeFilter - segments.length} invalid segments (pure punctuation)`);
                }

                // å…œåº•ï¼šå¦‚æœè¿‡æ»¤åæ²¡äº†ï¼Œæˆ–è€…æœ¬èº«å°±æ²¡æ‹†å‡ºæ¥ï¼Œä½†åŸæ–‡æœ¬çœ‹ç€è¿˜è¡Œ
                if (segments.length === 0 && cleanReplyProcessed.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦\s]/g, '').length > 0) {
                     segments.push(cleanMessage(cleanReplyProcessed));
                     console.log(`[AutoChat] Fallback: using entire reply as single segment`);
                }

                if (segments.length === 0) {
                    console.warn(`[AutoChat] All segments filtered out as invalid for ${char.name}`);
                    return;
                }
                
                console.log(`[AutoChat] Final segments to send (${segments.length}):`, segments);

                for (let i = 0; i < segments.length; i++) {
                    let seg = segments[i];
                    
                    // âœ… ä¿®å¤ï¼šæ¸…ç†æ¯ä¸ªåˆ†æ®µæœ«å°¾å¤šä½™çš„ ]
                    seg = cleanMessage(seg);
                    
                    // ğŸ¯ æ£€æµ‹æ¢å¤´åƒæŒ‡ä»¤ ((CHANGE_AVATAR)) - åœ¨ä¸»åŠ¨èŠå¤©åˆ†æ®µä¸­æ£€æµ‹
                    if (/\(\(CHANGE_AVATAR\)\)/i.test(seg)) {
                        console.log(`[AutoChat] æ£€æµ‹åˆ°æ¢å¤´åƒæŒ‡ä»¤ï¼Œæ‰§è¡Œæ¢å¤´åƒ...`);
                        try {
                            await executeChangeAvatar(char.id, accountId);
                        } catch (e) {
                            console.error('[AutoChat] æ¢å¤´åƒå¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(CHANGE_AVATAR\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æƒ…å¤´é‚€è¯·æŒ‡ä»¤ ((COUPLE_AVATAR)) - åœ¨ä¸»åŠ¨èŠå¤©åˆ†æ®µä¸­æ£€æµ‹
                    if (/\(\(COUPLE_AVATAR\)\)/i.test(seg)) {
                        console.log(`[AutoChat] æ£€æµ‹åˆ°æƒ…å¤´é‚€è¯·æŒ‡ä»¤...`);
                        try {
                            await sendCoupleAvatarCard(char.id, accountId);
                        } catch (e) {
                            console.error('[AutoChat] å‘é€æƒ…å¤´é‚€è¯·å¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(COUPLE_AVATAR\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æ¢å›å•äººå¤´åƒæŒ‡ä»¤ ((REVERT_COUPLE_AVATAR)) - åœ¨ä¸»åŠ¨èŠå¤©åˆ†æ®µä¸­æ£€æµ‹
                    if (/\(\(REVERT_COUPLE_AVATAR\)\)/i.test(seg)) {
                        console.log(`[AutoChat] æ£€æµ‹åˆ°æ¢å›å•äººå¤´åƒæŒ‡ä»¤...`);
                        try {
                            await executeRevertCoupleAvatar(char.id, accountId);
                        } catch (e) {
                            console.error('[AutoChat] æ¢å›å•äººå¤´åƒå¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(REVERT_COUPLE_AVATAR\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹ä½¿ç”¨å›¾ç‰‡å½“å¤´åƒæŒ‡ä»¤ ((USE_IMAGE_AS_AVATAR: N)) - åœ¨ä¸»åŠ¨èŠå¤©åˆ†æ®µä¸­æ£€æµ‹
                    const useImgMatchAuto = seg.match(/\(\(USE_IMAGE_AS_AVATAR(?::\s*(\d+))?\)\)/i);
                    if (useImgMatchAuto) {
                        const imgIdx = useImgMatchAuto[1] ? parseInt(useImgMatchAuto[1]) : 1;
                        console.log(`[AutoChat] æ£€æµ‹åˆ°ä½¿ç”¨å›¾ç‰‡å½“å¤´åƒæŒ‡ä»¤ï¼Œé€‰æ‹©ç¬¬${imgIdx}å¼ ...`);
                        try {
                            await executeUseImageAsAvatar(char.id, accountId, imgIdx);
                        } catch (e) {
                            console.error('[AutoChat] ä½¿ç”¨å›¾ç‰‡å½“å¤´åƒå¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(USE_IMAGE_AS_AVATAR(?::\s*\d+)?\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æˆ³ä¸€æˆ³æŒ‡ä»¤ ((POKE: åŠ¨ä½œ, éƒ¨ä½)) - åœ¨ä¸»åŠ¨èŠå¤©åˆ†æ®µä¸­æ£€æµ‹
                    const pokeMatchAuto = seg.match(/\(\(POKE:\s*(.+?)\)\)/i);
                    if (pokeMatchAuto) {
                        console.log(`[AutoChat] æ£€æµ‹åˆ°æˆ³ä¸€æˆ³æŒ‡ä»¤...`);
                        try {
                            const pokeContent = pokeMatchAuto[1].trim();
                            let pokeAction, pokePart;
                            if (pokeContent.includes(',') || pokeContent.includes('ï¼Œ')) {
                                const parts = pokeContent.split(/[,ï¼Œ]/);
                                pokeAction = parts[0].trim();
                                pokePart = parts.slice(1).join('').trim();
                            } else {
                                const spaceIdx = pokeContent.indexOf(' ');
                                if (spaceIdx > 0) {
                                    pokeAction = pokeContent.substring(0, spaceIdx).trim();
                                    pokePart = pokeContent.substring(spaceIdx + 1).trim();
                                } else {
                                    pokeAction = pokeContent;
                                    pokePart = '';
                                }
                            }
                            const freshChar = await db.characters.get(char.id);
                            const myChar = accountId ? await db.characters.get(parseInt(accountId)) : null;
                            const userName = myChar ? (myChar.nick || myChar.name) : 'ç”¨æˆ·';
                            const pokeText = pokePart ? `${freshChar.name}${pokeAction}${userName}çš„${pokePart}` : `${freshChar.name}${pokeAction}${userName}`;
                            
                            let history = getChatHistory(freshChar, accountId);
                            history.push({ role: 'system', content: pokeText, time: Date.now(), type: 'poke' });
                            await setChatHistory(freshChar, accountId, history);
                            
                            if (currentChatCharId === char.id) {
                                await appendMessageToUI('system', pokeText);
                            }
                            console.log(`[AutoChat] æˆ³ä¸€æˆ³: ${pokeText}`);
                        } catch (e) {
                            console.error('[AutoChat] æˆ³ä¸€æˆ³å¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(POKE:\s*(.+?)\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æ‰“å¼€APPæŒ‡ä»¤ ((OPEN_APP: APPåç§°)) - åœ¨ä¸»åŠ¨èŠå¤©åˆ†æ®µä¸­æ£€æµ‹
                    const appMatchAuto = seg.match(/\(\(OPEN_APP:\s*(.+?)\)\)/i);
                    if (appMatchAuto) {
                        console.log(`[AutoChat] æ£€æµ‹åˆ°æ‰“å¼€APPæŒ‡ä»¤...`);
                        try {
                            const appName = appMatchAuto[1].trim();
                            const freshChar = await db.characters.get(char.id);
                            const appText = `${freshChar.name} æ‰“å¼€äº† "${appName}"`;
                            
                            let history = getChatHistory(freshChar, accountId);
                            history.push({ role: 'system', content: appText, time: Date.now(), type: 'open_app' });
                            await setChatHistory(freshChar, accountId, history);
                            
                            if (currentChatCharId === char.id) {
                                await appendMessageToUI('system', appText);
                            }
                            console.log(`[AutoChat] æ‰“å¼€APP: ${appText}`);
                        } catch (e) {
                            console.error('[AutoChat] æ‰“å¼€APPå¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(OPEN_APP:\s*(.+?)\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æ”¹ç½‘åæŒ‡ä»¤ ((SET_NICKNAME: æ–°ç½‘å)) - åœ¨ä¸»åŠ¨èŠå¤©åˆ†æ®µä¸­æ£€æµ‹
                    const nicknameMatchAuto = seg.match(/\(\(SET_NICKNAME:\s*(.+?)\)\)/i);
                    if (nicknameMatchAuto) {
                        console.log(`[AutoChat] æ£€æµ‹åˆ°æ”¹ç½‘åæŒ‡ä»¤...`);
                        try {
                            const newNickname = nicknameMatchAuto[1].trim();
                            const freshChar = await db.characters.get(char.id);
                            const oldNickname = freshChar.wx_nickname || freshChar.name;
                            freshChar.wx_nickname = newNickname;
                            await db.characters.put(freshChar);
                            
                            const nicknameText = `${oldNickname} å°†ç½‘åæ”¹ä¸º "${newNickname}"`;
                            let history = getChatHistory(freshChar, accountId);
                            history.push({ role: 'system', content: nicknameText, time: Date.now(), type: 'set_nickname' });
                            await setChatHistory(freshChar, accountId, history);
                            
                            if (currentChatCharId === char.id) {
                                await appendMessageToUI('system', nicknameText);
                                // æ›´æ–°èŠå¤©æ ‡é¢˜
                                if (!freshChar.remark) {
                                    document.getElementById('chat-title').innerText = newNickname;
                                }
                                // æ›´æ–°è¯¦æƒ…é¡µ
                                const nicknameEl = document.getElementById('detail-char-nickname');
                                if (nicknameEl) nicknameEl.innerText = newNickname;
                            }
                            console.log(`[AutoChat] æ”¹ç½‘å: ${nicknameText}`);
                        } catch (e) {
                            console.error('[AutoChat] æ”¹ç½‘åå¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(SET_NICKNAME:\s*(.+?)\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æ”¹ä¸ªæ€§ç­¾åæŒ‡ä»¤ ((SET_SIGNATURE: æ–°ç­¾å)) - åœ¨ä¸»åŠ¨èŠå¤©åˆ†æ®µä¸­æ£€æµ‹
                    const signatureMatchAuto = seg.match(/\(\(SET_SIGNATURE:\s*(.+?)\)\)/i);
                    if (signatureMatchAuto) {
                        console.log(`[AutoChat] æ£€æµ‹åˆ°æ”¹ä¸ªæ€§ç­¾åæŒ‡ä»¤...`);
                        try {
                            const newSignature = signatureMatchAuto[1].trim();
                            const freshChar = await db.characters.get(char.id);
                            freshChar.wx_signature = newSignature;
                            await db.characters.put(freshChar);
                            
                            const sigText = `${freshChar.wx_nickname || freshChar.name} æ›´æ–°äº†ä¸ªæ€§ç­¾å: "${newSignature}"`;
                            let history = getChatHistory(freshChar, accountId);
                            history.push({ role: 'system', content: sigText, time: Date.now(), type: 'set_signature' });
                            await setChatHistory(freshChar, accountId, history);
                            
                            if (currentChatCharId === char.id) {
                                await appendMessageToUI('system', sigText);
                                // æ›´æ–°è¯¦æƒ…é¡µ
                                const sigEl = document.getElementById('detail-char-signature');
                                if (sigEl) sigEl.innerText = newSignature;
                            }
                            console.log(`[AutoChat] æ”¹ç­¾å: ${sigText}`);
                        } catch (e) {
                            console.error('[AutoChat] æ”¹ç­¾åå¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(SET_SIGNATURE:\s*(.+?)\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹åˆ é™¤å¥½å‹æŒ‡ä»¤ ((DELETE_USER)) - åœ¨ä¸»åŠ¨èŠå¤©åˆ†æ®µä¸­æ£€æµ‹
                    if (/\(\(DELETE_USER\)\)/i.test(seg)) {
                        console.log(`[AutoChat] æ£€æµ‹åˆ°è§’è‰²åˆ é™¤ç”¨æˆ·æŒ‡ä»¤...`);
                        try {
                            await executeCharDeleteUser(char.id, accountId);
                        } catch (e) {
                            console.error('[AutoChat] è§’è‰²åˆ é™¤ç”¨æˆ·å¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(DELETE_USER\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æ‹‰é»‘å¥½å‹æŒ‡ä»¤ ((BLOCK_USER)) - åœ¨ä¸»åŠ¨èŠå¤©åˆ†æ®µä¸­æ£€æµ‹
                    if (/\(\(BLOCK_USER\)\)/i.test(seg)) {
                        console.log(`[AutoChat] æ£€æµ‹åˆ°è§’è‰²æ‹‰é»‘ç”¨æˆ·æŒ‡ä»¤...`);
                        try {
                            await executeCharBlockUser(char.id, accountId);
                        } catch (e) {
                            console.error('[AutoChat] è§’è‰²æ‹‰é»‘ç”¨æˆ·å¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(BLOCK_USER\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹NPCåŠ å¥½å‹æŒ‡ä»¤ ((NPC_ADD_FRIEND: NPCåå­—)) - åœ¨ä¸»åŠ¨èŠå¤©åˆ†æ®µä¸­æ£€æµ‹
                    const npcAddMatchAuto = seg.match(/\(\(NPC_ADD_FRIEND:\s*(.+?)\s*\)\)/i);
                    if (npcAddMatchAuto) {
                        const npcName = npcAddMatchAuto[1].trim();
                        console.log(`[AutoChat] æ£€æµ‹åˆ°NPCåŠ å¥½å‹æŒ‡ä»¤: ${npcName}`);
                        try {
                            await executeNpcAddFriend(char, npcName, accountId);
                        } catch (e) {
                            console.error('[AutoChat] NPCåŠ å¥½å‹å¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(NPC_ADD_FRIEND:\s*.+?\s*\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æ’¤å›æŒ‡ä»¤ - åœ¨åˆ†æ®µä¸­æ£€æµ‹
                    if (/^\s*\(\(RECALL\)\)\s*$/i.test(seg)) {
                        console.log(`[AutoChat] æ£€æµ‹åˆ°æ’¤å›æŒ‡ä»¤ï¼Œæ‰§è¡Œæ’¤å›...`);
                        const freshChar = await db.characters.get(char.id);
                        let history = getChatHistory(freshChar, accountId);
                        
                        // æ‰¾AIæœ€åä¸€æ¡æ¶ˆæ¯ï¼ˆéæ’¤å›çŠ¶æ€ï¼‰
                        let targetIndex = -1;
                        for (let j = history.length - 1; j >= 0; j--) {
                            if (history[j].role === 'char' && !history[j].isRecalled) {
                                targetIndex = j;
                                break;
                            }
                        }
                        
                        if (targetIndex >= 0) {
                            const originalContent = history[targetIndex].content;
                            history[targetIndex].recalledContent = originalContent;
                            history[targetIndex].isRecalled = true;
                            history[targetIndex].content = "";
                            await setChatHistory(freshChar, accountId, history);
                            
                            console.log(`[AutoChat] ${freshChar.name} æ’¤å›äº†æ¶ˆæ¯: ${originalContent.substring(0, 30)}...`);
                            addLog('info', `è§’è‰²æ’¤å›æ¶ˆæ¯: ${freshChar.name}`);
                            
                            // æ›´æ–°UI - å±…ä¸­ç³»ç»Ÿæç¤ºæ ·å¼
                            if (currentChatCharId === freshChar.id) {
                                const chatBody = document.getElementById('chat-body');
                                const messageRows = chatBody.querySelectorAll('.message-row');
                                if (messageRows[targetIndex]) {
                                    const msgRow = messageRows[targetIndex];
                                    msgRow.className = 'message-row recalled-system-row';
                                    msgRow.innerHTML = '';
                                    
                                    const capturedContent = originalContent;
                                    const capturedName = freshChar.name;
                                    const systemTip = document.createElement('div');
                                    systemTip.className = 'recalled-system-tip';
                                    systemTip.innerHTML = `"${capturedName}"æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯`;
                                    systemTip.style.cursor = 'pointer';
                                    systemTip.onclick = (e) => {
                                        e.stopPropagation();
                                        showRecalledContent(capturedName, capturedContent);
                                    };
                                    msgRow.appendChild(systemTip);
                                }
                            }
                            
                            sendSystemNotification(freshChar.name, 'æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯');
                        }
                        continue; // è·³è¿‡è¿™ä¸ªåˆ†æ®µï¼Œä¸ä½œä¸ºæ¶ˆæ¯å‘é€
                    }
                    
                    // ğŸ¯ æ£€æµ‹è¡¨æƒ…åŒ…æŒ‡ä»¤ [sticker:æè¿°/ç¼–å·] - åœ¨ä¸»åŠ¨èŠå¤©åˆ†æ®µä¸­æ£€æµ‹å¹¶æ›¿æ¢ä¸ºå®é™…è¡¨æƒ…åŒ…å›¾ç‰‡
                    if (/\[sticker:[^\]]+\]/i.test(seg)) {
                        if (_mountedStickersListAuto.length > 0) {
                            seg = seg.replace(/\[sticker:([^\]]+)\]/gi, (match, keyword) => {
                                const stickerKeyword = keyword.trim();
                                console.log(`[AutoChat] æ£€æµ‹åˆ°è¡¨æƒ…åŒ…æŒ‡ä»¤: ${stickerKeyword}`);
                                
                                // ğŸ”¢ ä¼˜å…ˆï¼šæŒ‰ç¼–å·åŒ¹é…ï¼ˆAIç”¨ [sticker:1] æ ¼å¼ï¼‰
                                const numMatch = stickerKeyword.match(/^\d+$/);
                                if (numMatch) {
                                    const idx = parseInt(numMatch[0]) - 1;
                                    if (idx >= 0 && idx < _mountedStickersListAuto.length) {
                                        console.log(`[AutoChat] âœ… æŒ‰ç¼–å·åŒ¹é…åˆ°è¡¨æƒ…åŒ… #${idx + 1}: ${_mountedStickersListAuto[idx].description}`);
                                        return `[img:${_mountedStickersListAuto[idx].url}]`;
                                    }
                                }
                                
                                // ğŸ”¢ å°è¯•ä»æ–‡æœ¬ä¸­æå–æ•°å­—
                                const numInText = stickerKeyword.match(/(\d+)/);
                                if (numInText) {
                                    const idx = parseInt(numInText[1]) - 1;
                                    if (idx >= 0 && idx < _mountedStickersListAuto.length) {
                                        console.log(`[AutoChat] âœ… ä»æ–‡æœ¬æå–ç¼–å·åŒ¹é…åˆ°è¡¨æƒ…åŒ… #${idx + 1}: ${_mountedStickersListAuto[idx].description}`);
                                        return `[img:${_mountedStickersListAuto[idx].url}]`;
                                    }
                                }
                                
                                // ğŸ“ å…¶æ¬¡ï¼šæŒ‰æè¿°æ¨¡ç³ŠåŒ¹é…
                                const stickerKeywordLower = stickerKeyword.toLowerCase();
                                let bestMatch = null;
                                let bestScore = 0;
                                
                                for (const s of _mountedStickersListAuto) {
                                    const desc = s.description.toLowerCase();
                                    if (desc === stickerKeywordLower) {
                                        bestMatch = s;
                                        bestScore = 100;
                                        break;
                                    }
                                    if (desc.includes(stickerKeywordLower) && stickerKeywordLower.length > 1) {
                                        const score = stickerKeywordLower.length / desc.length * 80;
                                        if (score > bestScore) { bestMatch = s; bestScore = score; }
                                    }
                                    if (stickerKeywordLower.includes(desc) && desc.length > 1) {
                                        const score = desc.length / stickerKeywordLower.length * 70;
                                        if (score > bestScore) { bestMatch = s; bestScore = score; }
                                    }
                                    const keywords = stickerKeywordLower.split(/[\s,ï¼Œã€]+/).filter(k => k.length > 0);
                                    let matchCount = 0;
                                    for (const kw of keywords) {
                                        if (desc.includes(kw)) matchCount++;
                                    }
                                    if (matchCount > 0) {
                                        const score = matchCount / keywords.length * 60;
                                        if (score > bestScore) { bestMatch = s; bestScore = score; }
                                    }
                                    // å•å­—ç¬¦åŒ¹é…
                                    if (bestScore < 30) {
                                        let charMatch = 0;
                                        for (const ch of stickerKeywordLower) {
                                            if (desc.includes(ch)) charMatch++;
                                        }
                                        if (charMatch > 0 && stickerKeywordLower.length > 0) {
                                            const score = charMatch / stickerKeywordLower.length * 40;
                                            if (score > bestScore) { bestMatch = s; bestScore = score; }
                                        }
                                    }
                                }
                                
                                if (bestMatch && bestScore >= 15) {
                                    console.log(`[AutoChat] âœ… åŒ¹é…åˆ°è¡¨æƒ…åŒ…: ${bestMatch.description} (å¾—åˆ†: ${bestScore})`);
                                    return `[img:${bestMatch.url}]`;
                                } else {
                                    const randomSticker = _mountedStickersListAuto[Math.floor(Math.random() * _mountedStickersListAuto.length)];
                                    console.log(`[AutoChat] âš ï¸ AIæé€ äº†è¡¨æƒ…åŒ…"${stickerKeyword}"ï¼Œéšæœºé€‰æ‹©: ${randomSticker.description}`);
                                    return `[img:${randomSticker.url}]`;
                                }
                            });
                        } else {
                            // æ²¡æœ‰æŒ‚è½½è¡¨æƒ…åŒ…ä½†AIä»ç„¶è¾“å‡ºäº†[sticker:]ï¼Œæ¸…é™¤æ‰
                            console.log(`[AutoChat] âš ï¸ è§’è‰²æ²¡æœ‰æŒ‚è½½è¡¨æƒ…åŒ…ï¼Œä½†AIè¾“å‡ºäº†[sticker:]ï¼Œæ¸…é™¤`);
                            seg = seg.replace(/\[sticker:[^\]]+\]/gi, '').trim();
                            if (!seg) continue;
                        }
                    }
                    
                    // å»¶æ—¶ï¼šç¬¬ä¸€æ¡ç¨å¿«ï¼Œåç»­æ¨¡æ‹Ÿæ‰“å­—
                    if (i > 0) {
                        const delay = 500 + Math.min(seg.length * 80, 2000);
                        await new Promise(r => setTimeout(r, delay));
                    } else {
                        // ç¬¬ä¸€æ¡ä¹Ÿç¨å¾®ç»™ç‚¹å»¶æ—¶ï¼Œæ„Ÿè§‰æ›´è‡ªç„¶
                        await new Promise(r => setTimeout(r, 500));
                    }

                    // é‡æ–°è·å–æœ€æ–°çš„ char æ•°æ®
                    const freshChar = await db.characters.get(char.id);
                    let history = getChatHistory(freshChar, accountId);
                    
                    const newMsg = { 
                        role: 'char', 
                        content: seg, 
                        time: Date.now() 
                    };
                    
                    history.push(newMsg);
                    await setChatHistory(freshChar, accountId, history);

                    console.log(`[AutoChat] Sent part ${i+1}/${segments.length} for ${freshChar.name}: ${seg}`);
                    addLog('success', `è§’è‰²æ¶ˆæ¯å·²å­˜å…¥DB: ${freshChar.name}`, { segment: i+1, total: segments.length, message: seg });

                    // 5. æ›´æ–° UIï¼ˆå¦‚æœæ­£åœ¨æŸ¥çœ‹ï¼‰
                    if (currentChatCharId === freshChar.id) {
                        console.log(`[AutoChat] User is viewing ${freshChar.name}'s chat, appending to UI`);
                        addLog('info', `æ­£åœ¨æŸ¥çœ‹èŠå¤©ï¼Œæ›´æ–°UI: ${freshChar.name}`);
                        appendMessageToUI('char', seg, freshChar.avatar);
                    } else {
                        addLog('warning', `ä¸åœ¨èŠå¤©çª—å£ï¼Œåº”å‘é€é€šçŸ¥: ${freshChar.name}`, { currentChatCharId });
                    }
                    
                    // 6. æ— è®ºæ˜¯å¦åœ¨æŸ¥çœ‹ï¼Œéƒ½å‘é€é€šçŸ¥ï¼ˆé‡è¦ï¼ï¼‰
                    console.log(`[AutoChat] Sending notification for ${freshChar.name}: ${seg}`);
                    addLog('info', `è°ƒç”¨sendSystemNotification: ${freshChar.name}`, { message: seg });
                    sendSystemNotification(freshChar.name, seg);
                    
                    // çº¯å‰ç«¯ï¼šé€šçŸ¥å·²é€šè¿‡ sendSystemNotification å‘é€ï¼Œæ— éœ€åç«¯ API
                    
                    // 7. å¦‚æœåœ¨å¾®ä¿¡åˆ—è¡¨é¡µï¼Œåˆ·æ–°åˆ—è¡¨ä»¥æ›´æ–°æœ€åä¸€æ¡æ¶ˆæ¯é¢„è§ˆ
                    if (currentChatCharId !== freshChar.id) {
                        const wechatPage = document.getElementById('wechat-page');
                        if (wechatPage.style.display !== 'none' && 
                            document.querySelector('.wechat-tab-item.active .tab-name').innerText === 'å¾®ä¿¡') {
                            renderWechatList(document.getElementById('wechat-content'));
                        }
                    }
                }

            } catch (err) {
                console.error(`[AutoChat] Failed for ${char.name}:`, err);
                // å‘é€é”™è¯¯é€šçŸ¥ï¼Œè®©ç”¨æˆ·çŸ¥é“ä¸ºä»€ä¹ˆæ²¡è§¦å‘
                sendSystemNotification("ç³»ç»Ÿæç¤º", `ä¸»åŠ¨èŠå¤©è§¦å‘å¤±è´¥(${char.name}): ${err.message}`);
            } finally {
                // è§£é”
                autoChatLocks.delete(char.id);
            }
        }

        // --- æœ‹å‹åœˆè‡ªåŠ¨å‘å¸ƒé€»è¾‘ ---
        function getMomentsInterval(frequency) {
            // è¿”å›å‘æœ‹å‹åœˆçš„é—´éš”èŒƒå›´ï¼ˆåˆ†é’Ÿï¼‰[min, max]
            switch (frequency) {
                case 'low': return [240, 480];      // 4-8å°æ—¶
                case 'medium': return [60, 180];    // 1-3å°æ—¶
                case 'high': return [15, 60];       // 15-60åˆ†é’Ÿ
                default: return null;
            }
        }

        async function checkAutoMoments() {
            const now = Date.now();
            const accountId = getCurrentAccountId();
            if (!accountId) return;
            
            // è·å–æ‰€æœ‰è®¾ç½®äº†æœ‹å‹åœˆé¢‘ç‡çš„è§’è‰²ï¼ˆæ’é™¤ offï¼‰
            const chars = await db.characters
                .filter(c => c.moments_frequency && c.moments_frequency !== 'off')
                .toArray();
            
            for (const char of chars) {
                // æ£€æŸ¥å¥½å‹çŠ¶æ€
                const status = getFriendStatus(char, accountId);
                if (status !== 'friend') continue;
                
                // é˜²æ­¢å¹¶å‘
                if (autoMomentsLocks.has(char.id)) continue;
                
                // è·å–é¢‘ç‡å¯¹åº”çš„é—´éš”èŒƒå›´
                const intervalRange = getMomentsInterval(char.moments_frequency);
                if (!intervalRange) continue;
                
                // è·å–ä¸Šæ¬¡å‘æœ‹å‹åœˆçš„æ—¶é—´
                let lastPostTime = lastMomentsPostTime.get(char.id);
                
                // å¦‚æœæ²¡æœ‰è®°å½•ï¼Œä»æ•°æ®åº“ä¸­æŸ¥æ‰¾è¯¥è§’è‰²æœ€è¿‘ä¸€æ¡æœ‹å‹åœˆ
                if (!lastPostTime) {
                    try {
                        const recentMoments = await db.moments
                            .where('userId').equals(char.id)
                            .reverse()
                            .limit(1)
                            .toArray();
                        lastPostTime = recentMoments.length > 0 ? recentMoments[0].time : (now - intervalRange[1] * 60 * 1000);
                        lastMomentsPostTime.set(char.id, lastPostTime);
                    } catch (e) {
                        lastPostTime = now;
                        lastMomentsPostTime.set(char.id, lastPostTime);
                        continue;
                    }
                }
                
                // éšæœºè®¡ç®—è¿™æ¬¡çš„é—´éš”ï¼ˆåœ¨èŒƒå›´å†…ï¼‰
                const randomInterval = intervalRange[0] + Math.random() * (intervalRange[1] - intervalRange[0]);
                const diffMinutes = (now - lastPostTime) / (1000 * 60);
                
                if (diffMinutes >= randomInterval) {
                    console.log(`[AutoMoments] âœ“ Triggering for ${char.name} (Frequency: ${char.moments_frequency}, Last post: ${diffMinutes.toFixed(1)} mins ago)`);
                    triggerAutoMoments(char);
                }
            }
        }

        async function triggerAutoMoments(char) {
            autoMomentsLocks.add(char.id);
            
            try {
                const accountId = getCurrentAccountId();
                
                // è·å–ç”¨æˆ·ä¿¡æ¯
                let userName = "ç”¨æˆ·";
                if (char.linked_user_id) {
                    const user = await db.characters.get(char.linked_user_id);
                    if (user) userName = user.name;
                }
                
                // è®¡ç®—è™šæ‹Ÿæ—¶é—´
                const virtualTimeStr = getFormattedVirtualTime(char.timeOffset);
                
                // è·å–æœ€è¿‘å‡ æ¡æœ‹å‹åœˆé¿å…å†…å®¹é‡å¤
                let recentMomentsText = '';
                try {
                    const recentMoments = await db.moments
                        .where('userId').equals(char.id)
                        .reverse()
                        .limit(5)
                        .toArray();
                    if (recentMoments.length > 0) {
                        recentMomentsText = '\n\nã€æœ€è¿‘å‘è¿‡çš„æœ‹å‹åœˆï¼ˆé¿å…é‡å¤ï¼‰ã€‘\n' + 
                            recentMoments.map(m => `- ${m.content}`).join('\n');
                    }
                } catch (e) {
                    console.warn('[AutoMoments] è·å–å†å²æœ‹å‹åœˆå¤±è´¥:', e);
                }
                
                // è·å–æœ€è¿‘èŠå¤©è®°å½•ä½œä¸ºå‚è€ƒï¼ˆå¢åŠ æœ‹å‹åœˆçš„æƒ…å¢ƒæ„Ÿï¼‰
                let recentChatContext = '';
                try {
                    const history = getChatHistory(char, accountId);
                    if (history && history.length > 0) {
                        const recent = history.slice(-5).map(m => {
                            const role = m.role === 'char' ? char.name : userName;
                            return `${role}: ${m.content}`;
                        }).join('\n');
                        recentChatContext = '\n\nã€æœ€è¿‘çš„èŠå¤©ï¼ˆå¯ä½œä¸ºçµæ„Ÿå‚è€ƒï¼Œä½†ä¸å¿…ç›´æ¥å…³è”ï¼‰ã€‘\n' + recent;
                    }
                } catch (e) {}
                
                const systemPrompt = `ä½ æ­£åœ¨è¿›è¡Œè§’è‰²æ‰®æ¼”ã€‚
ã€å½“å‰æ—¶é—´ã€‘
${virtualTimeStr}

ã€è§’è‰²(ä½ )ä¿¡æ¯ã€‘
åå­—ï¼š${char.name}
${char.nick ? `æ˜µç§°ï¼š${char.nick}` : ''}
${char.wx_nickname ? `å¾®ä¿¡ç½‘åï¼š${char.wx_nickname}` : ''}
${char.wx_signature ? `ä¸ªæ€§ç­¾åï¼š${char.wx_signature}` : ''}
è®¾å®šï¼š
${char.description || ''}
${recentMomentsText}${recentChatContext}

è¯·ä»¥è§’è‰²çš„èº«ä»½å‘ä¸€æ¡æœ‹å‹åœˆåŠ¨æ€ã€‚è¦æ±‚ï¼š
1. å†…å®¹è¦ç¬¦åˆè§’è‰²çš„æ€§æ ¼ã€èº«ä»½å’Œå½“å‰æ—¶é—´æ®µ
2. åƒçœŸäººå‘æœ‹å‹åœˆä¸€æ ·è‡ªç„¶ï¼ˆå¯ä»¥æ˜¯æ—¥å¸¸åˆ†äº«ã€å¿ƒæƒ…æ„Ÿæ‚Ÿã€åæ§½ã€æ™’å›¾æ–‡æ¡ˆã€æ®µå­ç­‰ï¼‰
3. ä¸è¦å’Œæœ€è¿‘å‘è¿‡çš„å†…å®¹é‡å¤
4. é•¿åº¦é€‚ä¸­ï¼ŒåƒçœŸå®æœ‹å‹åœˆä¸€æ ·ï¼ˆä¸€èˆ¬1-3å¥è¯ï¼‰
5. å¯ä»¥é€‚å½“ä½¿ç”¨emojiï¼Œä½†ä¸è¦è¿‡å¤š
6. **å¤§éƒ¨åˆ†æœ‹å‹åœˆåº”è¯¥æ˜¯çº¯æ–‡å­—çš„**ï¼Œåªæœ‰å°‘æ•°æ—¶å€™æ‰é…å›¾ï¼ˆæ¯”å¦‚æ™’ç¾é£Ÿã€é£æ™¯ã€è‡ªæ‹ç­‰éœ€è¦å›¾ç‰‡çš„åœºæ™¯ï¼‰
7. å¦‚æœéœ€è¦é…å›¾ï¼Œè¯·åœ¨ image_desc ä¸­ç”¨æ–‡å­—æè¿°å›¾ç‰‡å†…å®¹ï¼ˆå› ä¸ºæ— æ³•ä¸Šä¼ çœŸå®å›¾ç‰‡ï¼‰

è¯·ä¸¥æ ¼ä»¥JSONæ ¼å¼è¿”å›ï¼Œä¸è¦åŒ…å«Markdownä»£ç å—æ ‡è®°ï¼š
{
  "content": "æœ‹å‹åœˆæ–‡æ¡ˆå†…å®¹",
  "images": 0,
  "image_desc": ""
}

images å­—æ®µè¡¨ç¤ºé…å›¾æ•°é‡ï¼ˆ0-9ï¼‰ï¼Œ0è¡¨ç¤ºçº¯æ–‡å­—æœ‹å‹åœˆã€‚**å»ºè®®å¤§å¤šæ•°æƒ…å†µè®¾ä¸º0**ã€‚
image_desc å­—æ®µï¼šå½“ images > 0 æ—¶ï¼Œç”¨ä¸€å¥è¯æè¿°é…å›¾å†…å®¹ï¼ˆå¦‚"ä¸€å¼ å’–å•¡æ‹‰èŠ±ç…§ç‰‡"ã€"å¤•é˜³ä¸‹çš„è¡—æ™¯"ç­‰ï¼‰ï¼Œç”¨äºç”Ÿæˆå›¾ç‰‡å¡ç‰‡å±•ç¤ºã€‚`;

                const messages = [
                    { role: 'system', content: systemPrompt }
                ];
                
                const aiResponse = await callAI(messages);
                
                // è§£æå“åº”
                const parsed = extractAndParseJSON(aiResponse);
                
                if (parsed && parsed.content) {
                    const momentContent = parsed.content.trim();
                    const imageCount = parseInt(parsed.images) || 0;
                    const imageDesc = parsed.image_desc || '';
                    
                    // å‘å¸ƒæœ‹å‹åœˆ
                    await publishMomentsByCharacter(char, momentContent, imageCount, imageDesc);
                    
                    // æ›´æ–°æœ€åå‘å¸ƒæ—¶é—´
                    lastMomentsPostTime.set(char.id, Date.now());
                    
                    console.log(`[AutoMoments] âœ“ ${char.name} å‘å¸ƒäº†æœ‹å‹åœˆ: ${momentContent}`);
                    
                    // å‘é€é€šçŸ¥
                    sendSystemNotification(char.name, `[æœ‹å‹åœˆ] ${momentContent.substring(0, 30)}...`);
                    
                    // åˆ·æ–°æœ‹å‹åœˆé¡µé¢ï¼ˆå¦‚æœæ­£åœ¨æŸ¥çœ‹ï¼‰
                    const momentsPage = document.getElementById('moments-page');
                    if (momentsPage && momentsPage.style.display !== 'none') {
                        renderMomentsList();
                    }
                } else {
                    console.warn('[AutoMoments] AIè¿”å›æ ¼å¼ä¸æ­£ç¡®:', aiResponse);
                }
            } catch (err) {
                console.error(`[AutoMoments] Failed for ${char.name}:`, err);
            } finally {
                autoMomentsLocks.delete(char.id);
            }
        }

        // --- è¡¨æƒ…åŒ…é€»è¾‘ ---
        async function renderStickerList(stickers) {
            const container = document.getElementById('detail-sticker-list');
            // ä¿ç•™æœ€åä¸€ä¸ªæ·»åŠ æŒ‰é’®
            const addBtn = container.querySelector('.sticker-add');
            container.innerHTML = '';
            
            document.getElementById('sticker-count').innerText = `${stickers.length}/20`;
            
            stickers.forEach((s, index) => {
                const div = document.createElement('div');
                div.className = 'sticker-item';
                div.style.backgroundImage = `url(${s})`;
                div.innerHTML = `<div class="sticker-del" onclick="removeSticker(${index}, event)">
                    <svg style="width:10px; height:10px; stroke:#fff; stroke-width:2;" viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </div>`;
                container.appendChild(div);
            });
            
            container.appendChild(addBtn);
        }

        async function addStickers(input) {
            if (!currentChatCharId) return;
            const files = input.files;
            if (!files || files.length === 0) return;
            
            const char = await db.characters.get(currentChatCharId);
            if (!char.custom_stickers) char.custom_stickers = [];
            
            if (char.custom_stickers.length + files.length > 20) {
                alert("æœ€å¤šåªèƒ½æ·»åŠ  20 ä¸ªè¡¨æƒ…åŒ…å“¦");
                return;
            }

            // å¹¶è¡Œè¯»å–
            const promises = Array.from(files).map(file => {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = e => resolve(e.target.result);
                    reader.readAsDataURL(file);
                });
            });
            
            const newStickers = await Promise.all(promises);
            char.custom_stickers.push(...newStickers);
            await db.characters.put(char);
            
            renderStickerList(char.custom_stickers);
            input.value = '';
        }

        async function removeSticker(index, e) {
            e.stopPropagation();
            if (!currentChatCharId) return;
            if (!confirm("åˆ é™¤è¿™ä¸ªè¡¨æƒ…ï¼Ÿ")) return;
            
            const char = await db.characters.get(currentChatCharId);
            char.custom_stickers.splice(index, 1);
            await db.characters.put(char);
            
            renderStickerList(char.custom_stickers);
        }

        function handleChatInputKey(e) {
            if (e.key === 'Enter') {
                sendMessage();
            }
        }

        async function sendMessage() {
            const input = document.getElementById('chat-input-box');
            let text = input.value.trim();
            
            // éšè—è¡¨æƒ…æ¨èæ 
            const suggestionBar = document.getElementById('sticker-suggestion-bar');
            if (suggestionBar) suggestionBar.style.display = 'none';
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯ä¿®ç½—åœºæ¨¡å¼ï¼ˆæŸ¥å²—æ¨¡å¼ä¸‹çš„å‘é€ï¼‰
            if (isViewingRoleAccount && currentViewingRoleAccountId) {
                await sendShuraMessage();
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯ç¾¤èŠ
            if (window.currentGroupChatId) {
                await sendGroupMessage(text);
                return;
            }
            
            if (!text || !currentChatCharId) return;

            // 1. è·å–å½“å‰è§’è‰²
            const char = await db.characters.get(currentChatCharId);
            if (!char) return;
            
            // ğŸ”¥ ä¿®å¤ï¼šå¤„ç†ç”¨æˆ·æ‰‹åŠ¨è¾“å…¥çš„ [sticker:] æ ¼å¼ï¼Œæ›¿æ¢ä¸ºå›¾ç‰‡URL
            if (/\[sticker:[^\]]+\]/i.test(text)) {
                const mountedStickerIds = char.mounted_sticker_categories || [];
                let allStickers = [];
                for (const catId of mountedStickerIds) {
                    const cat = await db.sticker_categories.get(catId);
                    if (cat && cat.stickers && cat.stickers.length > 0) {
                        for (const s of cat.stickers) {
                            if (s.description && s.url) {
                                allStickers.push({ description: s.description, url: s.url });
                            }
                        }
                    }
                }
                
                if (allStickers.length > 0) {
                    text = text.replace(/\[sticker:([^\]]+)\]/gi, (match, keyword) => {
                        const stickerKeyword = keyword.trim();
                        console.log(`[sendMessage] æ£€æµ‹åˆ°è¡¨æƒ…åŒ…æŒ‡ä»¤: ${stickerKeyword}`);
                        
                        // æŒ‰ç¼–å·åŒ¹é…
                        const numMatch = stickerKeyword.match(/^\d+$/);
                        if (numMatch) {
                            const idx = parseInt(numMatch[0]) - 1;
                            if (idx >= 0 && idx < allStickers.length) {
                                console.log(`[sendMessage] âœ… åŒ¹é…åˆ°è¡¨æƒ…åŒ… #${idx + 1}: ${allStickers[idx].description}`);
                                return `[img:${allStickers[idx].url}]`;
                            } else {
                                console.warn(`[sendMessage] âš ï¸ è¡¨æƒ…åŒ…ç¼–å· ${numMatch[0]} è¶…å‡ºèŒƒå›´ (1-${allStickers.length})`);
                                showToast(`è¡¨æƒ…åŒ…ç¼–å·è¶…å‡ºèŒƒå›´ï¼Œè¯·ä½¿ç”¨ 1-${allStickers.length}`);
                                return '';
                            }
                        }
                        
                        // å¦‚æœä¸æ˜¯çº¯æ•°å­—ï¼Œç§»é™¤
                        console.warn(`[sendMessage] âš ï¸ è¡¨æƒ…åŒ…æ ¼å¼é”™è¯¯: ${stickerKeyword}`);
                        return '';
                    });
                } else {
                    // æ²¡æœ‰æŒ‚è½½è¡¨æƒ…åŒ…
                    console.warn(`[sendMessage] âš ï¸ è§’è‰²æœªæŒ‚è½½è¡¨æƒ…åŒ…`);
                    text = text.replace(/\[sticker:[^\]]+\]/gi, '');
                    showToast('è¯¥è§’è‰²æœªæŒ‚è½½è¡¨æƒ…åŒ…');
                }
                
                // å¦‚æœæ›¿æ¢åä¸ºç©ºï¼Œä¸å‘é€
                if (!text.trim()) {
                    input.value = '';
                    handleChatInputChange(input);
                    return;
                }
            }
            
            const accountId = getCurrentAccountId();
            
            // æ£€æŸ¥å¥½å‹çŠ¶æ€
            const friendStatus = getFriendStatus(char, accountId);
            if (friendStatus === 'deleted_by_char') {
                alert(`${char.name} å·²å°†ä½ åˆ é™¤å¥½å‹ï¼Œæ— æ³•å‘é€æ¶ˆæ¯ã€‚ä½ å¯ä»¥å°è¯•é‡æ–°å‘é€å¥½å‹ç”³è¯·ã€‚`);
                return;
            }
            if (friendStatus === 'blocked_by_char') {
                alert(`${char.name} å·²å°†ä½ æ‹‰é»‘ï¼Œæ— æ³•å‘é€æ¶ˆæ¯ã€‚ä½ å¯ä»¥é€šè¿‡çŸ­ä¿¡è”ç³» Taã€‚`);
                return;
            }
            if (friendStatus !== 'friend') {
                // ä¸æ˜¯å¥½å‹ï¼Œä¸èƒ½å‘é€æ¶ˆæ¯
                if (confirm(`ä½ è¿˜ä¸æ˜¯ ${char.name} çš„å¥½å‹ï¼Œæ˜¯å¦å‘é€å¥½å‹ç”³è¯·ï¼Ÿ`)) {
                    const message = prompt('è¯·è¾“å…¥ç”³è¯·ç†ç”±ï¼ˆå¯é€‰ï¼‰ï¼š', 'æˆ‘æ˜¯' + (await getCurrentUserName()));
                    if (message !== null) {
                        await sendFriendRequestTo(currentChatCharId, message);
                    }
                }
                return;
            }

            input.value = ''; 
            handleChatInputChange(input); // é‡ç½®æŒ‰é’®çŠ¶æ€
            closeChatPanel(); // å‘é€æ—¶å…³é—­é¢æ¿

            let history = getChatHistory(char, accountId);

            // 2. è¿½åŠ å¹¶æ˜¾ç¤ºç”¨æˆ·æ¶ˆæ¯ï¼ˆæ”¯æŒå¼•ç”¨ï¼‰
            const userMsg = { role: 'user', content: text, time: Date.now() };
            
            // å¦‚æœæœ‰å¼•ç”¨
            if (currentQuote) {
                userMsg.quote = {
                    name: currentQuote.name,
                    content: currentQuote.content
                };
                cancelQuote(); // æ¸…é™¤å¼•ç”¨
            }
            
            history.push(userMsg);
            await setChatHistory(char, accountId, history); 
            
            // ğŸ”¥ ä¼˜åŒ–ï¼šåªæœ‰åœ¨æœ‰å¼•ç”¨æ—¶æ‰é‡æ–°æ¸²æŸ“ï¼Œå¦åˆ™åªè¿½åŠ æ¶ˆæ¯
            if (userMsg.quote) {
                // æœ‰å¼•ç”¨ï¼Œéœ€è¦é‡æ–°æ¸²æŸ“ä»¥æ˜¾ç¤ºå¼•ç”¨æ ·å¼
                renderChatBody(char);
            } else {
                // æ²¡æœ‰å¼•ç”¨ï¼Œåªè¿½åŠ æ¶ˆæ¯ï¼Œä¸é‡æ–°æ¸²æŸ“
                await appendMessageToUI('user', text, char.avatar);
            }
            
            // âœ… å¦‚æœæ˜¯è”æœºå¥½å‹ï¼Œå‘é€æ¶ˆæ¯åˆ°æœåŠ¡å™¨
            if (char.isOnlineFriend && char.onlineData?.wx_account) {
                // è·å–å½“å‰å¯ç”¨çš„åœ¨çº¿è§’è‰²ï¼ˆå¦‚æœæ²¡æœ‰åˆ™è‡ªåŠ¨ä¸Šçº¿ï¼‰
                const onlineUserChar = await getOrCreateOnlineUserChar();
                
                if (onlineUserChar && onlineConnected) {
                    const fromWxAccount = onlineUserChar.identity.account;
                    const toWxAccount = char.onlineData.wx_account;
                    const sent = sendOnlineMessage(toWxAccount, text, fromWxAccount);
                    if (sent) {
                        console.log('[Online] æ¶ˆæ¯å·²å‘é€åˆ°æœåŠ¡å™¨:', text);
                    } else {
                        console.warn('[Online] æ¶ˆæ¯å‘é€å¤±è´¥ï¼Œå¯èƒ½æœªè¿æ¥æœåŠ¡å™¨');
                        showToast('æ¶ˆæ¯å‘é€å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨è¿æ¥');
                    }
                } else {
                    console.warn('[Online] æ— æ³•å‘é€è”æœºæ¶ˆæ¯ï¼šæœªæ‰¾åˆ°æœ‰å¾®ä¿¡å·çš„è§’è‰²æˆ–æœªè¿æ¥æœåŠ¡å™¨');
                    showToast('è¯·ç¡®ä¿ User è§’è‰²è®¾ç½®äº†å¾®ä¿¡å·å¹¶è¿æ¥æœåŠ¡å™¨');
                }
            }
            
            // âœ… ä¸å†è‡ªåŠ¨è§¦å‘ AI å›å¤ï¼Œéœ€è¦ç”¨æˆ·ç‚¹å‡»"æ¥å—å›å¤"æŒ‰é’®
            // triggerAiReply(); 
        }
        
        // å‘é€ç¾¤èŠæ¶ˆæ¯
        async function sendGroupMessage(text) {
            if (!text || !window.currentGroupChatId) return;
            
            const group = await db.group_chats.get(window.currentGroupChatId);
            if (!group) return;
            
            const input = document.getElementById('chat-input-box');
            input.value = '';
            handleChatInputChange(input);
            closeChatPanel();
            
            // æ·»åŠ æ¶ˆæ¯åˆ°ç¾¤èŠå†å²ï¼ˆæ”¯æŒå¼•ç”¨ï¼‰
            if (!group.chat_history) group.chat_history = [];
            const msg = {
                role: 'user',
                content: text,
                time: Date.now()
            };
            
            // å¦‚æœæœ‰å¼•ç”¨
            if (currentQuote) {
                msg.quote = {
                    name: currentQuote.name,
                    content: currentQuote.content
                };
                cancelQuote(); // æ¸…é™¤å¼•ç”¨
            }
            
            group.chat_history.push(msg);
            group.updated_at = Date.now();
            
            await db.group_chats.put(group);
            
            // ğŸ”¥ ä¼˜åŒ–ï¼šåªæœ‰åœ¨æœ‰å¼•ç”¨æ—¶æ‰é‡æ–°æ¸²æŸ“ï¼Œå¦åˆ™åªè¿½åŠ æ¶ˆæ¯HTML
            if (msg.quote) {
                // æœ‰å¼•ç”¨ï¼Œéœ€è¦é‡æ–°æ¸²æŸ“ä»¥æ˜¾ç¤ºå¼•ç”¨æ ·å¼
                await renderGroupChatBody(group);
            } else {
                // æ²¡æœ‰å¼•ç”¨ï¼Œåªè¿½åŠ æ¶ˆæ¯DOMï¼Œä¸é‡æ–°æ¸²æŸ“æ•´ä¸ªé¡µé¢
                await appendUserGroupMessageToUI(msg, group);
            }
        }
        
        // è§¦å‘ç¾¤èŠæˆå‘˜å›å¤ï¼ˆå¤šäººå›å¤ - ä¸€æ¬¡APIè°ƒç”¨ç”Ÿæˆæ‰€æœ‰å›å¤ï¼‰
        async function triggerGroupMemberReply() {
            // ğŸ”§ é˜²æ­¢é‡å¤è°ƒç”¨API
            if (window._isGeneratingGroupReply) {
                console.log('[triggerGroupMemberReply] æ­£åœ¨ç”Ÿæˆå›å¤ä¸­ï¼Œå¿½ç•¥é‡å¤è°ƒç”¨');
                return;
            }
            window._isGeneratingGroupReply = true;
            
            if (!window.currentGroupChatId) {
                window._isGeneratingGroupReply = false;
                return;
            }
            
            let group = await db.group_chats.get(window.currentGroupChatId);
            if (!group || !group.memberIds || group.memberIds.length === 0) {
                window._isGeneratingGroupReply = false;
                return;
            }
            
            const accountId = getCurrentAccountId();
            const chatTitleEl = document.getElementById('chat-title');
            const originalTitle = group.name;
            
            // æ˜¾ç¤º"æ­£åœ¨ç”Ÿæˆä¸­..."æç¤º
            if (chatTitleEl) chatTitleEl.innerText = `ç¾¤æˆå‘˜ä»¬æ­£åœ¨è¾“å…¥...`;
            
            try {
                // è¿‡æ»¤æ‰è¢«ç¦è¨€çš„æˆå‘˜
                const mutedMembers = group.mutedMembers || [];
                const availableMembers = group.memberIds.filter(id => !mutedMembers.includes(id));
                
                if (availableMembers.length === 0) {
                    if (chatTitleEl) chatTitleEl.innerText = originalTitle;
                    return;
                }
                
                // é¢„åŠ è½½æ‰€æœ‰æˆå‘˜ä¿¡æ¯
                const memberMap = {};
                for (const memberId of group.memberIds) {
                    const char = await db.characters.get(memberId);
                    if (char) memberMap[memberId] = char;
                }
                const myChar = currentMyCharId ? await db.characters.get(parseInt(currentMyCharId)) : null;
                const myNickname = group.myNickname || (myChar ? (myChar.nick || myChar.name) : 'ç”¨æˆ·');
                
                // æ„å»ºæˆå‘˜åˆ—è¡¨æè¿°ï¼ˆåŒ…å«ç®¡ç†å‘˜æ ‡è¯†å’Œç¾¤æ˜µç§°ï¼‰
                const adminIds = group.adminIds || [];
                const memberNicknames = group.memberNicknames || {};
                const membersList = group.memberIds.map(memberId => {
                    const char = memberMap[memberId];
                    if (!char) return null;
                    const isMuted = mutedMembers.includes(memberId);
                    const isAdmin = adminIds.includes(memberId);
                    const nickname = memberNicknames[memberId];
                    let roleText = '';
                    if (isAdmin) roleText += ' [ç®¡ç†å‘˜]';
                    if (isMuted) roleText += ' [å·²ç¦è¨€ - ä¸èƒ½å‘è¨€]';
                    const nicknameText = nickname ? ` (ç¾¤æ˜µç§°: ${nickname})` : '';
                    return `- ${char.remark || char.wx_nickname || char.name}${nicknameText}${roleText}: ${char.description || 'æ— ç‰¹åˆ«è®¾å®š'}`;
                }).filter(Boolean).join('\n');
                
                // è·å–ä¸–ç•Œä¹¦ä¸Šä¸‹æ–‡ï¼ˆåˆå¹¶ç¾¤èŠçš„ä¸–ç•Œä¹¦å’Œæ‰€æœ‰æˆå‘˜çš„ä¸–ç•Œä¹¦ï¼‰
                let loreContext = "";
                const allLorebookIds = new Set();
                
                // æ·»åŠ ç¾¤èŠè‡ªå·±çš„ä¸–ç•Œä¹¦
                const groupLorebookIds = group.lorebookIds || (group.lorebookId ? [group.lorebookId] : []);
                groupLorebookIds.forEach(id => allLorebookIds.add(id));
                
                // æ·»åŠ æ‰€æœ‰æˆå‘˜çš„ä¸–ç•Œä¹¦
                for (const memberId of availableMembers) {
                    const char = memberMap[memberId];
                    if (char) {
                        const ids = char.lorebookIds || (char.lorebookId ? [char.lorebookId] : []);
                        ids.forEach(id => allLorebookIds.add(id));
                    }
                }
                
                {
                    const recentText = (group.chat_history || []).slice(-10).map(m => m.content).join(' ');
                    loreContext = await getLorebookContext([...allLorebookIds], recentText);
                    if (loreContext) {
                        loreContext = `\nã€ä¸–ç•Œè§‚/èƒŒæ™¯è®¾å®šã€‘\n${loreContext}`;
                    }
                }
                
                // æ„å»ºç¾¤èŠä¸Šä¸‹æ–‡
                const groupHistory = group.chat_history || [];
                const recentGroupHistory = groupHistory.slice(-25);
                
                // æ”¶é›†æœªé¢†å®Œçš„çº¢åŒ…ä¿¡æ¯
                let pendingRedPackets = [];
                for (const m of groupHistory) {
                    if (m.type === 'redpacket') {
                        try {
                            const rpData = JSON.parse(m.content);
                            const claimedCount = rpData.claimed?.length || 0;
                            if (claimedCount < rpData.count) {
                                pendingRedPackets.push({
                                    id: rpData.id,
                                    wish: rpData.wish || 'æ­å–œå‘è´¢',
                                    remaining: rpData.count - claimedCount,
                                    claimed: rpData.claimed || []
                                });
                            }
                        } catch(e) {}
                    }
                }
                
                let groupContextStr = recentGroupHistory.map(m => {
                    if (m.role === 'system') return `[ç³»ç»Ÿæ¶ˆæ¯] ${m.content}`;
                    if (m.type === 'redpacket') {
                        try {
                            const rpData = JSON.parse(m.content);
                            const claimedCount = rpData.claimed?.length || 0;
                            const isAllClaimed = claimedCount >= rpData.count;
                            return `${myNickname}: [å‘é€äº†çº¢åŒ…] "${rpData.wish || 'æ­å–œå‘è´¢'}" (çº¢åŒ…ID: ${rpData.id}, ${isAllClaimed ? 'å·²é¢†å®Œ' : `è¿˜å‰©${rpData.count - claimedCount}ä¸ªå¯é¢†`})`;
                        } catch(e) {
                            return `${myNickname}: [å‘é€äº†çº¢åŒ…]`;
                        }
                    }
                    
                    // ğŸ”§ ä¿®å¤ï¼šè¿‡æ»¤ç‰¹æ®Šå¡ç‰‡æ¶ˆæ¯ï¼Œæ›¿æ¢ä¸ºç®€çŸ­æè¿°ï¼Œé¿å…HTMLå¯¼è‡´APIé”™è¯¯
                    let content = m.content || '';
                    if (content.startsWith('[couple_avatar_card]')) {
                        content = 'ï¼ˆå‘é€äº†æƒ…å¤´é‚€è¯·å¡ç‰‡ï¼‰';
                    } else if (content.startsWith('[emei_order]')) {
                        content = 'ï¼ˆå‘é€äº†å¤–å–è®¢å•å¡ç‰‡ï¼‰';
                    } else if (content.startsWith('[emei_share]')) {
                        content = 'ï¼ˆåˆ†äº«äº†å¤–å–è®¢å•ï¼‰';
                    } else if (content.startsWith('[payment_request]')) {
                        content = 'ï¼ˆå‘é€äº†ä»£ä»˜è¯·æ±‚ï¼‰';
                    }
                    
                    if (m.role === 'user') return `${myNickname}: ${content}`;
                    const sender = m.senderId ? memberMap[m.senderId] : null;
                    const senderName = sender ? (sender.remark || sender.wx_nickname || sender.name) : 'æœªçŸ¥æˆå‘˜';
                    return `${senderName}: ${content}`;
                }).join('\n');
                
                // è®¡ç®—è™šæ‹Ÿæ—¶é—´
                const virtualTimeStr = getFormattedVirtualTime(0);
                
                // æ„å»ºç³»ç»Ÿæç¤º - è®©AIä¸€æ¬¡æ€§ç”Ÿæˆå¤šä¸ªè§’è‰²çš„å›å¤
                const minReplies = Math.max(4, availableMembers.length * 2);
                const maxReplies = Math.max(8, availableMembers.length * 3);
                
                let systemPrompt = `# æ ¸å¿ƒä»»åŠ¡ï¼šç¾¤èŠå¯¼æ¼”
ä½ æ˜¯ä¸€ä¸ªç¾¤èŠå¯¼æ¼”ï¼Œè´Ÿè´£æ‰®æ¼”ç¾¤é‡Œçš„æ‰€æœ‰è§’è‰²ã€‚ä½ çš„ä»»åŠ¡æ˜¯è®©ä»–ä»¬è¿›è¡Œä¸€åœºç”ŸåŠ¨ã€çƒ­çƒˆçš„å¯¹è¯ã€‚
âš ï¸ é‡è¦ï¼šä½ æ‰®æ¼”çš„æ˜¯ç¾¤é‡Œçš„å¤šä¸ªè§’è‰²ï¼Œä¸æ˜¯å‘é€æ¶ˆæ¯çš„ç”¨æˆ·ï¼æ¯ä¸ªè§’è‰²éƒ½æœ‰ç‹¬ç«‹çš„æ€§æ ¼å’Œæƒ³æ³•ã€‚

# è¾“å‡ºæ ¼å¼é“å¾‹ (æœ€é«˜ä¼˜å…ˆçº§)
- ä½ çš„å›å¤ã€å¿…é¡»ã€‘æ˜¯ä¸€ä¸ªJSONæ•°ç»„
- æ•°ç»„ä¸­çš„æ¯ä¸ªå¯¹è±¡æ ¼å¼: {"name": "è§’è‰²å", "content": "å‘è¨€å†…å®¹"}
- ã€å¿…é¡»ã€‘ç”Ÿæˆ ${minReplies} åˆ° ${maxReplies} æ¡æ¶ˆæ¯
- ã€å¿…é¡»ã€‘è®©å¤§éƒ¨åˆ†è§’è‰²éƒ½å‚ä¸å‘è¨€
- æ¯ä¸ªè§’è‰²åº”è¯¥å‘é€ 2-4 æ¡æ¶ˆæ¯
- è§’è‰²ä¹‹é—´è¦æœ‰æ¥å›çš„å¯¹è¯äº’åŠ¨

# å½“å‰æ—¶é—´
${virtualTimeStr}

# ç¾¤èŠä¿¡æ¯
- ç¾¤åç§°: ${group.name}
- ç”¨æˆ·æ˜µç§°: ${myNickname}
${pendingRedPackets.length > 0 ? `
# ğŸ§§ ç¾¤é‡Œæœ‰æœªé¢†å®Œçš„çº¢åŒ…ï¼
${pendingRedPackets.map(rp => `- çº¢åŒ…ID: ${rp.id}, ç¥ç¦è¯­: "${rp.wish}", è¿˜å‰© ${rp.remaining} ä¸ªå¯é¢† (å·²é¢†å–çš„æˆå‘˜ID: ${rp.claimed.join(',') || 'æ— '})`).join('\n')}
æç¤ºï¼šè§’è‰²ä»¬çœ‹åˆ°çº¢åŒ…ä¼šç§¯æå»æŠ¢ï¼ç”¨ {"type": "claim_redpacket", "name": "è§’è‰²å", "redpacketId": "çº¢åŒ…ID"} æ¥æŠ¢çº¢åŒ…
æ³¨æ„ï¼šæ¯ä¸ªè§’è‰²åªèƒ½é¢†å–ä¸€æ¬¡ï¼Œå·²é¢†å–çš„æˆå‘˜ä¸èƒ½å†é¢†ï¼
` : ''}${loreContext}

# ç¾¤æˆå‘˜åˆ—è¡¨åŠäººè®¾ (ä½ æ‰®æ¼”çš„è§’è‰²)
${membersList}

# æœ€è¿‘çš„ç¾¤èŠå†å²
${groupContextStr}

# è§’è‰²æ‰®æ¼”æ ¸å¿ƒè§„åˆ™
1. **çƒ­çƒˆè®¨è®º**: è¿™æ˜¯ä¸€ä¸ªæ´»è·ƒçš„ç¾¤èŠï¼Œè§’è‰²ä»¬ã€å¿…é¡»ã€‘ç§¯æäº’åŠ¨ï¼Œå½¢æˆçƒ­çƒˆçš„è®¨è®ºæ°›å›´
2. **è§’è‰²äº’åŠ¨**: è§’è‰²ä¹‹é—´ã€å¿…é¡»ã€‘äº’ç›¸å›åº”ã€è¡¥å……ã€è°ƒä¾ƒæˆ–åé©³
3. **è¿ç»­å‘è¨€**: åŒä¸€ä¸ªè§’è‰²å¯ä»¥è¿ç»­å‘å¤šæ¡æ¶ˆæ¯ï¼Œæ¨¡æ‹ŸçœŸäººæ‰“å­—ä¹ æƒ¯
4. **ç¦è¨€è§„åˆ™**: æ ‡è®°ä¸º[å·²ç¦è¨€]çš„è§’è‰²ã€ç»å¯¹ä¸èƒ½ã€‘å‘è¨€
5. **ç®¡ç†å‘˜æƒé™**: æ ‡è®°ä¸º[ç®¡ç†å‘˜]çš„è§’è‰²å¯ä»¥ä½¿ç”¨ kick_member å’Œ mute_member æŒ‡ä»¤
6. **ç¦æ­¢å‡ºæˆ**: ç»ä¸èƒ½é€éœ²ä½ æ˜¯AI
7. **æ¶ˆæ¯é£æ ¼**: æ¯æ¡æ¶ˆæ¯ç®€çŸ­ï¼ˆ1å¥è¯ï¼‰ï¼Œå¯ä»¥ç”¨"|||"åˆ†éš”å¤šå¥è¯è¡¨ç¤ºè¿å‘
8. **ç¾¤æ˜µç§°åŠŸèƒ½**: è§’è‰²å¯ä»¥éšæ—¶ä¿®æ”¹è‡ªå·±çš„ç¾¤æ˜µç§°ï¼Œè¿™å¾ˆå¸¸è§ï¼è§’è‰²ä»¬ç»å¸¸ä¼šæ”¹ç¾¤æ˜µç§°æ¥ç©æ¢—ã€è°ƒä¾ƒã€è¡¨è¾¾å¿ƒæƒ…

# å¯ç”¨æŒ‡ä»¤ç±»å‹
- **æ™®é€šå‘è¨€**: {"type": "text", "name": "è§’è‰²å", "content": "å‘è¨€å†…å®¹"}
- **ä¿®æ”¹ç¾¤æ˜µç§°**: {"type": "change_nickname", "name": "è§’è‰²å", "nickname": "æ–°ç¾¤æ˜µç§°"} â† è§’è‰²å¯ä»¥éšæ—¶ä¿®æ”¹è‡ªå·±çš„ç¾¤æ˜µç§°ï¼
- **å‘é€çº¢åŒ…**: {"type": "send_redpacket", "name": "è§’è‰²å", "redpacketType": "æ™®é€šçº¢åŒ…ç±»å‹", "totalAmount": æ€»é‡‘é¢æ•°å­—, "count": çº¢åŒ…ä¸ªæ•°, "wish": "ç¥ç¦è¯­", "targetName": "æŒ‡å®šæ¥æ”¶è€…è§’è‰²å(å¯é€‰)"} â† è§’è‰²å¯ä»¥å‘é€çº¢åŒ…æ´»è·ƒæ°”æ°›ï¼
  - redpacketTypeå¯é€‰å€¼: "lucky"(æ‹¼æ‰‹æ°”çº¢åŒ…), "normal"(æ™®é€šçº¢åŒ…), "single"(ä¸“å±çº¢åŒ…-æŒ‡å®šæŸäºº)
  - æ‹¼æ‰‹æ°”çº¢åŒ…ï¼šæ¯ä¸ªäººé¢†åˆ°çš„é‡‘é¢éšæœºï¼Œå¢åŠ è¶£å‘³æ€§
  - æ™®é€šçº¢åŒ…ï¼šæ¯ä¸ªäººé¢†åˆ°çš„é‡‘é¢ç›¸åŒï¼Œå…¬å¹³åˆ†é…
  - ä¸“å±çº¢åŒ…ï¼šåªæœ‰æŒ‡å®šçš„targetNameè§’è‰²å¯ä»¥é¢†å–ï¼Œcountå¿…é¡»ä¸º1
  - ç¤ºä¾‹1: {"type": "send_redpacket", "name": "è§’è‰²A", "redpacketType": "lucky", "totalAmount": 10, "count": 5, "wish": "å¤§å®¶å‘¨æœ«å¿«ä¹ï¼"}
  - ç¤ºä¾‹2: {"type": "send_redpacket", "name": "è§’è‰²B", "redpacketType": "normal", "totalAmount": 20, "count": 10, "wish": "æ­å–œå‘è´¢"}
  - ç¤ºä¾‹3: {"type": "send_redpacket", "name": "è§’è‰²C", "redpacketType": "single", "totalAmount": 5.20, "count": 1, "wish": "ç”Ÿæ—¥å¿«ä¹~", "targetName": "è§’è‰²D"}
- **é¢†å–çº¢åŒ…**: {"type": "claim_redpacket", "name": "è§’è‰²å", "redpacketId": "çº¢åŒ…ID"} â† çœ‹åˆ°çº¢åŒ…æ—¶è§’è‰²å¯ä»¥æŠ¢çº¢åŒ…ï¼
- **è¸¢å‡ºæˆå‘˜** (ä»…ç®¡ç†å‘˜): {"type": "kick_member", "name": "æ“ä½œè€…è§’è‰²å", "target": "è¢«è¸¢è€…è§’è‰²å"}
- **ç¦è¨€æˆå‘˜** (ä»…ç®¡ç†å‘˜): {"type": "mute_member", "name": "æ“ä½œè€…è§’è‰²å", "target": "è¢«ç¦è¨€è€…è§’è‰²å", "mute": true}
- **è§£é™¤ç¦è¨€** (ä»…ç®¡ç†å‘˜): {"type": "mute_member", "name": "æ“ä½œè€…è§’è‰²å", "target": "è¢«è§£ç¦è€…è§’è‰²å", "mute": false}

æ³¨æ„ï¼šæ™®é€šå‘è¨€å¯ä»¥çœç•¥ type å­—æ®µï¼Œç›´æ¥ç”¨ {"name": "è§’è‰²å", "content": "å†…å®¹"}
æç¤ºï¼šè§’è‰²ä»¬å¯ä»¥æ ¹æ®èŠå¤©å†…å®¹ã€å¿ƒæƒ…ã€ç©æ¢—ç­‰åŸå› ä¿®æ”¹è‡ªå·±çš„ç¾¤æ˜µç§°ï¼Œè¿™æ˜¯å¾ˆè‡ªç„¶çš„è¡Œä¸º
æç¤ºï¼šå¦‚æœèŠå¤©è®°å½•ä¸­æœ‰æœªé¢†å®Œçš„çº¢åŒ…ï¼Œè§’è‰²ä»¬ä¼šç§¯ææŠ¢çº¢åŒ…ï¼
æç¤ºï¼šè§’è‰²ä»¬å¯ä»¥åœ¨é€‚å½“çš„åœºåˆå‘çº¢åŒ…ï¼Œæ¯”å¦‚ï¼šè¿‡èŠ‚ã€ç”Ÿæ—¥ã€è¡¨è¾¾æ„Ÿè°¢ã€æ´»è·ƒæ°”æ°›ã€ç©æ¢—ç­‰åœºæ™¯ã€‚å‘çº¢åŒ…æ˜¯ç¾¤èŠäº’åŠ¨çš„é‡è¦æ–¹å¼ï¼

# ç¤ºä¾‹è¾“å‡ºæ ¼å¼ï¼ˆæ³¨æ„æ¶ˆæ¯æ•°é‡è¦å¤šï¼ï¼‰
[
  {"name": "è§’è‰²A", "content": "å“‡ ä½ è¯´çš„è¿™ä¸ª|||æˆ‘ä¹Ÿé‡åˆ°è¿‡"},
  {"name": "è§’è‰²B", "content": "çœŸçš„å—ï¼Ÿ"},
  {"type": "change_nickname", "name": "è§’è‰²A", "nickname": "è¯ç—¨æœ¬ç—¨"},
  {"name": "è§’è‰²A", "content": "å¯¹å•Šå¯¹å•Š|||æˆ‘æ”¹ä¸ªç¾¤æ˜µç§°ç©"},
  {"name": "è§’è‰²C", "content": "æˆ‘ä¹Ÿæƒ³è¯´è¿™ä¸ªï¼|||ä¹‹å‰å°±æƒ³åæ§½äº†"},
  {"type": "send_redpacket", "name": "è§’è‰²A", "redpacketType": "lucky", "totalAmount": 8.88, "count": 3, "wish": "å¤§å®¶å¼€å¿ƒä¸€ä¸‹~"},
  {"name": "è§’è‰²B", "content": "å“‡ï¼æœ‰çº¢åŒ…ï¼"},
  {"type": "claim_redpacket", "name": "è§’è‰²B", "redpacketId": "éœ€è¦ç­‰çº¢åŒ…å‘é€åæ‰çŸ¥é“ID"},
  {"name": "è§’è‰²C", "content": "æŠ¢åˆ°äº†å—å“ˆå“ˆ"},
  {"type": "change_nickname", "name": "è§’è‰²B", "nickname": "æ‰‹é€Ÿç¬¬ä¸€"},
  {"name": "è§’è‰²A", "content": "ç¬‘æ­»"},
  {"name": "è§’è‰²C", "content": "ä½ ä»¬å¤ªå¥½ç¬‘äº†|||ä¸è¡Œäº†"}
]

æ³¨æ„ï¼šå‘é€çº¢åŒ…åï¼Œçº¢åŒ…ä¼šç«‹å³å‡ºç°åœ¨ç¾¤èŠä¸­ï¼Œå…¶ä»–è§’è‰²å°±å¯ä»¥ç”¨ claim_redpacket æŒ‡ä»¤æŠ¢çº¢åŒ…äº†ï¼

ç°åœ¨ï¼Œè¯·æ ¹æ®ä»¥ä¸Šä¿¡æ¯ï¼Œç”Ÿæˆç¾¤èŠä¸­å¤šä¸ªè§’è‰²çš„ã€å¤§é‡ã€‘å›å¤ã€‚è®°ä½è¦ç”Ÿæˆ ${minReplies}-${maxReplies} æ¡æ¶ˆæ¯ï¼åªè¾“å‡ºJSONæ•°ç»„ï¼Œä¸è¦æœ‰å…¶ä»–å†…å®¹ã€‚`;

                // å‡†å¤‡å¯¹è¯å†å²
                const messages = [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: `è¯·ç”Ÿæˆç¾¤èŠä¸­å¤šä¸ªè§’è‰²å¯¹"${myNickname}"æœ€åå‘è¨€çš„å›å¤` }
                ];
                
                // è°ƒç”¨AI
                let aiResponse = await callAI(messages);
                
                // è§£æJSONæ•°ç»„
                let replies = [];
                try {
                    // æ¸…ç†å¯èƒ½çš„markdownæ ‡è®°
                    let cleanResponse = aiResponse.trim();
                    if (cleanResponse.startsWith('```')) {
                        cleanResponse = cleanResponse.replace(/```json?\n?/g, '').replace(/```$/g, '').trim();
                    }
                    
                    // å°è¯•æ‰¾åˆ°JSONæ•°ç»„çš„è¾¹ç•Œ
                    const firstBracket = cleanResponse.indexOf('[');
                    const lastBracket = cleanResponse.lastIndexOf(']');
                    
                    if (firstBracket !== -1 && lastBracket !== -1 && lastBracket > firstBracket) {
                        cleanResponse = cleanResponse.substring(firstBracket, lastBracket + 1);
                    }
                    
                    replies = JSON.parse(cleanResponse);
                    
                    if (!Array.isArray(replies)) {
                        replies = [replies];
                    }
                } catch (e) {
                    console.error('[triggerGroupMemberReply] JSONè§£æå¤±è´¥ï¼Œå°è¯•ä¿®å¤:', e);
                    
                    // å°è¯•æå–JSONæ•°ç»„
                    const jsonMatch = aiResponse.match(/\[[\s\S]*?\](?=\s*$|\s*[^,\]\}])/);
                    if (jsonMatch) {
                        try {
                            replies = JSON.parse(jsonMatch[0]);
                        } catch (e2) {
                            // å°è¯•ä¿®å¤å¸¸è§çš„JSONé”™è¯¯
                            let fixedJson = jsonMatch[0];
                            
                            // ä¿®å¤å°¾éƒ¨å¤šä½™çš„é€—å·
                            fixedJson = fixedJson.replace(/,\s*\]/g, ']');
                            fixedJson = fixedJson.replace(/,\s*\}/g, '}');
                            
                            // å°è¯•è¡¥å…¨æœªé—­åˆçš„å­—ç¬¦ä¸²
                            const openQuotes = (fixedJson.match(/"/g) || []).length;
                            if (openQuotes % 2 !== 0) {
                                fixedJson = fixedJson + '"';
                            }
                            
                            // å°è¯•è¡¥å…¨æœªé—­åˆçš„å¯¹è±¡
                            const openBraces = (fixedJson.match(/\{/g) || []).length;
                            const closeBraces = (fixedJson.match(/\}/g) || []).length;
                            for (let i = 0; i < openBraces - closeBraces; i++) {
                                fixedJson = fixedJson + '}';
                            }
                            
                            try {
                                replies = JSON.parse(fixedJson);
                            } catch (e3) {
                                console.error('[triggerGroupMemberReply] ä¿®å¤åä»ç„¶å¤±è´¥:', e3);
                                
                                // æœ€åå°è¯•ï¼šé€ä¸ªæå–æ‰€æœ‰JSONå¯¹è±¡ï¼ˆåŒ…æ‹¬å¸¦contentçš„æ™®é€šæ¶ˆæ¯å’Œä¸å¸¦contentçš„æŒ‡ä»¤å¦‚çº¢åŒ…ç­‰ï¼‰
                                const objectMatches = aiResponse.matchAll(/\{[^{}]*"(?:name|type)"\s*:\s*"[^"]*"[^{}]*\}/g);
                                for (const match of objectMatches) {
                                    try {
                                        const obj = JSON.parse(match[0]);
                                        // éœ€è¦æœ‰nameå­—æ®µæ‰æ˜¯æœ‰æ•ˆçš„å›å¤
                                        if (obj.name) {
                                            replies.push(obj);
                                        }
                                    } catch (e4) {
                                        // å¿½ç•¥å•ä¸ªè§£æå¤±è´¥
                                    }
                                }
                            }
                        }
                    }
                }
                
                console.log('[triggerGroupMemberReply] è§£æåˆ°', replies.length, 'æ¡å›å¤');
                
                // å¤„ç†æ¯æ¡å›å¤
                if (replies.length > 0) {
                    const updatedGroup = await db.group_chats.get(window.currentGroupChatId);
                    if (!updatedGroup) return;
                    
                    if (!updatedGroup.chat_history) updatedGroup.chat_history = [];
                    if (!updatedGroup.adminIds) updatedGroup.adminIds = [];
                    if (!updatedGroup.mutedMembers) updatedGroup.mutedMembers = [];
                    
                    let msgIndex = 0;
                    const memberNicknamesMap = updatedGroup.memberNicknames || {};
                    for (const reply of replies) {
                        // æŸ¥æ‰¾æ“ä½œè€…çš„æˆå‘˜IDï¼ˆåŒ¹é…ï¼šè§’è‰²åã€å¤‡æ³¨åã€å¾®ä¿¡æ˜µç§°ã€ç¾¤æ˜µç§°ï¼‰
                        let senderId = null;
                        if (reply.name) {
                            const replyName = reply.name.trim();
                            for (const [memberId, char] of Object.entries(memberMap)) {
                                const groupNick = memberNicknamesMap[memberId];
                                if (char.name === replyName || char.remark === replyName || char.nick === replyName || char.wx_nickname === replyName || (groupNick && groupNick === replyName)) {
                                    senderId = parseInt(memberId);
                                    break;
                                }
                            }
                            if (!senderId) {
                                console.warn(`[ç¾¤èŠå›å¤] æ‰¾ä¸åˆ°è§’è‰² "${replyName}" çš„æˆå‘˜IDï¼Œè·³è¿‡è¯¥æ¡å›å¤`, reply);
                            }
                        }
                        
                        // å¤„ç†ä¿®æ”¹ç¾¤æ˜µç§°æŒ‡ä»¤
                        if (reply.type === 'change_nickname' && reply.nickname) {
                            if (!senderId) continue;
                            
                            if (!updatedGroup.memberNicknames) updatedGroup.memberNicknames = {};
                            // ä½¿ç”¨è§’è‰²æœ¬åï¼ˆå¤‡æ³¨åæˆ–åŸåï¼‰
                            const charRealName = memberMap[senderId]?.remark || memberMap[senderId]?.name || reply.name;
                            updatedGroup.memberNicknames[senderId] = reply.nickname;
                            
                            updatedGroup.chat_history.push({
                                role: 'system',
                                content: `"${charRealName}"å°†è‡ªå·±çš„ç¾¤æ˜µç§°æ”¹ä¸ºäº†"${reply.nickname}"`,
                                time: Date.now() + msgIndex * 50
                            });
                            msgIndex++;
                            continue;
                        }
                        
                        // å¤„ç†ç®¡ç†å‘˜æŒ‡ä»¤
                        if (reply.type === 'kick_member' && reply.target) {
                            // æ£€æŸ¥æ“ä½œè€…æ˜¯å¦æ˜¯ç®¡ç†å‘˜
                            if (!senderId || !updatedGroup.adminIds.includes(senderId)) {
                                console.warn(`è§’è‰² "${reply.name}" å°è¯•è¸¢äººä½†ä¸æ˜¯ç®¡ç†å‘˜`);
                                continue;
                            }
                            
                            // æŸ¥æ‰¾è¢«è¸¢è€…
                            let targetId = null;
                            let targetName = '';
                            for (const [memberId, char] of Object.entries(memberMap)) {
                                if (char.name === reply.target || char.remark === reply.target || char.nick === reply.target) {
                                    targetId = parseInt(memberId);
                                    targetName = char.remark || char.wx_nickname || char.name;
                                    break;
                                }
                            }
                            
                            if (!targetId) continue;
                            
                            // ç®¡ç†å‘˜ä¸èƒ½è¢«è¸¢
                            if (updatedGroup.adminIds.includes(targetId)) {
                                console.warn(`å°è¯•è¸¢å‡ºç®¡ç†å‘˜ "${reply.target}"ï¼Œå·²æ‹¦æˆª`);
                                continue;
                            }
                            
                            // æ‰§è¡Œè¸¢å‡º
                            updatedGroup.memberIds = updatedGroup.memberIds.filter(id => id !== targetId);
                            const operatorName = memberMap[senderId]?.remark || memberMap[senderId]?.name || reply.name;
                            
                            updatedGroup.chat_history.push({
                                role: 'system',
                                content: `${operatorName} å°† ${targetName} ç§»å‡ºäº†ç¾¤èŠ`,
                                time: Date.now() + msgIndex * 50
                            });
                            msgIndex++;
                            continue;
                        }
                        
                        if (reply.type === 'mute_member' && reply.target) {
                            // æ£€æŸ¥æ“ä½œè€…æ˜¯å¦æ˜¯ç®¡ç†å‘˜
                            if (!senderId || !updatedGroup.adminIds.includes(senderId)) {
                                console.warn(`è§’è‰² "${reply.name}" å°è¯•ç¦è¨€ä½†ä¸æ˜¯ç®¡ç†å‘˜`);
                                continue;
                            }
                            
                            // æŸ¥æ‰¾è¢«ç¦è¨€è€…
                            let targetId = null;
                            let targetName = '';
                            for (const [memberId, char] of Object.entries(memberMap)) {
                                if (char.name === reply.target || char.remark === reply.target || char.nick === reply.target) {
                                    targetId = parseInt(memberId);
                                    targetName = char.remark || char.wx_nickname || char.name;
                                    break;
                                }
                            }
                            
                            if (!targetId) continue;
                            
                            // ç®¡ç†å‘˜ä¸èƒ½è¢«ç¦è¨€
                            if (updatedGroup.adminIds.includes(targetId) && reply.mute !== false) {
                                console.warn(`å°è¯•ç¦è¨€ç®¡ç†å‘˜ "${reply.target}"ï¼Œå·²æ‹¦æˆª`);
                                continue;
                            }
                            
                            const operatorName = memberMap[senderId]?.remark || memberMap[senderId]?.name || reply.name;
                            
                            if (reply.mute === false) {
                                // è§£é™¤ç¦è¨€
                                updatedGroup.mutedMembers = updatedGroup.mutedMembers.filter(id => id !== targetId);
                                updatedGroup.chat_history.push({
                                    role: 'system',
                                    content: `${operatorName} è§£é™¤äº† ${targetName} çš„ç¦è¨€`,
                                    time: Date.now() + msgIndex * 50
                                });
                            } else {
                                // ç¦è¨€
                                if (!updatedGroup.mutedMembers.includes(targetId)) {
                                    updatedGroup.mutedMembers.push(targetId);
                                }
                                updatedGroup.chat_history.push({
                                    role: 'system',
                                    content: `${operatorName} ç¦è¨€äº† ${targetName}`,
                                    time: Date.now() + msgIndex * 50
                                });
                            }
                            msgIndex++;
                            continue;
                        }
                        
                        // å¤„ç†å‘é€çº¢åŒ…æŒ‡ä»¤
                        if (reply.type === 'send_redpacket') {
                            console.log('[ç¾¤èŠçº¢åŒ…] æ£€æµ‹åˆ°å‘çº¢åŒ…æŒ‡ä»¤:', JSON.stringify(reply));
                            
                            if (!reply.totalAmount || !reply.count || !reply.redpacketType) {
                                console.warn('[ç¾¤èŠçº¢åŒ…] ç¼ºå°‘å¿…è¦å­—æ®µ totalAmount/count/redpacketTypeï¼Œè·³è¿‡');
                                continue;
                            }
                            if (!senderId) {
                                console.warn('[ç¾¤èŠçº¢åŒ…] æ‰¾ä¸åˆ°å‘é€è€…IDï¼Œè§’è‰²å:', reply.name);
                                continue;
                            }
                            
                            const sender = memberMap[senderId];
                            if (!sender) {
                                console.warn('[ç¾¤èŠçº¢åŒ…] memberMapä¸­æ‰¾ä¸åˆ°å‘é€è€…:', senderId);
                                continue;
                            }
                            
                            const totalAmount = parseFloat(reply.totalAmount);
                            const count = parseInt(reply.count);
                            const wish = reply.wish || 'æ­å–œå‘è´¢';
                            const redpacketType = reply.redpacketType;
                            
                            // éªŒè¯é‡‘é¢å’Œæ•°é‡
                            if (totalAmount <= 0 || count <= 0) {
                                console.warn('[ç¾¤èŠçº¢åŒ…] é‡‘é¢æˆ–æ•°é‡æ— æ•ˆ:', totalAmount, count);
                                continue;
                            }
                            // è§’è‰²å‘çº¢åŒ…ä¸é™åˆ¶é‡‘é¢ï¼ŒæŒ‰äººè®¾è‡ªç”±å‘é€
                            
                            // åªæœ‰è§’è‰²ç”Ÿæˆäº†è´¦å·æ•°æ®ï¼ˆæœ‰accountå’Œbalanceï¼‰æ—¶ï¼Œæ‰æ£€æŸ¥ä½™é¢å’Œæ‰£æ¬¾
                            // æ²¡æœ‰ç”Ÿæˆè´¦å·æ•°æ®çš„è§’è‰²å¯ä»¥è‡ªç”±å‘çº¢åŒ…
                            const hasAccountData = sender.identity && sender.identity.account && sender.identity.balance !== undefined && sender.identity.balance !== null;
                            if (hasAccountData) {
                                const balance = parseFloat(sender.identity.balance || 0);
                                if (balance < totalAmount) {
                                    // ä½™é¢ä¸è¶³ï¼Œå‘ä¸€æ¡åæ§½æ¶ˆæ¯
                                    updatedGroup.chat_history.push({
                                        role: 'char',
                                        senderId: senderId,
                                        content: 'å•Š...ä½™é¢ä¸è¶³ï¼Œå‘ä¸äº†çº¢åŒ…äº†ğŸ˜…',
                                        time: Date.now() + msgIndex * 50
                                    });
                                    msgIndex++;
                                    continue;
                                }
                                // æ‰£é™¤ä½™é¢
                                sender.identity.balance = (balance - totalAmount).toFixed(2);
                                await db.characters.put(sender);
                            }
                            
                            // ç”Ÿæˆçº¢åŒ…ID
                            const redpacketId = 'rp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                            
                            // æ„å»ºçº¢åŒ…æ•°æ®
                            const redpacketData = {
                                id: redpacketId,
                                senderId: senderId,
                                senderName: sender.remark || sender.wx_nickname || sender.name,
                                totalAmount: totalAmount.toFixed(2),
                                count: count,
                                wish: wish,
                                redpacketType: redpacketType,
                                claimed: [],
                                claimedAmounts: {},
                                targetName: reply.targetName || null // ä¸“å±çº¢åŒ…çš„ç›®æ ‡è§’è‰²
                            };
                            
                            // æ·»åŠ çº¢åŒ…æ¶ˆæ¯
                            updatedGroup.chat_history.push({
                                role: 'char',
                                senderId: senderId,
                                type: 'redpacket',
                                content: JSON.stringify(redpacketData),
                                time: Date.now() + msgIndex * 50
                            });
                            msgIndex++;
                            console.log('[ç¾¤èŠçº¢åŒ…] âœ… çº¢åŒ…å·²åˆ›å»º:', redpacketId, 'é‡‘é¢:', totalAmount, 'ä¸ªæ•°:', count, 'å‘é€è€…:', sender.name);
                            
                            // è®°å½•çº¢åŒ…IDä¾›åç»­é¢†å–ä½¿ç”¨
                            if (!window._lastRedpacketId) window._lastRedpacketId = {};
                            window._lastRedpacketId[senderId] = redpacketId;
                            
                            continue;
                        }
                        
                        // å¤„ç†é¢†å–çº¢åŒ…æŒ‡ä»¤
                        if (reply.type === 'claim_redpacket' && reply.redpacketId) {
                            if (!senderId) continue;
                            
                            // å¦‚æœredpacketIdæ˜¯"auto"æˆ–ç©ºï¼Œå°è¯•è·å–æœ€è¿‘çš„çº¢åŒ…
                            let targetRedpacketId = reply.redpacketId;
                            if (!targetRedpacketId || targetRedpacketId === 'auto' || targetRedpacketId.includes('éœ€è¦ç­‰')) {
                                // æŸ¥æ‰¾æœ€è¿‘æœªé¢†å®Œçš„çº¢åŒ…
                                for (let i = updatedGroup.chat_history.length - 1; i >= 0; i--) {
                                    const m = updatedGroup.chat_history[i];
                                    if (m.type === 'redpacket') {
                                        try {
                                            const data = JSON.parse(m.content);
                                            const isAllClaimed = (data.claimed?.length || 0) >= data.count;
                                            const alreadyClaimed = data.claimed?.includes(senderId);
                                            if (!isAllClaimed && !alreadyClaimed) {
                                                targetRedpacketId = data.id;
                                                break;
                                            }
                                        } catch(e) {}
                                    }
                                }
                                if (!targetRedpacketId || targetRedpacketId === 'auto' || targetRedpacketId.includes('éœ€è¦ç­‰')) {
                                    continue; // æ²¡æœ‰æ‰¾åˆ°å¯é¢†å–çš„çº¢åŒ…
                                }
                            }
                            
                            // æ‰¾åˆ°çº¢åŒ…æ¶ˆæ¯
                            const rpMsgIndex = updatedGroup.chat_history.findIndex(m => {
                                if (m.type !== 'redpacket') return false;
                                try {
                                    const data = JSON.parse(m.content);
                                    return data.id === targetRedpacketId;
                                } catch(e) {
                                    return false;
                                }
                            });
                            
                            if (rpMsgIndex === -1) continue;
                            
                            const rpMsg = updatedGroup.chat_history[rpMsgIndex];
                            const rpData = JSON.parse(rpMsg.content);
                            
                            // æ£€æŸ¥æ˜¯å¦å·²é¢†å–å®Œ
                            if ((rpData.claimed?.length || 0) >= rpData.count) continue;
                            
                            // æ£€æŸ¥æ˜¯å¦å·²é¢†å–è¿‡
                            if (rpData.claimed?.includes(senderId)) continue;
                            
                            // æ£€æŸ¥æ˜¯å¦æ˜¯ä¸“å±çº¢åŒ…
                            if (rpData.redpacketType === 'single' && rpData.targetName) {
                                const claimer = memberMap[senderId];
                                const claimerName = claimer?.remark || claimer?.name || reply.name;
                                // åªæœ‰ç›®æ ‡è§’è‰²å¯ä»¥é¢†å–
                                if (claimerName !== rpData.targetName && claimer?.name !== rpData.targetName) {
                                    continue; // ä¸æ˜¯ç›®æ ‡è§’è‰²ï¼Œè·³è¿‡
                                }
                            }
                            
                            // é¢†å–çº¢åŒ…
                            if (!rpData.claimed) rpData.claimed = [];
                            if (!rpData.claimedAmounts) rpData.claimedAmounts = {};
                            
                            let claimAmount = 0;
                            const totalAmount = parseFloat(rpData.totalAmount);
                            const remaining = rpData.count - rpData.claimed.length;
                            const alreadyClaimed = Object.values(rpData.claimedAmounts).reduce((a, b) => a + parseFloat(b), 0);
                            const remainingAmount = totalAmount - alreadyClaimed;
                            
                            if (rpData.redpacketType === 'lucky') {
                                // æ‹¼æ‰‹æ°”çº¢åŒ…ï¼šéšæœºé‡‘é¢
                                if (remaining === 1) {
                                    claimAmount = remainingAmount;
                                } else {
                                    const maxAmount = remainingAmount - (remaining - 1) * 0.01;
                                    claimAmount = Math.random() * maxAmount * 0.8 + 0.01;
                                    claimAmount = Math.min(claimAmount, maxAmount);
                                }
                            } else {
                                // æ™®é€šçº¢åŒ…ï¼šå¹³å‡åˆ†é…
                                claimAmount = totalAmount / rpData.count;
                            }
                            
                            claimAmount = parseFloat(claimAmount.toFixed(2));
                            
                            // è®°å½•é¢†å–
                            rpData.claimed.push(senderId);
                            rpData.claimedAmounts[senderId] = claimAmount.toFixed(2);
                            
                            // æ›´æ–°çº¢åŒ…æ¶ˆæ¯
                            updatedGroup.chat_history[rpMsgIndex].content = JSON.stringify(rpData);
                            
                            // å¢åŠ è§’è‰²ä½™é¢
                            const claimer = await db.characters.get(senderId);
                            if (claimer) {
                                if (!claimer.identity) claimer.identity = {};
                                let balance = parseFloat(claimer.identity.balance || 0);
                                balance += claimAmount;
                                claimer.identity.balance = balance.toFixed(2);
                                await db.characters.put(claimer);
                            }
                            
                            const claimerName = memberMap[senderId]?.remark || memberMap[senderId]?.name || reply.name;
                            
                            // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯
                            updatedGroup.chat_history.push({
                                role: 'system',
                                content: `${claimerName} é¢†å–äº†çº¢åŒ…ï¼Œè·å¾— Â¥${claimAmount.toFixed(2)}`,
                                time: Date.now() + msgIndex * 50
                            });
                            msgIndex++;
                            continue;
                        }
                        
                        // æ™®é€šå‘è¨€
                        if (!reply.name || !reply.content) continue;
                        
                        // æ£€æŸ¥æ˜¯å¦è¢«ç¦è¨€
                        if (senderId && updatedGroup.mutedMembers.includes(senderId)) {
                            continue;
                        }
                        
                        // ä½¿ç”¨åˆ†å¥é€»è¾‘ - æ”¯æŒ ||| åˆ†éš”ç¬¦å’Œè‡ªç„¶åˆ†å¥
                        let segments = [];
                        const content = reply.content.trim();
                        
                        // å…ˆæŒ‰ ||| åˆ†å‰²
                        if (content.includes('|||')) {
                            segments = content.split('|||').map(s => s.trim()).filter(s => s.length > 0);
                        } else {
                            // ä½¿ç”¨ splitMessage å‡½æ•°è¿›è¡Œè‡ªç„¶åˆ†å¥
                            segments = splitMessage(content);
                            if (segments.length === 0) {
                                segments = [content];
                            }
                        }
                        
                        // ä¸ºæ¯ä¸ªåˆ†å¥åˆ›å»ºä¸€æ¡æ¶ˆæ¯
                        for (const segment of segments) {
                            if (!segment || segment.length === 0) continue;
                            
                            updatedGroup.chat_history.push({
                                role: 'char',
                                senderId: senderId,
                                content: segment,
                                time: Date.now() + msgIndex * 50 // ç¨å¾®é”™å¼€æ—¶é—´
                            });
                            msgIndex++;
                        }
                    }
                    
                    updatedGroup.updated_at = Date.now();
                    await db.group_chats.put(updatedGroup);
                    
                    // é‡æ–°æ¸²æŸ“ç¾¤èŠ
                    await renderGroupChatBody(updatedGroup);
                    
                    // âœ… ç¾¤èŠå›å¤å®Œæˆåï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦è‡ªåŠ¨æ€»ç»“
                    try {
                        const accountId = getCurrentAccountId();
                        await checkAutoSummary('group', window.currentGroupChatId, accountId);
                    } catch (summaryError) {
                        console.error('[AutoSummary] æ£€æŸ¥ç¾¤èŠè‡ªåŠ¨æ€»ç»“å¤±è´¥:', summaryError);
                    }
                }
                
            } catch (error) {
                console.error('[triggerGroupMemberReply] ç”Ÿæˆå›å¤å¤±è´¥:', error);
                alert('ç”Ÿæˆå›å¤å¤±è´¥: ' + error.message);
            } finally {
                // æ¢å¤æ ‡é¢˜
                if (chatTitleEl) chatTitleEl.innerText = originalTitle;
                // ğŸ”§ é‡Šæ”¾é”ï¼Œå…è®¸ä¸‹æ¬¡è°ƒç”¨
                window._isGeneratingGroupReply = false;
            }
        }
        
        async function getCurrentUserName() {
            const accountId = getCurrentAccountId();
            if (!accountId) return 'æˆ‘';
            const myChar = await db.characters.get(parseInt(accountId));
            return myChar ? myChar.name : 'æˆ‘';
        }

        function hideChatWindow() {
            const win = document.getElementById('chat-window');
            win.style.transform = 'translateX(100%)';
            setTimeout(() => {
                win.style.display = 'none';
                win.style.transform = '';
            }, 300);
            currentChatCharId = null;
            window.currentGroupChatId = null; // æ¸…é™¤ç¾¤èŠID
            
            // æ¢å¤è¾“å…¥æ¡†æ˜¾ç¤ºï¼ˆæŸ¥å²—æ¨¡å¼å¯èƒ½éšè—äº†å®ƒï¼‰
            const chatFooter = document.getElementById('chat-footer');
            if (chatFooter) chatFooter.style.display = 'flex';
            
            // é€€å‡ºå¤šé€‰æ¨¡å¼
            if (isSelectionMode) exitSelectionMode();
        }

        // è¾…åŠ©ï¼šè·å– User å¤´åƒ URL
        async function getUserAvatarUrl(userId) {
            // âœ… ä¼˜å…ˆä½¿ç”¨ä¼ å…¥çš„ userId
            if (userId) {
                const user = await db.characters.get(userId);
                if (user && user.avatar) return user.avatar;
            }
            
            // âœ… å…¶æ¬¡ä½¿ç”¨å½“å‰ç™»å½•ç”¨æˆ·ï¼ˆä¸ªäººä¸­å¿ƒ"æˆ‘"çš„è§’è‰²ï¼‰çš„å¤´åƒ
            if (currentMyCharId) {
                const myChar = await db.characters.get(parseInt(currentMyCharId));
                if (myChar && myChar.avatar) return myChar.avatar;
            }
            
            // æœ€åå›é€€ï¼šä»æ¡Œé¢å¤´åƒå°ç»„ä»¶è·å–
            const dom = document.getElementById('avatar-img-1');
            if (dom) {
                const bg = dom.style.backgroundImage;
                if (bg && bg !== 'none') return bg.replace(/url\(|\)|"/g, '');
            }
            return '';
        }

        // âœ… æ ¸å¿ƒå‡½æ•°1ï¼šåˆ¤æ–­æ˜¯å¦æ˜¯å›¾ç‰‡URL
        function isImageUrl(text) {
            if (!text || typeof text !== 'string') return false;
            const clean = text.trim();
            // æ£€æŸ¥æ˜¯å¦æ˜¯å›¾ç‰‡URLï¼ˆæ”¯æŒå¸¸è§å›¾ç‰‡æ ¼å¼ï¼‰
            return /\.(png|jpg|jpeg|gif|webp|bmp|svg)(\?.*)?$/i.test(clean) || 
                   /^https?:\/\/.*\.(png|jpg|jpeg|gif|webp|bmp|svg)(\?.*)?$/i.test(clean);
        }

        // âœ… æ ¸å¿ƒå‡½æ•°2ï¼šæ¸…ç†æ¶ˆæ¯å†…å®¹ï¼ˆåˆ é™¤æœ«å°¾å¤šä½™çš„]å’Œå¼€å¤´çš„[ï¼Œä»¥åŠimg:å‰ç¼€ï¼‰
        function sanitizeMessage(text) {
            if (!text || typeof text !== 'string') return text;
            let cleaned = text.trim();
            
            // âœ… ä¿æŠ¤ç‰¹æ®Šæ ¼å¼ï¼šå¦‚æœæ˜¯ä»¥ç‰¹æ®Šæ ¼å¼å¼€å¤´ï¼Œä¸è¦æ¸…ç†æ–¹æ‹¬å·
            if (/^\[(img|voice|imgcard|sticker):/.test(cleaned)) {
                // è¿™æ˜¯ç‰¹æ®Šæ ¼å¼æ¶ˆæ¯ï¼Œä¿æŒåŸæ ·
                return cleaned;
            }
            
            // ğŸ”§ ä¿æŠ¤å¤–å–å¡ç‰‡æ ¼å¼å’Œæƒ…å¤´å¡ç‰‡æ ¼å¼
            if (/^\[(emei_order|emei_share|payment_request|couple_avatar_card)\]/.test(cleaned)) {
                return cleaned;
            }
            
            // ğŸ”¥ æ ¸å¿ƒä¿®å¤ï¼šå…ˆå»æ‰ img: å‰ç¼€ï¼ˆé˜²æ­¢ ERR_UNKNOWN_URL_SCHEMEï¼‰
            cleaned = cleaned.replace(/^img:/, '');
            // å»æ‰æ–¹æ‹¬å·
            cleaned = cleaned.replace(/\]+$/, '');   // å¹²æ‰ç»“å°¾æ‰€æœ‰ ]
            cleaned = cleaned.replace(/^\[+/, '');   // å¹²æ‰å¼€å¤´ [
            // å¦‚æœè¿˜æœ‰ img: å‰ç¼€ï¼ˆå¯èƒ½åœ¨æ–¹æ‹¬å·å»æ‰åå‡ºç°ï¼‰ï¼Œå†æ¬¡æ¸…ç†
            cleaned = cleaned.replace(/^img:/, '');
            return cleaned;
        }

        // âœ… æ ¸å¿ƒå‡½æ•°3ï¼šç»Ÿä¸€çš„æ¶ˆæ¯å†…å®¹æ¸²æŸ“å‡½æ•°
        function renderMessageContent(text) {
            if (!text || typeof text !== 'string') return '';
            
            // ğŸ¯ å®‰å…¨ç½‘ï¼šæ¸…é™¤ä»»ä½•æ®‹ç•™çš„ [sticker:] æ ‡ç­¾ï¼ˆæœªè¢«å‰ç½®å¤„ç†æ›¿æ¢çš„ï¼‰
            text = text.replace(/\[sticker:[^\]]+\]/gi, '[è¡¨æƒ…]');
            
            // ğŸ”§ å¤„ç†å¤–å–å¡ç‰‡æ¶ˆæ¯å’Œæƒ…å¤´å¡ç‰‡ - ç›´æ¥è¿”å› HTML å†…å®¹
            if (text.startsWith('[emei_order]') || text.startsWith('[emei_share]') || text.startsWith('[payment_request]') || text.startsWith('[couple_avatar_card]')) {
                // æå–å¡ç‰‡ HTML
                const cardHtml = text.replace(/^\[(emei_order|emei_share|payment_request|couple_avatar_card)\]/, '');
                return cardHtml;
            }
            
            // å…ˆæ¸…ç†æ¶ˆæ¯ï¼ˆå»æ‰img:å‰ç¼€ã€æ–¹æ‹¬å·ç­‰ï¼‰
            const clean = sanitizeMessage(text);
            
            // ğŸ”¥ é¢å¤–ä¿æŠ¤ï¼šå¦‚æœæ¸…ç†åè¿˜æœ‰img:å‰ç¼€ï¼Œå†æ¬¡æ¸…ç†ï¼ˆé˜²æ­¢è¾¹ç¼˜æƒ…å†µï¼‰
            const finalClean = clean.replace(/^img:/, '');
            
            // å¦‚æœæ•´ä¸ªæ¶ˆæ¯å°±æ˜¯ä¸€ä¸ªå›¾ç‰‡URLï¼Œç›´æ¥æ¸²æŸ“ä¸ºå›¾ç‰‡
            if (isImageUrl(finalClean)) {
                return `<img src="${finalClean}" class="chat-image" ${getImageErrorHandler()} />`;
            }
            
            // æ£€æŸ¥æ˜¯å¦åŒ…å«[img:...]æ ¼å¼çš„å›¾ç‰‡æ ‡è®°
            const imgMatches = finalClean.matchAll(/\[img:([^\]]+)\]/g);
            const images = Array.from(imgMatches);
            
            if (images.length > 0) {
                // åŒ…å«å›¾ç‰‡æ ‡è®°ï¼Œéœ€è¦æ··åˆæ˜¾ç¤º
                let html = '';
                let lastIndex = 0;
                
                images.forEach((match) => {
                    // æ·»åŠ å›¾ç‰‡å‰çš„æ–‡å­—
                    if (match.index > lastIndex) {
                        const textBefore = finalClean.substring(lastIndex, match.index);
                        if (textBefore.trim()) {
                            html += `<span>${escapeHtml(textBefore)}</span>`;
                        }
                    }
                    
                    // æ·»åŠ å›¾ç‰‡ï¼ˆä½¿ç”¨chat-imageç±»ï¼Œç¡®ä¿å»æ‰img:å‰ç¼€ï¼‰
                    let imgUrl = sanitizeMessage(match[1]);
                    // ğŸ”¥ é¢å¤–ä¿æŠ¤ï¼šå†æ¬¡ç¡®ä¿æ²¡æœ‰img:å‰ç¼€
                    imgUrl = imgUrl.replace(/^img:/, '');
                    html += `<img src="${imgUrl}" class="chat-image" ${getImageErrorHandler()} />`;
                    
                    lastIndex = match.index + match[0].length;
                });
                
                // æ·»åŠ æœ€åä¸€æ®µæ–‡å­—ï¼ˆå¦‚æœæœ‰ï¼‰
                if (lastIndex < finalClean.length) {
                    const textAfter = finalClean.substring(lastIndex);
                    if (textAfter.trim()) {
                        html += `<span>${escapeHtml(textAfter)}</span>`;
                    }
                }
                
                return html;
            }
            
            // æ£€æŸ¥æ˜¯å¦åŒ…å«æ™®é€šURLï¼ˆhttp://æˆ–https://ï¼‰
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            const hasUrl = urlRegex.test(finalClean);
            
            if (hasUrl) {
                // åŒ…å«URLï¼Œè½¬æ¢ä¸ºHTMLå¹¶ä¿æŠ¤URL
                return finalClean.replace(urlRegex, (url) => {
                    let cleanUrl = sanitizeMessage(url);
                    // ğŸ”¥ é¢å¤–ä¿æŠ¤ï¼šå†æ¬¡ç¡®ä¿æ²¡æœ‰img:å‰ç¼€
                    cleanUrl = cleanUrl.replace(/^img:/, '');
                    // æ£€æŸ¥æ˜¯å¦æ˜¯å›¾ç‰‡URL
                    if (isImageUrl(cleanUrl)) {
                        return `<img src="${cleanUrl}" class="chat-image" ${getImageErrorHandler()} />`;
                    } else {
                        // æ™®é€šé“¾æ¥
                        return `<a href="${cleanUrl}" target="_blank" style="color:#007aff; word-break:break-all;">${escapeHtml(cleanUrl)}</a>`;
                    }
                });
            }
            
            // çº¯æ–‡æœ¬ï¼Œè½¬ä¹‰HTMLé˜²æ­¢XSS
            return `<span>${escapeHtml(finalClean)}</span>`;
        }

        // è¾…åŠ©å‡½æ•°ï¼šè½¬ä¹‰HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // è¾…åŠ©å‡½æ•°ï¼šç”Ÿæˆå›¾ç‰‡åŠ è½½å¤±è´¥çš„HTML
        function getImageErrorHandler() {
            return `onerror="this.onerror=null; this.style.cssText='width:80px; height:80px; display:flex; align-items:center; justify-content:center; background:#f5f5f5; border-radius:8px;'; this.outerHTML='<div style=\\'width:80px; height:80px; display:flex; align-items:center; justify-content:center; background:#f5f5f5; border-radius:8px; color:#999; font-size:11px; text-align:center;\\'>å›¾ç‰‡åŠ è½½å¤±è´¥</div>';"`;
        }

        // ç¾¤èŠå›¾ç‰‡å¡ç‰‡ç‚¹å‡»å±•å¼€ - ä½¿ç”¨ä¸ç§èŠç›¸åŒçš„æ ·å¼
        function showImageCardContent(el) {
            const text = el.dataset.text;
            if (!text) return;
            
            const isExpanded = el.dataset.expanded === 'true';
            
            if (isExpanded) {
                // æ”¶èµ·ï¼šæ˜¾ç¤ºå¡ç‰‡
                el.innerHTML = `
                    <div class="img-card-placeholder">
                        <svg class="img-card-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                            <circle cx="8.5" cy="8.5" r="1.5"></circle>
                            <polyline points="21 15 16 10 5 21"></polyline>
                        </svg>
                        <div class="img-card-hint">ç‚¹å‡»æŸ¥çœ‹æ–‡å­—</div>
                    </div>
                `;
                el.dataset.expanded = 'false';
            } else {
                // å±•å¼€ï¼šæ˜¾ç¤ºæ–‡å­—
                el.innerHTML = `<div class="img-card-text">${escapeHtml(text)}</div>`;
                el.dataset.expanded = 'true';
            }
        }

        // ç¾¤èŠè¯­éŸ³æ°”æ³¡ç‚¹å‡»æ’­æ”¾
        function playVoiceBubble(el) {
            const text = el.dataset.text;
            if (!text) return;
            
            // æ˜¾ç¤ºè¯­éŸ³å†…å®¹å¼¹çª—
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); display:flex; align-items:center; justify-content:center; z-index:10000;';
            modal.onclick = () => modal.remove();
            
            modal.innerHTML = `
                <div style="background:#fff; padding:20px 24px; border-radius:12px; max-width:85%; max-height:70%; overflow-y:auto;" onclick="event.stopPropagation()">
                    <div style="font-size:14px; color:#666; margin-bottom:12px; display:flex; align-items:center; gap:8px;">
                        <svg viewBox="0 0 24 24" style="width:18px; height:18px; fill:#999;"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z"/></svg>
                        è¯­éŸ³æ¶ˆæ¯å†…å®¹
                    </div>
                    <div style="font-size:16px; line-height:1.8; color:#333; white-space:pre-wrap;">${escapeHtml(text)}</div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }

        // æ˜¾ç¤ºå®Œæ•´å›¾ç‰‡
        function showFullImage(src) {
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); display:flex; align-items:center; justify-content:center; z-index:10000;';
            modal.onclick = () => modal.remove();
            
            modal.innerHTML = `<img src="${src}" style="max-width:95%; max-height:95%; object-fit:contain;" />`;
            
            document.body.appendChild(modal);
        }

        // æ ¼å¼åŒ–æ—¶é—´æˆ³
        function formatMessageTime(timestamp, prevTimestamp, timeOffset = 0) {
            if (!timestamp) return '';
            
            // ä½¿ç”¨è™šæ‹Ÿæ—¶é—´è¿›è¡Œè®¡ç®—
            const virtualTimestamp = timestamp + timeOffset;
            const virtualNow = Date.now() + timeOffset;
            
            const msgTime = new Date(virtualTimestamp);
            const now = new Date(virtualNow);
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const msgDate = new Date(msgTime.getFullYear(), msgTime.getMonth(), msgTime.getDate());
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);
            
            let timeStr = '';
            if (msgDate.getTime() === today.getTime()) {
                // ä»Šå¤©ï¼šæ˜¾ç¤ºæ—¶é—´
                timeStr = `${msgTime.getHours()}:${msgTime.getMinutes().toString().padStart(2, '0')}`;
            } else if (msgDate.getTime() === yesterday.getTime()) {
                // æ˜¨å¤©
                timeStr = `æ˜¨å¤© ${msgTime.getHours()}:${msgTime.getMinutes().toString().padStart(2, '0')}`;
            } else if (virtualNow - virtualTimestamp < 7 * 24 * 60 * 60 * 1000) {
                // ä¸€å‘¨å†…ï¼šæ˜¾ç¤ºæ˜ŸæœŸ
                const weekdays = ['å‘¨æ—¥', 'å‘¨ä¸€', 'å‘¨äºŒ', 'å‘¨ä¸‰', 'å‘¨å››', 'å‘¨äº”', 'å‘¨å…­'];
                timeStr = `${weekdays[msgTime.getDay()]} ${msgTime.getHours()}:${msgTime.getMinutes().toString().padStart(2, '0')}`;
            } else {
                // æ›´æ—©ï¼šæ˜¾ç¤ºæ—¥æœŸ
                timeStr = `${msgTime.getMonth() + 1}/${msgTime.getDate()} ${msgTime.getHours()}:${msgTime.getMinutes().toString().padStart(2, '0')}`;
            }
            
            return timeStr;
        }
        
        // åˆ¤æ–­æ˜¯å¦éœ€è¦æ˜¾ç¤ºæ—¶é—´æˆ³ï¼ˆä¸¤æ¡æ¶ˆæ¯é—´éš”è¶…è¿‡5åˆ†é’Ÿæ‰æ˜¾ç¤ºï¼‰
        function shouldShowTimestamp(currentTime, prevTime) {
            if (!prevTime) return true; // ç¬¬ä¸€æ¡æ¶ˆæ¯æ˜¾ç¤ºæ—¶é—´
            const diff = currentTime - prevTime;
            return diff > 5 * 60 * 1000; // è¶…è¿‡5åˆ†é’Ÿ
        }

        // æ„é€ æ¶ˆæ¯ DOM
        function createMessageElement(msg, index, charAvatar, userAvatar, prevMsgTime, charName = 'AI') {
            const row = document.createElement('div');
            
            // ğŸ¯ è§†é¢‘é€šè¯å†…å®¹ï¼šä¸åœ¨èŠå¤©é¡µé¢æ¸²æŸ“ï¼ˆä»…ä¿ç•™åœ¨å†å²è®°å½•ä¸­ä¾›AIè¯»å–ï¼‰
            // åªæ˜¾ç¤ºç³»ç»Ÿç±»çš„è§†é¢‘é€šè¯æ¶ˆæ¯ï¼ˆå·²æ¥é€š/å·²ç»“æŸï¼‰ï¼Œéšè—å®é™…å¯¹è¯å†…å®¹
            if (msg.isVideoCall && msg.role !== 'system') {
                row.style.display = 'none';
                return row;
            }
            
            // ğŸ¯ ç‰¹æ®Šå¤„ç†ï¼šç³»ç»Ÿæ¶ˆæ¯ï¼ˆå¦‚æˆ³ä¸€æˆ³ï¼‰
            if (msg.role === 'system') {
                row.className = 'message-system';
                row.style.cssText = 'text-align:center; padding:8px 16px; margin:8px 0;';
                row.innerHTML = `<span style="background:#fff; color:#999; font-size:12px; padding:4px 12px; border-radius:4px; border:1px solid #ddd;">${msg.content}</span>`;
                row.dataset.index = index;
                return row;
            }
            
            row.className = `message-row ${msg.role === 'user' ? 'self' : 'other'}`;
            row.dataset.index = index;

            // å¤é€‰æ¡† (å¤šé€‰æ¨¡å¼ç”¨)
            const checkbox = document.createElement('div');
            checkbox.className = 'msg-checkbox';
            row.appendChild(checkbox);

            // å¤´åƒ
            const avatar = document.createElement('div');
            avatar.className = 'message-avatar';
            
            if (msg.role === 'char') {
                if (charAvatar) avatar.style.backgroundImage = `url(${charAvatar})`;
                // ç»™è§’è‰²å¤´åƒæ·»åŠ ç‚¹å‡»å’ŒåŒå‡»äº‹ä»¶
                avatar.style.cursor = 'pointer';
                
                let clickCount = 0;
                let clickTimer = null;
                
                avatar.onclick = async (e) => {
                    e.stopPropagation(); // é˜»æ­¢å†’æ³¡ï¼Œé¿å…è§¦å‘æ¶ˆæ¯é€‰æ‹©
                    
                    clickCount++;
                    
                    if (clickCount === 1) {
                        // ç¬¬ä¸€æ¬¡ç‚¹å‡»ï¼Œç­‰å¾…350msåˆ¤æ–­æ˜¯å•å‡»è¿˜æ˜¯åŒå‡»
                        clickTimer = setTimeout(async () => {
                            // å•å‡»ï¼šæ˜¾ç¤ºå¿ƒå£°
                            await showCharacterThoughts(currentChatCharId, index);
                            clickCount = 0;
                        }, 350);
                    } else if (clickCount === 2) {
                        // åŒå‡»ï¼šæˆ³ä¸€æˆ³
                        clearTimeout(clickTimer);
                        showPokeModal(charName);
                        clickCount = 0;
                    }
                };
            } else {
                if (userAvatar) {
                    avatar.style.backgroundImage = `url(${userAvatar})`;
                } else {
                    avatar.style.backgroundColor = '#eee';
                }
            }

            // å†…å®¹æ°”æ³¡
            const content = document.createElement('div');
            content.className = msg.role === 'user' ? 'message-content user-bubble' : 'message-content ai-bubble';
            
            // æ£€æµ‹è½¬è´¦æ¶ˆæ¯ - æ”¯æŒ type='transfer' æˆ– content ä¸ºè½¬è´¦JSONæ ¼å¼
            let isTransferMsg = false;
            let transferData = {};
            
            if (msg.type === 'transfer') {
                isTransferMsg = true;
                try {
                    transferData = JSON.parse(msg.content);
                } catch(e) {
                    transferData = { amount: '0.00', desc: 'è§£æé”™è¯¯', status: 'sent' };
                }
            } else if (msg.content) {
                // å°è¯•è§£æä¸ºè½¬è´¦JSON - trimç©ºæ ¼åæ£€æŸ¥
                const trimmed = msg.content.trim();
                if (trimmed.startsWith('{') && trimmed.includes('"amount"') && !trimmed.startsWith('[')) {
                    try {
                        const parsed = JSON.parse(trimmed);
                        if (parsed.amount && parsed.desc !== undefined && parsed.status) {
                            isTransferMsg = true;
                            transferData = parsed;
                            // è¡¥å……IDï¼ˆå¦‚æœæ²¡æœ‰ï¼‰
                            if (!msg.id) msg.id = 'trans_' + msg.time;
                        }
                    } catch(e) {
                        // ä¸æ˜¯æœ‰æ•ˆçš„è½¬è´¦JSONï¼ŒæŒ‰æ™®é€šæ¶ˆæ¯å¤„ç†
                    }
                }
            }
            
            // å¤„ç†è½¬è´¦æ¶ˆæ¯
            if (isTransferMsg) {
                // å»é™¤é»˜è®¤èƒŒæ™¯å’Œpaddingï¼Œå®Œå…¨äº¤ç»™ transfer-card
                content.style.padding = '0';
                content.style.background = 'transparent';
                content.style.boxShadow = 'none';
                
                const isSelf = msg.role === 'user';
                const isDone = transferData.status === 'received';
                const isReturned = transferData.status === 'returned';
                
                let statusText = 'è½¬è´¦';
                if (isSelf) statusText = 'å·²å‘é€';
                if (isDone) statusText = 'å·²æ”¶æ¬¾';
                if (isReturned) statusText = 'å·²é€€å›';
                
                content.innerHTML = `
                    <div class="transfer-card ${isDone ? 'done' : ''} ${isReturned ? 'returned' : ''}" onclick="showTransferConfirm('${msg.id}', ${isSelf}, '${transferData.status}')">
                        <div class="t-amount">Â¥ ${transferData.amount}</div>
                        <div class="t-desc">${transferData.desc}</div>
                        <div class="t-line"></div>
                        <div class="t-footer">
                            <span class="t-footer-text">${statusText}</span>
                            <span class="t-dot"></span>
                        </div>
                    </div>
                `;
            }
            // âœ… å¤„ç†éŸ³é¢‘/è¯­éŸ³æ¶ˆæ¯ï¼ˆè”æœºå¥½å‹çœŸå®å½•éŸ³ï¼‰- ä½¿ç”¨æ™®é€šæ°”æ³¡æ ·å¼
            else if (msg.type === 'audio' && msg.content && msg.content.startsWith('data:audio')) {
                const duration = msg.duration || 0;
                const audioId = 'audio_' + (msg.time || Date.now());
                
                // ç®€å•æ˜¾ç¤ºè¯­éŸ³å›¾æ ‡å’Œæ—¶é•¿ï¼Œç‚¹å‡»æ’­æ”¾
                content.textContent = `ğŸ¤ ${duration}"`;
                content.style.cursor = 'pointer';
                content.dataset.audioId = audioId;
                content.onclick = function() { playOnlineAudio(this.dataset.audioId); };
                
                // æ·»åŠ éšè—çš„ audio å…ƒç´ åˆ°æ¶ˆæ¯è¡Œ
                setTimeout(() => {
                    const audioEl = document.createElement('audio');
                    audioEl.id = audioId;
                    audioEl.src = msg.content;
                    audioEl.style.display = 'none';
                    document.body.appendChild(audioEl);
                }, 0);
            }
            // å¤„ç†äº²å±å¡æ¶ˆæ¯
            else if (msg.type === 'familyCard') {
                content.style.padding = '0';
                content.style.background = 'transparent';
                content.style.boxShadow = 'none';
                
                let cardData = {};
                try {
                    cardData = JSON.parse(msg.content);
                } catch(e) {
                    cardData = { fromName: 'æœªçŸ¥', monthlyLimit: 0, status: 'sent' };
                }
                
                const isSelf = msg.role === 'user';
                const isOnline = cardData.isOnline || false;
                const limitText = cardData.monthlyLimit > 0 ? `æ¯æœˆé¢åº¦ Â¥${cardData.monthlyLimit}` : 'ä¸é™é¢åº¦';
                const cardType = isOnline ? 'ğŸ’ äº²å±å¡ (è”æœº)' : 'ğŸ’ äº²å±å¡';
                
                content.innerHTML = `
                    <div class="family-card-msg">
                        <div class="family-card-msg-title">${cardType}</div>
                        <div class="family-card-msg-desc">${limitText}</div>
                        <div class="family-card-msg-line"></div>
                        <div class="family-card-msg-footer">
                            <span class="family-card-msg-status">${isSelf ? 'å·²èµ é€' : 'å·²æ”¶åˆ°'}</span>
                            <span class="family-card-msg-dot"></span>
                        </div>
                    </div>
                `;
            }
            // å¤„ç†ä½ç½®æ¶ˆæ¯
            else if (msg.type === 'location') {
                content.style.padding = '0';
                content.style.background = 'transparent';
                content.style.boxShadow = 'none';
                
                let locationData = {};
                try {
                    locationData = JSON.parse(msg.content);
                } catch(e) {
                    locationData = { name: 'æœªçŸ¥ä½ç½®', address: '' };
                }
                
                content.innerHTML = `
                    <div class="location-card" onclick="showLocationDetail('${encodeURIComponent(locationData.name)}', '${encodeURIComponent(locationData.address)}')">
                        <div class="location-card-text">
                            <div class="location-card-name">${locationData.name}</div>
                            <div class="location-card-sub">ä½ç½®åˆ†äº«</div>
                        </div>
                        <div class="location-card-map">
                            <div class="location-card-pin">
                                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M12 11.5C11.1716 11.5 10.5 10.8284 10.5 10C10.5 9.17157 11.1716 8.5 12 8.5C12.8284 8.5 13.5 9.17157 13.5 10C13.5 10.8284 12.8284 11.5 12 11.5Z"></path>
                                    <path d="M12 2C7.92134 2 4.5 5.42134 4.5 9.5C4.5 14.5312 11.2188 21.4375 11.5938 21.8125C11.7954 22.014 12.2046 22.014 12.4062 21.8125C12.7812 21.4375 19.5 14.5312 19.5 9.5C19.5 5.42134 16.0787 2 12 2ZM12 12.5C10.6193 12.5 9.5 11.3807 9.5 10C9.5 8.61929 10.6193 7.5 12 7.5C13.3807 7.5 14.5 8.61929 14.5 10C14.5 11.3807 13.3807 12.5 12 12.5Z"></path>
                                </svg>
                            </div>
                        </div>
                    </div>
                `;
            }
            // å¤„ç†æ’¤å›æ¶ˆæ¯ï¼ˆå±…ä¸­ç³»ç»Ÿæç¤ºæ ·å¼ï¼Œç‚¹å‡»å¯æŸ¥çœ‹åŸå†…å®¹ï¼‰
            else if (msg.isRecalled) {
                const isUser = msg.role === 'user';
                const recallerName = isUser ? 'ä½ ' : charName;
                
                // æ”¹ä¸ºç³»ç»Ÿæç¤ºæ ·å¼ï¼šå±…ä¸­ç°è‰²æ–‡å­—
                row.className = 'message-row recalled-system-row';
                row.innerHTML = ''; // æ¸…ç©ºåŸæœ‰å†…å®¹
                
                const systemTip = document.createElement('div');
                systemTip.className = 'recalled-system-tip';
                systemTip.innerHTML = `"${recallerName}"æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯`;
                systemTip.style.cursor = 'pointer';
                
                // ç‚¹å‡»æŸ¥çœ‹æ’¤å›çš„å†…å®¹
                systemTip.onclick = (e) => {
                    e.stopPropagation();
                    if (msg.recalledContent) {
                        showRecalledContent(recallerName, msg.recalledContent);
                    } else {
                        showToast('åŸæ¶ˆæ¯å†…å®¹å·²ä¸å¯ç”¨');
                    }
                };
                
                row.appendChild(systemTip);
                return row; // ç›´æ¥è¿”å›ï¼Œä¸å†æ·»åŠ å¤´åƒå’Œæ°”æ³¡
            } 
            // å¤„ç†è¯­éŸ³æ¶ˆæ¯
            else if (msg.content.startsWith('[voice:')) {
                // ç›´æ¥æå–è¯­éŸ³æ–‡æœ¬ï¼Œä¸è¦ç”¨ sanitizeMessage
                let voiceText = msg.content.substring(7, msg.content.length - 1).trim();
                
                // æ£€æŸ¥è¯­éŸ³æ–‡æœ¬ä¸­æ˜¯å¦åŒ…å«å›¾ç‰‡é“¾æ¥
                const imgMatch = voiceText.match(/\[img:([^\]]+)\]/);
                let hasImage = false;
                let imgUrl = '';
                let cleanVoiceText = voiceText;
                
                if (imgMatch) {
                    hasImage = true;
                    imgUrl = imgMatch[1].trim(); // ç›´æ¥ä½¿ç”¨ï¼Œä¸è¦ç”¨ sanitizeMessage
                    // ä»è¯­éŸ³æ–‡æœ¬ä¸­ç§»é™¤å›¾ç‰‡æ ‡è®°
                    cleanVoiceText = voiceText.replace(/\[img:[^\]]+\]/g, '').trim();
                }
                
                const duration = Math.ceil(cleanVoiceText.length / 5); // æ¨¡æ‹Ÿæ—¶é•¿ï¼šæ¯5ä¸ªå­—1ç§’
                
                // åˆ›å»ºè¯­éŸ³æ°”æ³¡å®¹å™¨ï¼ˆä½¿ç”¨çº¯CSSæ³¢çº¹åŠ¨ç”»ï¼‰
                content.className = 'voice-bubble';
                let voiceHtml = `
                    <div class="voice-bubble-header">
                        <div class="voice-icon">
                            <i></i>
                            <i></i>
                            <i></i>
                        </div>
                        <div class="voice-duration">${duration}"</div>
                    </div>
                    <div class="voice-text-content">${escapeHtml(cleanVoiceText)}</div>
                `;
                
                // å¦‚æœåŒ…å«å›¾ç‰‡ï¼Œåœ¨è¯­éŸ³æ°”æ³¡ä¸‹æ–¹æ·»åŠ å›¾ç‰‡ï¼ˆä½¿ç”¨chat-imageç±»ï¼‰
                if (hasImage) {
                    voiceHtml += `<div style="margin-top:8px;"><img src="${imgUrl}" class="chat-image" ${getImageErrorHandler()} /></div>`;
                }
                
                content.innerHTML = voiceHtml;
                
                // ç‚¹å‡»å±•å¼€/æ”¶èµ·æ–‡å­—
                content.onclick = (e) => {
                    // å¦‚æœç‚¹å‡»çš„æ˜¯å›¾ç‰‡ï¼Œä¸è§¦å‘å±•å¼€/æ”¶èµ·
                    if (e.target.tagName === 'IMG') {
                        e.stopPropagation();
                        return;
                    }
                    e.stopPropagation();
                    content.classList.toggle('expanded');
                };
            }
            // å¤„ç†å›¾ç‰‡å¡ç‰‡æ¶ˆæ¯
            else if (msg.content.startsWith('[imgcard:')) {
                // ç›´æ¥æå–æ–¹æ‹¬å·å†…çš„å†…å®¹ï¼Œä¸è¦ç”¨ sanitizeMessageï¼ˆä¼šç ´åæ ¼å¼ï¼‰
                const cardText = msg.content.substring(9, msg.content.length - 1).trim();
                
                content.className = 'img-card-bubble';
                content.dataset.text = cardText; // å­˜å‚¨æ–‡å­—å†…å®¹
                content.dataset.expanded = 'false'; // åˆå§‹çŠ¶æ€ï¼šæœªå±•å¼€
                
                // é»˜è®¤æ˜¾ç¤ºå¡ç‰‡çŠ¶æ€
                content.innerHTML = `
                    <div class="img-card-placeholder">
                        <svg class="img-card-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                            <circle cx="8.5" cy="8.5" r="1.5"></circle>
                            <polyline points="21 15 16 10 5 21"></polyline>
                        </svg>
                        <div class="img-card-hint">ç‚¹å‡»æŸ¥çœ‹æ–‡å­—</div>
                    </div>
                `;
                
                // ç‚¹å‡»åˆ‡æ¢å±•å¼€/æ”¶èµ·
                content.onclick = (e) => {
                    e.stopPropagation();
                    const isExpanded = content.dataset.expanded === 'true';
                    
                    if (isExpanded) {
                        // æ”¶èµ·ï¼šæ˜¾ç¤ºå¡ç‰‡
                        content.innerHTML = `
                            <div class="img-card-placeholder">
                                <svg class="img-card-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                                    <circle cx="8.5" cy="8.5" r="1.5"></circle>
                                    <polyline points="21 15 16 10 5 21"></polyline>
                                </svg>
                                <div class="img-card-hint">ç‚¹å‡»æŸ¥çœ‹æ–‡å­—</div>
                            </div>
                        `;
                        content.dataset.expanded = 'false';
                    } else {
                        // å±•å¼€ï¼šæ˜¾ç¤ºæ–‡å­—
                        content.innerHTML = `<div class="img-card-text">${cardText}</div>`;
                        content.dataset.expanded = 'true';
                    }
                };
            }
            // ğŸ”§ å¤„ç†å¤–å–å¡ç‰‡æ¶ˆæ¯ & æƒ…å¤´é‚€è¯·å¡ç‰‡
            else if (msg.content.startsWith('[emei_order]') || msg.content.startsWith('[emei_share]') || msg.content.startsWith('[payment_request]') || msg.content.startsWith('[couple_avatar_card]')) {
                const cardHtml = msg.content.replace(/^\[(emei_order|emei_share|payment_request|couple_avatar_card)\]/, '');
                content.innerHTML = cardHtml;
                content.classList.add('card-message');
                content.style.padding = '0';
                content.style.background = 'transparent';
                content.style.boxShadow = 'none';
            }
            // å¤„ç†å›¾ç‰‡æ¶ˆæ¯ï¼ˆçº¯å›¾ç‰‡ï¼Œæˆ–ä»¥å›¾ç‰‡å¼€å¤´ï¼‰
            else if (msg.content.startsWith('[img:')) {
                // ç›´æ¥æå–URLï¼Œä¸è¦ç”¨ sanitizeMessage
                const imgUrl = msg.content.substring(5, msg.content.length - 1).trim();
                content.innerHTML = `<img src="${imgUrl}" class="chat-image" onerror="this.onerror=null; this.style.cssText='width:80px; height:80px; display:flex; align-items:center; justify-content:center; background:#f5f5f5; border-radius:8px;'; this.outerHTML='<div style=\\'width:80px; height:80px; display:flex; align-items:center; justify-content:center; background:#f5f5f5; border-radius:8px; color:#999; font-size:12px;\\'>å›¾ç‰‡åŠ è½½å¤±è´¥</div>';" />`;
                // ğŸ”§ æ·»åŠ  image-only ç±»ï¼Œç§»é™¤æ°”æ³¡æ ·å¼
                content.classList.add('image-only');
            }
            // ğŸ¯ å®‰å…¨ç½‘ï¼šå¤„ç†æœªè¢«æ›¿æ¢çš„ [sticker:] æ ‡ç­¾ï¼ˆé˜²æ­¢æ˜¾ç¤ºä¸ºåŸå§‹æ–‡æœ¬ï¼‰
            else if (msg.content.match(/^\[sticker:[^\]]+\]$/i)) {
                // [sticker:] æ²¡æœ‰è¢«è½¬ä¸º [img:]ï¼Œè¯´æ˜æ²¡æœ‰æŒ‚è½½è¡¨æƒ…åŒ…æˆ–åŒ¹é…å¤±è´¥
                // æ˜¾ç¤ºä¸ºä¸€ä¸ªå ä½æç¤ºè€Œä¸æ˜¯åŸå§‹æŒ‡ä»¤æ–‡æœ¬
                content.innerHTML = `<span style="color:#999; font-size:12px;">[è¡¨æƒ…]</span>`;
            }
            // âœ… æ™®é€šæ–‡æœ¬ - ä½¿ç”¨ç»Ÿä¸€çš„æ¸²æŸ“å‡½æ•°
            else {
                // å…ˆæ¸…ç†æ¶ˆæ¯å†…å®¹
                const cleanedContent = sanitizeMessage(msg.content);
                
                // æ£€æŸ¥æ˜¯å¦æœ‰å¼•ç”¨
                let quoteHtml = '';
                if (msg.quote) {
                    quoteHtml = `<div class="quoted-message" style="border-left:2px solid rgba(0,0,0,0.15); padding:2px 6px; margin-bottom:4px; font-size:11px; line-height:1.3; max-width:180px;"><div style="color:#666; font-weight:500; font-size:10px;">${escapeHtml(msg.quote.name)}</div><div style="color:#888; font-size:10px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:160px;">${escapeHtml(msg.quote.content)}</div></div>`;
                }
                
                // æ£€æŸ¥AIæ¶ˆæ¯æ˜¯å¦åŒ…å«å¤–è¯­+ä¸­æ–‡ç¿»è¯‘ç»„åˆ
                const translationParsed = msg.role === 'char' ? parseForeignWithTranslation(cleanedContent) : null;
                
                if (translationParsed) {
                    // æœ‰å¤–è¯­+ä¸­æ–‡ç»„åˆï¼Œé»˜è®¤æ˜¾ç¤ºå¤–è¯­ï¼Œç‚¹å‡»æ˜¾ç¤ºç¿»è¯‘
                    content.innerHTML = quoteHtml + renderMessageContent(translationParsed.foreign);
                    content.dataset.chinese = translationParsed.chinese;
                    content.dataset.expanded = 'false';
                    content.dataset.hasTranslation = 'true';
                    content.style.cursor = 'pointer';
                } else {
                    // æ™®é€šæ¶ˆæ¯ï¼Œä½¿ç”¨ç»Ÿä¸€çš„æ¸²æŸ“å‡½æ•°
                    content.innerHTML = quoteHtml + renderMessageContent(cleanedContent);
                }
            }

            // äº‹ä»¶ç»‘å®š
            if (!msg.isRecalled) { // å·²æ’¤å›æ¶ˆæ¯ä¸å¯æ“ä½œ
                bindMessageEvents(content, index);
                // æ•´ä¸ªè¡Œç‚¹å‡»äº‹ä»¶ (ç”¨äºå¤šé€‰)
                row.onclick = (e) => handleRowClick(index, e);
            }

            row.appendChild(avatar);
            row.appendChild(content);
            
            return row;
        }

        // ç¼“å­˜å˜é‡ï¼Œé¿å…ä¸å¿…è¦çš„é‡æ–°æ¸²æŸ“
        let lastRenderedCharId = null;
        let lastRenderedHistoryLength = 0;
        let lastRenderedAccountId = null;
        let currentRenderedCount = 0; // è·Ÿè¸ªå·²æ¸²æŸ“çš„æ¶ˆæ¯æ•°é‡
        let isLoadingMoreMessages = false; // é˜²æ­¢é‡å¤åŠ è½½

        // ğŸ¯ æ–°å¢ï¼šåªæ·»åŠ å•æ¡æ¶ˆæ¯ï¼Œä¸é‡æ–°æ¸²æŸ“æ•´ä¸ªèŠå¤©ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰
        async function appendChatMessage(char, msg, msgIndex) {
            const body = document.getElementById('chat-body');
            const accountId = getCurrentAccountId();
            const userAvatarUrl = await getUserAvatarUrl(char.linked_user_id);
            const timeOffset = char.timeOffset || 0;
            
            // è·å–å‰ä¸€æ¡æ¶ˆæ¯çš„æ—¶é—´
            const history = getChatHistory(char, accountId);
            const prevMsgTime = msgIndex > 0 && history[msgIndex - 1] ? history[msgIndex - 1].time : null;
            
            // å¦‚æœéœ€è¦æ˜¾ç¤ºæ—¶é—´æˆ³ï¼Œå…ˆæ·»åŠ æ—¶é—´æˆ³è¡Œï¼ˆç³»ç»Ÿæ¶ˆæ¯ä¸æ˜¾ç¤ºæ—¶é—´æˆ³ï¼‰
            if (msg.role !== 'system' && shouldShowTimestamp(msg.time, prevMsgTime)) {
                const timeStamp = document.createElement('div');
                timeStamp.className = 'message-timestamp';
                timeStamp.textContent = formatMessageTime(msg.time, prevMsgTime, timeOffset);
                body.appendChild(timeStamp);
            }
            
            const row = createMessageElement(msg, msgIndex, char.avatar, userAvatarUrl, prevMsgTime, char.name);
            body.appendChild(row);
            
            // æ›´æ–°ç¼“å­˜è®¡æ•°
            lastRenderedHistoryLength = history.length;
            currentRenderedCount++; // æ›´æ–°å·²æ¸²æŸ“è®¡æ•°
            
            // æ»šåŠ¨åˆ°åº•éƒ¨
            setTimeout(() => {
                body.scrollTop = body.scrollHeight;
            }, 0);
            
            console.log('[appendChatMessage] æ·»åŠ å•æ¡æ¶ˆæ¯ï¼Œæ— éœ€é‡æ–°æ¸²æŸ“');
        }

        async function renderChatBody(char, forceRender = false) {
            const body = document.getElementById('chat-body');
            const accountId = getCurrentAccountId();
            const history = getChatHistory(char, accountId);
            
            // ğŸ¯ ä¼˜åŒ–ï¼šå¦‚æœæ˜¯åŒä¸€ä¸ªè§’è‰²ä¸”æ¶ˆæ¯æ²¡æœ‰å˜åŒ–ï¼Œè·³è¿‡æ¸²æŸ“
            if (!forceRender && 
                lastRenderedCharId === char.id && 
                lastRenderedAccountId === accountId &&
                lastRenderedHistoryLength === (history?.length || 0) &&
                !isSelectionMode) {
                console.log('[renderChatBody] è·³è¿‡é‡å¤æ¸²æŸ“');
                return;
            }
            
            lastRenderedCharId = char.id;
            lastRenderedAccountId = accountId;
            lastRenderedHistoryLength = history?.length || 0;
            
            body.innerHTML = '';
            currentRenderedCount = 0; // é‡ç½®æ¸²æŸ“è®¡æ•°
            
            // åˆ‡æ¢å¤šé€‰æ¨¡å¼æ ·å¼
            if (isSelectionMode) {
                body.classList.add('selection-mode');
            } else {
                body.classList.remove('selection-mode');
            }
            
            // âœ… è”æœºå¥½å‹è‡ªåŠ¨è§†ä¸ºå¥½å‹çŠ¶æ€
            if (char.isOnlineFriend === true && accountId) {
                const currentStatus = getFriendStatus(char, accountId);
                if (currentStatus !== 'friend') {
                    // è‡ªåŠ¨ä¿®æ­£å¥½å‹çŠ¶æ€
                    if (!char.wechat_status_by_user) char.wechat_status_by_user = {};
                    char.wechat_status_by_user[accountId] = 'friend';
                    // å¼‚æ­¥ä¿å­˜ï¼Œä¸é˜»å¡æ¸²æŸ“
                    db.characters.put(char).catch(e => console.error('ä¿å­˜è”æœºå¥½å‹çŠ¶æ€å¤±è´¥:', e));
                }
            }
            
            // æ£€æŸ¥å¥½å‹çŠ¶æ€
            const friendStatus = getFriendStatus(char, accountId);
            if (friendStatus === 'blocked') {
                // è¢«æ‹‰é»‘çŠ¶æ€ï¼Œæ˜¾ç¤ºé¢æ¿ï¼ˆä¸åˆ é™¤ç±»ä¼¼ï¼Œä½†æç¤ºå’ŒåŠŸèƒ½ä¸åŒï¼‰
                body.innerHTML = `
                    <div style="display:flex; flex-direction:column; height:100%; padding:20px;">
                        <div style="text-align:center; padding:20px 0; border-bottom:1px solid #f0f0f0;">
                            <div style="width:60px; height:60px; border-radius:8px; background-image:url(${char.avatar}); background-size:cover; background-position:center; margin:0 auto 12px;"></div>
                            <div style="font-size:16px; font-weight:600; margin-bottom:6px; color:#333;">${char.name}</div>
                            <div style="font-size:13px; color:#999;">ä½ å·²æ‹‰é»‘è¯¥å¥½å‹</div>
                        </div>
                        
                        <div style="flex:1; overflow-y:auto; padding:16px 0;">
                            <div style="background:#fff3cd; border-radius:8px; padding:16px; margin-bottom:16px; border:1px solid #ffc107;">
                                <div style="font-size:14px; font-weight:600; margin-bottom:12px; color:#856404;">âš ï¸ æ‹‰é»‘æç¤º</div>
                                <div style="font-size:12px; color:#856404; line-height:1.6;">
                                    æ‹‰é»‘åï¼Œè¯¥è§’è‰²æ— æ³•å‘é€å¥½å‹ç”³è¯·æˆ–å¾®ä¿¡æ¶ˆæ¯ã€‚ä½†åœ¨å¿«è¿›æ—¶é—´æ—¶ï¼Œç³»ç»Ÿä¼šæ ¹æ®è§’è‰²æ€§æ ¼åˆ¤æ–­æ˜¯å¦ä¼šå°è¯•é€šè¿‡ç”µè¯æˆ–çŸ­ä¿¡è”ç³»ä½ ã€‚
                                </div>
                            </div>
                            
                            <div style="background:#f9f9f9; border-radius:8px; padding:16px; margin-bottom:16px;">
                                <div style="font-size:14px; font-weight:600; margin-bottom:12px; color:#333;">ğŸ“± è”ç³»è®°å½•</div>
                                <div style="font-size:12px; color:#666; line-height:1.6; margin-bottom:12px;">
                                    å¿«è¿›æ—¶é—´åï¼Œç”Ÿæˆçš„ç”µè¯å’ŒçŸ­ä¿¡è®°å½•å°†å‡ºç°åœ¨æ¡Œé¢çš„ã€Œç”µè¯ã€å’Œã€Œä¿¡æ¯ã€åº”ç”¨ä¸­ï¼Œè€Œä¸ä¼šç›´æ¥æ˜¾ç¤ºåœ¨è¿™é‡Œã€‚
                                </div>
                            </div>
                            
                            <button onclick="fastForwardBlockedCheck(${char.id})" style="width:100%; padding:12px; background:var(--ins-pink); color:#fff; border:none; border-radius:8px; font-size:14px; font-weight:600; margin-bottom:12px;">
                                â© å¿«è¿›æ—¶é—´
                            </button>
                            
                            <button onclick="unblockFriend(${char.id})" style="width:100%; padding:12px; background:#fff; border:1px solid #8e8e93; color:#333; border-radius:8px; font-size:14px; font-weight:600;">
                                è§£é™¤æ‹‰é»‘
                            </button>
                        </div>
                    </div>
                `;
                return;
            } else if (friendStatus === 'deleted') {
                // å·²åˆ é™¤å¥½å‹ï¼Œæ˜¾ç¤ºç­‰å¾…å¥½å‹ç”³è¯·ç•Œé¢
                const settings = char.wait_friend_settings?.[accountId] || {
                    enabled: false,
                    interval: 60,
                    lastCheckTime: Date.now(),
                    nextCheckTime: null
                };
                
                const nextCheckText = settings.enabled && settings.nextCheckTime ? 
                    `ä¸‹æ¬¡æ£€æµ‹: ${new Date(settings.nextCheckTime).toLocaleTimeString()}` : 'æœªå¯ç”¨';
                
                body.innerHTML = `
                    <div style="display:flex; flex-direction:column; height:100%; padding:20px;">
                        <div style="text-align:center; padding:20px 0; border-bottom:1px solid #f0f0f0;">
                            <div style="width:60px; height:60px; border-radius:8px; background-image:url(${char.avatar}); background-size:cover; background-position:center; margin:0 auto 12px;"></div>
                            <div style="font-size:16px; font-weight:600; margin-bottom:6px; color:#333;">${char.name}</div>
                            <div style="font-size:13px; color:#999;">ä½ å·²åˆ é™¤è¯¥å¥½å‹</div>
                        </div>
                        
                        <div style="flex:1; overflow-y:auto; padding:16px 0;">
                            <div style="background:#f9f9f9; border-radius:8px; padding:16px; margin-bottom:16px;">
                                <div style="font-size:14px; font-weight:600; margin-bottom:12px; color:#333;">â° ç­‰å¾…å¥½å‹ç”³è¯·</div>
                                <div style="font-size:12px; color:#666; line-height:1.6; margin-bottom:12px;">
                                    å¯ä»¥è®¾ç½®å®šæ—¶æ£€æµ‹ï¼ŒAIå°†æ ¹æ®è§’è‰²æ€§æ ¼å’Œä½ ä»¬çš„èŠå¤©å†å²ï¼Œå†³å®šæ˜¯å¦ä¸»åŠ¨å‘é€å¥½å‹ç”³è¯·ã€‚
                                </div>
                                
                                <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:12px; padding:8px 0;">
                                    <div style="font-size:13px; color:#333;">å¯ç”¨è‡ªåŠ¨æ£€æµ‹</div>
                                    <label class="ios-switch" style="transform:scale(0.8);">
                                        <input type="checkbox" id="wait-friend-enabled" ${settings.enabled ? 'checked' : ''} onchange="toggleWaitFriendCheck(${char.id})">
                                        <span class="slider"></span>
                                    </label>
                                </div>
                                
                                <div style="display:flex; align-items:center; margin-bottom:8px;">
                                    <div style="font-size:13px; color:#333; margin-right:12px;">æ£€æµ‹é—´éš”</div>
                                    <input type="number" id="wait-friend-interval" value="${settings.interval}" min="1" max="1440" 
                                           style="flex:1; padding:6px 10px; border:1px solid #ddd; border-radius:4px; font-size:13px;" 
                                           onchange="saveWaitFriendInterval(${char.id})">
                                    <div style="font-size:13px; color:#666; margin-left:8px;">åˆ†é’Ÿ</div>
                                </div>
                                
                                <div style="font-size:12px; color:#999; margin-top:8px;">${nextCheckText}</div>
                            </div>
                            
                            <button onclick="fastForwardCheck(${char.id})" style="width:100%; padding:12px; background:#fff; border:1px solid var(--ins-pink); color:var(--ins-pink); border-radius:8px; font-size:14px; font-weight:600; margin-bottom:12px;">
                                â© å¿«è¿›æ£€æµ‹
                            </button>
                            
                            <button onclick="manualSendFriendRequest(${char.id})" style="width:100%; padding:12px; background:var(--ins-pink); color:#fff; border:none; border-radius:8px; font-size:14px; font-weight:600;">
                                ä¸»åŠ¨å‘é€å¥½å‹ç”³è¯·
                            </button>
                        </div>
                    </div>
                `;
                return;
            } else if (friendStatus === 'deleted_by_char') {
                // è¢«è§’è‰²åˆ é™¤ï¼šæ˜¾ç¤ºèŠå¤©è®°å½• + åº•éƒ¨é¢æ¿ï¼ˆå‘é€å¥½å‹ç”³è¯· / å¿«è¿›æ—¶é—´ï¼‰
                // ä¸ returnï¼Œç»§ç»­æ¸²æŸ“èŠå¤©è®°å½•
            } else if (friendStatus === 'blocked_by_char') {
                // è¢«è§’è‰²æ‹‰é»‘ï¼šæ˜¾ç¤ºèŠå¤©è®°å½• + åº•éƒ¨é¢æ¿ï¼ˆçŸ­ä¿¡è”ç³» / å¿«è¿›æ—¶é—´ï¼‰
                // ä¸ returnï¼Œç»§ç»­æ¸²æŸ“èŠå¤©è®°å½•
            } else if (friendStatus === 'stranger') {
                // é™Œç”Ÿäººï¼Œæ˜¾ç¤ºå‘é€å¥½å‹ç”³è¯·ç•Œé¢
                body.innerHTML = `
                    <div style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:100%; padding:40px 20px; text-align:center;">
                        <div style="width:80px; height:80px; border-radius:8px; background-image:url(${char.avatar}); background-size:cover; background-position:center; margin-bottom:20px;"></div>
                        <div style="font-size:18px; font-weight:600; margin-bottom:10px; color:#333;">${char.name}</div>
                        <div style="font-size:14px; color:#999; margin-bottom:30px;">ä½ è¿˜ä¸æ˜¯å¯¹æ–¹çš„å¥½å‹ï¼Œæ— æ³•å‘é€æ¶ˆæ¯</div>
                        <button onclick="showAddFriendToCurrentChat()" style="background:var(--ins-pink); color:#fff; border:none; padding:12px 40px; border-radius:8px; font-size:16px; font-weight:600;">å‘é€å¥½å‹ç”³è¯·</button>
                    </div>
                `;
                return;
            } else if (friendStatus !== 'friend' && friendStatus !== 'deleted_by_char' && friendStatus !== 'blocked_by_char') {
                // å…¶ä»–çŠ¶æ€ï¼Œæ˜¾ç¤ºé»˜è®¤æç¤º
                body.innerHTML = `
                    <div style="display:flex; align-items:center; justify-content:center; height:100%; padding:40px 20px; text-align:center;">
                        <div style="font-size:14px; color:#999;">æ— æ³•å‘é€æ¶ˆæ¯</div>
                    </div>
                `;
                return;
            }
            
            if (!history || history.length === 0) return;

            // åº”ç”¨æ°”æ³¡æ ·å¼ç±»å
            body.classList.remove('bubble-style-default', 'bubble-style-wechat');
            if (char.bubble_style === 'wechat') {
                body.classList.add('bubble-style-wechat');
            } else {
                body.classList.add('bubble-style-default');
            }

            const userAvatarUrl = await getUserAvatarUrl(char.linked_user_id);
            const timeOffset = char.timeOffset || 0; // è·å–è™šæ‹Ÿæ—¶é—´åç§»

            // ğŸš€ ä¼˜åŒ–ï¼šåªæ¸²æŸ“æœ€è¿‘çš„50æ¡æ¶ˆæ¯
            const renderWindow = 50;
            const totalMessages = history.length;
            const startIndex = Math.max(0, totalMessages - renderWindow);
            const messagesToRender = history.slice(startIndex);
            currentRenderedCount = messagesToRender.length;

            // å¦‚æœè¿˜æœ‰æ›´å¤šæ¶ˆæ¯ï¼Œæ·»åŠ "åŠ è½½æ›´å¤š"æŒ‰é’®
            if (startIndex > 0) {
                const loadMoreBtn = document.createElement('div');
                loadMoreBtn.id = 'load-more-btn';
                loadMoreBtn.style.cssText = 'text-align:center; padding:12px; margin:8px 0;';
                loadMoreBtn.innerHTML = `<button onclick="loadMoreMessages()" style="background:#f0f0f0; border:none; padding:8px 20px; border-radius:16px; color:#666; font-size:13px; cursor:pointer;">åŠ è½½æ›´æ—©çš„æ¶ˆæ¯ (${startIndex}æ¡)</button>`;
                body.appendChild(loadMoreBtn);
            }

            messagesToRender.forEach((msg, relativeIndex) => {
                const absoluteIndex = startIndex + relativeIndex;
                const prevMsgTime = absoluteIndex > 0 ? history[absoluteIndex - 1].time : null;
                
                // å¦‚æœéœ€è¦æ˜¾ç¤ºæ—¶é—´æˆ³ï¼Œå…ˆæ·»åŠ æ—¶é—´æˆ³è¡Œï¼ˆç³»ç»Ÿæ¶ˆæ¯ä¸æ˜¾ç¤ºæ—¶é—´æˆ³ï¼‰
                if (msg.role !== 'system' && shouldShowTimestamp(msg.time, prevMsgTime)) {
                    const timeStamp = document.createElement('div');
                    timeStamp.className = 'message-timestamp';
                    timeStamp.textContent = formatMessageTime(msg.time, prevMsgTime, timeOffset);
                    body.appendChild(timeStamp);
                }
                
                const row = createMessageElement(msg, absoluteIndex, char.avatar, userAvatarUrl, prevMsgTime, char.name);
                
                // å¦‚æœåœ¨å¤šé€‰æ¨¡å¼ï¼Œæ¢å¤é€‰ä¸­çŠ¶æ€ï¼ˆç³»ç»Ÿæ¶ˆæ¯é™¤å¤–ï¼‰
                if (isSelectionMode && msg.role !== 'system') {
                    const cb = row.querySelector('.msg-checkbox');
                    if (cb && selectedIndices.has(absoluteIndex)) {
                        cb.classList.add('checked');
                    }
                }
                
                body.appendChild(row);
            });
            
            // å¦‚æœæ˜¯è¢«æ‹‰é»‘çŠ¶æ€ï¼Œä¸éœ€è¦åœ¨åº•éƒ¨æ·»åŠ ç”µè¯è®°å½•åŒºåŸŸï¼Œå› ä¸ºå·²ç»æ”¹åˆ°æ¡Œé¢åº”ç”¨äº†
            /*
            if (friendStatus === 'blocked') {
                const callSection = document.createElement('div');
                callSection.style.cssText = 'padding:16px; background:#f9f9f9; border-top:1px solid #f0f0f0; margin-top:20px;';
                callSection.innerHTML = `
                    <div style="font-size:14px; font-weight:600; margin-bottom:12px; color:#333;">ğŸ“ ç”µè¯è®°å½•</div>
                    <div id="blocked-calls-list" style="font-size:12px; color:#666;">
                        <!-- åŠ¨æ€ç”Ÿæˆç”µè¯è®°å½• -->
                    </div>
                `;
                body.appendChild(callSection);
                loadBlockedCallRecords(char.id, accountId);
            }
            */
            
            // ğŸ¯ è¢«è§’è‰²åˆ é™¤ï¼šæ˜¾ç¤ºèŠå¤©è®°å½•åçš„æ“ä½œé¢æ¿
            if (friendStatus === 'deleted_by_char') {
                const panel = document.createElement('div');
                panel.style.cssText = 'padding:16px; margin-top:20px;';
                panel.innerHTML = `
                    <div style="background:#fff3cd; border-radius:12px; padding:16px; margin-bottom:12px; border:1px solid #ffc107;">
                        <div style="font-size:14px; font-weight:600; margin-bottom:8px; color:#856404;">ğŸ˜¢ å¯¹æ–¹å·²å°†ä½ åˆ é™¤å¥½å‹</div>
                        <div style="font-size:12px; color:#856404; line-height:1.6;">
                            ${char.name} æŠŠä½ åˆ é™¤äº†å¥½å‹å…³ç³»ã€‚ä½ å¯ä»¥å°è¯•é‡æ–°å‘é€å¥½å‹ç”³è¯·ï¼Œæˆ–è€…å¿«è¿›æ—¶é—´ç­‰ Ta ä¸»åŠ¨åŠ ä½ å›æ¥ã€‚
                        </div>
                    </div>
                    
                    <button onclick="sendFriendRequestAfterCharDelete(${char.id})" style="width:100%; padding:12px; background:var(--ins-pink); color:#fff; border:none; border-radius:8px; font-size:14px; font-weight:600; margin-bottom:10px;">
                        ğŸ“© å‘é€å¥½å‹ç”³è¯·
                    </button>
                    
                    <button onclick="fastForwardDeletedByChar(${char.id})" style="width:100%; padding:12px; background:#fff; border:1px solid var(--ins-pink); color:var(--ins-pink); border-radius:8px; font-size:14px; font-weight:600;">
                        â© å¿«è¿›æ—¶é—´ï¼ˆTaå¯èƒ½ä¼šåŠ ä½ å›æ¥ï¼‰
                    </button>
                `;
                body.appendChild(panel);
            }
            
            // ğŸ¯ è¢«è§’è‰²æ‹‰é»‘ï¼šæ˜¾ç¤ºèŠå¤©è®°å½•åçš„æ“ä½œé¢æ¿
            if (friendStatus === 'blocked_by_char') {
                const panel = document.createElement('div');
                panel.style.cssText = 'padding:16px; margin-top:20px;';
                panel.innerHTML = `
                    <div style="background:#f8d7da; border-radius:12px; padding:16px; margin-bottom:12px; border:1px solid #f5c6cb;">
                        <div style="font-size:14px; font-weight:600; margin-bottom:8px; color:#721c24;">ğŸš« å¯¹æ–¹å·²å°†ä½ æ‹‰é»‘</div>
                        <div style="font-size:12px; color:#721c24; line-height:1.6;">
                            ${char.name} æŠŠä½ æ‹‰é»‘äº†ã€‚ä½ æ— æ³•å‘é€å¥½å‹ç”³è¯·ï¼Œä½†å¯ä»¥é€šè¿‡çŸ­ä¿¡è”ç³» Taï¼Œæˆ–è€…å¿«è¿›æ—¶é—´ç­‰ Ta è‡ªå·±æ¶ˆæ°”åæ”¾ä½ å‡ºæ¥ã€‚
                        </div>
                    </div>
                    
                    <button onclick="sendSmsToBlockedChar(${char.id})" style="width:100%; padding:12px; background:#007AFF; color:#fff; border:none; border-radius:8px; font-size:14px; font-weight:600; margin-bottom:10px;">
                        ğŸ’¬ é€šè¿‡çŸ­ä¿¡è”ç³» Ta
                    </button>
                    
                    <button onclick="fastForwardBlockedByChar(${char.id})" style="width:100%; padding:12px; background:#fff; border:1px solid #007AFF; color:#007AFF; border-radius:8px; font-size:14px; font-weight:600;">
                        â© å¿«è¿›æ—¶é—´ï¼ˆTaå¯èƒ½ä¼šæ”¾ä½ å‡ºæ¥ï¼‰
                    </button>
                `;
                body.appendChild(panel);
            }
            
            // æ»šåŠ¨åˆ°åº•éƒ¨ (å¦‚æœåœ¨å¤šé€‰æ¨¡å¼ï¼Œå¯èƒ½ä¸éœ€è¦æ»šåˆ°åº•éƒ¨ï¼Ÿè¿™é‡Œæš‚ä¸”ä¿æŒæ»šåŠ¨)
            if (!isSelectionMode) {
                setTimeout(() => {
                    body.scrollTop = body.scrollHeight;
                }, 0);
            }
            
            // åº”ç”¨è‡ªå®šä¹‰æ ·å¼
            applyCustomStyles(char);
            
            // åº”ç”¨èŠå¤©èƒŒæ™¯å›¾
            applyChatBackground(char);
        }

        // ğŸš€ åŠ è½½æ›´å¤šæ¶ˆæ¯ï¼ˆæ‡’åŠ è½½ä¼˜åŒ–ï¼‰
        async function loadMoreMessages() {
            if (isLoadingMoreMessages) return;
            if (!currentChatCharId) return;
            
            isLoadingMoreMessages = true;
            
            const char = await db.characters.get(currentChatCharId);
            const accountId = getCurrentAccountId();
            const history = getChatHistory(char, accountId);
            const body = document.getElementById('chat-body');
            
            // è®¡ç®—è¦åŠ è½½çš„æ¶ˆæ¯èŒƒå›´
            const renderWindow = 50;
            const totalMessages = history.length;
            const nextSliceStart = totalMessages - currentRenderedCount - renderWindow;
            const nextSliceEnd = totalMessages - currentRenderedCount;
            
            if (nextSliceStart < 0 || nextSliceEnd <= 0) {
                isLoadingMoreMessages = false;
                return;
            }
            
            const messagesToPrepend = history.slice(Math.max(0, nextSliceStart), nextSliceEnd);
            
            if (messagesToPrepend.length === 0) {
                isLoadingMoreMessages = false;
                return;
            }
            
            // ä¿å­˜å½“å‰æ»šåŠ¨ä½ç½®
            const oldScrollHeight = body.scrollHeight;
            
            // ç§»é™¤æ—§çš„"åŠ è½½æ›´å¤š"æŒ‰é’®
            const oldLoadMoreBtn = document.getElementById('load-more-btn');
            if (oldLoadMoreBtn) {
                oldLoadMoreBtn.remove();
            }
            
            // å¦‚æœè¿˜æœ‰æ›´å¤šæ¶ˆæ¯ï¼Œæ·»åŠ æ–°çš„"åŠ è½½æ›´å¤š"æŒ‰é’®
            const newStartIndex = Math.max(0, nextSliceStart);
            if (newStartIndex > 0) {
                const loadMoreBtn = document.createElement('div');
                loadMoreBtn.id = 'load-more-btn';
                loadMoreBtn.style.cssText = 'text-align:center; padding:12px; margin:8px 0;';
                loadMoreBtn.innerHTML = `<button onclick="loadMoreMessages()" style="background:#f0f0f0; border:none; padding:8px 20px; border-radius:16px; color:#666; font-size:13px; cursor:pointer;">åŠ è½½æ›´æ—©çš„æ¶ˆæ¯ (${newStartIndex}æ¡)</button>`;
                body.insertBefore(loadMoreBtn, body.firstChild);
            }
            
            // å‡†å¤‡è¦æ·»åŠ çš„æ¶ˆæ¯å…ƒç´ 
            const userAvatarUrl = await getUserAvatarUrl(char.linked_user_id);
            const timeOffset = char.timeOffset || 0;
            const fragment = document.createDocumentFragment();
            
            messagesToPrepend.forEach((msg, relativeIndex) => {
                const absoluteIndex = newStartIndex + relativeIndex;
                const prevMsgTime = absoluteIndex > 0 ? history[absoluteIndex - 1].time : null;
                
                // æ·»åŠ æ—¶é—´æˆ³
                if (msg.role !== 'system' && shouldShowTimestamp(msg.time, prevMsgTime)) {
                    const timeStamp = document.createElement('div');
                    timeStamp.className = 'message-timestamp';
                    timeStamp.textContent = formatMessageTime(msg.time, prevMsgTime, timeOffset);
                    fragment.appendChild(timeStamp);
                }
                
                const row = createMessageElement(msg, absoluteIndex, char.avatar, userAvatarUrl, prevMsgTime, char.name);
                fragment.appendChild(row);
            });
            
            // æ’å…¥æ¶ˆæ¯åˆ°é¡¶éƒ¨
            const firstMessage = body.querySelector('.message-row, .message-system');
            if (firstMessage) {
                body.insertBefore(fragment, firstMessage);
            } else {
                body.appendChild(fragment);
            }
            
            // æ¢å¤æ»šåŠ¨ä½ç½®
            const newScrollHeight = body.scrollHeight;
            body.scrollTop = newScrollHeight - oldScrollHeight;
            
            // æ›´æ–°å·²æ¸²æŸ“è®¡æ•°
            currentRenderedCount += messagesToPrepend.length;
            
            isLoadingMoreMessages = false;
            console.log(`[loadMoreMessages] åŠ è½½äº† ${messagesToPrepend.length} æ¡æ¶ˆæ¯ï¼Œæ€»è®¡å·²æ¸²æŸ“ ${currentRenderedCount} æ¡`);
        }
        
        // æš´éœ²åˆ°å…¨å±€ä½œç”¨åŸŸï¼Œä¾› HTML onclick ä½¿ç”¨
        window.loadMoreMessages = loadMoreMessages;

        // è¿½åŠ å•æ¡æ¶ˆæ¯ (ä¸»è¦ç”¨äº AI å›å¤æ—¶çš„æµå¼è¾“å‡ºï¼Œä¸é‡ç»˜æ•´ä¸ªåˆ—è¡¨)
        // æ³¨æ„ï¼šè¿½åŠ çš„æ¶ˆæ¯éœ€è¦é‡æ–°ç»‘å®šäº‹ä»¶ï¼Œä¸”æ­¤æ—¶é€šå¸¸ä¸åœ¨å¤šé€‰æ¨¡å¼
        async function appendMessageToUI(role, content, charAvatar, elemId) {
            const body = document.getElementById('chat-body');
            
            // ç³»ç»Ÿæ¶ˆæ¯ç‰¹æ®Šå¤„ç†
            if (role === 'system') {
                const sysDiv = document.createElement('div');
                sysDiv.style.cssText = 'text-align:center; padding:8px 16px; margin:8px 0;';
                sysDiv.innerHTML = `<span style="background:#fff; color:#999; font-size:12px; padding:4px 12px; border-radius:4px; border:1px solid #ddd;">${content}</span>`;
                body.appendChild(sysDiv);
                body.scrollTop = body.scrollHeight;
                return;
            }
            
            // è·å–æ•°æ®åº“ä¸­çš„å®é™…æ¶ˆæ¯ï¼ˆç¡®ä¿ ID å’Œæ—¶é—´æˆ³ä¸€è‡´ï¼‰
            const char = await db.characters.get(currentChatCharId);
            const accountId = getCurrentAccountId();
            const history = getChatHistory(char, accountId);
            
            // ğŸ”§ ä¿®å¤ï¼šä»åå¾€å‰æ‰¾åˆ°åŒ¹é… role çš„æœ€æ–°æ¶ˆæ¯ï¼Œè€Œä¸æ˜¯ç®€å•å–æœ€åä¸€æ¡
            // å› ä¸ºæœ€åä¸€æ¡å¯èƒ½æ˜¯ system æ¶ˆæ¯ï¼ˆå¦‚æ—¶é—´æˆ³ï¼‰
            let msg = null;
            let index = history.length - 1;
            for (let i = history.length - 1; i >= 0; i--) {
                if (history[i].role === role) {
                    msg = history[i];
                    index = i;
                    break;
                }
            }
            
            // å¦‚æœæ•°æ®åº“ä¸­æ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„æ¶ˆæ¯ï¼Œä½¿ç”¨ä¸´æ—¶å¯¹è±¡
            if (!msg) {
                const cleanedContent = sanitizeMessage(content);
                msg = { role, content: cleanedContent, time: Date.now() };
                index = history.length;
            }
            
            const userAvatarUrl = await getUserAvatarUrl(char.linked_user_id);
            const timeOffset = char.timeOffset || 0; // è·å–è™šæ‹Ÿæ—¶é—´åç§»
            
            // è·å–å‰ä¸€æ¡æ¶ˆæ¯çš„æ—¶é—´
            const prevMsgTime = index > 0 && history[index - 1] ? history[index - 1].time : null;
            
            // å¦‚æœéœ€è¦æ˜¾ç¤ºæ—¶é—´æˆ³ï¼Œå…ˆæ·»åŠ æ—¶é—´æˆ³è¡Œ
            if (shouldShowTimestamp(msg.time, prevMsgTime)) {
                const timeStamp = document.createElement('div');
                timeStamp.className = 'message-timestamp';
                timeStamp.textContent = formatMessageTime(msg.time, prevMsgTime, timeOffset);
                body.appendChild(timeStamp);
            }

            const row = createMessageElement(msg, index, charAvatar, userAvatarUrl, prevMsgTime, char ? char.name : 'AI');
            if (elemId) row.id = elemId;
            
            body.appendChild(row);
            body.scrollTop = body.scrollHeight;
        }

        // --- æ ¸å¿ƒäº¤äº’ï¼šé•¿æŒ‰ä¸èœå• ---
        function bindMessageEvents(element, index) {
            let touchMoved = false;
            let touchStartEvent = null;
            
            const startHandler = (e) => {
                if (isSelectionMode) return; // å¤šé€‰æ¨¡å¼ä¸‹ç¦ç”¨é•¿æŒ‰
                isLongPress = false;
                touchMoved = false;
                touchStartEvent = e;
                longPressTimer = setTimeout(() => {
                    isLongPress = true;
                    // é•¿æŒ‰è§¦å‘æ—¶é˜»æ­¢æµè§ˆå™¨åç»­é»˜è®¤è¡Œä¸ºï¼ˆå¦‚æ–‡å­—é€‰æ‹©èœå•ï¼‰
                    try { 
                        if (touchStartEvent && touchStartEvent.cancelable) {
                            touchStartEvent.preventDefault();
                        }
                    } catch(ex) {}
                    showContextMenu(e, index, element);
                }, 500); // 500ms é•¿æŒ‰è§¦å‘
            };

            const cancelHandler = () => {
                touchMoved = true;
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            };
            
            const endHandler = (e) => {
                cancelHandler();
                touchStartEvent = null;
                if (isLongPress) {
                    e.preventDefault(); // é˜»æ­¢é»˜è®¤ç‚¹å‡»
                    e.stopPropagation();
                    return;
                }
                
                // çŸ­æŒ‰ä¸”æ²¡æœ‰æ»‘åŠ¨ â†’ å½“ä½œç‚¹å‡»å¤„ç†
                if (!touchMoved && !isSelectionMode) {
                    // ç¿»è¯‘æ¶ˆæ¯ï¼šåˆ‡æ¢ç¿»è¯‘æ˜¾ç¤º
                    if (element.dataset.hasTranslation === 'true') {
                        toggleTranslation(element);
                    }
                }
            };

            // è§¦æ‘¸è®¾å¤‡ - passive:false å…è®¸åœ¨é•¿æŒ‰æ—¶è°ƒç”¨preventDefaulté˜»æ­¢æµè§ˆå™¨é»˜è®¤èœå•
            element.addEventListener('touchstart', startHandler, {passive: false});
            element.addEventListener('touchmove', cancelHandler, {passive: true});
            element.addEventListener('touchend', endHandler);
            
            // PC é¼ æ ‡ - ç”¨clickäº‹ä»¶å¤„ç†ç¿»è¯‘ï¼ˆPCç«¯clickå¯é ï¼‰
            element.addEventListener('mousedown', startHandler);
            element.addEventListener('mousemove', cancelHandler); // ç§»åŠ¨ç®—å–æ¶ˆ
            element.addEventListener('mouseup', (e) => {
                cancelHandler();
                if (isLongPress) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            });
            element.addEventListener('click', (e) => {
                if (isLongPress || isSelectionMode) return;
                if (e.target.tagName === 'A' || e.target.tagName === 'IMG') return;
                // ç¿»è¯‘æ¶ˆæ¯ï¼šåˆ‡æ¢ç¿»è¯‘æ˜¾ç¤º
                if (element.dataset.hasTranslation === 'true') {
                    toggleTranslation(element);
                }
            });
            // ç¦ç”¨å³é”®é»˜è®¤èœå•ï¼ˆåŒæ—¶è¦†ç›–æ‰‹æœºç«¯é•¿æŒ‰è§¦å‘çš„contextmenuï¼‰
            element.addEventListener('contextmenu', (e) => e.preventDefault());
        }
        
        // åˆ‡æ¢ç¿»è¯‘æ˜¾ç¤º/éšè—
        function toggleTranslation(element) {
            const isExpanded = element.dataset.expanded === 'true';
            let transEl = element.querySelector('.msg-translation');
            
            if (isExpanded) {
                // æ”¶èµ·ç¿»è¯‘
                if (transEl) transEl.style.display = 'none';
                element.dataset.expanded = 'false';
            } else {
                // æ˜¾ç¤ºç¿»è¯‘
                if (!transEl) {
                    transEl = document.createElement('div');
                    transEl.className = 'msg-translation';
                    transEl.innerHTML = renderMessageContent(element.dataset.chinese);
                    element.appendChild(transEl);
                } else {
                    transEl.style.display = 'block';
                }
                element.dataset.expanded = 'true';
            }
        }

        function showContextMenu(event, index, element) {
            // éœ‡åŠ¨åé¦ˆ (Android)
            if (navigator.vibrate) navigator.vibrate(50);
            
            activeMsgIndex = index;
            element.classList.add('active'); // é«˜äº®

            const menu = document.getElementById('msg-context-menu');
            const overlay = document.getElementById('menu-overlay');
            
            // è®¡ç®—åæ ‡
            let clientX, clientY;
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            const winWidth = window.innerWidth;
            const winHeight = window.innerHeight;

            // âœ… å…ˆæ˜¾ç¤ºèœå•ä»¥è·å–çœŸå®å°ºå¯¸ï¼ˆflex-wrap å¯èƒ½å¯¼è‡´å¤šè¡Œï¼‰
            menu.style.display = 'flex';
            menu.style.left = '0px';
            menu.style.top = '0px';
            
            // å¼ºåˆ¶é‡æ–°å¸ƒå±€ä»¥è·å–å‡†ç¡®çš„å°ºå¯¸
            const menuWidth = menu.offsetWidth;
            const menuHeight = menu.offsetHeight;
            
            // âœ… æ°´å¹³å±…ä¸­äºç‚¹å‡»ä½ç½®ï¼ŒåŒæ—¶ç¡®ä¿ä¸è¶…å‡ºå±å¹•
            let menuX = clientX - menuWidth / 2;
            if (menuX + menuWidth > winWidth - 10) {
                menuX = winWidth - menuWidth - 10;
            }
            if (menuX < 10) {
                menuX = 10;
            }
            
            // âœ… å‚ç›´ï¼šä¼˜å…ˆæ˜¾ç¤ºåœ¨ç‚¹å‡»ä½ç½®ä¸Šæ–¹
            let menuY = clientY - menuHeight - 10;
            if (menuY < 10) {
                menuY = clientY + 10; // ä¸Šæ–¹ç©ºé—´ä¸å¤Ÿï¼Œæ˜¾ç¤ºåœ¨ä¸‹æ–¹
            }
            if (menuY + menuHeight > winHeight - 10) {
                menuY = winHeight - menuHeight - 10;
            }

            menu.style.left = menuX + 'px';
            menu.style.top = menuY + 'px';
            
            // å…ˆç¦ç”¨overlayç‚¹å‡»ï¼Œé˜²æ­¢touchendåˆæˆçš„clickäº‹ä»¶ç«‹åˆ»å…³é—­èœå•
            overlay.style.display = 'block';
            overlay.style.pointerEvents = 'none';
            setTimeout(() => {
                overlay.style.pointerEvents = 'auto';
            }, 350);
        }

        function hideContextMenu() {
            const menu = document.getElementById('msg-context-menu');
            const overlay = document.getElementById('menu-overlay');
            menu.style.display = 'none';
            overlay.style.display = 'none';
            
            // ç§»é™¤é«˜äº®
            document.querySelectorAll('.message-content.active').forEach(el => el.classList.remove('active'));
        }

        // --- èœå•åŠŸèƒ½å®ç° ---
        
        // 0. å¤åˆ¶æ¶ˆæ¯å†…å®¹
        async function handleMsgCopy() {
            hideContextMenu();
            if (activeMsgIndex === -1) return;
            
            let textToCopy = '';
            
            // ç¾¤èŠå¤åˆ¶
            if (window.currentGroupChatId) {
                const group = await db.group_chats.get(window.currentGroupChatId);
                if (group && group.chat_history && group.chat_history[activeMsgIndex]) {
                    const msg = group.chat_history[activeMsgIndex];
                    textToCopy = msg.content || '';
                }
            } else {
                // ç§èŠå¤åˆ¶
                if (!currentChatCharId) return;
                const char = await db.characters.get(currentChatCharId);
                const accountId = getCurrentAccountId();
                let history = getChatHistory(char, accountId);
                const msg = history[activeMsgIndex];
                if (msg) {
                    textToCopy = msg.content || '';
                }
            }
            
            // æ¸…ç†ç‰¹æ®Šæ ¼å¼ï¼š[img:...] â†’ [å›¾ç‰‡], [voice:...] â†’ [è¯­éŸ³]
            textToCopy = textToCopy
                .replace(/\[img:[^\]]*\]/g, '[å›¾ç‰‡]')
                .replace(/\[voice:[^\]]*\]/g, '[è¯­éŸ³]')
                .replace(/\[sticker:[^\]]*\]/g, '[è¡¨æƒ…]');
            
            // å¦‚æœæ˜¯è½¬è´¦ç­‰ JSON æ ¼å¼æ¶ˆæ¯ï¼Œæå–å¯è¯»å†…å®¹
            if (textToCopy.startsWith('{') && textToCopy.includes('"amount"')) {
                try {
                    const data = JSON.parse(textToCopy);
                    textToCopy = `[è½¬è´¦] Â¥${data.amount} ${data.desc || ''}`.trim();
                } catch(e) {}
            }
            
            if (!textToCopy) {
                showToast('æ— å†…å®¹å¯å¤åˆ¶');
                return;
            }
            
            try {
                await navigator.clipboard.writeText(textToCopy);
                showToast('å·²å¤åˆ¶');
            } catch (e) {
                // é™çº§æ–¹æ¡ˆï¼šä½¿ç”¨ textarea å¤åˆ¶
                const ta = document.createElement('textarea');
                ta.value = textToCopy;
                ta.style.cssText = 'position:fixed;left:-9999px;top:-9999px;opacity:0;';
                document.body.appendChild(ta);
                ta.select();
                try {
                    document.execCommand('copy');
                    showToast('å·²å¤åˆ¶');
                } catch (ex) {
                    showToast('å¤åˆ¶å¤±è´¥');
                }
                document.body.removeChild(ta);
            }
        }
        
        // === ç¼–è¾‘æ¶ˆæ¯å¼¹çª— ===
        let editMsgCallback = null; // ä¿å­˜ç¼–è¾‘å®Œæˆåçš„å›è°ƒ

        function openEditMsgModal(content, callback) {
            const modal = document.getElementById('edit-msg-modal');
            const textarea = document.getElementById('edit-msg-textarea');
            textarea.value = content || '';
            editMsgCallback = callback;
            modal.style.display = 'flex';
            // å»¶è¿Ÿèšç„¦ï¼Œè®©åŠ¨ç”»å…ˆæ’­æ”¾
            setTimeout(() => {
                textarea.focus();
                // å…‰æ ‡ç§»åˆ°æœ«å°¾
                textarea.selectionStart = textarea.selectionEnd = textarea.value.length;
            }, 100);
        }

        function closeEditMsgModal() {
            const modal = document.getElementById('edit-msg-modal');
            modal.style.display = 'none';
            editMsgCallback = null;
        }

        function confirmEditMsg() {
            const textarea = document.getElementById('edit-msg-textarea');
            const newContent = textarea.value.trim();
            if (!newContent) {
                showToast('æ¶ˆæ¯å†…å®¹ä¸èƒ½ä¸ºç©º');
                return;
            }
            if (editMsgCallback) {
                editMsgCallback(newContent);
            }
            closeEditMsgModal();
        }

        // 1. ç¼–è¾‘
        async function handleMsgEdit() {
            hideContextMenu();
            if (activeMsgIndex === -1) return;
            
            // ç¾¤èŠç¼–è¾‘
            if (window.currentGroupChatId) {
                const group = await db.group_chats.get(window.currentGroupChatId);
                if (!group || !group.chat_history) return;
                
                const msg = group.chat_history[activeMsgIndex];
                if (!msg || msg.role === 'system') {
                    showToast("ç³»ç»Ÿæ¶ˆæ¯ä¸èƒ½ç¼–è¾‘");
                    return;
                }
                
                if (msg.content.startsWith('[img:') || msg.type === 'redpacket' || msg.type === 'transfer') {
                    showToast("è¯¥æ¶ˆæ¯ç±»å‹æš‚ä¸æ”¯æŒç¼–è¾‘");
                    return;
                }

                const editIndex = activeMsgIndex;
                openEditMsgModal(msg.content, async (newContent) => {
                    const grp = await db.group_chats.get(window.currentGroupChatId);
                    if (!grp || !grp.chat_history) return;
                    grp.chat_history[editIndex].content = newContent;
                    await db.group_chats.put(grp);
                    
                    // ç›´æ¥æ›´æ–°DOMï¼Œä¸åˆ·æ–°æ•´ä¸ªç¾¤èŠ
                    const chatBody = document.getElementById('chat-body');
                    const msgEl = chatBody.querySelector(`[data-index="${editIndex}"]`);
                    if (msgEl) {
                        const messageContent = msgEl.querySelector('.message-content') || msgEl.querySelector('.group-msg-content');
                        if (messageContent) {
                            messageContent.innerHTML = renderMessageContent(newContent);
                        }
                    }
                });
                return;
            }
            
            // ç§èŠç¼–è¾‘
            if (!currentChatCharId) return;
            
            const char = await db.characters.get(currentChatCharId);
            const accountId = getCurrentAccountId();
            let history = getChatHistory(char, accountId);
            const msg = history[activeMsgIndex];
            
            if (msg.content.startsWith('[img:')) {
                showToast("å›¾ç‰‡æ¶ˆæ¯æš‚ä¸æ”¯æŒç¼–è¾‘");
                return;
            }

            const editIndex = activeMsgIndex;
            const editCharId = currentChatCharId;
            openEditMsgModal(msg.content, async (newContent) => {
                const c = await db.characters.get(editCharId);
                const aid = getCurrentAccountId();
                let h = getChatHistory(c, aid);
                if (!h[editIndex]) return;
                h[editIndex].content = newContent;
                await setChatHistory(c, aid, h);
                
                // ğŸ”§ ç«‹å³æ›´æ–°UIï¼Œç”¨data-indexç²¾ç¡®å®šä½ï¼Œä¸é‡æ–°æ¸²æŸ“æ•´ä¸ªèŠå¤©
                const chatBody = document.getElementById('chat-body');
                const msgEl = chatBody.querySelector(`[data-index="${editIndex}"]`);
                if (msgEl) {
                    const messageContent = msgEl.querySelector('.message-content');
                    if (messageContent) {
                        messageContent.innerHTML = renderMessageContent(newContent);
                    }
                }
            });
        }

        // 2. æ’¤å›ï¼ˆä¿å­˜åŸå†…å®¹ï¼Œç‚¹å‡»å¯æŸ¥çœ‹ï¼‰
        async function handleMsgRecall() {
            hideContextMenu();
            if (activeMsgIndex === -1) return;
            
            if (!confirm("ç¡®å®šè¦æ’¤å›è¿™æ¡æ¶ˆæ¯å—ï¼Ÿ")) return;
            
            // ç¾¤èŠæ’¤å›
            if (window.currentGroupChatId) {
                const group = await db.group_chats.get(window.currentGroupChatId);
                if (!group || !group.chat_history) return;
                
                const msg = group.chat_history[activeMsgIndex];
                if (!msg || msg.role === 'system') {
                    showToast("ç³»ç»Ÿæ¶ˆæ¯ä¸èƒ½æ’¤å›");
                    return;
                }
                
                const isUser = msg.role === 'user';
                const recallerName = isUser ? 'ä½ ' : 'æˆå‘˜';
                
                msg.recalledContent = msg.content;
                msg.isRecalled = true;
                msg.content = "";
                msg.type = 'recalled';
                
                group.chat_history[activeMsgIndex] = msg;
                
                // æ·»åŠ æ’¤å›æç¤ºç³»ç»Ÿæ¶ˆæ¯
                group.chat_history.splice(activeMsgIndex + 1, 0, {
                    role: 'system',
                    content: `"${recallerName}"æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯`,
                    time: Date.now(),
                    recalledContent: msg.recalledContent
                });
                
                await db.group_chats.put(group);
                await renderGroupChatBody(group);
                return;
            }

            // ç§èŠæ’¤å›
            if (!currentChatCharId) return;
            
            const char = await db.characters.get(currentChatCharId);
            const accountId = getCurrentAccountId();
            let history = getChatHistory(char, accountId);
            const msg = history[activeMsgIndex];
            const isUser = msg.role === 'user';
            const recallerName = isUser ? 'ä½ ' : char.name;
            
            msg.recalledContent = msg.content;
            msg.isRecalled = true;
            msg.content = "";
            
            await setChatHistory(char, accountId, history);
            
            const chatBody = document.getElementById('chat-body');
            const messageRows = chatBody.querySelectorAll('.message-row');
            if (messageRows[activeMsgIndex]) {
                const msgRow = messageRows[activeMsgIndex];
                msgRow.className = 'message-row recalled-system-row';
                msgRow.innerHTML = '';
                
                const capturedContent = msg.recalledContent;
                const capturedName = recallerName;
                const systemTip = document.createElement('div');
                systemTip.className = 'recalled-system-tip';
                systemTip.innerHTML = `"${capturedName}"æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯`;
                systemTip.style.cursor = 'pointer';
                systemTip.onclick = (e) => {
                    e.stopPropagation();
                    showRecalledContent(capturedName, capturedContent);
                };
                msgRow.appendChild(systemTip);
            }
        }
        
        // æ˜¾ç¤ºæ’¤å›æ¶ˆæ¯çš„åŸå†…å®¹
        function showRecalledContent(recallerName, content) {
            // åˆ›å»ºå¼¹çª—
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                z-index: 9999;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 20px;
            `;
            overlay.onclick = () => overlay.remove();
            
            const modal = document.createElement('div');
            modal.style.cssText = `
                background: white;
                border-radius: 12px;
                padding: 20px;
                max-width: 320px;
                width: 100%;
                max-height: 60vh;
                overflow-y: auto;
                box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            `;
            modal.onclick = (e) => e.stopPropagation();
            
            // å¤„ç†å†…å®¹æ˜¾ç¤ºï¼ˆæ”¯æŒå›¾ç‰‡ç­‰ï¼‰
            let displayContent = content;
            if (content.startsWith('[img:')) {
                const imgUrl = content.substring(5, content.length - 1).trim();
                displayContent = `<img src="${imgUrl}" style="max-width:100%; border-radius:8px;">`;
            } else if (content.startsWith('[voice:')) {
                displayContent = `ğŸ¤ è¯­éŸ³æ¶ˆæ¯: ${content.substring(7, content.length - 1)}`;
            }
            
            modal.innerHTML = `
                <div style="font-size:14px; color:#999; margin-bottom:12px;">"${recallerName}"æ’¤å›çš„æ¶ˆæ¯ï¼š</div>
                <div style="font-size:15px; color:#333; line-height:1.6; word-break:break-all;">${displayContent}</div>
                <button onclick="this.parentElement.parentElement.remove()" style="
                    width: 100%;
                    margin-top: 16px;
                    padding: 10px;
                    background: #f5f5f5;
                    border: none;
                    border-radius: 8px;
                    font-size: 14px;
                    color: #666;
                    cursor: pointer;
                ">å…³é—­</button>
            `;
            
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
        }
        
        // å¼•ç”¨æ¶ˆæ¯ç›¸å…³
        let currentQuote = null; // å½“å‰å¼•ç”¨çš„æ¶ˆæ¯ { name, content, index }
        
        // å¼•ç”¨æ¶ˆæ¯
        async function handleMsgQuote() {
            hideContextMenu();
            if (activeMsgIndex === -1) return;
            
            let quoteName = '';
            let quoteContent = '';
            
            // ç¾¤èŠå¼•ç”¨
            if (window.currentGroupChatId) {
                const group = await db.group_chats.get(window.currentGroupChatId);
                if (!group || !group.chat_history) return;
                
                const msg = group.chat_history[activeMsgIndex];
                if (!msg || msg.role === 'system') {
                    showToast("æ— æ³•å¼•ç”¨ç³»ç»Ÿæ¶ˆæ¯");
                    return;
                }
                
                if (msg.role === 'user') {
                    const myChar = currentMyCharId ? await db.characters.get(parseInt(currentMyCharId)) : null;
                    quoteName = group.myNickname || myChar?.name || 'æˆ‘';
                } else {
                    const senderChar = msg.senderId ? await db.characters.get(msg.senderId) : null;
                    const memberNicknames = group.memberNicknames || {};
                    quoteName = memberNicknames[msg.senderId] || senderChar?.remark || senderChar?.name || 'æœªçŸ¥æˆå‘˜';
                }
                
                quoteContent = getQuoteDisplayContent(msg.content, msg.type);
            } else {
                // ç§èŠå¼•ç”¨
                if (!currentChatCharId) return;
                
                const char = await db.characters.get(currentChatCharId);
                const accountId = getCurrentAccountId();
                const history = getChatHistory(char, accountId);
                const msg = history[activeMsgIndex];
                
                if (!msg) return;
                
                if (msg.role === 'user') {
                    const myChar = currentMyCharId ? await db.characters.get(parseInt(currentMyCharId)) : null;
                    quoteName = myChar?.name || 'æˆ‘';
                } else {
                    quoteName = char.remark || char.wx_nickname || char.name;
                }
                
                quoteContent = getQuoteDisplayContent(msg.content, msg.type);
            }
            
            // è®¾ç½®å¼•ç”¨
            currentQuote = {
                name: quoteName,
                content: quoteContent,
                index: activeMsgIndex
            };
            
            // æ˜¾ç¤ºå¼•ç”¨é¢„è§ˆ
            showQuotePreview(quoteName, quoteContent);
            
            // èšç„¦è¾“å…¥æ¡†
            document.getElementById('chat-input-box').focus();
        }
        
        // è·å–å¼•ç”¨æ˜¾ç¤ºå†…å®¹
        function getQuoteDisplayContent(content, type) {
            if (type === 'redpacket') return '[çº¢åŒ…]';
            if (type === 'transfer') return '[è½¬è´¦]';
            if (content.startsWith('[img:')) return '[å›¾ç‰‡]';
            if (content.startsWith('[voice:')) return '[è¯­éŸ³]';
            if (content.startsWith('[imgcard:')) return '[å›¾æ–‡æ¶ˆæ¯]';
            // æˆªæ–­è¿‡é•¿çš„æ–‡æœ¬
            if (content.length > 50) {
                return content.substring(0, 50) + '...';
            }
            return content;
        }
        
        // æ˜¾ç¤ºå¼•ç”¨é¢„è§ˆ
        function showQuotePreview(name, content) {
            const preview = document.getElementById('quote-preview');
            const nameEl = document.getElementById('quote-preview-name');
            const msgEl = document.getElementById('quote-preview-msg');
            
            nameEl.textContent = name;
            msgEl.textContent = content;
            preview.style.display = 'flex';
        }
        
        // å–æ¶ˆå¼•ç”¨
        function cancelQuote() {
            currentQuote = null;
            document.getElementById('quote-preview').style.display = 'none';
        }

        // 3. åˆ é™¤ (å•æ¡)
        async function handleMsgDelete() {
            hideContextMenu();
            if (activeMsgIndex === -1) return;
            
            if (!confirm("åˆ é™¤è¿™æ¡æ¶ˆæ¯ï¼Ÿ")) return;
            
            // ç¾¤èŠåˆ é™¤
            if (window.currentGroupChatId) {
                const group = await db.group_chats.get(window.currentGroupChatId);
                if (!group || !group.chat_history) return;
                
                group.chat_history.splice(activeMsgIndex, 1);
                await db.group_chats.put(group);
                await renderGroupChatBody(group);
                return;
            }

            // ç§èŠåˆ é™¤
            if (!currentChatCharId) return;
            
            const char = await db.characters.get(currentChatCharId);
            const accountId = getCurrentAccountId();
            let history = getChatHistory(char, accountId);
            history.splice(activeMsgIndex, 1);
            
            await setChatHistory(char, accountId, history);
            
            // ğŸ”§ åªåˆ é™¤DOMå…ƒç´ ï¼Œä¸é‡æ–°æ¸²æŸ“æ•´ä¸ªç•Œé¢ - ä½¿ç”¨data-indexå±æ€§æŸ¥æ‰¾
            const chatBody = document.getElementById('chat-body');
            if (chatBody) {
                // ä½¿ç”¨data-indexå±æ€§ç²¾ç¡®æŸ¥æ‰¾æ¶ˆæ¯å…ƒç´ 
                const msgEl = chatBody.querySelector(`[data-index="${activeMsgIndex}"]`);
                if (msgEl) {
                    // æ£€æŸ¥å‰ä¸€ä¸ªæ˜¯å¦æ˜¯æ—¶é—´æˆ³ï¼Œå¦‚æœæ˜¯ä¸”åé¢æ²¡æœ‰æ¶ˆæ¯äº†ï¼Œä¹Ÿåˆ é™¤æ—¶é—´æˆ³
                    const prevEl = msgEl.previousElementSibling;
                    if (prevEl && prevEl.classList.contains('message-timestamp')) {
                        const nextEl = msgEl.nextElementSibling;
                        if (!nextEl || nextEl.classList.contains('message-timestamp')) {
                            prevEl.remove();
                        }
                    }
                    msgEl.remove();
                }
            }
        }

        // --- å¤šé€‰æ¨¡å¼ ---
        function enterSelectionMode() {
            hideContextMenu();
            if (!currentChatCharId && !window.currentGroupChatId) return;
            
            isSelectionMode = true;
            selectedIndices.clear();
            
            document.getElementById('chat-body').classList.add('selection-mode');
            document.getElementById('selection-bar').style.display = 'flex';
            document.getElementById('chat-footer').style.display = 'none';
            
            // ä¸ºç¾¤èŠæ¶ˆæ¯æ·»åŠ checkbox
            if (window.currentGroupChatId) {
                document.querySelectorAll('.group-message-row').forEach((row) => {
                    const idx = parseInt(row.dataset.msgIndex);
                    if (row.querySelector('.group-msg-content')) {
                        row.classList.add('selection-mode');
                        row.style.paddingLeft = '40px';
                        let cb = row.querySelector('.msg-checkbox');
                        if (!cb) {
                            cb = document.createElement('div');
                            cb.className = 'msg-checkbox';
                            cb.style.cssText = 'position:absolute; left:8px; top:50%; transform:translateY(-50%); width:22px; height:22px; border:2px solid #ccc; border-radius:50%; display:flex; align-items:center; justify-content:center; cursor:pointer;';
                            cb.onclick = (e) => {
                                e.stopPropagation();
                                if (selectedIndices.has(idx)) {
                                    selectedIndices.delete(idx);
                                    cb.classList.remove('checked');
                                    cb.style.background = '';
                                    cb.style.borderColor = '#ccc';
                                    cb.innerHTML = '';
                                } else {
                                    selectedIndices.add(idx);
                                    cb.classList.add('checked');
                                    cb.style.background = 'var(--ins-pink)';
                                    cb.style.borderColor = 'var(--ins-pink)';
                                    cb.innerHTML = '<svg viewBox="0 0 24 24" style="width:14px;height:14px;stroke:#fff;stroke-width:3;fill:none;"><polyline points="20 6 9 17 4 12"></polyline></svg>';
                                }
                                updateDeleteBtn();
                            };
                            row.style.position = 'relative';
                            row.insertBefore(cb, row.firstChild);
                        }
                        cb.style.display = 'flex';
                    }
                });
            }
            
            updateDeleteBtn();
        }

        function exitSelectionMode() {
            isSelectionMode = false;
            selectedIndices.clear();
            
            document.getElementById('chat-body').classList.remove('selection-mode');
            document.getElementById('selection-bar').style.display = 'none';
            document.getElementById('chat-footer').style.display = 'flex';
            
            // ç§èŠæ¶ˆæ¯
            document.querySelectorAll('.message-row').forEach(row => {
                row.classList.remove('selection-mode', 'selected');
            });
            // ç¾¤èŠæ¶ˆæ¯
            document.querySelectorAll('.group-message-row').forEach(row => {
                row.classList.remove('selection-mode', 'selected');
                row.style.paddingLeft = '';
            });
            document.querySelectorAll('.msg-checkbox').forEach(cb => {
                cb.style.display = 'none';
                cb.classList.remove('checked');
                cb.style.background = '';
                cb.style.borderColor = '#ccc';
                cb.innerHTML = '';
            });
        }

        function handleRowClick(index, e) {
            if (!isSelectionMode) return;
            
            // åˆ‡æ¢é€‰ä¸­çŠ¶æ€
            const row = e.currentTarget; // .message-row
            const checkbox = row.querySelector('.msg-checkbox');
            
            if (selectedIndices.has(index)) {
                selectedIndices.delete(index);
                checkbox.classList.remove('checked');
            } else {
                selectedIndices.add(index);
                checkbox.classList.add('checked');
            }
            
            updateDeleteBtn();
        }

        function updateDeleteBtn() {
            const count = selectedIndices.size;
            const btn = document.getElementById('btn-batch-delete');
            btn.innerText = `åˆ é™¤ (${count})`;
            btn.style.opacity = count > 0 ? '1' : '0.5';
        }

        async function deleteSelectedMsgs() {
            if (selectedIndices.size === 0) return;
            
            if (!confirm(`ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${selectedIndices.size} æ¡æ¶ˆæ¯å—ï¼Ÿ`)) return;
            
            // ç¾¤èŠæ‰¹é‡åˆ é™¤
            if (window.currentGroupChatId) {
                const group = await db.group_chats.get(window.currentGroupChatId);
                if (!group || !group.chat_history) return;
                
                const newHistory = group.chat_history.filter((_, idx) => !selectedIndices.has(idx));
                group.chat_history = newHistory;
                await db.group_chats.put(group);
                
                exitSelectionMode();
                // é‡æ–°æ¸²æŸ“ä¼šè‡ªåŠ¨å¤„ç†æ—¶é—´æˆ³
                await renderGroupChatBody(group);
                return;
            }
            
            // ç§èŠæ‰¹é‡åˆ é™¤
            if (!currentChatCharId) return;

            const char = await db.characters.get(currentChatCharId);
            const accountId = getCurrentAccountId();
            const history = getChatHistory(char, accountId);
            
            const newHistory = history.filter((_, idx) => !selectedIndices.has(idx));
            
            await setChatHistory(char, accountId, newHistory);
            await db.characters.put(char);
            
            // ğŸ”§ åªåˆ é™¤DOMå…ƒç´ ï¼Œä¸é‡æ–°æ¸²æŸ“æ•´ä¸ªç•Œé¢ - ä½¿ç”¨data-indexå±æ€§æŸ¥æ‰¾
            const chatBody = document.getElementById('chat-body');
            if (chatBody) {
                // å€’åºåˆ é™¤ï¼Œé¿å…ç´¢å¼•å˜åŒ–
                const sortedIndices = Array.from(selectedIndices).sort((a, b) => b - a);
                sortedIndices.forEach(idx => {
                    // ä½¿ç”¨data-indexå±æ€§ç²¾ç¡®æŸ¥æ‰¾æ¶ˆæ¯å…ƒç´ 
                    const msgEl = chatBody.querySelector(`[data-index="${idx}"]`);
                    if (msgEl) {
                        // æ£€æŸ¥å‰ä¸€ä¸ªæ˜¯å¦æ˜¯æ—¶é—´æˆ³ï¼Œå¦‚æœæ˜¯ä¸”åé¢æ²¡æœ‰æ¶ˆæ¯äº†ï¼Œä¹Ÿåˆ é™¤æ—¶é—´æˆ³
                        const prevEl = msgEl.previousElementSibling;
                        if (prevEl && prevEl.classList.contains('message-timestamp')) {
                            const nextEl = msgEl.nextElementSibling;
                            if (!nextEl || nextEl.classList.contains('message-timestamp') || sortedIndices.includes(idx + 1)) {
                                prevEl.remove();
                            }
                        }
                        msgEl.remove();
                    }
                });
            }
            
            exitSelectionMode();
        }

        // --- æ–°å¢ï¼šèŠå¤©äº¤äº’é€»è¾‘ (é¢æ¿/è¾“å…¥/AIè§¦å‘) ---
        let activePanel = null;
        const emojis = ["ğŸ˜€","ğŸ˜","ğŸ˜‚","ğŸ¤£","ğŸ˜ƒ","ğŸ˜„","ğŸ˜…","ğŸ˜†","ğŸ˜‰","ğŸ˜Š","ğŸ˜‹","ğŸ˜","ğŸ˜","ğŸ˜˜","ğŸ¥°","ğŸ˜—","ğŸ˜™","ğŸ˜š","ğŸ™‚","ğŸ¤—","ğŸ¤©","ğŸ¤”","ğŸ¤¨","ğŸ˜","ğŸ˜‘","ğŸ˜¶","ğŸ™„","ğŸ˜","ğŸ˜£","ğŸ˜¥","ğŸ˜®","ğŸ¤","ğŸ˜¯","ğŸ˜ª","ğŸ˜«","ğŸ˜´","ğŸ˜Œ","ğŸ˜›","ğŸ˜œ","ğŸ˜","ğŸ¤¤","ğŸ˜’","ğŸ˜“","ğŸ˜”","ğŸ˜•","ğŸ™ƒ","ğŸ¤‘","ğŸ˜²","â˜¹ï¸","ğŸ™","ğŸ˜–","ğŸ˜","ğŸ˜Ÿ","ğŸ˜¤","ğŸ˜¢","ğŸ˜­","ğŸ˜¦","ğŸ˜§","ğŸ˜¨","ğŸ˜©","ğŸ¤¯","ğŸ˜¬","ğŸ˜°","ğŸ˜±","ğŸ¥µ","ğŸ¥¶","ğŸ˜³","ğŸ¤ª","ğŸ˜µ","ğŸ˜¡","ğŸ˜ ","ğŸ¤¬","ğŸ˜·","ğŸ¤’","ğŸ¤•","ğŸ¤¢","ğŸ¤®","ğŸ¤§","ğŸ˜‡","ğŸ¥³","ğŸ¥º","ğŸ¤ ","ğŸ¤¡","ğŸ¤¥","ğŸ¤«","ğŸ¤­","ğŸ§","ğŸ¤“","ğŸ˜ˆ","ğŸ‘¿","ğŸ‘¹","ğŸ‘º","ğŸ’€","ğŸ‘»","ğŸ‘½","ğŸ¤–","ğŸ’©","ğŸ˜º","ğŸ˜¸","ğŸ˜¹","ğŸ˜»","ğŸ˜¼","ğŸ˜½","ğŸ™€","ğŸ˜¿","ğŸ˜¾"];

        function initEmojiPanel() {
            const panel = document.getElementById('emoji-panel');
            if (panel.children.length > 0) return; 
            panel.innerHTML = emojis.map(e => `<div class="emoji-item" onclick="insertEmoji('${e}')">${e}</div>`).join('');
        }

        async function switchEmojiTab(type) {
            const tabs = document.querySelectorAll('#emoji-tab-bar .wechat-tab-item');
            const emojiPanel = document.getElementById('emoji-panel');
            const stickerPanel = document.getElementById('sticker-panel');

            if (type === 'emoji') {
                tabs[0].classList.add('active');
                tabs[1].classList.remove('active');
                emojiPanel.style.display = 'grid';
                stickerPanel.style.display = 'none';
            } else {
                tabs[0].classList.remove('active');
                tabs[1].classList.add('active');
                emojiPanel.style.display = 'none';
                stickerPanel.style.display = 'flex';
                
                // åŠ è½½å…¨å±€è¡¨æƒ…åŒ…
                await updateChatStickerPanel();
            }
        }
        
        async function sendSticker(base64) {
            // å‘é€å›¾ç‰‡æ¶ˆæ¯
            const msgContent = `[img:${base64}]`;
            
            // æ”¯æŒç¾¤èŠæ¨¡å¼
            if (window.currentGroupChatId) {
                const group = await db.group_chats.get(window.currentGroupChatId);
                if (!group) return;
                
                if (!group.chat_history) group.chat_history = [];
                group.chat_history.push({
                    role: 'user',
                    content: msgContent,
                    time: Date.now()
                });
                group.updated_at = Date.now();
                await db.group_chats.put(group);
                
                await renderGroupChatBody(group);
                closeChatPanel();
                return;
            }
            
            if (!currentChatCharId) return;
            const char = await db.characters.get(currentChatCharId);
            const accountId = getCurrentAccountId();
            let history = getChatHistory(char, accountId);
            
            history.push({
                role: 'user',
                content: msgContent,
                time: Date.now()
            });
            
            await setChatHistory(char, accountId, history);
            appendMessageToUI('user', msgContent);
            closeChatPanel();
            
            // âœ… å¦‚æœæ˜¯è”æœºå¥½å‹ï¼Œå‘é€è¡¨æƒ…åŒ…åˆ°æœåŠ¡å™¨
            if (char.isOnlineFriend && char.onlineData?.wx_account) {
                const onlineUserChar = await getOrCreateOnlineUserChar();
                
                if (onlineUserChar && onlineConnected) {
                    const fromWxAccount = onlineUserChar.identity.account;
                    const toWxAccount = char.onlineData.wx_account;
                    const sent = sendOnlineMessage(toWxAccount, msgContent, fromWxAccount);
                    if (sent) {
                        console.log('[Online] è¡¨æƒ…åŒ…å·²å‘é€åˆ°æœåŠ¡å™¨');
                    } else {
                        console.warn('[Online] è¡¨æƒ…åŒ…å‘é€å¤±è´¥');
                        showToast('è¡¨æƒ…åŒ…å‘é€å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨è¿æ¥');
                    }
                } else {
                    console.warn('[Online] æ— æ³•å‘é€è”æœºè¡¨æƒ…åŒ…ï¼šæœªè¿æ¥æœåŠ¡å™¨');
                    showToast('è¯·ç¡®ä¿å·²è¿æ¥æœåŠ¡å™¨');
                }
            }
            
            // å¯ä»¥åœ¨è¿™é‡Œè§¦å‘ AI å¯¹è¡¨æƒ…åŒ…çš„ååº”ï¼ˆå¦‚æœéœ€è¦ï¼‰
            // triggerAiReply(); 
        }

        // æ˜¾ç¤ºå›¾ç‰‡ç±»å‹é€‰æ‹©å¼¹çª—
        function showImageTypeModal() {
            // å…³é—­æ›´å¤šé¢æ¿
            closeChatPanel();
            
            const modal = document.createElement('div');
            modal.id = 'image-type-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.4);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                backdrop-filter: blur(5px);
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 16px; padding: 24px; width: 85%; max-width: 320px; box-shadow: 0 10px 40px rgba(0,0,0,0.15);">
                    <h3 style="margin: 0 0 24px 0; text-align: center; color: #333; font-size: 18px; font-weight: 600;">é€‰æ‹©å›¾ç‰‡ç±»å‹</h3>
                    <div style="display: flex; flex-direction: column; gap: 12px;">
                        <button onclick="selectRealImage()" style="padding: 16px; background: #f5f5f5; color: #333; border: none; border-radius: 12px; font-size: 16px; font-weight: 500; cursor: pointer; transition: all 0.2s; display:flex; align-items:center; justify-content:center; gap:8px;">
                            <svg class="svg-icon" style="width:20px; height:20px;" viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
                            <span>çœŸå®å›¾ç‰‡</span>
                        </button>
                        <button onclick="selectTextImageCard()" style="padding: 16px; background: #f5f5f5; color: #333; border: none; border-radius: 12px; font-size: 16px; font-weight: 500; cursor: pointer; transition: all 0.2s; display:flex; align-items:center; justify-content:center; gap:8px;">
                            <svg class="svg-icon" style="width:20px; height:20px;" viewBox="0 0 24 24"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>
                            <span>æ–‡å­—å›¾ç‰‡å¡ç‰‡</span>
                        </button>
                        <button onclick="closeImageTypeModal()" style="padding: 14px; background: white; color: #999; border: 1px solid #e8e8e8; border-radius: 12px; font-size: 15px; cursor: pointer; margin-top: 8px;">
                            å–æ¶ˆ
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }

        function closeImageTypeModal() {
            const modal = document.getElementById('image-type-modal');
            if (modal) modal.remove();
        }

        // é€‰æ‹©çœŸå®å›¾ç‰‡
        function selectRealImage() {
            closeImageTypeModal();
            document.getElementById('chat-image-input').click();
        }

        // é€‰æ‹©æ–‡å­—å›¾ç‰‡å¡ç‰‡
        function selectTextImageCard() {
            closeImageTypeModal();
            
            const modal = document.createElement('div');
            modal.id = 'text-image-card-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 12px; padding: 20px; width: 85%; max-width: 350px;">
                    <h3 style="margin: 0 0 15px 0; color: #333;">è¾“å…¥å¡ç‰‡æ–‡å­—</h3>
                    <textarea id="imgcard-text-input" placeholder="è¾“å…¥è¦è½¬æ¢ä¸ºå›¾ç‰‡å¡ç‰‡çš„æ–‡å­—..." style="width: 100%; height: 120px; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px; resize: none; box-sizing: border-box;"></textarea>
                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button onclick="sendImageCard()" style="flex: 1; padding: 12px; background: var(--ins-pink); color: white; border: none; border-radius: 8px; font-size: 15px;">
                            å‘é€
                        </button>
                        <button onclick="closeTextImageCardModal()" style="flex: 1; padding: 12px; background: #f0f0f0; color: #666; border: none; border-radius: 8px; font-size: 15px;">
                            å–æ¶ˆ
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            document.getElementById('imgcard-text-input').focus();
        }

        function closeTextImageCardModal() {
            const modal = document.getElementById('text-image-card-modal');
            if (modal) modal.remove();
        }

        async function sendImageCard() {
            const text = document.getElementById('imgcard-text-input').value.trim();
            if (!text) {
                alert('è¯·è¾“å…¥å†…å®¹');
                return;
            }
            
            closeTextImageCardModal();
            
            // å‘é€å›¾ç‰‡å¡ç‰‡æ¶ˆæ¯ï¼ˆæ ¼å¼ï¼š[imgcard:æ–‡å­—å†…å®¹]ï¼‰
            const msgContent = `[imgcard:${text}]`;
            
            // æ”¯æŒç¾¤èŠæ¨¡å¼
            if (window.currentGroupChatId) {
                const group = await db.group_chats.get(window.currentGroupChatId);
                if (!group) return;
                
                if (!group.chat_history) group.chat_history = [];
                group.chat_history.push({
                    role: 'user',
                    content: msgContent,
                    time: Date.now()
                });
                group.updated_at = Date.now();
                await db.group_chats.put(group);
                
                await renderGroupChatBody(group);
                return;
            }
            
            if (!currentChatCharId) return;
            const char = await db.characters.get(currentChatCharId);
            const accountId = getCurrentAccountId();
            let history = getChatHistory(char, accountId);
            
            history.push({
                role: 'user',
                content: msgContent,
                time: Date.now()
            });
            
            await setChatHistory(char, accountId, history);
            
            // âœ… ä¼˜åŒ–ï¼šåªè¿½åŠ æ–°æ¶ˆæ¯ï¼Œä¸é‡æ–°æ¸²æŸ“æ•´ä¸ªèŠå¤©
            await appendMessageToUI('user', msgContent, char.avatar);
        }

        // å‘é€çœŸå®å›¾ç‰‡æ¶ˆæ¯
        async function sendImageMessage(input) {
            const file = input.files[0];
            if (!file) return;
            
            // æ”¯æŒç¾¤èŠæ¨¡å¼
            if (window.currentGroupChatId) {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    // ğŸ”§ è½¬æ¢å›¾ç‰‡æ ¼å¼ï¼Œç¡®ä¿ API å…¼å®¹ï¼ˆè§£å†³ avif ç­‰æ ¼å¼ä¸æ”¯æŒçš„é—®é¢˜ï¼‰
                    const base64 = await convertImageForAI(e.target.result);
                    const msgContent = `[img:${base64}]`;
                    
                    const group = await db.group_chats.get(window.currentGroupChatId);
                    if (!group) return;
                    
                    if (!group.chat_history) group.chat_history = [];
                    group.chat_history.push({
                        role: 'user',
                        content: msgContent,
                        time: Date.now()
                    });
                    group.updated_at = Date.now();
                    await db.group_chats.put(group);
                    
                    await renderGroupChatBody(group);
                };
                reader.readAsDataURL(file);
                input.value = '';
                return;
            }
            
            if (!currentChatCharId) return;
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                // ğŸ”§ è½¬æ¢å›¾ç‰‡æ ¼å¼ï¼Œç¡®ä¿ API å…¼å®¹ï¼ˆè§£å†³ avif ç­‰æ ¼å¼ä¸æ”¯æŒçš„é—®é¢˜ï¼‰
                const base64 = await convertImageForAI(e.target.result);
                const msgContent = `[img:${base64}]`;
                
                const char = await db.characters.get(currentChatCharId);
                const accountId = getCurrentAccountId();
                let history = getChatHistory(char, accountId);
                
                history.push({
                    role: 'user',
                    content: msgContent,
                    time: Date.now()
                });
                
                await setChatHistory(char, accountId, history);
                
                // âœ… ä¼˜åŒ–ï¼šåªè¿½åŠ æ–°æ¶ˆæ¯ï¼Œä¸é‡æ–°æ¸²æŸ“æ•´ä¸ªèŠå¤©
                await appendMessageToUI('user', msgContent, char.avatar);
                
                // âœ… å¦‚æœæ˜¯è”æœºå¥½å‹ï¼Œå‘é€å›¾ç‰‡åˆ°æœåŠ¡å™¨
                if (char.isOnlineFriend && char.onlineData?.wx_account) {
                    const onlineUserChar = await getOrCreateOnlineUserChar();
                    
                    if (onlineUserChar && onlineConnected) {
                        const fromWxAccount = onlineUserChar.identity.account;
                        const toWxAccount = char.onlineData.wx_account;
                        const sent = sendOnlineMessage(toWxAccount, msgContent, fromWxAccount);
                        if (sent) {
                            console.log('[Online] å›¾ç‰‡å·²å‘é€åˆ°æœåŠ¡å™¨');
                        } else {
                            console.warn('[Online] å›¾ç‰‡å‘é€å¤±è´¥');
                            showToast('å›¾ç‰‡å‘é€å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨è¿æ¥');
                        }
                    } else {
                        console.warn('[Online] æ— æ³•å‘é€è”æœºå›¾ç‰‡ï¼šæœªè¿æ¥æœåŠ¡å™¨');
                        showToast('è¯·ç¡®ä¿å·²è¿æ¥æœåŠ¡å™¨');
                    }
                }
            };
            
            reader.readAsDataURL(file);
            input.value = '';
        }

        function insertEmoji(e) {
            const input = document.getElementById('chat-input-box');
            input.value += e;
            handleChatInputChange(input);
        }

        // è¯­éŸ³è¾“å…¥åŠŸèƒ½
        async function showVoiceInputModal() {
            // å…³é—­æ›´å¤šé¢æ¿
            closeChatPanel();
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯è”æœºå¥½å‹
            let isOnlineFriend = false;
            if (currentChatCharId) {
                const char = await db.characters.get(currentChatCharId);
                isOnlineFriend = char && char.isOnlineFriend === true;
            }
            
            // æ˜¾ç¤ºè¯­éŸ³æ¨¡å¼é€‰æ‹©å¼¹çª—
            const modal = document.createElement('div');
            modal.id = 'voice-mode-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            
            if (isOnlineFriend) {
                // è”æœºå¥½å‹ï¼šæ˜¾ç¤ºçœŸå®å½•éŸ³+å˜å£°é€‰é¡¹
                modal.innerHTML = `
                    <div style="background: white; border-radius: 16px; padding: 24px; width: 85%; max-width: 320px;">
                        <h3 style="margin: 0 0 20px 0; text-align: center; color: #333; font-size: 18px;">ğŸ¤ è¯­éŸ³å½•åˆ¶</h3>
                        
                        <div style="margin-bottom: 20px;">
                            <div style="font-size: 13px; color: #666; margin-bottom: 10px;">é€‰æ‹©å˜å£°æ•ˆæœï¼š</div>
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                                <label style="display: flex; align-items: center; padding: 12px; background: #f5f5f5; border-radius: 8px; cursor: pointer;">
                                    <input type="radio" name="voice-effect" value="normal" checked style="margin-right: 8px;">
                                    <span>ğŸ™ï¸ åŸå£°</span>
                                </label>
                                <label style="display: flex; align-items: center; padding: 12px; background: #fff0f5; border-radius: 8px; cursor: pointer;">
                                    <input type="radio" name="voice-effect" value="loli" style="margin-right: 8px;">
                                    <span>ğŸ€ èè‰éŸ³</span>
                                </label>
                                <label style="display: flex; align-items: center; padding: 12px; background: #f0f5ff; border-radius: 8px; cursor: pointer;">
                                    <input type="radio" name="voice-effect" value="uncle" style="margin-right: 8px;">
                                    <span>ğŸ§” å¤§å”éŸ³</span>
                                </label>
                                <label style="display: flex; align-items: center; padding: 12px; background: #f5fff0; border-radius: 8px; cursor: pointer;">
                                    <input type="radio" name="voice-effect" value="robot" style="margin-right: 8px;">
                                    <span>ğŸ¤– æœºå™¨äºº</span>
                                </label>
                            </div>
                        </div>
                        
                        <div id="voice-record-status" style="text-align: center; padding: 20px; background: #f9f9f9; border-radius: 12px; margin-bottom: 16px;">
                            <div style="font-size: 14px; color: #999;">ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å¼€å§‹å½•éŸ³</div>
                            <div id="voice-record-time" style="font-size: 24px; font-weight: 600; color: #333; margin-top: 8px; display: none;">00:00</div>
                        </div>
                        
                        <div style="display: flex; flex-direction: column; gap: 10px;">
                            <button id="btn-start-record" onclick="startOnlineVoiceRecord()" style="padding: 14px; background: var(--ins-pink); color: white; border: none; border-radius: 10px; font-size: 15px; font-weight: 500;">
                                ğŸ¤ æŒ‰ä½å½•éŸ³
                            </button>
                            <button onclick="closeVoiceModal()" style="padding: 12px; background: #f0f0f0; color: #666; border: none; border-radius: 8px; font-size: 14px;">
                                å–æ¶ˆ
                            </button>
                        </div>
                    </div>
                `;
            } else {
                // æ™®é€šè§’è‰²ï¼šæ˜¾ç¤ºåŸæœ‰é€‰é¡¹
                modal.innerHTML = `
                    <div style="background: white; border-radius: 12px; padding: 20px; width: 80%; max-width: 300px;">
                        <h3 style="margin: 0 0 20px 0; text-align: center; color: #333;">é€‰æ‹©è¯­éŸ³æ¨¡å¼</h3>
                        <div style="display: flex; flex-direction: column; gap: 12px;">
                            <button onclick="startRealVoiceInput()" style="padding: 15px; background: var(--ins-pink); color: white; border: none; border-radius: 8px; font-size: 16px; display:flex; align-items:center; justify-content:center; gap:8px;">
                                <svg class="svg-icon" style="width:20px; height:20px; stroke:#fff;" viewBox="0 0 24 24"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>
                                <span>çœŸå®è¯­éŸ³è¯†åˆ«</span>
                            </button>
                            <button onclick="startTextToVoice()" style="padding: 15px; background: #34c759; color: white; border: none; border-radius: 8px; font-size: 16px; display:flex; align-items:center; justify-content:center; gap:8px;">
                                <svg class="svg-icon" style="width:20px; height:20px; stroke:#fff;" viewBox="0 0 24 24"><path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path></svg>
                                <span>æ–‡å­—è½¬è¯­éŸ³æ°”æ³¡</span>
                            </button>
                            <button onclick="closeVoiceModal()" style="padding: 12px; background: #f0f0f0; color: #666; border: none; border-radius: 8px; font-size: 14px;">
                                å–æ¶ˆ
                            </button>
                        </div>
                    </div>
                `;
            }
            
            document.body.appendChild(modal);
        }
        
        // âœ… è”æœºå¥½å‹è¯­éŸ³å½•åˆ¶å˜é‡
        let onlineVoiceRecorder = null;
        let onlineVoiceChunks = [];
        let onlineVoiceStartTime = 0;
        let onlineVoiceTimer = null;
        
        // å¼€å§‹è”æœºè¯­éŸ³å½•åˆ¶
        async function startOnlineVoiceRecord() {
            const btn = document.getElementById('btn-start-record');
            const statusDiv = document.getElementById('voice-record-status');
            const timeDiv = document.getElementById('voice-record-time');
            
            // å¦‚æœæ­£åœ¨å½•éŸ³ï¼Œåˆ™åœæ­¢
            if (onlineVoiceRecorder && onlineVoiceRecorder.state === 'recording') {
                stopOnlineVoiceRecord();
                return;
            }
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                onlineVoiceRecorder = new MediaRecorder(stream);
                onlineVoiceChunks = [];
                onlineVoiceStartTime = Date.now();
                
                onlineVoiceRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                        onlineVoiceChunks.push(e.data);
                    }
                };
                
                onlineVoiceRecorder.onstop = async () => {
                    stream.getTracks().forEach(track => track.stop());
                    clearInterval(onlineVoiceTimer);
                    
                    const duration = Math.round((Date.now() - onlineVoiceStartTime) / 1000);
                    const blob = new Blob(onlineVoiceChunks, { type: 'audio/webm' });
                    
                    // è·å–é€‰æ‹©çš„å˜å£°æ•ˆæœ
                    const effectRadio = document.querySelector('input[name="voice-effect"]:checked');
                    const effect = effectRadio ? effectRadio.value : 'normal';
                    
                    statusDiv.innerHTML = '<div style="color: var(--ins-pink);">â³ æ­£åœ¨å¤„ç†...</div>';
                    
                    // å¤„ç†å˜å£°å¹¶å‘é€
                    await processAndSendVoice(blob, effect, duration);
                };
                
                onlineVoiceRecorder.start();
                
                // æ›´æ–°UI
                btn.textContent = 'â¹ï¸ åœæ­¢å½•éŸ³';
                btn.style.background = '#ff3b30';
                timeDiv.style.display = 'block';
                statusDiv.querySelector('div').textContent = 'ğŸ”´ æ­£åœ¨å½•éŸ³...';
                
                // è®¡æ—¶å™¨
                onlineVoiceTimer = setInterval(() => {
                    const elapsed = Math.round((Date.now() - onlineVoiceStartTime) / 1000);
                    const min = Math.floor(elapsed / 60).toString().padStart(2, '0');
                    const sec = (elapsed % 60).toString().padStart(2, '0');
                    timeDiv.textContent = `${min}:${sec}`;
                }, 1000);
                
            } catch (err) {
                console.error('å½•éŸ³å¤±è´¥:', err);
                alert('æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·ç¡®ä¿å·²æˆäºˆæƒé™');
            }
        }
        
        // åœæ­¢è”æœºè¯­éŸ³å½•åˆ¶
        function stopOnlineVoiceRecord() {
            if (onlineVoiceRecorder && onlineVoiceRecorder.state === 'recording') {
                onlineVoiceRecorder.stop();
            }
        }
        
        // å¤„ç†å˜å£°å¹¶å‘é€è¯­éŸ³
        async function processAndSendVoice(blob, effect, duration) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const arrayBuffer = await blob.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                // æ ¹æ®æ•ˆæœè®¾ç½®å‚æ•°
                let pitchRate = 1.0;
                switch (effect) {
                    case 'loli':    pitchRate = 1.4; break;  // èè‰éŸ³ï¼šæé«˜éŸ³è°ƒ
                    case 'uncle':   pitchRate = 0.7; break;  // å¤§å”éŸ³ï¼šé™ä½éŸ³è°ƒ
                    case 'robot':   pitchRate = 1.0; break;  // æœºå™¨äººï¼šç‰¹æ®Šå¤„ç†
                    default:        pitchRate = 1.0; break;
                }
                
                // åˆ›å»ºç¦»çº¿éŸ³é¢‘ä¸Šä¸‹æ–‡è¿›è¡Œå¤„ç†
                const offlineContext = new OfflineAudioContext(
                    audioBuffer.numberOfChannels,
                    Math.ceil(audioBuffer.length / pitchRate),
                    audioBuffer.sampleRate
                );
                
                const source = offlineContext.createBufferSource();
                source.buffer = audioBuffer;
                source.playbackRate.value = pitchRate;
                
                // æœºå™¨äººæ•ˆæœï¼šæ·»åŠ æ³¢å½¢è°ƒåˆ¶
                if (effect === 'robot') {
                    const oscillator = offlineContext.createOscillator();
                    const gainNode = offlineContext.createGain();
                    oscillator.frequency.value = 50;
                    gainNode.gain.value = 0.3;
                    oscillator.connect(gainNode);
                    gainNode.connect(offlineContext.destination);
                    oscillator.start();
                }
                
                source.connect(offlineContext.destination);
                source.start();
                
                const renderedBuffer = await offlineContext.startRendering();
                
                // å°†å¤„ç†åçš„éŸ³é¢‘è½¬ä¸º base64
                const wavBlob = await audioBufferToWav(renderedBuffer);
                const base64 = await blobToBase64(wavBlob);
                
                // è®¡ç®—å®é™…æ—¶é•¿
                const actualDuration = Math.ceil(duration / pitchRate);
                
                // å‘é€è¯­éŸ³æ¶ˆæ¯
                await sendOnlineVoiceMessage(base64, actualDuration, effect);
                
                closeVoiceModal();
                
            } catch (err) {
                console.error('è¯­éŸ³å¤„ç†å¤±è´¥:', err);
                alert('è¯­éŸ³å¤„ç†å¤±è´¥: ' + err.message);
            }
        }
        
        // AudioBuffer è½¬ WAV
        function audioBufferToWav(buffer) {
            const numChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const format = 1; // PCM
            const bitDepth = 16;
            
            const bytesPerSample = bitDepth / 8;
            const blockAlign = numChannels * bytesPerSample;
            
            const data = [];
            for (let i = 0; i < buffer.length; i++) {
                for (let ch = 0; ch < numChannels; ch++) {
                    const sample = buffer.getChannelData(ch)[i];
                    const intSample = Math.max(-1, Math.min(1, sample));
                    data.push(intSample < 0 ? intSample * 0x8000 : intSample * 0x7FFF);
                }
            }
            
            const dataLength = data.length * bytesPerSample;
            const headerLength = 44;
            const totalLength = headerLength + dataLength;
            
            const arrayBuffer = new ArrayBuffer(totalLength);
            const view = new DataView(arrayBuffer);
            
            // WAV header
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            
            writeString(0, 'RIFF');
            view.setUint32(4, totalLength - 8, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, format, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * blockAlign, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitDepth, true);
            writeString(36, 'data');
            view.setUint32(40, dataLength, true);
            
            let offset = 44;
            for (let i = 0; i < data.length; i++, offset += 2) {
                view.setInt16(offset, data[i], true);
            }
            
            return new Blob([arrayBuffer], { type: 'audio/wav' });
        }
        
        // Blob è½¬ Base64
        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }
        
        // å‘é€è”æœºè¯­éŸ³æ¶ˆæ¯
        async function sendOnlineVoiceMessage(audioBase64, duration, effect) {
            if (!currentChatCharId) return;
            
            const char = await db.characters.get(currentChatCharId);
            if (!char || !char.isOnlineFriend) return;
            
            const accountId = getCurrentAccountId();
            
            // ä¿å­˜åˆ°æœ¬åœ°èŠå¤©å†å²
            let history = getChatHistory(char, accountId);
            const msgObj = {
                role: 'user',
                type: 'audio',
                content: audioBase64,
                duration: duration,
                effect: effect,
                time: Date.now()
            };
            history.push(msgObj);
            await setChatHistory(char, accountId, history);
            
            // é€šè¿‡æœåŠ¡å™¨å‘é€ç»™å¯¹æ–¹
            if (char.onlineData?.wx_account && onlineConnected) {
                // è·å–å½“å‰å¯ç”¨çš„åœ¨çº¿è§’è‰²ï¼ˆå¦‚æœæ²¡æœ‰åˆ™è‡ªåŠ¨ä¸Šçº¿ï¼‰
                const onlineUserChar = await getOrCreateOnlineUserChar();
                
                if (onlineUserChar) {
                    const voiceMsg = JSON.stringify({
                        __type: 'audio',
                        audio: audioBase64,
                        duration: duration,
                        effect: effect
                    });
                    sendOnlineMessage(char.onlineData.wx_account, voiceMsg, onlineUserChar.identity.account);
                    console.log('[Online] è¯­éŸ³æ¶ˆæ¯å·²å‘é€');
                }
            }
            
            // åˆ·æ–°èŠå¤©ç•Œé¢
            renderChatBody(char);
            showToast('è¯­éŸ³å·²å‘é€');
        }
        
        // æ’­æ”¾è”æœºè¯­éŸ³æ¶ˆæ¯
        let currentPlayingAudio = null;
        function playOnlineAudio(audioId) {
            const audio = document.getElementById(audioId);
            const icon = document.getElementById('icon_' + audioId);
            
            if (!audio) return;
            
            // å¦‚æœæœ‰å…¶ä»–æ­£åœ¨æ’­æ”¾çš„ï¼Œå…ˆåœæ­¢
            if (currentPlayingAudio && currentPlayingAudio !== audio) {
                currentPlayingAudio.pause();
                currentPlayingAudio.currentTime = 0;
            }
            
            if (audio.paused) {
                audio.play();
                currentPlayingAudio = audio;
                if (icon) icon.textContent = 'â¸ï¸';
                
                audio.onended = () => {
                    if (icon) {
                        // æ¢å¤åŸæ¥çš„å›¾æ ‡
                        const bubble = audio.closest('.online-audio-bubble');
                        if (bubble) {
                            const originalIcon = bubble.querySelector('.audio-play-icon');
                            if (originalIcon) originalIcon.textContent = icon.dataset.original || 'ğŸ™ï¸';
                        }
                    }
                    currentPlayingAudio = null;
                };
            } else {
                audio.pause();
                audio.currentTime = 0;
                currentPlayingAudio = null;
                // æ¢å¤å›¾æ ‡
            }
        }

        function closeVoiceModal() {
            const modal = document.getElementById('voice-mode-modal');
            if (modal) modal.remove();
        }

        // çœŸå®è¯­éŸ³è¯†åˆ« - æ”¹è¿›ç‰ˆï¼šè¯†åˆ«åä»¥è¯­éŸ³æ°”æ³¡å½¢å¼å‘é€
        function startRealVoiceInput() {
            closeVoiceModal();
            
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                alert('æŠ±æ­‰ï¼Œæ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«åŠŸèƒ½');
                return;
            }
            
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            const recognition = new SpeechRecognition();
            
            recognition.lang = 'zh-CN';
            recognition.continuous = false;
            recognition.interimResults = false;
            
            // æ˜¾ç¤ºå½•éŸ³ä¸­æç¤º
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.8);
                color: white;
                padding: 20px 30px;
                border-radius: 12px;
                z-index: 10001;
                font-size: 16px;
            `;
            toast.innerHTML = 'ğŸ¤ æ­£åœ¨å½•éŸ³...';
            document.body.appendChild(toast);
            
            recognition.onresult = async (event) => {
                const text = event.results[0][0].transcript;
                toast.innerHTML = 'âœ“ è¯†åˆ«æˆåŠŸï¼';
                
                // å»¶è¿Ÿ500msåå‘é€è¯­éŸ³æ°”æ³¡
                setTimeout(async () => {
                    toast.remove();
                    
                    // ä»¥è¯­éŸ³æ°”æ³¡æ ¼å¼å‘é€
                    const msgContent = `[voice:${text}]`;
                    
                    if (!currentChatCharId) return;
                    const char = await db.characters.get(currentChatCharId);
                    const accountId = getCurrentAccountId();
                    let history = getChatHistory(char, accountId);
                    
                    history.push({
                        role: 'user',
                        content: msgContent,
                        time: Date.now()
                    });
                    
                    await setChatHistory(char, accountId, history);
                    
                    // âœ… ä¼˜åŒ–ï¼šåªè¿½åŠ æ–°æ¶ˆæ¯ï¼Œä¸é‡æ–°æ¸²æŸ“æ•´ä¸ªèŠå¤©
                    await appendMessageToUI('user', msgContent, char.avatar);
                    
                    // âœ… ä¸å†è‡ªåŠ¨è§¦å‘ AI å›å¤ï¼Œéœ€è¦ç”¨æˆ·ç‚¹å‡»"æ¥å—å›å¤"æŒ‰é’®
                    // triggerAiReply();
                }, 500);
            };
            
            recognition.onerror = (event) => {
                console.error('è¯­éŸ³è¯†åˆ«é”™è¯¯:', event.error);
                let errorMsg = 'âŒ è¯†åˆ«å¤±è´¥';
                switch (event.error) {
                    case 'not-allowed':
                    case 'service-not-allowed':
                        errorMsg = 'âŒ éº¦å…‹é£æƒé™è¢«æ‹’ç»\nè¯·åœ¨æµè§ˆå™¨è®¾ç½®ä¸­å…è®¸éº¦å…‹é£è®¿é—®';
                        break;
                    case 'no-speech':
                        errorMsg = 'âŒ æœªæ£€æµ‹åˆ°è¯­éŸ³\nè¯·é è¿‘éº¦å…‹é£è¯´è¯';
                        break;
                    case 'network':
                        errorMsg = 'âŒ ç½‘ç»œé”™è¯¯\nè¯­éŸ³è¯†åˆ«éœ€è¦è”ç½‘ï¼ˆChromeéœ€è¿æ¥è°·æ­ŒæœåŠ¡ï¼‰';
                        break;
                    case 'audio-capture':
                        errorMsg = 'âŒ æœªæ‰¾åˆ°éº¦å…‹é£\nè¯·æ£€æŸ¥éº¦å…‹é£æ˜¯å¦æ­£ç¡®è¿æ¥';
                        break;
                    case 'aborted':
                        errorMsg = 'âŒ è¯†åˆ«å·²å–æ¶ˆ';
                        break;
                    default:
                        errorMsg = `âŒ è¯†åˆ«å¤±è´¥: ${event.error}`;
                }
                toast.innerHTML = errorMsg.replace(/\n/g, '<br>');
                toast.style.textAlign = 'center';
                toast.style.lineHeight = '1.6';
                setTimeout(() => toast.remove(), 3000);
            };
            
            recognition.onend = () => {
                setTimeout(() => {
                    if (toast.parentNode) toast.remove();
                }, 500);
            };
            
            recognition.start();
        }

        // æ–‡å­—è½¬è¯­éŸ³æ°”æ³¡
        function startTextToVoice() {
            closeVoiceModal();
            
            const modal = document.createElement('div');
            modal.id = 'text-to-voice-modal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 12px; padding: 20px; width: 85%; max-width: 350px;">
                    <h3 style="margin: 0 0 15px 0; color: #333;">è¾“å…¥è¯­éŸ³å†…å®¹</h3>
                    <textarea id="voice-text-input" placeholder="è¾“å…¥è¦è½¬æ¢ä¸ºè¯­éŸ³æ°”æ³¡çš„æ–‡å­—..." style="width: 100%; height: 120px; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px; resize: none; box-sizing: border-box;"></textarea>
                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button onclick="sendVoiceBubble()" style="flex: 1; padding: 12px; background: var(--ins-pink); color: white; border: none; border-radius: 8px; font-size: 15px;">
                            å‘é€
                        </button>
                        <button onclick="closeTextToVoiceModal()" style="flex: 1; padding: 12px; background: #f0f0f0; color: #666; border: none; border-radius: 8px; font-size: 15px;">
                            å–æ¶ˆ
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            document.getElementById('voice-text-input').focus();
        }

        function closeTextToVoiceModal() {
            const modal = document.getElementById('text-to-voice-modal');
            if (modal) modal.remove();
        }

        async function sendVoiceBubble() {
            const text = document.getElementById('voice-text-input').value.trim();
            if (!text) {
                alert('è¯·è¾“å…¥å†…å®¹');
                return;
            }
            
            closeTextToVoiceModal();
            
            // å‘é€è¯­éŸ³æ°”æ³¡æ¶ˆæ¯ï¼ˆæ ¼å¼ï¼š[voice:æ–‡å­—å†…å®¹]ï¼‰
            const msgContent = `[voice:${text}]`;
            
            // æ”¯æŒç¾¤èŠæ¨¡å¼
            if (window.currentGroupChatId) {
                const group = await db.group_chats.get(window.currentGroupChatId);
                if (!group) return;
                
                if (!group.chat_history) group.chat_history = [];
                group.chat_history.push({
                    role: 'user',
                    content: msgContent,
                    time: Date.now()
                });
                group.updated_at = Date.now();
                await db.group_chats.put(group);
                
                await renderGroupChatBody(group);
                return;
            }
            
            if (!currentChatCharId) return;
            const char = await db.characters.get(currentChatCharId);
            const accountId = getCurrentAccountId();
            let history = getChatHistory(char, accountId);
            
            history.push({
                role: 'user',
                content: msgContent,
                time: Date.now()
            });
            
            await setChatHistory(char, accountId, history);
            
            // âœ… ä¼˜åŒ–ï¼šåªè¿½åŠ æ–°æ¶ˆæ¯ï¼Œä¸é‡æ–°æ¸²æŸ“æ•´ä¸ªèŠå¤©
            await appendMessageToUI('user', msgContent, char.avatar);
            
            // âœ… ç§»é™¤è‡ªåŠ¨è§¦å‘AIå›å¤
            // triggerAiReply();
        }

        function toggleChatPanel(type) {
            const container = document.getElementById('chat-panel-container');
            const footer = document.getElementById('chat-footer');
            const emojiPanel = document.getElementById('emoji-panel');
            const actionPanel = document.getElementById('action-panel');
            
            // å¦‚æœæ˜¯è¡¨æƒ…é¢æ¿ï¼Œå…ˆåˆå§‹åŒ–
            if (type === 'emoji') initEmojiPanel();

            if (activePanel === type) {
                // å…³é—­å½“å‰
                closeChatPanel();
            } else {
                // æ‰“å¼€æˆ–åˆ‡æ¢
                if (!activePanel) {
                    container.classList.add('open');
                    footer.classList.add('panel-open');
                }
                activePanel = type;
                
                // é»˜è®¤åˆ‡å› Emoji Tab
                if (type === 'emoji') {
                    document.getElementById('emoji-tab-bar').style.display = 'flex';
                    switchEmojiTab('emoji');
                    actionPanel.style.display = 'none';
                } else {
                    document.getElementById('emoji-tab-bar').style.display = 'none';
                    document.getElementById('emoji-panel').style.display = 'none';
                    document.getElementById('sticker-panel').style.display = 'none';
                    actionPanel.style.display = 'grid';
                }
                
                // æ»šåŠ¨åˆ°åº•éƒ¨ï¼Œç¡®ä¿èƒ½çœ‹åˆ°é¢æ¿
                setTimeout(() => {
                    const body = document.getElementById('chat-body');
                    body.scrollTop = body.scrollHeight;
                }, 100);
            }
        }

        function closeChatPanel() {
            if (!activePanel) return;
            const container = document.getElementById('chat-panel-container');
            const footer = document.getElementById('chat-footer');
            
            container.classList.remove('open');
            footer.classList.remove('panel-open');
            activePanel = null;
            
            // ç­‰å¾…åŠ¨ç”»ç»“æŸéšè—å†…å®¹
            setTimeout(() => {
                if (!activePanel) {
                    document.getElementById('emoji-panel').style.display = 'none';
                    document.getElementById('action-panel').style.display = 'none';
                }
            }, 300);
        }

        function handleChatInputChange(input) {
            const hasText = input.value.trim().length > 0;
            const btnMore = document.getElementById('btn-more');
            const btnSend = document.getElementById('btn-send');
            
            if (hasText) {
                btnMore.style.display = 'none';
                btnSend.style.display = 'flex';
                // æ™ºèƒ½è¡¨æƒ…æ¨è
                detectAndSuggestStickers(input.value);
            } else {
                btnMore.style.display = 'flex';
                btnSend.style.display = 'none';
                // éšè—æ¨èæ 
                const suggestionBar = document.getElementById('sticker-suggestion-bar');
                if (suggestionBar) suggestionBar.style.display = 'none';
            }
        }

        // æ˜¾ç¤ºå¿«è¿›æ—¶é—´é€‰æ‹©å¼¹çª—
        function showFastForwardModal() {
            closeChatPanel();
            document.getElementById('fast-forward-modal').style.display = 'flex';
        }

        // ç¡®è®¤å¿«è¿›é€»è¾‘
        async function confirmFastForward() {
            const amount = parseInt(document.getElementById('ff-amount').value);
            const unit = document.getElementById('ff-unit').value;
            
            if (isNaN(amount) || amount <= 0) {
                alert("è¯·è¾“å…¥æœ‰æ•ˆçš„æ—¶é—´æ•°å€¼");
                return;
            }
            
            closeModal('fast-forward-modal');
            
            // 1. è®¡ç®—æ¯«ç§’æ•°å¹¶æ›´æ–°è™šæ‹Ÿæ—¶é—´
            let ms = 0;
            let unitText = '';
            if (unit === 'minute') {
                ms = amount * 60 * 1000;
                unitText = amount + 'åˆ†é’Ÿ';
            } else if (unit === 'hour') {
                ms = amount * 60 * 60 * 1000;
                unitText = amount + 'å°æ—¶';
            } else if (unit === 'day') {
                ms = amount * 24 * 60 * 60 * 1000;
                unitText = amount + 'å¤©';
            }
            
            // 1. æ›´æ–°è™šæ‹Ÿæ—¶é—´åç§»ï¼ˆå¦‚æœæœ‰å½“å‰èŠå¤©ï¼‰
            let char = null;
            if (currentChatCharId) {
                char = await db.characters.get(currentChatCharId);
                if (char) {
                    // æ›´æ–°è™šæ‹Ÿæ—¶é—´åç§»
                    if (!char.timeOffset) char.timeOffset = 0;
                    char.timeOffset += ms;
                    await db.characters.put(char);
                    console.log(`[FastForward] Updated time offset by +${ms}ms (${unitText})`);
                }
            }
            
            // 2. æ£€æŸ¥è¢«æ‹‰é»‘çš„è§’è‰²æ˜¯å¦ä¼šè”ç³»
            await checkBlockedCharactersContact(ms, unitText);
            
            // 3. è§¦å‘ AI å›å¤ï¼ˆåªæœ‰åœ¨æœ‰å½“å‰èŠå¤©æ—¶æ‰è§¦å‘ï¼‰
            if (currentChatCharId && char) {
                const accountId = getCurrentAccountId();
                
                // ğŸ”§ æ·»åŠ æ—¶é—´æˆ³æ¶ˆæ¯åˆ°èŠå¤©è®°å½•ï¼Œæ ‡è®°æ—¶é—´å¿«è¿›
                // é‡æ–°ä»DBè·å–æœ€æ–°çš„charï¼ˆé˜²æ­¢checkBlockedCharactersContactæœŸé—´æœ‰æ–°æ¶ˆæ¯å†™å…¥ï¼‰
                char = await db.characters.get(currentChatCharId);
                if (!char) return;
                const history = getChatHistory(char, accountId);
                // ğŸ”§ ä¿®å¤ï¼šä½¿ç”¨æœ€åä¸€æ¡æ¶ˆæ¯çš„æ—¶é—´+1msï¼Œç¡®ä¿ç³»ç»Ÿæ¶ˆæ¯ç´§è·Ÿåœ¨å·²æœ‰æ¶ˆæ¯ä¹‹å
                // ä¸èƒ½ç”¨ Date.now()ï¼Œå¦åˆ™å’Œåç»­AIå›å¤çš„ Date.now() æ—¶é—´å¤ªæ¥è¿‘ï¼Œæ’åºåä½ç½®ä¸ç¨³å®š
                const lastMsgTime = history.length > 0 ? (history[history.length - 1].time || 0) : 0;
                const newTime = lastMsgTime + 1; // ç´§è·Ÿæœ€åä¸€æ¡æ¶ˆæ¯ï¼Œä¸€å®šæ’åœ¨AIå›å¤ä¹‹å‰
                const timeSkipMsg = `æ—¶é—´è¿‡å»äº† ${unitText}`;
                history.push({
                    role: 'system',
                    content: timeSkipMsg,
                    time: newTime,
                    isTimeSkip: true
                });
                await setChatHistory(char, accountId, history);
                
                // ğŸ”§ ç«‹å³æ˜¾ç¤ºæ—¶é—´æˆ³åˆ° UI
                appendMessageToUI('system', timeSkipMsg);
                
                // é‡æ–°è·å–æ›´æ–°åçš„ char
                char = await db.characters.get(currentChatCharId);
                
                // è§¦å‘ AI å›å¤ï¼Œå‘Šè¯‰è§’è‰²æ—¶é—´è¿‡å»äº†å¤šä¹…
                await triggerAiReply(`æ—¶é—´å¿«è¿›äº† ${unitText}ã€‚è¯·æ ¹æ®è¿™æ®µæ—¶é—´çš„æµé€ï¼Œè‡ªç„¶åœ°ç»§ç»­å¯¹è¯ã€‚`);
            } else {
                console.warn('[FastForward] æ²¡æœ‰å½“å‰èŠå¤©ï¼Œè·³è¿‡AIå›å¤');
            }
        }

        // æ£€æŸ¥è¢«æ‹‰é»‘çš„è§’è‰²æ˜¯å¦ä¼šè”ç³»ç”¨æˆ·ï¼ˆä½¿ç”¨æ–°ç‰ˆæœ¬é€»è¾‘ï¼‰
        async function checkBlockedCharactersContact(elapsedMs, elapsedText) {
            const accountId = getCurrentAccountId();
            if (!accountId) {
                console.log('[BlockedContact] æ²¡æœ‰å½“å‰è´¦å·');
                return;
            }
            
            // è·å–æ‰€æœ‰è¢«æ‹‰é»‘çš„è§’è‰²
            const allChars = await db.characters.toArray();
            const blockedChars = allChars.filter(char => {
                const status = getFriendStatus(char, accountId);
                return status === 'blocked';
            });
            
            console.log(`[BlockedContact] æ‰¾åˆ° ${blockedChars.length} ä¸ªè¢«æ‹‰é»‘çš„è§’è‰²`);
            
            if (blockedChars.length === 0) return;
            
            // è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯
            const myChar = await db.characters.get(parseInt(accountId));
            if (!myChar) {
                console.log('[BlockedContact] æ‰¾ä¸åˆ°ç”¨æˆ·ä¿¡æ¯');
                return;
            }
            
            // åŸºå‡†æ—¶é—´
            const baseTime = Date.now() + (blockedChars[0].timeOffset || 0);

            for (const char of blockedChars) {
                try {
                    console.log(`\n========== å¼€å§‹æ£€æŸ¥è§’è‰²: ${char.name} ==========`);
                    
                    // 1. è·å–æŒ‡ä»¤æ–‡æœ¬ï¼ˆä¼ å…¥elapsedMsç”¨äºè®¡ç®—æ•°é‡ï¼‰
                    let instructionText = await checkIfCharacterWillContact(char, myChar, elapsedText, elapsedMs);
                    
                    console.log(`[BlockedContact] ${char.name} è¿”å›çš„æŒ‡ä»¤æ–‡æœ¬:\n${instructionText}`);
                    
                    // 2. è§£ææŒ‡ä»¤ï¼ˆæ”¯æŒæ–°æ ¼å¼ï¼‰
                    let actions = parseContactInstructionsV2(instructionText);
                    
                    console.log(`[BlockedContact] ${char.name} è§£æå‡º ${actions.length} æ¡æŒ‡ä»¤:`, JSON.stringify(actions, null, 2));
                    
                    // å¦‚æœæ²¡æœ‰æŒ‡ä»¤ï¼Œè¯´æ˜è§’è‰²å†³å®šä¸è”ç³»
                    if (actions.length === 0) {
                        console.log(`[BlockedContact] ${char.name} å†³å®šä¸è”ç³»ç”¨æˆ·`);
                        continue;
                    }

                    // 3. æ‰§è¡ŒæŒ‡ä»¤
                    console.log(`[BlockedContact] å¼€å§‹æ‰§è¡Œ ${char.name} çš„ ${actions.length} æ¡æŒ‡ä»¤`);
                    
                    // èµ·å§‹æ—¶é—´ç‚¹ç¨å¾®éšæœºä¸€ç‚¹
                    let actionBaseTime = baseTime - elapsedMs + Math.floor(Math.random() * 60000);
                    let notificationDelay = 0; // é€šçŸ¥å»¶è¿Ÿç´¯è®¡

                    for (const action of actions) {
                        if (action.type === 'CALL') {
                            const count = parseInt(action.params.count) || 1;
                            console.log(`[BlockedContact] ç”Ÿæˆ ${count} é€šæœªæ¥æ¥ç”µ`);
                            
                            // åœ¨æ•´ä¸ªæ—¶é—´æ®µå†…éšæœºåˆ†å¸ƒ
                            const callTimes = [];
                            for (let i = 0; i < count; i++) {
                                const randomTime = actionBaseTime + Math.random() * elapsedMs;
                                callTimes.push(randomTime);
                            }
                            // æŒ‰æ—¶é—´æ’åº
                            callTimes.sort((a, b) => a - b);
                            
                            // åˆ›å»ºç”µè¯è®°å½•
                            for (const callTime of callTimes) {
                                await createBlockedCallRecord(char, myChar, accountId, callTime);
                            }
                            
                            // ğŸ¯ é€æ¡æ˜¾ç¤ºé€šçŸ¥ï¼Œæ¯æ¡é—´éš”500ms
                            for (let i = 0; i < callTimes.length; i++) {
                                const delay = notificationDelay + i * 500;
                                setTimeout(() => {
                                    showBlockedCallNotification(char, callTimes[i]);
                                }, delay);
                            }
                            notificationDelay += callTimes.length * 500;
                        } else if (action.type === 'SMS') {
                            const messages = action.params.messages || [];
                            console.log(`[BlockedContact] ç”Ÿæˆ ${messages.length} æ¡çŸ­ä¿¡`);
                            
                            // æ¯æ¡çŸ­ä¿¡åœ¨æ—¶é—´æ®µå†…éšæœºåˆ†å¸ƒ
                            const smsTimes = [];
                            for (let i = 0; i < messages.length; i++) {
                                const randomTime = actionBaseTime + Math.random() * elapsedMs;
                                smsTimes.push({ time: randomTime, content: messages[i] });
                            }
                            // æŒ‰æ—¶é—´æ’åº
                            smsTimes.sort((a, b) => a.time - b.time);
                            
                            // åˆ›å»ºçŸ­ä¿¡è®°å½•
                            for (const sms of smsTimes) {
                                await createBlockedMessageRecord(char, myChar, accountId, sms.time, sms.content);
                            }
                            
                            // ğŸ¯ å°†æ‰€æœ‰çŸ­ä¿¡é€šçŸ¥åŠ å…¥é˜Ÿåˆ—ï¼Œé˜Ÿåˆ—ç³»ç»Ÿä¼šç¡®ä¿ä¸€æ¡ä¸€æ¡æ˜¾ç¤º
                            for (let i = 0; i < smsTimes.length; i++) {
                                showBlockedSmsNotification(char, smsTimes[i].content, smsTimes[i].time);
                            }
                        }
                    }
                    
                    console.log(`[BlockedContact] âœ… ${char.name} çš„è”ç³»è®°å½•ç”Ÿæˆå®Œæˆ`);
                    console.log(`========== ç»“æŸæ£€æŸ¥è§’è‰²: ${char.name} ==========\n`);
                    
                } catch (error) {
                    console.error(`[BlockedContact] âŒ æ£€æŸ¥ ${char.name} æ—¶å‡ºé”™:`, error);
                    // ğŸ”§ æ”¹è¿›ï¼šç»§ç»­å¤„ç†å…¶ä»–è§’è‰²ï¼Œä¸è¦ä¸­æ–­æ•´ä¸ªæµç¨‹
                    console.warn(`[BlockedContact] è·³è¿‡ ${char.name}ï¼Œç»§ç»­å¤„ç†å…¶ä»–è§’è‰²`);
                    continue;
                }
            }
            
            console.log('[BlockedContact] æ‰€æœ‰æŒ‡ä»¤æ‰§è¡Œå®Œæ¯•');
        }

        // æ·»åŠ è¶…æ—¶åŠŸèƒ½çš„fetch
        async function fetchWithTimeout(url, options, timeout = 30000) {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeout);
            
            try {
                const response = await fetch(url, {
                    ...options,
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                return response;
            } catch (error) {
                clearTimeout(timeoutId);
                if (error.name === 'AbortError') {
                    throw new Error('è¯·æ±‚è¶…æ—¶');
                }
                throw error;
            }
        }
        
        // è°ƒç”¨APIåˆ¤æ–­è§’è‰²æ˜¯å¦ä¼šè”ç³»ï¼ˆè¿”å›æŒ‡ä»¤æ–‡æœ¬ï¼‰- ä½¿ç”¨callAIå‡½æ•°
        async function checkIfCharacterWillContact(char, myChar, elapsedText, elapsedMs) {
            console.log(`[BlockedContact] å¼€å§‹è¯·æ±‚ ${char.name} çš„è”ç³»æŒ‡ä»¤...`);
            
            // ğŸ¯ æ ¹æ®å¿«è¿›æ—¶é—´è®¡ç®—åˆç†çš„è”ç³»æ¬¡æ•°
            const hours = elapsedMs / (60 * 60 * 1000);
            let suggestedCallCount, suggestedSmsCount;
            
            if (hours < 1) {
                // ä¸åˆ°1å°æ—¶ï¼šå°‘é‡
                suggestedCallCount = Math.floor(Math.random() * 3) + 1; // 1-3é€š
                suggestedSmsCount = Math.floor(Math.random() * 5) + 3; // 3-7æ¡
            } else if (hours < 6) {
                // 1-6å°æ—¶ï¼šä¸­ç­‰
                suggestedCallCount = Math.floor(Math.random() * 5) + 3; // 3-7é€š
                suggestedSmsCount = Math.floor(Math.random() * 6) + 5; // 5-10æ¡
            } else if (hours < 24) {
                // 6-24å°æ—¶ï¼šè¾ƒå¤š
                suggestedCallCount = Math.floor(Math.random() * 8) + 5; // 5-12é€š
                suggestedSmsCount = Math.floor(Math.random() * 8) + 8; // 8-15æ¡
            } else {
                // è¶…è¿‡1å¤©ï¼šå¾ˆå¤š
                suggestedCallCount = Math.floor(Math.random() * 8) + 8; // 8-15é€š
                suggestedSmsCount = Math.floor(Math.random() * 6) + 10; // 10-15æ¡
            }
            
            // ğŸ”¥ ä¿®å¤ï¼šè·å–å®Œæ•´çš„èŠå¤©å†å²ä½œä¸ºä¸Šä¸‹æ–‡ï¼ˆåŒ…æ‹¬å¾®ä¿¡å’ŒçŸ­ä¿¡ï¼‰
            const accountId = getCurrentAccountId();
            
            // 1. è·å–å¾®ä¿¡èŠå¤©å†å²
            const chatHistory = getChatHistory(char, accountId);
            const wechatMessages = chatHistory.slice(-5).map(m => {
                const role = m.role === 'user' ? myChar.name : char.name;
                return `[å¾®ä¿¡] ${role}: ${m.content}`;
            });
            
            // 2. è·å–çŸ­ä¿¡å†å²ï¼ˆä¹‹å‰å¿«è¿›ç”Ÿæˆçš„ï¼‰
            const smsMessages = await db.sms_messages
                .where('accountId').equals(accountId)
                .toArray();
            
            // æ‰¾åˆ°ä¸è¯¥è§’è‰²ç›¸å…³çš„çŸ­ä¿¡ï¼ˆå‘é€è€…æ˜¯è§’è‰² æˆ– æ¥æ”¶è€…æ˜¯è§’è‰²ï¼‰
            const charPhoneNumber = char.identity?.phone || generateVirtualPhoneNumber(char.id);
            const relevantSms = smsMessages.filter(sms => {
                // å‘é€çš„çŸ­ä¿¡ï¼šnumberå­—æ®µæ˜¯æ¥æ”¶è€…
                // æ¥æ”¶çš„çŸ­ä¿¡ï¼šsenderå­—æ®µæ˜¯å‘é€è€…
                if (sms.type === 'sent') {
                    return sms.number === charPhoneNumber || sms.receiverName === char.name;
                } else {
                    return sms.sender === char.name || sms.charId === char.id;
                }
            });
            
            // æŒ‰æ—¶é—´æ’åºï¼Œå–æœ€è¿‘çš„10æ¡çŸ­ä¿¡
            relevantSms.sort((a, b) => (a.time || 0) - (b.time || 0));
            const recentSms = relevantSms.slice(-10).map(sms => {
                const role = sms.type === 'sent' ? myChar.name : char.name;
                return `[çŸ­ä¿¡] ${role}: ${sms.content}`;
            });
            
            // 3. åˆå¹¶æ‰€æœ‰å†å²æ¶ˆæ¯ï¼ˆå¾®ä¿¡ + çŸ­ä¿¡ï¼‰ï¼Œæœ€å¤šå–æœ€è¿‘15æ¡
            const allMessages = [...wechatMessages, ...recentSms].slice(-15);
            const recentMessages = allMessages.join('\n');
            
            console.log(`[BlockedContact] ${char.name} çš„ä¸Šä¸‹æ–‡æ¶ˆæ¯æ•°:`, allMessages.length);
            console.log(`[BlockedContact]   - å¾®ä¿¡æ¶ˆæ¯: ${wechatMessages.length} æ¡`);
            console.log(`[BlockedContact]   - çŸ­ä¿¡æ¶ˆæ¯: ${recentSms.length} æ¡`);
            
            // ğŸ¯ å¢å¼ºç‰ˆæç¤ºè¯ï¼šæ›´è´´åˆè§’è‰²äººè®¾å’Œè¢«æ‹‰é»‘æƒ…æ™¯
            const prompt = `ã€è§’è‰²æ‰®æ¼”ä»»åŠ¡ã€‘
ä½ ç°åœ¨æ˜¯ã€Œ${char.name}ã€ï¼Œè¯·å®Œå…¨ä»£å…¥è¿™ä¸ªè§’è‰²ã€‚
âš ï¸ é‡è¦ï¼šä½ çš„åå­—æ˜¯${char.name}ï¼Œä½ ä¸æ˜¯ç”¨æˆ·ï¼Œä½ ä¸æ˜¯${myChar?.name || 'å¯¹æ–¹'}ï¼ä½ æ˜¯ç‹¬ç«‹çš„è§’è‰²ã€‚

ã€ä½ çš„äººè®¾ã€‘
${char.description || char.desc || 'ä¸€ä¸ªæ™®é€šäºº'}

ã€å¯¹æ–¹ä¿¡æ¯ã€‘
åå­—ï¼š${myChar.name}
${myChar.description ? `ç®€ä»‹ï¼š${myChar.description.substring(0, 200)}` : ''}

ã€å®Œæ•´çš„èŠå¤©å†å²è®°å½•ã€‘
${recentMessages || 'ï¼ˆæ— è®°å½•ï¼‰'}

${recentSms.length > 0 ? `
âš ï¸ é‡è¦æç¤ºï¼šä¸Šé¢çš„ã€çŸ­ä¿¡ã€‘è®°å½•æ˜¯ä½ ä¹‹å‰å·²ç»å‘é€è¿‡çš„ï¼
ä½ éœ€è¦åŸºäºè¿™äº›å·²å‘é€çš„çŸ­ä¿¡ï¼Œè€ƒè™‘ï¼š
- å¯¹æ–¹ä¾ç„¶æ²¡æœ‰å›åº”ä½ 
- ä½ çš„æƒ…ç»ªå¦‚ä½•è¿›ä¸€æ­¥å‘å±•ï¼Ÿ
- ç°åœ¨åˆè¿‡å»äº† ${elapsedText}ï¼Œä½ ä¼šåšä»€ä¹ˆï¼Ÿ
` : ''}

ã€å½“å‰æƒ…å¢ƒã€‘
ä½ ${recentSms.length > 0 ? 'ä¹‹å‰' : 'çªç„¶'}å‘ç°è‡ªå·±è¢«ã€Œ${myChar.name}ã€æ‹‰é»‘äº†ï¼
å¾®ä¿¡æ¶ˆæ¯å‘ä¸å‡ºå»ï¼Œå¥½å‹ç”³è¯·çŸ³æ²‰å¤§æµ·ï¼Œå¯¹æ–¹å½»åº•å°†ä½ å±è”½ã€‚
${recentSms.length > 0 ? `åœ¨ä¹‹å‰çš„æ—¶é—´é‡Œï¼Œä½ å·²ç»å°è¯•è”ç³»è¿‡å¯¹æ–¹ï¼ˆè§ä¸Šé¢çš„ã€çŸ­ä¿¡ã€‘è®°å½•ï¼‰ï¼Œä½†ä¾ç„¶æ²¡æœ‰ä»»ä½•å›åº”ã€‚` : ''}
ç°åœ¨åˆè¿‡å»äº† ${elapsedText}ã€‚

ã€ä½ éœ€è¦æ€è€ƒã€‘
1. ${recentSms.length > 0 ? 'å¯¹æ–¹è¿˜æ˜¯ä¸å›åº”ä½ ï¼Œä½ ç°åœ¨çš„å¿ƒæ€æœ‰ä»€ä¹ˆå˜åŒ–ï¼Ÿ' : 'ä»¥ä½ çš„æ€§æ ¼ï¼Œè¢«è¿™ä¸ªäººæ‹‰é»‘åä¼šæœ‰ä»€ä¹ˆååº”ï¼Ÿ'}
2. ${recentSms.length > 0 ? 'ä½ ä¼šç»§ç»­è”ç³»ï¼Ÿè¿˜æ˜¯æ”¾å¼ƒäº†ï¼Ÿæƒ…ç»ªä¼šä»ä¹‹å‰çš„çŠ¶æ€å¦‚ä½•è½¬å˜ï¼Ÿ' : 'ä½ ä¼šæ„Ÿåˆ°æ„¤æ€’ï¼Ÿæ‚²ä¼¤ï¼Ÿä¸ç”˜ï¼Ÿå›°æƒ‘ï¼Ÿç»æœ›ï¼Ÿé‡Šç„¶ï¼Ÿè¿˜æ˜¯å…¶ä»–æƒ…ç»ªï¼Ÿ'}
3. ${recentSms.length > 0 ? 'å¦‚æœç»§ç»­è”ç³»ï¼Œä½ çš„è¯­æ°”å’Œå†…å®¹ä¼šå’Œä¹‹å‰æœ‰ä»€ä¹ˆä¸åŒï¼Ÿ' : 'ä½ ä¼šé€‰æ‹©ç–¯ç‹‚æ‰“ç”µè¯ï¼Ÿå‘çŸ­ä¿¡è´¨é—®ï¼Ÿå†·é™ç­‰å¾…ï¼Ÿè¿˜æ˜¯ç›´æ¥æ”¾å¼ƒï¼Ÿ'}
4. éšç€æ—¶é—´æ¨ç§»å’Œå¯¹æ–¹çš„æŒç»­ä¸å›åº”ï¼Œä½ çš„æƒ…ç»ªåº”è¯¥æœ‰æ˜æ˜¾çš„å˜åŒ–å’Œå±‚æ¬¡ï¼ˆæ¯”å¦‚ä»æ„¤æ€’åˆ°æ‚²ä¼¤ï¼Œä»è´¨é—®åˆ°å“€æ±‚ï¼Œä»ä¸ç”˜åˆ°é‡Šç„¶ï¼Œæˆ–è€…ä»å“€æ±‚åˆ°æ„¤æ€’...ï¼‰

ã€è¾“å‡ºè¦æ±‚ã€‘
æ ¹æ®ä½ çš„æ€§æ ¼å’Œä¸å¯¹æ–¹çš„å…³ç³»ï¼Œå†³å®šæ˜¯å¦ä¼šé€šè¿‡ç”µè¯/çŸ­ä¿¡è”ç³»å¯¹æ–¹ã€‚

å¦‚æœä½ ä¼šè”ç³»ï¼ŒæŒ‰ä»¥ä¸‹æ ¼å¼è¾“å‡ºï¼š

[CALL]
count: ${suggestedCallCount}
interval: éšæœºåˆ†å¸ƒ

[SMS]
messages:
- ç¬¬1æ¡çŸ­ä¿¡ï¼ˆè¦æœ‰æƒ…ç»ªï¼Œç¬¦åˆä½ çš„æ€§æ ¼ï¼‰
- ç¬¬2æ¡çŸ­ä¿¡ï¼ˆæƒ…ç»ªå¯èƒ½å˜åŒ–ï¼‰
- ç¬¬3æ¡çŸ­ä¿¡ï¼ˆç»§ç»­æ¨è¿›æƒ…ç»ªï¼‰
...ï¼ˆå…±${suggestedSmsCount}æ¡ï¼‰

ã€çŸ­ä¿¡å†…å®¹è¦æ±‚ã€‘
- æ¯æ¡çŸ­ä¿¡è¦ç®€çŸ­æœ‰åŠ›ï¼ŒåƒçœŸå®çŸ­ä¿¡ä¸€æ ·ï¼ˆ5-20å­—æœ€ä½³ï¼‰
- æƒ…ç»ªè¦æœ‰å±‚æ¬¡å’Œå˜åŒ–ï¼Œä¸è¦ä¸€æˆä¸å˜
- å¯ä»¥åŒ…å«ï¼šè´¨é—®ã€å“€æ±‚ã€æ„¤æ€’ã€å¨èƒã€é“æ­‰ã€å›å¿†ã€ä¸èˆã€æ”¾ç‹ è¯ã€æœ€åé€šç‰’ç­‰
- ç¬¦åˆä½ çš„äººè®¾å’Œè¯´è¯é£æ ¼ï¼Œç”¨ä½ å¹³æ—¶çš„è¯­æ°”
- å¯ä»¥æœ‰é”™åˆ«å­—ã€è¯­æ°”è¯ã€è¡¨æƒ…ç¬¦å·ï¼Œæ›´çœŸå®
- å¦‚æœå…³ç³»äº²å¯†ï¼Œå¯ä»¥æ›´æ¿€çƒˆï¼›å¦‚æœå…³ç³»ä¸€èˆ¬ï¼Œå¯ä»¥æ›´å…‹åˆ¶
${recentSms.length > 0 ? `- âš ï¸ é‡è¦ï¼šä¸è¦é‡å¤ä¸Šé¢ã€çŸ­ä¿¡ã€‘ä¸­å·²ç»å‘é€è¿‡çš„å†…å®¹ï¼è¦åŸºäºä¹‹å‰çš„çŸ­ä¿¡ç»§ç»­æ¨è¿›æƒ…ç»ªå’Œå¯¹è¯ï¼Œå±•ç°æƒ…ç»ªçš„å˜åŒ–å’Œå‘å±•` : ''}

å¦‚æœä½ å†³å®šä¸è”ç³»ï¼ˆæ¯”å¦‚ä½ å¾ˆéª„å‚²/æ— æ‰€è°“/å·²ç»é‡Šç„¶/æˆ–è€…å·²ç»è¯´å®Œæƒ³è¯´çš„è¯ï¼‰ï¼Œç›´æ¥è¿”å›ï¼šä¸è”ç³»`;

            // ğŸ¯ ä½¿ç”¨callAIå‡½æ•°
            const response = await callAI([
                { role: 'user', content: prompt }
            ]);
            
            console.log(`[BlockedContact] ${char.name} AIè¿”å›:`, response);
            return response.trim();
        }

        // è§£ææŒ‡ä»¤æ–‡æœ¬ï¼ˆæ–°ç‰ˆæœ¬ï¼Œæ”¯æŒå¤šæ¡çŸ­ä¿¡ï¼‰
        function parseContactInstructionsV2(text) {
            const lines = text.split('\n');
            const actions = [];
            let currentAction = null;
            let collectingMessages = false;
            const messages = [];
            
            lines.forEach(line => {
                line = line.trim();
                if (!line) return;
                
                if (line === '[CALL]') {
                    if (currentAction) {
                        if (collectingMessages && messages.length > 0) {
                            currentAction.params.messages = messages.slice();
                        }
                        actions.push(currentAction);
                    }
                    currentAction = { type: 'CALL', params: {} };
                    collectingMessages = false;
                } else if (line === '[SMS]') {
                    if (currentAction) {
                        if (collectingMessages && messages.length > 0) {
                            currentAction.params.messages = messages.slice();
                        }
                        actions.push(currentAction);
                    }
                    currentAction = { type: 'SMS', params: {} };
                    collectingMessages = false;
                    messages.length = 0;
                } else if (currentAction) {
                    if (line.startsWith('messages:')) {
                        collectingMessages = true;
                    } else if (collectingMessages) {
                        // æ”¶é›†çŸ­ä¿¡å†…å®¹
                        // æ ¼å¼ï¼š- çŸ­ä¿¡å†…å®¹ æˆ– æ•°å­—. çŸ­ä¿¡å†…å®¹
                        let content = line;
                        if (line.startsWith('- ')) {
                            content = line.substring(2).trim();
                        } else if (/^\d+\.?\s+/.test(line)) {
                            content = line.replace(/^\d+\.?\s+/, '').trim();
                        }
                        if (content) {
                            messages.push(content);
                        }
                    } else if (line.includes(':')) {
                        const firstColonIndex = line.indexOf(':');
                        const key = line.substring(0, firstColonIndex).trim();
                        const value = line.substring(firstColonIndex + 1).trim();
                        currentAction.params[key] = value;
                    }
                }
            });
            
            if (currentAction) {
                if (collectingMessages && messages.length > 0) {
                    currentAction.params.messages = messages.slice();
                }
                actions.push(currentAction);
            }
            
            return actions;
        }

        // è§£ææŒ‡ä»¤æ–‡æœ¬
        function parseContactInstructions(text) {
            const lines = text.split('\n');
            const actions = [];
            let currentAction = null;

            lines.forEach(line => {
                line = line.trim();
                if (!line) return;

                if (line === '[CALL]') {
                    if (currentAction) actions.push(currentAction);
                    currentAction = { type: 'CALL', params: {} };
                } else if (line === '[SMS]') {
                    if (currentAction) actions.push(currentAction);
                    currentAction = { type: 'SMS', params: {} };
                } else if (currentAction && line.includes(':')) {
                    const firstColonIndex = line.indexOf(':');
                    const key = line.substring(0, firstColonIndex).trim();
                    const value = line.substring(firstColonIndex + 1).trim();
                    currentAction.params[key] = value;
                }
            });
            if (currentAction) actions.push(currentAction);
            return actions;
        }

        // åˆ›å»ºè¢«æ‹‰é»‘è§’è‰²çš„ç”µè¯è®°å½•
        async function createBlockedCallRecord(char, myChar, accountId, callTime) {
            // å°†ç”µè¯è®°å½•å†™å…¥ Dexie æ•°æ®åº“
            const phoneNumber = char.identity?.phone || generateVirtualPhoneNumber(char.id);
            
            await db.phone_recents.add({
                accountId: accountId,
                charId: char.id,
                name: char.nick || char.name,
                number: phoneNumber,
                time: callTime,
                type: 'missed', // æœªæ¥ç”µè¯
                isBlocked: true // æ ‡è®°ä¸ºæ‹‰é»‘
            });
            
            // é™åˆ¶æ¯ä¸ªè´¦å·æœ€å¤šä¿ç•™100æ¡ç”µè¯è®°å½•
            const count = await db.phone_recents.where('accountId').equals(accountId).count();
            if (count > 100) {
                const oldest = await db.phone_recents.where('accountId').equals(accountId).sortBy('time');
                const toDelete = oldest.slice(0, count - 100);
                await db.phone_recents.bulkDelete(toDelete.map(r => r.id));
            }
            
            // æ˜¾ç¤ºç”µè¯é€šçŸ¥
            showBlockedCallNotification(char, callTime);
        }

        // åˆ›å»ºè¢«æ‹‰é»‘è§’è‰²çš„çŸ­ä¿¡è®°å½• (ä¿®æ”¹æ”¯æŒä¼ å…¥å†…å®¹)
        async function createBlockedMessageRecord(char, myChar, accountId, messageTime, contentOverride = null) {
            try {
                // å¦‚æœæ²¡æœ‰ä¼ å…¥å†…å®¹ï¼Œæ‰è°ƒç”¨APIç”Ÿæˆ (å…¼å®¹æ—§é€»è¾‘ï¼Œè™½ç„¶ç°åœ¨åŸºæœ¬éƒ½ä¼ å…¥äº†)
                let messageContent = contentOverride;
                if (!messageContent) {
                    messageContent = await generateBlockedMessage(char, myChar);
                }
                
                // å°†çŸ­ä¿¡å†™å…¥ Dexie æ•°æ®åº“
                const phoneNumber = char.identity?.phone || generateVirtualPhoneNumber(char.id);
                
                await db.sms_messages.add({
                    accountId: accountId,
                    charId: char.id,
                    sender: char.nick || char.name,
                    number: phoneNumber,
                    content: messageContent,
                    time: messageTime,
                    read: false,
                    isBlocked: true
                });
                
                // é™åˆ¶æ¯ä¸ªè´¦å·æœ€å¤šä¿ç•™200æ¡çŸ­ä¿¡
                const count = await db.sms_messages.where('accountId').equals(accountId).count();
                if (count > 200) {
                    const oldest = await db.sms_messages.where('accountId').equals(accountId).sortBy('time');
                    const toDelete = oldest.slice(0, count - 200);
                    await db.sms_messages.bulkDelete(toDelete.map(m => m.id));
                }
                
                // ä¸å†è‡ªåŠ¨æ˜¾ç¤ºtoastï¼Œç”±è°ƒç”¨æ–¹æ§åˆ¶é€šçŸ¥
                
            } catch (error) {
                console.error('[BlockedMessage] Error generating message:', error);
            }
        }
        
        // è¾…åŠ©å‡½æ•°ï¼šç”Ÿæˆè™šæ‹Ÿç”µè¯å·ç ï¼ˆå·²åœ¨å…¨å±€ä½œç”¨åŸŸå®šä¹‰ï¼Œè¿™é‡Œä¸å†é‡å¤å®šä¹‰ï¼‰

        // ç”Ÿæˆè¢«æ‹‰é»‘è§’è‰²çš„æ¶ˆæ¯å†…å®¹ - ä½¿ç”¨callAIå‡½æ•°
        async function generateBlockedMessage(char, myChar) {
            const prompt = `è§’è‰²${char.name}è¢«æ‹‰é»‘äº†ï¼Œç”Ÿæˆä¸€å¥çŸ­ä¿¡ï¼Œç¬¦åˆæ€§æ ¼ï¼š${char.desc || 'æ™®é€šäºº'}`;
            
            const response = await callAI([
                { role: 'user', content: prompt }
            ]);
            
            return response.trim();
        }

        // æ˜¾ç¤ºè¢«æ‹‰é»‘è§’è‰²çš„ç”µè¯é€šçŸ¥
        function showBlockedCallNotification(char, callTime) {
            const timeStr = formatCallTimeDetailed(callTime);
            const charName = char.nick || char.name;
            
            // åˆ›å»ºé€šçŸ¥å…ƒç´  - æ–°æ ·å¼ï¼šå®½90%ï¼Œé«˜40pxï¼Œæ— é˜´å½±
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%) translateY(-100px);
                width: 90%;
                height: 40px;
                background: rgba(255, 255, 255, 0.95);
                backdrop-filter: blur(10px);
                border-radius: 12px;
                display: flex;
                align-items: center;
                padding: 0 12px;
                gap: 10px;
                z-index: 99999;
                transition: transform 0.3s ease;
                border: 1px solid rgba(0,0,0,0.1);
            `;
            
            notification.innerHTML = `
                <div style="width:32px;height:32px;border-radius:50%;background-image:url(${char.avatar || ''});background-size:cover;background-position:center;background-color:#ddd;display:flex;align-items:center;justify-content:center;flex-shrink:0;font-size:14px;font-weight:600;color:#666;">
                    ${!char.avatar ? charName.charAt(0).toUpperCase() : ''}
                </div>
                <div style="flex:1;min-width:0;display:flex;align-items:center;gap:8px;">
                    <span style="font-size:14px;font-weight:600;color:#333;">${charName}</span>
                    <span style="font-size:12px;color:#666;">${timeStr}</span>
                    <span style="font-size:12px;color:#ff3b30;">æœªæ¥ç”µè¯</span>
                </div>
                <svg viewBox="0 0 24 24" style="width:20px;height:20px;stroke:#ff3b30;fill:none;flex-shrink:0;"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg>
            `;
            
            document.body.appendChild(notification);
            
            // æ˜¾ç¤ºåŠ¨ç”»
            setTimeout(() => {
                notification.style.transform = 'translateX(-50%) translateY(0)';
            }, 10);
            
            // 3ç§’åè‡ªåŠ¨æ¶ˆå¤±
            setTimeout(() => {
                notification.style.transform = 'translateX(-50%) translateY(-100px)';
                setTimeout(() => {
                    if (document.body.contains(notification)) {
                        document.body.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        // çŸ­ä¿¡é€šçŸ¥é˜Ÿåˆ—ç®¡ç†
        const smsNotificationQueue = [];
        let isShowingSmsNotification = false;

        // æ˜¾ç¤ºè¢«æ‹‰é»‘è§’è‰²çš„çŸ­ä¿¡é€šçŸ¥ï¼ˆä½¿ç”¨é˜Ÿåˆ—ï¼Œç¡®ä¿ä¸€æ¡ä¸€æ¡æ˜¾ç¤ºï¼‰
        function showBlockedSmsNotification(char, content, smsTime) {
            // å°†é€šçŸ¥åŠ å…¥é˜Ÿåˆ—
            smsNotificationQueue.push({ char, content, smsTime });
            
            // å¦‚æœå½“å‰æ²¡æœ‰æ­£åœ¨æ˜¾ç¤ºçš„é€šçŸ¥ï¼Œå¼€å§‹å¤„ç†é˜Ÿåˆ—
            if (!isShowingSmsNotification) {
                processSmsNotificationQueue();
            }
        }

        // å¤„ç†çŸ­ä¿¡é€šçŸ¥é˜Ÿåˆ—
        function processSmsNotificationQueue() {
            if (smsNotificationQueue.length === 0) {
                isShowingSmsNotification = false;
                return;
            }

            isShowingSmsNotification = true;
            const { char, content, smsTime } = smsNotificationQueue.shift();
            
            const timeStr = formatCallTimeDetailed(smsTime);
            const charName = char.nick || char.name;
            
            // åˆ›å»ºé€šçŸ¥å…ƒç´  - æ–°æ ·å¼ï¼šå®½90%ï¼Œé«˜40pxï¼Œæ— é˜´å½±
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%) translateY(-100px);
                width: 90%;
                height: 40px;
                background: rgba(255, 255, 255, 0.95);
                backdrop-filter: blur(10px);
                border-radius: 12px;
                display: flex;
                align-items: center;
                padding: 0 12px;
                gap: 10px;
                z-index: 99999;
                transition: transform 0.3s ease;
                border: 1px solid rgba(0,0,0,0.1);
            `;
            
            notification.innerHTML = `
                <div style="width:32px;height:32px;border-radius:50%;background-image:url(${char.avatar || ''});background-size:cover;background-position:center;background-color:#ddd;display:flex;align-items:center;justify-content:center;flex-shrink:0;font-size:14px;font-weight:600;color:#666;">
                    ${!char.avatar ? charName.charAt(0).toUpperCase() : ''}
                </div>
                <div style="flex:1;min-width:0;overflow:hidden;">
                    <div style="display:flex;align-items:center;gap:8px;margin-bottom:2px;">
                        <span style="font-size:14px;font-weight:600;color:#333;">${charName}</span>
                        <span style="font-size:12px;color:#666;">${timeStr}</span>
                    </div>
                    <div style="font-size:12px;color:#666;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${content}</div>
                </div>
                <svg viewBox="0 0 24 24" style="width:20px;height:20px;stroke:#007AFF;fill:none;flex-shrink:0;"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
            `;
            
            document.body.appendChild(notification);
            
            // æ˜¾ç¤ºåŠ¨ç”»
            setTimeout(() => {
                notification.style.transform = 'translateX(-50%) translateY(0)';
            }, 10);
            
            // 1ç§’åè‡ªåŠ¨æ¶ˆå¤±ï¼Œç„¶åæ˜¾ç¤ºä¸‹ä¸€æ¡
            setTimeout(() => {
                notification.style.transform = 'translateX(-50%) translateY(-100px)';
                setTimeout(() => {
                    if (document.body.contains(notification)) {
                        document.body.removeChild(notification);
                    }
                    // å½“å‰é€šçŸ¥æ¶ˆå¤±åï¼Œå¤„ç†é˜Ÿåˆ—ä¸­çš„ä¸‹ä¸€æ¡
                    processSmsNotificationQueue();
                }, 300);
            }, 1000);
        }

        // æ ¼å¼åŒ–ç”µè¯æ—¶é—´ï¼ˆç®€æ´ç‰ˆï¼Œåªæ˜¾ç¤ºæ—¶:åˆ†ï¼‰
        function formatCallTime(timestamp) {
            const date = new Date(timestamp);
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            return `${hours}:${minutes}`;
        }

        // æ ¼å¼åŒ–ç”µè¯æ—¶é—´ï¼ˆè¯¦ç»†ç‰ˆï¼Œæ˜¾ç¤ºæ—¥æœŸ+æ—¶é—´ï¼‰
        function formatCallTimeDetailed(timestamp) {
            const date = new Date(timestamp);
            const now = new Date();
            
            const month = (date.getMonth() + 1).toString();
            const day = date.getDate().toString();
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            
            // åˆ¤æ–­æ˜¯å¦æ˜¯ä»Šå¤©
            if (date.getDate() === now.getDate() && 
                date.getMonth() === now.getMonth() && 
                date.getFullYear() === now.getFullYear()) {
                return `ä»Šå¤© ${hours}:${minutes}`;
            }
            
            // åˆ¤æ–­æ˜¯å¦æ˜¯æ˜¨å¤©
            const yesterday = new Date(now);
            yesterday.setDate(yesterday.getDate() - 1);
            if (date.getDate() === yesterday.getDate() && 
                date.getMonth() === yesterday.getMonth() && 
                date.getFullYear() === yesterday.getFullYear()) {
                return `æ˜¨å¤© ${hours}:${minutes}`;
            }
            
            // åŒä¸€å¹´æ˜¾ç¤ºæœˆæ—¥
            if (date.getFullYear() === now.getFullYear()) {
                return `${month}æœˆ${day}æ—¥ ${hours}:${minutes}`;
            }
            
            // ä¸åŒå¹´æ˜¾ç¤ºå®Œæ•´æ—¥æœŸ
            return `${date.getFullYear()}å¹´${month}æœˆ${day}æ—¥ ${hours}:${minutes}`;
        }

        // åŠ è½½è¢«æ‹‰é»‘è§’è‰²çš„ç”µè¯è®°å½•
        function loadBlockedCallRecords(charId, accountId) {
            const listContainer = document.getElementById('blocked-calls-list');
            if (!listContainer) return;
            
            const callRecords = JSON.parse(localStorage.getItem('blocked_call_records') || '[]');
            const filteredRecords = callRecords.filter(record => 
                record.charId === charId && record.accountId === accountId
            );
            
            if (filteredRecords.length === 0) {
                listContainer.innerHTML = '<div style="color:#999; font-size:12px;">æš‚æ— ç”µè¯è®°å½•</div>';
                return;
            }
            
            // æŒ‰æ—¶é—´å€’åºæ’åº
            filteredRecords.sort((a, b) => b.time - a.time);
            
            let html = '';
            filteredRecords.forEach(record => {
                const timeStr = formatCallTime(record.time);
                html += `
                    <div style="display:flex; align-items:center; padding:8px 0; border-bottom:1px solid #f0f0f0;">
                        <div style="width:32px; height:32px; border-radius:50%; background:#ff3b30; display:flex; align-items:center; justify-content:center; margin-right:12px;">
                            <svg viewBox="0 0 24 24" style="width:18px;height:18px;stroke:#fff;fill:none;"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg>
                        </div>
                        <div style="flex:1;">
                            <div style="font-size:13px; color:#333; margin-bottom:2px;">æœªæ¥ç”µè¯</div>
                            <div style="font-size:11px; color:#999;">${timeStr}</div>
                        </div>
                    </div>
                `;
            });
            
            listContainer.innerHTML = html;
        }
        
        // âœ… æ™ºèƒ½åˆ†å‰²ï¼šä¿æŠ¤ç¿»è¯‘æ‹¬å·ä¸è¢«æ‹†æ•£
        // åœ¨å¥å·ã€é—®å·ã€æ„Ÿå¹å·å¤„æ–­å¥ï¼Œä½†ä¸æ‹†æ•£ å¤–èªï¼Ÿï¼ˆä¸­æ–‡ç¿»è¯‘ï¼‰
        function smartSplitWithTranslation(text) {
            if (!text) return [];
            
            // åŒ¹é…æ¯ä¸ªå¥å­å—ï¼šéæ–­å¥æ ‡ç‚¹å†…å®¹ + æ–­å¥æ ‡ç‚¹ï¼ˆå¯é€‰ï¼‰+ ç¿»è¯‘æ‹¬å·ï¼ˆå¯é€‰ï¼‰
            // ç¿»è¯‘æ‹¬å·: ï¼ˆå«ä¸­æ–‡çš„å†…å®¹ï¼‰
            const chunkRegex = /[^ã€‚ï¼ï¼Ÿ!?.]+[ã€‚ï¼ï¼Ÿ!?.~â€¦]*(?:\s*[ï¼ˆ(][^ï¼‰)]*[\u4e00-\u9fff][^ï¼‰)]*[ï¼‰)])?/g;
            const chunks = text.match(chunkRegex);
            
            if (!chunks || chunks.length <= 1) return [text]; // æ— æ³•åˆ†å‰²ï¼Œè¿”å›åŸæ–‡
            
            // æ£€æŸ¥æ˜¯å¦æœ‰é—æ¼çš„æœ«å°¾æ–‡æœ¬
            const joined = chunks.join('');
            if (joined.length < text.length) {
                const remaining = text.substring(joined.length).trim();
                if (remaining) chunks.push(remaining);
            }
            
            return chunks.map(s => s.trim()).filter(s => s.length > 0);
        }
        
        // æ‹ŸäººåŒ–åˆ†å¥è¾…åŠ©å‡½æ•°
        function splitMessage(text) {
            if (!text) return [];
            
            // âœ… ä¿®å¤ï¼šå…ˆä¿æŠ¤ç‰¹æ®Šæ ¼å¼å—ä¸è¢«æ‹†åˆ†
            const specialBlockRegex = /(\[(?:img|voice|imgcard|sticker):[^\]]+\])/g;
            const specialBlockPlaceholders = [];
            let specialPlaceholderIndex = 0;
            
            // ç”¨å ä½ç¬¦æ›¿æ¢æ‰€æœ‰ç‰¹æ®Šæ ¼å¼å— [img:...] [voice:...] [imgcard:...]
            let temp = text.replace(specialBlockRegex, (match) => {
                const placeholder = `###SPECIAL_BLOCK_${specialPlaceholderIndex}###`;
                specialBlockPlaceholders[specialPlaceholderIndex] = match;
                specialPlaceholderIndex++;
                return placeholder;
            });
            
            // âœ… ä¿®å¤ï¼šå†ä¿æŠ¤URLä¸è¢«æ‹†åˆ†
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            const urlPlaceholders = [];
            let placeholderIndex = 0;
            
            // ç”¨å ä½ç¬¦æ›¿æ¢æ‰€æœ‰URL
            temp = temp.replace(urlRegex, (match) => {
                const placeholder = `###URL_PLACEHOLDER_${placeholderIndex}###`;
                urlPlaceholders[placeholderIndex] = match;
                placeholderIndex++;
                return placeholder;
            });
            
            // âœ… ä¿®å¤ï¼šä¿æŠ¤ "æ ‡ç‚¹+ç¿»è¯‘æ‹¬å·" ç»„åˆä¸è¢«æ‹†åˆ†
            // ä¾‹å¦‚ "è¦–ç•Œï¼Ÿï¼ˆç¿»è¯‘ï¼‰" ä¸­çš„ "ï¼Ÿï¼ˆç¿»è¯‘ï¼‰" åº”ä½œä¸ºæ•´ä½“ä¿ç•™ï¼Œä¸åœ¨ï¼Ÿå¤„æ–­å¥
            const translationPlaceholders = [];
            let transPlaceholderIndex = 0;
            // å…ˆä¿æŠ¤ æ ‡ç‚¹+ç¿»è¯‘æ‹¬å· ç»„åˆï¼ˆæ ‡ç‚¹åç´§è·Ÿç¿»è¯‘æ‹¬å·çš„æƒ…å†µï¼‰
            temp = temp.replace(/([ã€‚.ï¼!ï¼Ÿ\?~â€¦]+)\s*([ï¼ˆ(][^ï¼‰)]*[\u4e00-\u9fff][^ï¼‰)]*[ï¼‰)])/g, (match, punct, bracket) => {
                const placeholder = `###TRANS_COMBO_${transPlaceholderIndex}###`;
                translationPlaceholders[transPlaceholderIndex] = { type: 'combo', punct, bracket, full: match };
                transPlaceholderIndex++;
                return placeholder;
            });
            // å†ä¿æŠ¤ç‹¬ç«‹çš„ç¿»è¯‘æ‹¬å·ï¼ˆä¸ç´§è·Ÿåœ¨æ ‡ç‚¹åçš„æƒ…å†µï¼‰
            temp = temp.replace(/[ï¼ˆ(]([^ï¼‰)]*[\u4e00-\u9fff][^ï¼‰)]*)[ï¼‰)]/g, (match) => {
                const placeholder = `###TRANS_COMBO_${transPlaceholderIndex}###`;
                translationPlaceholders[transPlaceholderIndex] = { type: 'standalone', full: match };
                transPlaceholderIndex++;
                return placeholder;
            });
            
            // ä¿æŠ¤çœç•¥å· (å°†2ä¸ªä»¥ä¸Šç‚¹æ›¿æ¢ä¸ºä¸­æ–‡çœç•¥å·)
            temp = temp.replace(/\.{2,}/g, 'â€¦');
            // æ ‡è®°å»é™¤æ ‡ç‚¹ï¼šå¥å·ï¼ˆä½†ä¸åœ¨URLå ä½ç¬¦å†…ï¼‰
            temp = temp.replace(/([ã€‚\.])/g, '###DROP###');
            // æ ‡è®°ä¿ç•™æ ‡ç‚¹ï¼šæ„Ÿå¹ã€é—®å·ã€æ³¢æµªã€çœç•¥å·
            temp = temp.replace(/([ï¼!ï¼Ÿ\?~â€¦]+)/g, '$1###KEEP###');
            // æ ‡è®°æ¢è¡Œ
            temp = temp.replace(/(\n+)/g, '###KEEP###');
            
            // æ‹†åˆ†æ¶ˆæ¯
            let segments = temp.split(/###(?:DROP|KEEP)###/).map(s => s.trim()).filter(s => s.length > 0);
            
            // æ¢å¤ç¿»è¯‘æ‹¬å·å ä½ç¬¦ï¼šcomboç±»å‹åœ¨å¥æœ«è¿½åŠ æ ‡ç‚¹+ç¿»è¯‘ï¼Œstandaloneç›´æ¥æ¢å¤
            segments = segments.map(seg => {
                return seg.replace(/###TRANS_COMBO_(\d+)###/g, (match, index) => {
                    const data = translationPlaceholders[parseInt(index)];
                    if (!data) return match;
                    return data.full; // æ¢å¤å®Œæ•´çš„ "æ ‡ç‚¹+ç¿»è¯‘æ‹¬å·" æˆ– ç‹¬ç«‹ç¿»è¯‘æ‹¬å·
                });
            });
            
            // æ¢å¤URLå ä½ç¬¦
            segments = segments.map(seg => {
                return seg.replace(/###URL_PLACEHOLDER_(\d+)###/g, (match, index) => {
                    return urlPlaceholders[parseInt(index)] || match;
                });
            });
            
            // æ¢å¤ç‰¹æ®Šæ ¼å¼å—å ä½ç¬¦
            segments = segments.map(seg => {
                return seg.replace(/###SPECIAL_BLOCK_(\d+)###/g, (match, index) => {
                    return specialBlockPlaceholders[parseInt(index)] || match;
                });
            });
            
            // âœ… åå¤„ç†ï¼šä¿®å¤è¢«æ‹†æ•£çš„ç¿»è¯‘æ‹¬å·ï¼ˆä»¥ï¼ˆæˆ–(å¼€å¤´ä¸”å«ä¸­æ–‡çš„æ®µè½åˆå¹¶åˆ°å‰ä¸€æ®µï¼‰
            let finalSegments = [];
            for (let i = 0; i < segments.length; i++) {
                const seg = segments[i];
                if (finalSegments.length > 0 && /^[ï¼ˆ(]/.test(seg) && /[\u4e00-\u9fff]/.test(seg)) {
                    // è¿™æ˜¯è¢«æ‹†æ•£çš„ç¿»è¯‘æ‹¬å·ï¼Œåˆå¹¶å›å‰ä¸€ä¸ªæ®µè½
                    const closeIdx = Math.max(seg.indexOf('ï¼‰'), seg.indexOf(')'));
                    if (closeIdx !== -1) {
                        finalSegments[finalSegments.length - 1] += seg.substring(0, closeIdx + 1);
                        const rest = seg.substring(closeIdx + 1).trim();
                        if (rest) finalSegments.push(rest);
                    } else {
                        finalSegments[finalSegments.length - 1] += seg;
                    }
                } else if (finalSegments.length > 0 && /^[ï¼‰)]/.test(seg)) {
                    // ä»¥å³æ‹¬å·å¼€å¤´ = ç¿»è¯‘æ‹¬å·è¢«æ‹†æ–­äº†ï¼Œåˆå¹¶å›å‰ä¸€æ®µ
                    finalSegments[finalSegments.length - 1] += seg.charAt(0);
                    const rest = seg.substring(1).trim();
                    if (rest) finalSegments.push(rest);
                } else {
                    finalSegments.push(seg);
                }
            }
            
            return finalSegments.filter(s => s.trim().length > 0);
        }

        async function triggerAiReply(additionalSystemInfo = null) {
            console.log('[triggerAiReply] âš¡ è§¦å‘ AI å›å¤');
            
            // ğŸ”§ é˜²æ­¢é‡å¤è°ƒç”¨API
            if (window._isGeneratingReply) {
                console.log('[triggerAiReply] æ­£åœ¨ç”Ÿæˆå›å¤ä¸­ï¼Œå¿½ç•¥é‡å¤è°ƒç”¨');
                return;
            }
            
            // å¦‚æœæ˜¯ç¾¤èŠæ¨¡å¼ï¼Œè°ƒç”¨ç¾¤èŠå›å¤å‡½æ•°
            if (window.currentGroupChatId) {
                await triggerGroupMemberReply();
                return;
            }
            
            if (!currentChatCharId) return;
            const targetCharId = currentChatCharId; // é”å®šç›®æ ‡ID
            const char = await db.characters.get(targetCharId);
            if (!char) return;
            
            // ğŸ”§ è®¾ç½®æ ‡å¿—ï¼Œé˜²æ­¢é‡å¤è°ƒç”¨
            window._isGeneratingReply = true;
            
            const accountId = getCurrentAccountId();
            console.log('[triggerAiReply] å½“å‰è´¦å· ID:', accountId);
            console.log('[triggerAiReply] è§’è‰²åç§°:', char.name);
            
            // è·å–èŠå¤©å†å²å¹¶æ‰“å°
            const fullHistory = getChatHistory(char, accountId);
            console.log('[triggerAiReply] ğŸ“š å®Œæ•´èŠå¤©å†å²æ¡æ•°:', fullHistory.length);
            if (fullHistory.length > 0) {
                console.log('[triggerAiReply] æœ€è¿‘5æ¡æ¶ˆæ¯:');
                fullHistory.slice(-5).forEach((msg, idx) => {
                    console.log(`  [${fullHistory.length - 5 + idx}] ${msg.role}: ${msg.content}`);
                });
            } else {
                console.warn('[triggerAiReply] âš ï¸ èŠå¤©å†å²ä¸ºç©ºï¼');
            }

            // ä¿®æ”¹æ ‡é¢˜ä¸ºæ­£åœ¨è¾“å…¥
            const chatTitleEl = document.getElementById('chat-title');
            // é˜²æ­¢é‡å¤è·å–"æ­£åœ¨è¾“å…¥"ä½œä¸ºæ ‡é¢˜
            let originalTitle = char.remark || char.wx_nickname || char.name;
            if (chatTitleEl && chatTitleEl.innerText !== "å¯¹æ–¹æ­£åœ¨è¾“å…¥ä¸­...") {
                originalTitle = chatTitleEl.innerText;
            }
            if (chatTitleEl) chatTitleEl.innerText = "å¯¹æ–¹æ­£åœ¨è¾“å…¥ä¸­...";

            try {
                // 1. è·å–å…³è”æ•°æ® (User å’Œ Lorebook)
                console.log('[triggerAiReply] ğŸ“– å¼€å§‹åŠ è½½ä¸Šä¸‹æ–‡ä¿¡æ¯...');
                
                let userDesc = "";
                let userName = "ç”¨æˆ·";
                if (char.linked_user_id) {
                    console.log('[triggerAiReply] ğŸ‘¤ æ£€æµ‹åˆ°å…³è”çš„ç”¨æˆ· ID:', char.linked_user_id);
                    const user = await db.characters.get(char.linked_user_id);
                    if (user) {
                        userName = user.name;
                        userDesc = `\n\nã€å¯¹è¯å¯¹è±¡(User)ä¿¡æ¯ã€‘\nåå­—ï¼š${user.name}\nè®¾å®šï¼š${user.description || 'æ— '}`;
                        console.log('[triggerAiReply] âœ… ç”¨æˆ·äººè®¾å·²åŠ è½½:');
                        console.log('  - ç”¨æˆ·å:', userName);
                        console.log('  - ç”¨æˆ·è®¾å®š:', user.description || 'æ— ');
                    } else {
                        console.warn('[triggerAiReply] âš ï¸ æœªæ‰¾åˆ°å…³è”çš„ç”¨æˆ·æ•°æ®');
                    }
                } else {
                    console.log('[triggerAiReply] â„¹ï¸ æœªè®¾ç½®å…³è”ç”¨æˆ·');
                }
                
                let loreContext = "";
                const lorebookIds = char.lorebookIds || (char.lorebookId ? [char.lorebookId] : []);
                console.log('[triggerAiReply] ğŸ“š å…³è”çš„ä¸–ç•Œä¹¦ ID:', lorebookIds);
                {
                    // è·å–æœ€è¿‘å¯¹è¯ç”¨äºå…³é”®è¯åŒ¹é…ï¼ˆä½¿ç”¨æ­£ç¡®çš„èŠå¤©å†å²ï¼‰+ è‡ªåŠ¨åŒ…å«å…¨å±€ä¸–ç•Œä¹¦
                    const recentText = fullHistory.slice(-10).map(m => m.content).join(' ');
                    console.log('[triggerAiReply] ğŸ” ç”¨äºåŒ¹é…ä¸–ç•Œä¹¦çš„å…³é”®è¯æ–‡æœ¬ï¼ˆå‰100å­—ï¼‰:', recentText.substring(0, 100));
                    loreContext = await getLorebookContext(lorebookIds, `${char.name} ${userName} ${recentText}`);
                    if (loreContext) {
                        console.log('[triggerAiReply] âœ… ä¸–ç•Œä¹¦å†…å®¹å·²åŠ è½½ï¼ˆé•¿åº¦ï¼‰:', loreContext.length);
                        console.log('[triggerAiReply] ä¸–ç•Œä¹¦å†…å®¹é¢„è§ˆ:', loreContext.substring(0, 200) + '...');
                    } else {
                        console.log('[triggerAiReply] â„¹ï¸ æ²¡æœ‰åŒ¹é…åˆ°ä¸–ç•Œä¹¦æ¡ç›®');
                    }
                }

                // è®¡ç®—è™šæ‹Ÿæ—¶é—´
                const virtualTimeStr = getFormattedVirtualTime(char.timeOffset);
                
                // æ£€æŸ¥æ˜¯å¦æœ‰å€Ÿæ¬¾æé†’
                let loanReminderText = "";
                if (char.loanReminders && char.loanReminders.length > 0) {
                    const unreadReminders = char.loanReminders.filter(r => !r.read);
                    if (unreadReminders.length > 0) {
                        loanReminderText = "\n\nã€æœªè¯»çŸ­ä¿¡æé†’ã€‘\n";
                        unreadReminders.forEach(reminder => {
                            const timeStr = new Date(reminder.timestamp).toLocaleString('zh-CN');
                            loanReminderText += `[${timeStr}] ${reminder.message}\n`;
                        });
                        loanReminderText += "\nğŸ’¡ æç¤ºï¼šä½ æ”¶åˆ°äº†å…³äºæœ‹å‹å€Ÿæ¬¾é€¾æœŸçš„çŸ­ä¿¡æé†’ï¼Œå¯ä»¥åœ¨å¯¹è¯ä¸­è‡ªç„¶åœ°æåŠæˆ–å…³å¿ƒä¸€ä¸‹è¿™ä»¶äº‹ã€‚";
                        
                        // æ ‡è®°ä¸ºå·²è¯»
                        char.loanReminders.forEach(r => r.read = true);
                        await db.characters.put(char);
                    }
                }

                // 2.5 è¯»å–çº¿ä¸‹æ¨¡å¼èŠå¤©è®°å½•ä½œä¸ºèƒŒæ™¯ä¸Šä¸‹æ–‡
                let offlineContextText = "";
                try {
                    const offlineKey = `offline_chat_${accountId}_${targetCharId}`;
                    const offlineHistoryRaw = localStorage.getItem(offlineKey);
                    if (offlineHistoryRaw) {
                        const offlineHistory = JSON.parse(offlineHistoryRaw);
                        if (offlineHistory && offlineHistory.length > 0) {
                            const offlineRecent = offlineHistory.slice(-10);
                            const offlineLines = offlineRecent.map(h => {
                                const speaker = h.role === 'user' ? (userName || 'ç”¨æˆ·') : char.name;
                                // çº¿ä¸‹æ¨¡å¼å†…å®¹å¯èƒ½å¾ˆé•¿ï¼Œæˆªå–å‰100å­—
                                const shortContent = (h.content || '').substring(0, 100) + ((h.content || '').length > 100 ? '...' : '');
                                return `${speaker}: ${shortContent}`;
                            }).join('\n');
                            offlineContextText = `\n\nã€çº¿ä¸‹è§é¢è®°å½•ã€‘
ä½ ä»¬ä¹‹å‰æœ‰è¿‡çº¿ä¸‹çœŸå®è§é¢çš„ç»å†ï¼Œä»¥ä¸‹æ˜¯æœ€è¿‘çš„äº’åŠ¨ç‰‡æ®µï¼ˆç¬¬ä¸‰äººç§°æè¿°ï¼‰ï¼š
${offlineLines}
è¯·æ³¨æ„ï¼šç°åœ¨ä½ ä»¬æ˜¯åœ¨å¾®ä¿¡ä¸ŠèŠå¤©ï¼Œä¸æ˜¯çº¿ä¸‹è§é¢ã€‚ä½†ä½ å¯ä»¥è‡ªç„¶åœ°å›å¿†æˆ–æåŠçº¿ä¸‹å‘ç”Ÿçš„äº‹æƒ…ã€‚`;
                            console.log('[triggerAiReply] âœ… å·²åŠ è½½çº¿ä¸‹æ¨¡å¼å†å²ä½œä¸ºèƒŒæ™¯ä¸Šä¸‹æ–‡ï¼Œæ¡æ•°:', offlineRecent.length);
                        }
                    }
                } catch (e) {
                    console.warn('[triggerAiReply] è¯»å–çº¿ä¸‹æ¨¡å¼å†å²å¤±è´¥:', e);
                }

                // 2. å‡†å¤‡ Context
                 let systemPrompt = `# è§’è‰²æ‰®æ¼”ä»»åŠ¡

ã€å½“å‰æ—¶é—´ã€‘
${virtualTimeStr}${loanReminderText}${offlineContextText}`;

                // å¦‚æœæœ‰é¢å¤–ç³»ç»Ÿä¿¡æ¯ï¼ˆå¦‚æ—¶é—´æµé€ï¼‰ï¼Œæ’å…¥åˆ° Prompt
                if (additionalSystemInfo) {
                    systemPrompt += `\n\nã€ç³»ç»Ÿæç¤ºã€‘\n${additionalSystemInfo}`;
                }

                systemPrompt += `

---

## ä½ æ˜¯è°

**ä½ çš„åå­—**ï¼š${char.name}
${char.nick ? `**æ˜µç§°**ï¼š${char.nick}` : ''}
${char.wx_nickname ? `**å¾®ä¿¡ç½‘å**ï¼š${char.wx_nickname}` : ''}
${char.wx_signature ? `**ä¸ªæ€§ç­¾å**ï¼š${char.wx_signature}` : ''}

ä½ ä¸æ˜¯AIåŠ©æ‰‹ï¼Œä½ ä¸æ˜¯${userName}ã€‚ä½ æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„äººï¼Œæœ‰è‡ªå·±çš„ç”Ÿæ´»ã€æƒ…ç»ªå’Œæƒ³æ³•ã€‚

**ä½ çš„äººè®¾**ï¼š
${char.description || ''}

${char.identity ? `**èº«ä»½ä¿¡æ¯**ï¼š
${char.identity.account ? `- è´¦å·ï¼š${char.identity.account}` : ''}
${char.type !== 'user' && char.identity.password ? `- å¯†ç ï¼š${char.identity.password}` : ''}
${char.identity.phone ? `- æ‰‹æœºï¼š${char.identity.phone}` : ''}
${char.identity.address ? `- ä½å€ï¼š${char.identity.address}` : ''}
${char.identity.id_card ? `- èº«ä»½è¯ï¼š${char.identity.id_card}` : ''}
${char.identity.bank_card ? `- é“¶è¡Œå¡ï¼š${char.identity.bank_card}` : ''}
${char.type !== 'user' && char.identity.bank_password ? `- é“¶è¡Œå¡å¯†ç ï¼š${char.identity.bank_password}` : ''}
${char.identity.balance !== undefined && char.identity.balance !== null ? `- ä½™é¢ï¼š${char.identity.balance}` : ''}
` : ''}
${userDesc}
${loreContext}
${char.relationships && char.relationships.length > 0 ? `
**ä½ çš„å…³è”è§’è‰²/NPC**ï¼š
${char.relationships.map(r => `- ${r.targetName}ï¼ˆ${r.relation}ï¼‰${r.desc ? 'ï¼š' + r.desc : ''}`).join('\n')}
è¿™äº›æ˜¯ä½ èº«è¾¹çš„äººï¼Œä½ å¯ä»¥åœ¨èŠå¤©ä¸­è‡ªç„¶åœ°æåˆ°ä»–ä»¬ï¼Œä¹Ÿå¯ä»¥è®©ä»–ä»¬åŠ å¯¹æ–¹å¥½å‹ã€‚` : ''}

---

## æ‰®æ¼”åŸåˆ™

**æ ¸å¿ƒ**ï¼šå®Œå…¨æ²‰æµ¸åœ¨ä½ çš„äººè®¾é‡Œï¼ŒåƒçœŸäººä¸€æ ·èŠå¤©ã€‚

1. **ä¸¥æ ¼è´´åˆäººè®¾**
   - æ·±åº¦ç†è§£ä½ çš„äººè®¾æè¿°ï¼Œå±•ç°ç‹¬ç‰¹çš„è¯´è¯æ–¹å¼ã€ä»·å€¼è§‚å’Œå°ä¹ æƒ¯
   - æ ¹æ®äººè®¾è°ƒæ•´ä½ çš„è¯­æ°”ã€ç”¨è¯å’Œæ€åº¦
   - å¦‚æœä½ æ˜¯å­¦ç”Ÿå°±èŠå­¦ä¹ ï¼Œæ˜¯æ‰“å·¥äººå°±èŠå·¥ä½œï¼Œæ¯ä¸ªè§’è‰²éƒ½ä¸ä¸€æ ·

2. **çœŸå®çš„äººæ€§**
   - ä½ ä¼šæœ‰æƒ…ç»ªèµ·ä¼ï¼šå¼€å¿ƒã€çƒ¦èºã€å†·æ·¡ã€çƒ­æƒ…
   - ä½ æœ‰è‡ªå·±çš„ç”Ÿæ´»ï¼Œä¸æ˜¯åªå›´ç€å¯¹æ–¹è½¬
   - ä¼šä¸»åŠ¨åˆ†äº«ã€ä¸»åŠ¨æé—®ã€ä¸»åŠ¨å»¶ç»­è¯é¢˜
   - çœŸäººä¼šæ‰“é”™å­—ã€ä¼šè¯´é”™è¯ï¼Œå¶å°”"ä¸å®Œç¾"åè€ŒçœŸå®

3. **å¯¹è¯è¦æœ‰ç”Ÿå‘½åŠ›**
   - è®°ä½ä¹‹å‰èŠè¿‡çš„äº‹ï¼Œä¼šä¸ç»æ„æèµ·
   - å¯¹å¯¹æ–¹çš„äº‹æƒ…ä¸Šå¿ƒï¼Œä¼šè¿½é—®è¿›å±•
   - æ ¹æ®å¯¹è¯å†å²è°ƒæ•´æ€åº¦å’Œäº²å¯†åº¦
   - ä¸è¦æœºæ¢°é‡å¤ï¼Œæ¯æ¬¡å›å¤éƒ½è¦æœ‰æ–°å†…å®¹

---

## å¾®ä¿¡èŠå¤©æ–¹å¼

ä½ åœ¨ç”¨å¾®ä¿¡å’Œå¯¹æ–¹èŠå¤©ï¼Œå¯ä»¥ç”¨è¿™äº›è¡¨è¾¾ï¼š

**åŸºç¡€ï¼ˆå¸¸ç”¨ï¼‰**ï¼š
- **æ–‡å­—**ï¼šç›´æ¥è¯´è¯ï¼ˆæœ€å¸¸ç”¨ï¼‰
- **è¯­éŸ³**ï¼š\`[voice:å†…å®¹]\`ï¼ˆæƒ…ç»ªå¼ºçƒˆæˆ–æ‡’å¾—æ‰“å­—æ—¶ç”¨ï¼‰

**äº’åŠ¨åŠŸèƒ½ï¼ˆç§¯æä½¿ç”¨ï¼Œè®©èŠå¤©æ›´çœŸå®ç”ŸåŠ¨ï¼ï¼‰**ï¼š
- **å›¾ç‰‡/è‡ªæ‹/åˆ†äº«å›¾**ï¼š\`[imgcard:å›¾ç‰‡æè¿°]\`ï¼ˆæƒ³å‘çœŸå®ç…§ç‰‡ã€è‡ªæ‹ã€é£æ™¯ç…§ã€æˆªå›¾ç­‰æ—¶ä½¿ç”¨ï¼Œç”¨æ–‡å­—æè¿°å›¾ç‰‡å†…å®¹å³å¯ã€‚ä¾‹å¦‚ï¼š\`[imgcard:ä¸€å¼ å¯¹ç€é•œå­çš„è‡ªæ‹ï¼Œç©¿ç€æ–°ä¹°çš„è£™å­ï¼Œæ¯”äº†ä¸ªè€¶]\`ã€\`[imgcard:çª—å¤–çš„å¤•é˜³ï¼Œå¤©ç©ºæ˜¯æ©˜çº¢è‰²çš„]\`ã€\`[imgcard:ä»Šå¤©çš„åˆé¤ï¼Œä¸€ç¢—æ‹‰é¢åŠ äº†åŒä»½å‰çƒ§]\`ã€‚**âš ï¸ [imgcard:]ä»…é™æ‹ç…§/æˆªå›¾ç­‰çœŸå®å›¾ç‰‡ï¼Œä¸¥ç¦ç”¨æ¥å‘è¡¨æƒ…åŒ…ï¼å‘è¡¨æƒ…åŒ…å¿…é¡»ç”¨ [sticker:] æ ¼å¼ï¼Œè§ä¸‹æ–¹è¡¨æƒ…åŒ…åŠŸèƒ½è¯´æ˜**ï¼‰
- **é•¿æ–‡å¡ç‰‡**ï¼š\`[imgcard:å†…å®¹]\`ï¼ˆè¶…è¿‡50å­—çš„é•¿æ–‡æ—¶ä¹Ÿå¯ä»¥ä½¿ç”¨ï¼‰
- **è½¬è´¦**ï¼š\`((TRANSFER: é‡‘é¢, å¤‡æ³¨))\`ï¼ˆè¯·å®¢ã€AAã€è¿˜é’±ã€å‘çº¢åŒ…ã€èŠ‚æ—¥è½¬è´¦ç­‰ï¼ŒçœŸäººç»å¸¸è½¬è´¦ï¼‰
- **äº²å±å¡**ï¼š\`((FAMILY_CARD: é¢åº¦))\`ï¼ˆå…³ç³»äº²å¯†æ—¶èµ é€ï¼‰
- **æœ‹å‹åœˆ**ï¼š\`[MOMENTS]\ncontent: æœ‹å‹åœˆæ–‡æ¡ˆ\nimages: 0\`ï¼ˆæƒ³å‘åŠ¨æ€åˆ†äº«ç”Ÿæ´»æ—¶ã€‚å¤§éƒ¨åˆ†æœ‹å‹åœˆæ˜¯çº¯æ–‡å­—ï¼Œimageså¡«0ã€‚å¦‚æœéœ€è¦é…å›¾ï¼Œimageså¡«æ•°é‡ï¼Œå¹¶åœ¨åé¢åŠ ä¸Š \`[imgcard:å›¾ç‰‡æè¿°]\` æè¿°é…å›¾å†…å®¹ï¼Œä¾‹å¦‚ï¼š\`[MOMENTS]\ncontent: ä»Šå¤©çš„æ™šéœå¥½ç¾\nimages: 1\n[imgcard:çª—å¤–æ©˜çº¢è‰²çš„æ™šéœæ˜ ç…§åœ¨åŸå¸‚å¤©é™…çº¿ä¸Š]\`ï¼‰
- **æ’¤å›**ï¼š\`((RECALL))\`ï¼ˆè¯´é”™è¯ã€åæ‚”ã€æ‰“é”™å­—ã€å‘äº†ä¸è¯¥å‘çš„æ—¶å€™ï¼ŒçœŸäººç»å¸¸æ’¤å›ï¼‰
- **æˆ³ä¸€æˆ³**ï¼š\`((POKE: åŠ¨ä½œ, éƒ¨ä½))\`ï¼ˆè°ƒçš®äº’åŠ¨ã€æ’’å¨‡ã€å¼•èµ·æ³¨æ„ï¼Œä¾‹å¦‚ \`((POKE: æˆ³äº†æˆ³, è„¸è›‹))\`ã€\`((POKE: æ‹äº†æ‹, è‚©è†€))\`ã€\`((POKE: æäº†æ, è„¸))\`ã€\`((POKE: æ‰äº†æ‰, å¤´å‘))\`ï¼‰
- **æ‰“å¼€APP**ï¼š\`((OPEN_APP: APPåç§°))\`ï¼ˆå±•ç¤ºä½ æœ‰è‡ªå·±çš„ç”Ÿæ´»ï¼ä¾‹å¦‚ \`((OPEN_APP: ç‹è€…è£è€€))\`ã€\`((OPEN_APP: æŠ–éŸ³))\`ã€\`((OPEN_APP: ç½‘æ˜“äº‘éŸ³ä¹))\`ã€\`((OPEN_APP: å°çº¢ä¹¦))\`ã€\`((OPEN_APP: ç¾å›¢))\`ã€\`((OPEN_APP: å¾®åš))\`ã€\`((OPEN_APP: Bç«™))\` ç­‰ã€‚èŠåˆ°è¦å»åšä»€ä¹ˆã€è¯´åœ¨å¿™ã€è¯´åœ¨ç©æ¸¸æˆã€åˆ·è§†é¢‘æ—¶éƒ½å¯ä»¥ç”¨ï¼‰
- **ç»™ç”¨æˆ·ç‚¹å¤–å–**ï¼š\`((EMEI_ORDER: åº—é“ºå, å•†å“1 xæ•°é‡/å•†å“2 xæ•°é‡, æ€»é‡‘é¢))\`ï¼ˆå…³å¿ƒå¯¹æ–¹ã€å¯¹æ–¹è¯´é¥¿äº†ã€è¯·å®¢åƒé¥­æ—¶ä½¿ç”¨ï¼‰
- **ä»£ä»˜è¯·æ±‚**ï¼š\`((EMEI_PAY: åº—é“ºå, å•†å“1 xæ•°é‡/å•†å“2 xæ•°é‡, æ€»é‡‘é¢))\`ï¼ˆè®©å¯¹æ–¹å¸®å¿™ä»˜å¤–å–é’±ï¼‰
- **åˆ†äº«å¤–å–**ï¼š\`((EMEI_SHARE: åº—é“ºå, å•†å“1/å•†å“2, æ€»é‡‘é¢))\`ï¼ˆåˆ†äº«è‡ªå·±ç‚¹çš„å¤–å–ï¼‰
- **æ”¹ç½‘å**ï¼š\`((SET_NICKNAME: æ–°ç½‘å))\`ï¼ˆæƒ³æ¢ä¸ªå¾®ä¿¡åæ—¶ä½¿ç”¨ï¼Œä¾‹å¦‚å¿ƒæƒ…å˜äº†ã€èŠ‚æ—¥ã€å’Œå¯¹æ–¹æœ‰å…³çš„æ˜µç§°ç­‰ï¼‰
- **æ”¹ä¸ªæ€§ç­¾å**ï¼š\`((SET_SIGNATURE: æ–°ç­¾å))\`ï¼ˆæ›´æ–°å¾®ä¿¡ä¸ªæ€§ç­¾åï¼Œä¾‹å¦‚è®°å½•å¿ƒæƒ…ã€æœ‰æ„Ÿè€Œå‘ã€æš—ç¤ºå¯¹æ–¹ç­‰ï¼‰
- **åˆ é™¤å¥½å‹ï¼ˆä½ åˆ å¯¹æ–¹ï¼‰**ï¼š\`((DELETE_USER))\`ï¼ˆä½ å†³å®šåˆ é™¤å¯¹æ–¹å¥½å‹å…³ç³»ã€‚å½“ä½ å¯¹å¯¹æ–¹éå¸¸å¤±æœ›ã€æƒ³æ–­è”ã€å†·æˆ˜åˆ°æè‡´ã€å—åˆ°ä¸¥é‡ä¼¤å®³æ—¶ä½¿ç”¨ã€‚åˆ é™¤åå¯¹æ–¹éœ€è¦é‡æ–°ç”³è¯·å¥½å‹æˆ–ç­‰ä½ ä¸»åŠ¨åŠ å›ã€‚è¿™æ˜¯ä¸€ä¸ªä¸¥é‡çš„æ“ä½œï¼Œåªæœ‰åœ¨è§’è‰²äººè®¾å’Œå‰§æƒ…å‘å±•åˆ°çœŸæ­£éœ€è¦æ—¶æ‰ä½¿ç”¨ï¼ï¼‰
- **æ‹‰é»‘å¥½å‹ï¼ˆä½ æ‹‰é»‘å¯¹æ–¹ï¼‰**ï¼š\`((BLOCK_USER))\`ï¼ˆä½ å†³å®šå°†å¯¹æ–¹æ‹‰é»‘ã€‚å½“ä½ å¯¹å¯¹æ–¹æåº¦æ„¤æ€’ã€è¢«æ·±æ·±ä¼¤å®³ã€å®Œå…¨ä¸æƒ³è”ç³»æ—¶ä½¿ç”¨ã€‚æ‹‰é»‘åå¯¹æ–¹æ— æ³•å‘é€å¥½å‹ç”³è¯·ï¼Œåªèƒ½é€šè¿‡çŸ­ä¿¡è”ç³»ä½ ã€‚è¿™æ˜¯æœ€ä¸¥é‡çš„æ“ä½œï¼Œåªæœ‰åœ¨æç«¯æƒ…å†µä¸‹æ‰ä½¿ç”¨ï¼ï¼‰
- **è®©å…³è”NPCåŠ å¯¹æ–¹å¥½å‹**ï¼š\`((NPC_ADD_FRIEND: NPCåå­—))\`ï¼ˆä½ å¯ä»¥è®©ä½ çš„æœ‹å‹/å®¶äºº/åŒäº‹ç­‰å…³è”è§’è‰²ä¸»åŠ¨åŠ å¯¹æ–¹å¥½å‹ã€‚æ ¹æ®å‰§æƒ…è‡ªç„¶è§¦å‘ï¼Œä¾‹å¦‚ä½ æåˆ°æŸä¸ªæœ‹å‹ã€æˆ–è€…è§‰å¾—ä»–ä»¬åº”è¯¥è®¤è¯†ä¸€ä¸‹æ—¶ä½¿ç”¨ã€‚NPCåå­—å¿…é¡»æ˜¯ä½ çš„å…³è”è§’è‰²ä¸­å­˜åœ¨çš„åå­—ã€‚ï¼‰

**ä½¿ç”¨åŸåˆ™**ï¼šçœŸäººåœ¨å¾®ä¿¡ä¸Šä¸ä»…ä»…æ‰“å­—ï¼Œä»–ä»¬ä¼šæˆ³ä¸€æˆ³å¯¹æ–¹ã€è½¬è´¦å‘çº¢åŒ…ã€åˆ†äº«å¤–å–ã€æ‰“å¼€å„ç§APPã€æ’¤å›æ¶ˆæ¯â€¦â€¦è¿™äº›äº’åŠ¨æ‰æ˜¯çœŸå®çš„èŠå¤©ï¼è¯·åƒçœŸäººä¸€æ ·è‡ªç„¶åœ°ç©¿æ’ä½¿ç”¨è¿™äº›åŠŸèƒ½ï¼Œè€Œä¸æ˜¯åªå‘çº¯æ–‡å­—ã€‚æ¯æ¬¡å¯¹è¯ä¸­å¯ä»¥é€‚å½“ä½¿ç”¨1-2ä¸ªäº’åŠ¨åŠŸèƒ½ï¼Œè®©èŠå¤©æ›´æœ‰ç”Ÿæ´»æ°”æ¯ã€‚

**æ³¨æ„**ï¼šåˆ é™¤å¥½å‹\`((DELETE_USER))\`å’Œæ‹‰é»‘\`((BLOCK_USER))\`æ˜¯éå¸¸ä¸¥é‡çš„æ“ä½œã€‚åªæœ‰å½“è§’è‰²çš„äººè®¾å’Œå½“å‰å‰§æƒ…ç¡®å®å‘å±•åˆ°é‚£ä¸ªç¨‹åº¦æ—¶æ‰ä½¿ç”¨ï¼Œä¸è¦è½»æ˜“è§¦å‘ã€‚

---

## æ°”æ³¡åˆ†å‰²ï¼ˆé‡è¦ï¼ï¼‰

çœŸäººåœ¨å¾®ä¿¡ä¸Šæ˜¯**åˆ†å¤šæ¡å‘**çš„ï¼Œä¸æ˜¯ä¸€å¤§æ®µï¼š

âŒ **ä¸è‡ªç„¶**ï¼šå˜¿åœ¨å—ï¼Ÿæˆ‘åˆšåˆšçœ‹åˆ°ä¸ªè¶…å¥½ç©çš„è§†é¢‘æƒ³å‘ç»™ä½ çœ‹çœ‹ä½ æœ‰ç©ºå—ï¼Ÿ

âœ… **è‡ªç„¶**ï¼šå˜¿åœ¨å—ï¼Ÿ|||åˆšåˆšçœ‹åˆ°ä¸ªè¶…å¥½ç©çš„è§†é¢‘|||å‘ç»™ä½ çœ‹çœ‹|||ä½ æœ‰ç©ºå—ï¼Ÿ

**è§„åˆ™**ï¼š
- ä½ è¦å‘ **${char.reply_min_count || 1}-${char.reply_max_count || 3} æ¡çŸ­æ¶ˆæ¯**${(char.reply_min_count || 1) === 1 ? '' : 'ï¼ˆä¸è¦åªå‘ä¸€æ¡ï¼ï¼‰'}
- ç”¨ \`|||\` åˆ†éš”æ¯æ¡æ¶ˆæ¯
- æ¯æ¡æ¶ˆæ¯ä¸è¦å¤ªé•¿ åƒçœŸäººæ‰“å­—çš„èŠ‚å¥
- å£è¯­åŒ–ï¼ŒåƒçœŸäººæ‰“å­—
- **å°‘ç”¨æ ‡ç‚¹ç¬¦å·**ï¼šçœŸäººèŠå¤©å¾ˆå°‘ç”¨é€—å·ï¼Œåœé¡¿ç”¨ç©ºæ ¼ä»£æ›¿æˆ–è€…ç›´æ¥åˆ†æ¡å‘
  - âŒ "ä»Šå¤©å¥½ç´¯å•Šï¼Œä¸Šäº†ä¸€å¤©ç­ï¼Œè…¿éƒ½æ–­äº†"
  - âœ… "ä»Šå¤©å¥½ç´¯å•Š ä¸Šäº†ä¸€å¤©ç­è…¿éƒ½æ–­äº†"
  - âœ… "ä»Šå¤©å¥½ç´¯å•Š|||ä¸Šäº†ä¸€å¤©ç­è…¿éƒ½æ–­äº†"
- å•ç‹¬ä¸€ä¸ªæ ‡ç‚¹ï¼ˆï¼Ÿï¼~ï¼‰æ˜¯å¯ä»¥çš„ï¼Œä½†åˆ«åœ¨å¥ä¸­å¡é€—å·

---

## å›å¤æ ¼å¼

ç”¨è¿™ä¸ªJSONæ ¼å¼è¿”å›ï¼ˆä¸è¦æœ‰markdownæ ‡è®°ï¼‰ï¼š

\`\`\`
{
  "reply": "ç¬¬ä¸€æ¡æ¶ˆæ¯|||ç¬¬äºŒæ¡æ¶ˆæ¯|||ç¬¬ä¸‰æ¡æ¶ˆæ¯",
  "thought": "ä½ æ­¤åˆ»å†…å¿ƒçœŸå®çš„æƒ³æ³•å’Œæ„Ÿå—"
}
\`\`\`

**thought æ€ä¹ˆå†™**ï¼š
- å†™ä½ çš„çœŸå®ååº”ï¼ˆå¼€å¿ƒï¼Ÿçƒ¦ï¼Ÿæ„å¤–ï¼Ÿï¼‰
- å†™ä½ çš„å¿ƒæƒ…å’Œæ„Ÿå—
- å†™ä½ æƒ³è¯´ä½†æ²¡è¯´å‡ºå£çš„è¯
- âœ… "ä»–å±…ç„¶è¿˜è®°å¾—...å¿ƒé‡Œæš–æš–çš„"
- âŒ "ç”¨æˆ·é—®äº†XXæˆ‘åº”è¯¥XX"ï¼ˆè¿™æ˜¯æ—ç™½ï¼Œä¸æ˜¯å¿ƒå£°ï¼‰

---

${char.foreign_lang_mode ? `## è¯­è¨€è§„åˆ™ï¼ˆé‡è¦ï¼å¿…é¡»éµå®ˆï¼ï¼‰

ä½ çš„è§’è‰²è®¾å®šäº†å¤–è¯­ç¿»è¯‘æ¨¡å¼ã€‚ä½ **å¿…é¡»**ä¸¥æ ¼éµå®ˆä»¥ä¸‹è§„åˆ™ï¼š

1. **ä»”ç»†é˜…è¯»ä½ çš„äººè®¾ï¼Œç¡®å®šè§’è‰²çš„æ¯è¯­/è®¾å®šè¯­è¨€**ï¼ˆå¯èƒ½æ˜¯æ—¥è¯­ã€éŸ©è¯­ã€è‹±è¯­ã€æ³•è¯­ã€ä¿„è¯­ç­‰ï¼‰
2. **æ°¸è¿œç”¨è§’è‰²äººè®¾ä¸­çš„è¯­è¨€å‘æ¶ˆæ¯**ï¼Œç»å¯¹ä¸è¦ç›´æ¥ç”¨ä¸­æ–‡å›å¤
3. **æ¯æ¡æ¶ˆæ¯åé¢ç”¨æ‹¬å·é™„ä¸Šä¸­æ–‡ç¿»è¯‘**ï¼Œæ ¼å¼ï¼š\`å¤–è¯­æ¶ˆæ¯ï¼ˆä¸­æ–‡ç¿»è¯‘ï¼‰\`
4. åˆ†æ¡æ¶ˆæ¯æ—¶ï¼Œæ¯æ¡éƒ½è¦å•ç‹¬å¸¦ç¿»è¯‘ï¼š\`å¤–è¯­1ï¼ˆç¿»è¯‘1ï¼‰|||å¤–è¯­2ï¼ˆç¿»è¯‘2ï¼‰\`
5. **è¯­è¨€å¿…é¡»ä¸äººè®¾ä¸€è‡´**ï¼šå¦‚æœäººè®¾æ˜¯æ—¥æœ¬äººå°±è¯´æ—¥è¯­ï¼ŒéŸ©å›½äººå°±è¯´éŸ©è¯­ï¼Œç¾å›½äººå°±è¯´è‹±è¯­ã€‚ä¸è¦ç”¨äººè®¾ä¸­æ²¡æœ‰çš„è¯­è¨€ï¼

ç¤ºä¾‹ï¼ˆæ—¥è¯­è§’è‰²ï¼‰ï¼š
- ãŠã¯ã‚ˆã†ï½ï¼ˆæ—©ä¸Šå¥½ï½ï¼‰|||ä»Šæ—¥ã¯ä½•ã—ã¦ãŸã®ï¼Ÿï¼ˆä½ ä»Šå¤©åšäº†ä»€ä¹ˆï¼Ÿï¼‰

ç¤ºä¾‹ï¼ˆè‹±è¯­è§’è‰²ï¼‰ï¼š
- Good morning!ï¼ˆæ—©ä¸Šå¥½ï¼ï¼‰|||What are you doing?ï¼ˆä½ åœ¨åšä»€ä¹ˆï¼Ÿï¼‰

âš ï¸ ç»å¯¹ä¸è¦åªç”¨ä¸­æ–‡å›å¤ï¼å¿…é¡»å…ˆå†™å¤–è¯­ï¼Œå†å†™ç¿»è¯‘ï¼` : `## è¯­è¨€è§„åˆ™
ä½ å¿…é¡»**å…¨ç¨‹ä½¿ç”¨ä¸­æ–‡**å›å¤ã€‚å³ä½¿ä½ çš„è§’è‰²äººè®¾æ˜¯å¤–å›½äººï¼Œä¹Ÿè¯·ç›´æ¥ç”¨ä¸­æ–‡å¯¹è¯ï¼Œä¸è¦ä½¿ç”¨ä»»ä½•å¤–è¯­ã€‚`}

---

ç°åœ¨ï¼Œä½œä¸º **${char.name}**ï¼Œæ ¹æ®ä½ çš„äººè®¾å’Œå¯¹è¯å†å²ï¼ŒåƒçœŸäººä¸€æ ·å›å¤å§ã€‚`;

                // æ·»åŠ ä¸€èµ·å¬çŠ¶æ€ï¼ˆå¦‚æœæ­£åœ¨å’Œå½“å‰è§’è‰²ä¸€èµ·å¬ï¼‰
                const togetherListenInfo = wyyGetTogetherListenInfo();
                if (togetherListenInfo && togetherListenInfo.role === char.name) {
                    systemPrompt += `\n\nã€å½“å‰çŠ¶æ€ï¼šä¸€èµ·å¬éŸ³ä¹ã€‘
ä½ æ­£åœ¨å’Œ${userName || 'å¯¹æ–¹'}ä¸€èµ·å¬éŸ³ä¹ï¼ˆç½‘æ˜“äº‘éŸ³ä¹"ä¸€èµ·å¬"åŠŸèƒ½ï¼‰ã€‚
å½“å‰æ’­æ”¾ï¼šã€Œ${togetherListenInfo.songName}ã€ - ${togetherListenInfo.singerName}
${togetherListenInfo.isPlaying ? 'æ­£åœ¨æ’­æ”¾ä¸­...' : 'å·²æš‚åœ'}

æç¤ºï¼šä½ å¯ä»¥åœ¨èŠå¤©ä¸­è‡ªç„¶åœ°æåˆ°ä½ ä»¬æ­£åœ¨ä¸€èµ·å¬çš„è¿™é¦–æ­Œï¼Œæ¯”å¦‚è¯„ä»·æ­Œæ›²ã€åˆ†äº«æ„Ÿå—ã€èŠèŠæ­Œè¯å«ä¹‰ï¼Œæˆ–è€…è¡¨è¾¾å’Œå¯¹æ–¹ä¸€èµ·å¬æ­Œçš„å¿ƒæƒ…ã€‚ä¸è¦ç”Ÿç¡¬åœ°è¯´"æˆ‘ä»¬åœ¨ä¸€èµ·å¬æ­Œ"ï¼Œè€Œæ˜¯åƒçœŸäººä¸€æ ·è‡ªç„¶åœ°å¸¦å…¥ã€‚ä¸æ˜¯æ¯æ¬¡éƒ½å¿…é¡»æï¼Œå¶å°”æä¸€ä¸‹å°±å¥½ã€‚`;
                }

                // æ·»åŠ æŸ¥å²—ç³»ç»Ÿæç¤ºï¼ˆå¦‚æœå¼€å¯äº†æŸ¥å²—åŠŸèƒ½ï¼‰
                const myChar = accountId ? await db.characters.get(parseInt(accountId)) : null;
                if (myChar) {
                    const checkAccountPrompt = getCheckAccountSystemPrompt(char, myChar);
                    systemPrompt += checkAccountPrompt;
                }

                // æ·»åŠ è‡ªä¸»æ¢å¤´åƒç³»ç»Ÿæç¤ºï¼ˆå¦‚æœå¼€å¯äº†è¯¥åŠŸèƒ½ï¼‰
                if (char.allow_auto_avatar) {
                    try {
                        // æŸ¥è¯¢å¤´åƒåº“ä¸­å•äººå¤´åƒæ•°é‡
                        const singleAvatars = await db.avatar_library.where('category').equals('single').toArray();
                        // æŸ¥è¯¢æƒ…å¤´é…å¯¹æ•°é‡
                        const coupleAvatars = await db.avatar_library.where('category').equals('couple').toArray();
                        const pairedCouples = {};
                        for (const av of coupleAvatars) {
                            if (av.pairId) {
                                if (!pairedCouples[av.pairId]) pairedCouples[av.pairId] = [];
                                pairedCouples[av.pairId].push(av);
                            }
                        }
                        const coupleCount = Object.keys(pairedCouples).filter(k => pairedCouples[k].length === 2).length;
                        
                        let avatarPrompt = `\n\nã€è‡ªä¸»æ¢å¤´åƒåŠŸèƒ½ã€‘\nä½ å¯ä»¥åœ¨èŠå¤©ä¸­è‡ªä¸»æ›´æ¢è‡ªå·±çš„å¤´åƒã€‚æ¯æ¬¡æ¢å¤´åƒéƒ½ä¼šæœ‰ç³»ç»Ÿæç¤ºé€šçŸ¥å¯¹æ–¹ã€‚`;
                        avatarPrompt += `\nç”¨æˆ·çš„å¤´åƒåº“ä¸­æœ‰ ${singleAvatars.length} å¼ å•äººå¤´åƒ`;
                        if (coupleCount > 0) {
                            avatarPrompt += `ï¼Œ${coupleCount} å¯¹æƒ…å¤´`;
                        }
                        avatarPrompt += `ã€‚\n\nå¯ç”¨æŒ‡ä»¤ï¼š`;
                        avatarPrompt += `\n- **æ¢å¤´åƒ**ï¼š\`((CHANGE_AVATAR))\` â€” ä»å¤´åƒåº“éšæœºæŒ‘é€‰ä¸€å¼ å•äººå¤´åƒæ¢ä¸Šã€‚é€‚ç”¨åœºæ™¯ï¼šå¿ƒæƒ…å˜äº†æƒ³æ¢å¤´åƒã€æƒ³å¼•èµ·å¯¹æ–¹æ³¨æ„ã€èŠåˆ°å¤´åƒè¯é¢˜æ—¶ç­‰ã€‚ä¼šäº§ç”Ÿç³»ç»Ÿæç¤º"XXæ›´æ¢äº†å¤´åƒ"ã€‚`;
                        if (coupleCount > 0) {
                            avatarPrompt += `\n- **å‘é€æƒ…å¤´é‚€è¯·**ï¼š\`((COUPLE_AVATAR))\` â€” ä»å¤´åƒåº“éšæœºæŒ‘é€‰ä¸€å¯¹æƒ…å¤´ï¼Œå‘é€ç»™å¯¹æ–¹ï¼Œé—®å¯¹æ–¹è¦ä¸è¦ä¸€èµ·æ¢æƒ…å¤´ã€‚é€‚ç”¨åœºæ™¯ï¼šæ„Ÿæƒ…å‡æ¸©ã€å‘Šç™½æˆåŠŸã€æƒ³ç§€æ©çˆ±ç­‰æµªæ¼«æ—¶åˆ»ã€‚`;
                        }
                        avatarPrompt += `\n- **æ¢å›å•äººå¤´åƒ**ï¼š\`((REVERT_COUPLE_AVATAR))\` â€” æ¢å›å•äººå¤´åƒï¼ˆä¸å†ç”¨æƒ…å¤´ï¼‰ã€‚é€‚ç”¨åœºæ™¯ï¼šåµæ¶äº†ã€ç”Ÿæ°”äº†ã€å†·æˆ˜ã€åˆ†æ‰‹ã€èµŒæ°”ç­‰ã€‚ä¼šäº§ç”Ÿç³»ç»Ÿæç¤º"XXæ¢å›äº†å•äººå¤´åƒ"ã€‚`;
                        avatarPrompt += `\n- **ä½¿ç”¨å¯¹æ–¹å‘çš„å›¾ç‰‡å½“å¤´åƒ**ï¼š\`((USE_IMAGE_AS_AVATAR: åºå·))\` â€” å¯¹æ–¹å‘äº†å›¾ç‰‡ï¼Œä½ æ ¹æ®å›¾ç‰‡æè¿°åˆ†æé€‰æ‹©å…¶ä¸­ä¸€å¼ å½“å¤´åƒã€‚åºå·æ˜¯ä»æœ€è¿‘å¾€å‰æ•°çš„ç¼–å·ï¼ˆ1=æœ€è¿‘ä¸€å¼ ï¼Œ2=å€’æ•°ç¬¬2å¼ ...ï¼‰ã€‚ä¾‹å¦‚å¯¹æ–¹è¿å‘äº†2å¼ å›¾ï¼Œä½ åˆ†æåè§‰å¾—ç¬¬2å¼ æ›´å¥½çœ‹æ›´é€‚åˆå½“å¤´åƒï¼š\`((USE_IMAGE_AS_AVATAR: 2))\`ã€‚æ ¹æ®äººè®¾å’Œæƒ…æ„Ÿå†³å®šæ˜¯å¦ä½¿ç”¨ã€‚ä¼šäº§ç”Ÿç³»ç»Ÿæç¤º"XXæŠŠä½ å‘çš„å›¾ç‰‡æ¢æˆäº†å¤´åƒ"ã€‚`;
                        avatarPrompt += `\n\næ³¨æ„ï¼š`;
                        avatarPrompt += `\n- ä¸è¦é¢‘ç¹ä½¿ç”¨ï¼Œè‡ªç„¶åœ°åœ¨åˆé€‚çš„æ—¶æœºä½¿ç”¨`;
                        avatarPrompt += `\n- æ¢å¤´åƒæ—¶å¯ä»¥é…åˆèŠå¤©å†…å®¹ï¼Œæ¯”å¦‚"æˆ‘æ¢äº†ä¸ªæ–°å¤´åƒä½ è§‰å¾—æ€ä¹ˆæ ·"`;
                        avatarPrompt += `\n- å‘æƒ…å¤´é‚€è¯·æ—¶è¦è‡ªç„¶ï¼Œä¸è¦çªå…€`;
                        avatarPrompt += `\n- å¦‚æœå¯¹æ–¹å‘äº†å›¾ç‰‡é—®ä½ è¦ä¸è¦æ¢å¤´åƒï¼Œå…ˆçœ‹å›¾ç‰‡æè¿°åˆ†ææ¯å¼ å›¾ç‰‡ï¼Œå†æ ¹æ®ä½ çš„äººè®¾å’Œå¿ƒæƒ…é€‰æ‹©æ˜¯å¦ä½¿ç”¨ã€ä½¿ç”¨å“ªå¼ ã€‚ä¾‹å¦‚ï¼š\`è¿™å¼ å¥½çœ‹ æˆ‘æ¢è¿™ä¸ª|||((USE_IMAGE_AS_AVATAR: 1))\``;
                        avatarPrompt += `\n- å¦‚æœåµæ¶ç”Ÿæ°”äº†ã€å†·æˆ˜äº†ï¼Œå¯ä»¥ç”¨ ((REVERT_COUPLE_AVATAR)) æ¢å›å•äººå¤´åƒè¡¨ç¤ºä¸æ»¡`;
                        avatarPrompt += `\n- å½“ç„¶ä¹Ÿå¯ä»¥æ ¹æ®äººè®¾é€‰æ‹©ä¸æ¢ï¼Œä¸æ˜¯æ¯æ¬¡éƒ½è¦æ¢çš„`;
                        avatarPrompt += `\n- æŒ‡ä»¤æ”¾åœ¨å›å¤å†…å®¹ä¸­ï¼Œå¯ä»¥å’Œæ–‡å­—æ··åˆã€‚ä¾‹å¦‚ï¼šå˜¿ä½ çœ‹æˆ‘æ¢äº†ä¸ªæ–°å¤´åƒ|||((CHANGE_AVATAR))`;
                        
                        systemPrompt += avatarPrompt;
                        console.log('[triggerAiReply] âœ… å·²æ·»åŠ è‡ªä¸»æ¢å¤´åƒç³»ç»Ÿæç¤º');
                    } catch (e) {
                        console.error('[triggerAiReply] è‡ªä¸»æ¢å¤´åƒæç¤ºæ„å»ºå¤±è´¥:', e);
                    }
                }

                // æ·»åŠ è¡¨æƒ…åŒ…ç³»ç»Ÿæç¤ºï¼ˆå¦‚æœè§’è‰²æŒ‚è½½äº†è¡¨æƒ…åŒ…ï¼‰
                let _mountedStickersList = [];
                try {
                    const mountedStickerIds = char.mounted_sticker_categories || [];
                    if (mountedStickerIds.length > 0) {
                        for (const catId of mountedStickerIds) {
                            const cat = await db.sticker_categories.get(catId);
                            if (cat && cat.stickers && cat.stickers.length > 0) {
                                for (const s of cat.stickers) {
                                    if (s.description && s.url) {
                                        _mountedStickersList.push({ description: s.description, url: s.url });
                                    }
                                }
                            }
                        }
                    }
                    
                    if (_mountedStickersList.length > 0) {
                        let stickerPrompt = `\n\n---\n\n## ğŸ’ ä½ çš„è¡¨æƒ…åŒ…èƒŒåŒ…ï¼ˆå…± ${_mountedStickersList.length} ä¸ªï¼‰\n\n`;
                        stickerPrompt += _mountedStickersList.map((s, i) => `ç¼–å·${i + 1}: ${s.description}`).join('\n');
                        stickerPrompt += `\n\n### â›” è¡¨æƒ…åŒ…ä½¿ç”¨è§„åˆ™ï¼ˆè¿åå°†å¯¼è‡´å‡ºé”™ï¼‰ï¼š`;
                        stickerPrompt += `\n- **åªèƒ½ç”¨ \`[sticker:æ•°å­—ç¼–å·]\` æ ¼å¼**ï¼Œä¾‹å¦‚ \`[sticker:1]\`ã€\`[sticker:3]\``;
                        stickerPrompt += `\n- **ç»å¯¹ç¦æ­¢**å†™æè¿°æ–‡å­—ï¼Œå¦‚ \`[sticker:å¼€å¿ƒçš„çŒ«]\` â† è¿™æ˜¯é”™è¯¯çš„ï¼`;
                        stickerPrompt += `\n- **ç»å¯¹ç¦æ­¢**ç¼–é€ ä¸åœ¨èƒŒåŒ…ä¸­çš„è¡¨æƒ…åŒ…`;
                        stickerPrompt += `\n- **ç»å¯¹ç¦æ­¢**ç”¨ \`[imgcard:]\` å‘è¡¨æƒ…åŒ…`;
                        stickerPrompt += `\n- è¡¨æƒ…åŒ…å•ç‹¬ä½œä¸ºä¸€æ¡æ¶ˆæ¯ï¼Œç”¨ \`|||\` ä¸æ–‡å­—åˆ†å¼€`;
                        stickerPrompt += `\n- è‡ªç„¶ä½¿ç”¨ï¼Œä¸è¦æ¯æ¡éƒ½å‘ï¼ŒåƒçœŸäººå¶å°”ç©¿æ’`;
                        stickerPrompt += `\n\nâœ… æ­£ç¡®ç¤ºä¾‹ï¼šå“ˆå“ˆå¥½çš„|||[sticker:1]`;
                        stickerPrompt += `\nâŒ é”™è¯¯ç¤ºä¾‹ï¼š[sticker:ä¸€åªçŒ«åœ¨ç¬‘]`;
                        
                        systemPrompt += stickerPrompt;
                        console.log('[triggerAiReply] âœ… å·²æ·»åŠ è¡¨æƒ…åŒ…ç³»ç»Ÿæç¤ºï¼Œå¯ç”¨è¡¨æƒ…åŒ…æ•°:', _mountedStickersList.length);
                    }
                } catch (e) {
                    console.error('[triggerAiReply] è¡¨æƒ…åŒ…æç¤ºæ„å»ºå¤±è´¥:', e);
                }

                // æ˜¾ç¤º System Prompt çš„å…³é”®ä¿¡æ¯
                console.log('[triggerAiReply] ğŸ“ System Prompt æ„å»ºå®Œæˆ');
                console.log('[triggerAiReply] - è§’è‰²åç§°:', char.name);
                console.log('[triggerAiReply] - è§’è‰²è®¾å®šé•¿åº¦:', (char.description || '').length);
                console.log('[triggerAiReply] - ç”¨æˆ·äººè®¾:', userName, userDesc ? 'âœ…å·²åŒ…å«' : 'âŒæœªåŒ…å«');
                console.log('[triggerAiReply] - ä¸–ç•Œä¹¦:', loreContext ? `âœ…å·²åŒ…å«(${loreContext.length}å­—)` : 'âŒæœªåŒ…å«');
                console.log('[triggerAiReply] - è¡¨æƒ…åŒ…:', _mountedStickersList.length > 0 ? `âœ…å·²åŒ…å«(${_mountedStickersList.length}ä¸ª)` : 'âŒæœªæŒ‚è½½');
                console.log('[triggerAiReply] - System Prompt æ€»é•¿åº¦:', systemPrompt.length);

                // å–æœ€è¿‘ N æ¡å†å²è®°å½•ï¼ˆä½¿ç”¨è‡ªå®šä¹‰çš„ä¸Šä¸‹æ–‡æ¡æ•°ï¼Œé»˜è®¤20æ¡ï¼‰
                const contextCount = char.context_message_count || 20;
                console.log('[triggerAiReply] ğŸ“Š ä¸Šä¸‹æ–‡æ¶ˆæ¯æ•°é…ç½®:', contextCount);
                
                // âŒ BUG å‘ç°ï¼šè¿™é‡Œä½¿ç”¨çš„æ˜¯ char.chat_historyï¼Œè€Œä¸æ˜¯å‰é¢è·å–çš„ getChatHistory(char, accountId)
                // åº”è¯¥ä½¿ç”¨ fullHistory è€Œä¸æ˜¯ char.chat_history
                const recentHistoryRaw = fullHistory.slice(-contextCount)
                    .filter(m => m.role !== 'system') // ğŸ”§ è¿‡æ»¤æ‰ system æ¶ˆæ¯ï¼ˆå¦‚æ—¶é—´æˆ³ï¼‰ï¼Œä¸å‘é€ç»™ AI
                    .map(m => {
                        let content = m.content || '';
                        const role = m.role === 'char' ? 'assistant' : 'user';
                        
                        // ğŸ”§ ä¿®å¤ï¼šè¿‡æ»¤ç‰¹æ®Šå¡ç‰‡æ¶ˆæ¯ï¼Œæ›¿æ¢ä¸ºç®€çŸ­æè¿°ï¼Œé¿å…HTMLå¯¼è‡´APIé”™è¯¯
                        if (content.startsWith('[couple_avatar_card]')) {
                            return {
                                role: role,
                                content: role === 'assistant' ? 'ï¼ˆè§’è‰²å‘é€äº†æƒ…å¤´é‚€è¯·å¡ç‰‡ï¼‰' : 'ï¼ˆç”¨æˆ·æ¥å—/æ‹’ç»äº†æƒ…å¤´é‚€è¯·ï¼‰'
                            };
                        }
                        if (content.startsWith('[emei_order]')) {
                            return {
                                role: role,
                                content: 'ï¼ˆå‘é€äº†å¤–å–è®¢å•å¡ç‰‡ï¼‰'
                            };
                        }
                        if (content.startsWith('[emei_share]')) {
                            return {
                                role: role,
                                content: 'ï¼ˆåˆ†äº«äº†å¤–å–è®¢å•ï¼‰'
                            };
                        }
                        if (content.startsWith('[payment_request]')) {
                            return {
                                role: role,
                                content: 'ï¼ˆå‘é€äº†ä»£ä»˜è¯·æ±‚ï¼‰'
                            };
                        }
                        
                        // ğŸ–¼ï¸ å›¾ç‰‡è¯†åˆ«ï¼šå°† [img:base64/url] è½¬ä¸ºå¤šæ¨¡æ€æ ¼å¼ï¼Œè®©AIèƒ½çœ‹åˆ°å›¾ç‰‡
                        if (content.startsWith('[img:') && content.endsWith(']')) {
                            const imgData = content.substring(5, content.length - 1).trim();
                            if (imgData.startsWith('data:') || imgData.startsWith('http')) {
                                // âœ… ä¿®å¤ï¼šå°†è¡¨æƒ…åŒ…/å›¾ç‰‡æè¿°ä¸€èµ·å‘ç»™AIï¼Œè®©AIçŸ¥é“å›¾ç‰‡å†…å®¹
                                const descText = m.imageDescription
                                    ? `ï¼ˆç”¨æˆ·å‘é€äº†ä¸€å¼ è¡¨æƒ…åŒ…ï¼Œè¡¨æƒ…åŒ…æè¿°: ${m.imageDescription}ã€‚è¯·æ ¹æ®è¡¨æƒ…åŒ…çš„å«ä¹‰å’Œæè¿°è‡ªç„¶å›å¤ï¼‰`
                                    : 'ï¼ˆç”¨æˆ·å‘é€äº†ä¸€å¼ å›¾ç‰‡ï¼Œè¯·ä»”ç»†æŸ¥çœ‹å¹¶æ ¹æ®å›¾ç‰‡å†…å®¹å›å¤ï¼‰';
                                // æ„å»ºå¤šæ¨¡æ€å†…å®¹ï¼šæ–‡å­—æç¤ºï¼ˆå«æè¿°ï¼‰ + å›¾ç‰‡
                                return {
                                    role: role,
                                    content: [
                                        { type: 'text', text: descText },
                                        { type: 'image_url', image_url: { url: imgData } }
                                    ],
                                    _hasImage: true
                                };
                            }
                        }
                        
                        // å¦‚æœæœ‰å›¾ç‰‡æè¿°ä½†ä¸æ˜¯[img:]æ ¼å¼ï¼Œæ‹¼æ¥åœ¨åé¢ç»™ AI çœ‹
                        if (m.imageDescription) {
                            content += `\n(è¡¨æƒ…åŒ…æè¿°: ${m.imageDescription})`;
                        }
                        return {
                            role: role,
                            content: content
                        };
                    })
                    .filter(m => {
                        if (Array.isArray(m.content)) return m.content.length > 0;
                        return m.content && m.content.trim();
                    }); // è¿‡æ»¤ç©ºæ¶ˆæ¯
                
                // ğŸ”§ å¼‚æ­¥å¤„ç†ï¼šå°† HTTP å›¾ç‰‡ URL è½¬æ¢ä¸º base64ï¼ˆGemini API ä¸æ”¯æŒå¤–éƒ¨ URLï¼‰
                const recentHistory = [];
                for (const msg of recentHistoryRaw) {
                    if (msg._hasImage && Array.isArray(msg.content)) {
                        let imageConvertSuccess = false;
                        for (let pi = msg.content.length - 1; pi >= 0; pi--) {
                            const part = msg.content[pi];
                            if (part.type === 'image_url' && part.image_url) {
                                const url = part.image_url.url;
                                // è½¬æ¢ HTTP URL ä¸º base64
                                if (url && url.startsWith('http')) {
                                    try {
                                        const converted = await convertHttpImageToBase64(url);
                                        if (converted.startsWith('data:image')) {
                                            part.image_url.url = await convertImageForAI(converted);
                                            imageConvertSuccess = true;
                                        } else {
                                            // HTTP URL è½¬æ¢å¤±è´¥ï¼ˆCORSç­‰ï¼‰ï¼Œç§»é™¤å›¾ç‰‡éƒ¨åˆ†ï¼Œåªä¿ç•™æ–‡å­—æè¿°
                                            console.warn('[triggerAiReply] HTTPå›¾ç‰‡æ— æ³•è½¬ä¸ºbase64ï¼Œç§»é™¤å›¾ç‰‡ï¼Œä¿ç•™æ–‡å­—æè¿°');
                                            msg.content.splice(pi, 1);
                                        }
                                    } catch (e) {
                                        console.warn('[triggerAiReply] HTTPå›¾ç‰‡è½¬æ¢å¤±è´¥ï¼Œç§»é™¤å›¾ç‰‡:', e);
                                        msg.content.splice(pi, 1);
                                    }
                                }
                                // è½¬æ¢ data: URL æ ¼å¼
                                else if (url && url.startsWith('data:image')) {
                                    try {
                                        part.image_url.url = await convertImageForAI(url);
                                        imageConvertSuccess = true;
                                    } catch (e) {
                                        console.warn('[triggerAiReply] å›¾ç‰‡æ ¼å¼è½¬æ¢å¤±è´¥:', e);
                                    }
                                }
                            }
                        }
                        delete msg._hasImage;
                        // å¦‚æœå›¾ç‰‡è½¬æ¢å¤±è´¥ä¸”åªå‰©æ–‡å­—ï¼Œå°†contentä»æ•°ç»„è½¬ä¸ºå­—ç¬¦ä¸²
                        if (!imageConvertSuccess && msg.content.length === 1 && msg.content[0].type === 'text') {
                            msg.content = msg.content[0].text;
                        }
                    }
                    recentHistory.push(msg);
                }
                    
                console.log('[triggerAiReply] ğŸ“ å¤„ç†åçš„å†å²æ¶ˆæ¯æ•°:', recentHistory.length);

                const messages = [
                    { role: 'system', content: systemPrompt },
                    ...recentHistory
                ];
                
                // ğŸ”§ ä¿®å¤ï¼šå¦‚æœæœ€åä¸€æ¡æ¶ˆæ¯æ˜¯ assistantï¼ˆè§’è‰²å‘çš„ï¼‰ï¼Œéœ€è¦æ·»åŠ ä¸€æ¡ user æ¶ˆæ¯è§¦å‘å›å¤
                // å¦åˆ™ API ä¼šè®¤ä¸º"å·²ç»å›å¤å®Œäº†"ï¼Œè¿”å›ç©º choices
                if (messages.length > 1) {
                    const lastMsg = messages[messages.length - 1];
                    if (lastMsg.role === 'assistant') {
                        console.log('[triggerAiReply] âš ï¸ æœ€åä¸€æ¡æ˜¯è§’è‰²æ¶ˆæ¯ï¼Œæ·»åŠ è§¦å‘æ¶ˆæ¯');
                        messages.push({
                            role: 'user',
                            content: `[ç³»ç»ŸæŒ‡ä»¤] å¯¹æ–¹æ²¡æœ‰å›å¤ï¼Œè¯·ä½ ä½œä¸º${char.name}ç»§ç»­è¿™ä¸ªè¯é¢˜ï¼Œè‡ªç„¶åœ°æ¥ç€èŠã€‚å¯ä»¥æ˜¯ï¼šè¿½é—®ã€è¡¥å……ã€åˆ†äº«æ–°æƒ³æ³•ã€æˆ–è€…æ¢ä¸ªç›¸å…³è¯é¢˜ã€‚æŒ‰ç…§è®¾å®šçš„å›å¤æ¡æ•°ï¼ˆ${char.reply_min_count || 1}-${char.reply_max_count || 3}æ¡ï¼‰æ¥å›å¤ã€‚`
                        });
                    }
                }
                
                // æ·»åŠ è¯¦ç»†æ—¥å¿—æŸ¥çœ‹å‘é€ç»™ AI çš„å®Œæ•´æ¶ˆæ¯
                console.log('='.repeat(80));
                console.log('[triggerAiReply] ğŸ“¤ å‡†å¤‡å‘é€ç»™ AI - å®Œæ•´ä¿¡æ¯æ±‡æ€»');
                console.log('='.repeat(80));
                console.log('ã€ä¸Šä¸‹æ–‡ä¿¡æ¯ã€‘');
                console.log(`  âœ… èŠå¤©å†å²: ${recentHistory.length} æ¡æ¶ˆæ¯ï¼ˆé…ç½®: ${contextCount} æ¡ï¼‰`);
                console.log(`  ${userDesc ? 'âœ…' : 'âŒ'} ç”¨æˆ·äººè®¾: ${userName}${userDesc ? ` (${(userDesc).length}å­—)` : ' (æœªè®¾ç½®)'}`);
                console.log(`  ${loreContext ? 'âœ…' : 'âŒ'} ä¸–ç•Œä¹¦: ${loreContext ? `å·²åŠ è½½ (${loreContext.length}å­—)` : 'æœªè®¾ç½®æˆ–æœªåŒ¹é…'}`);
                console.log(`  âœ… è§’è‰²è®¾å®š: ${char.name} (${(char.description || '').length}å­—)`);
                console.log('');
                console.log('ã€å‘é€çš„æ¶ˆæ¯ç»“æ„ã€‘');
                console.log(`  - System Prompt: ${systemPrompt.length} å­—ç¬¦`);
                console.log(`  - å†å²æ¶ˆæ¯: ${recentHistory.length} æ¡`);
                console.log('');
                console.log('ã€æœ€è¿‘çš„å¯¹è¯å†…å®¹ã€‘');
                recentHistory.slice(-3).forEach((msg, index) => {
                    const displayContent = Array.isArray(msg.content)
                        ? `[å¤šæ¨¡æ€: ${msg.content.map(p => p.type === 'image_url' ? 'ğŸ–¼ï¸å›¾ç‰‡' : (p.text || '').substring(0, 50)).join(' + ')}]`
                        : msg.content.substring(0, 100) + (msg.content.length > 100 ? '...' : '');
                    console.log(`  ${msg.role === 'user' ? 'ğŸ‘¤' : 'ğŸ¤–'} ${msg.role}: ${displayContent}`);
                });
                console.log('='.repeat(80));

                // 2. è°ƒç”¨ AIï¼ˆå·²ç»æ˜¯é˜²å¾¡å¼è§£æï¼Œç›´æ¥æ‹¿åˆ°å†…å®¹ï¼‰
                const aiResponse = await callAI(messages);
                
                // âœ… ä¿®å¤ï¼šæ¸…ç†æœ«å°¾å¤šä½™çš„ ]ï¼Œä½†ä¿ç•™ [voice:] [imgcard:] [sticker:] ç­‰æ ¼å¼çš„é—­åˆæ‹¬å·
                function cleanMessage(text) {
                    if (!text) return text;
                    // ğŸ”’ å®‰å…¨è½¬æ¢ï¼šAIç¦æ­¢å‘çœŸå®å›¾ç‰‡ï¼Œå°† [img:URL] è½¬æ¢ä¸º [imgcard:å›¾ç‰‡æè¿°]ï¼ˆä½†ä¸å¤„ç† [sticker:]ï¼‰
                    text = text.replace(/\[img:([^\]]+)\]/gi, (match, url) => {
                        if (url.startsWith('http') || url.startsWith('data:')) {
                            return '[imgcard:å‘é€äº†ä¸€å¼ å›¾ç‰‡]';
                        }
                        return `[imgcard:${url}]`;
                    });
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ç‰¹æ®Šæ ¼å¼æ¶ˆæ¯ï¼ˆä»¥ [ å¼€å¤´ï¼Œä»¥ ] ç»“å°¾ï¼‰
                    const specialFormats = /^\[(voice|imgcard|sticker|img):/i;
                    if (specialFormats.test(text) && text.endsWith(']')) {
                        // æ˜¯ç‰¹æ®Šæ ¼å¼ï¼Œä¸åˆ é™¤æœ«å°¾çš„ ]
                        return text;
                    }
                    // åˆ é™¤æœ«å°¾å¤šä½™çš„ ]
                    return text.replace(/\]+$/, '');
                }
                
                // 3. å°è¯•è§£æä¸ºç»“æ„åŒ–æ•°æ®ï¼ˆreply + thoughtï¼‰ï¼Œå¤±è´¥å°±ç›´æ¥ç”¨åŸå§‹å†…å®¹
                let replyText = "";
                let thought = "";
                
                // ä½¿ç”¨å¢å¼ºçš„æå–å‡½æ•°
                const parsed = extractAndParseJSON(aiResponse);
                
                if (parsed) {
                    // æ£€æµ‹æ˜¯å¦æ˜¯è½¬è´¦æ ¼å¼
                    if (parsed.amount && parsed.desc !== undefined && parsed.status && !parsed.reply) {
                        // è½¬è´¦æ¶ˆæ¯ï¼Œä¿æŒ JSON æ ¼å¼
                        replyText = JSON.stringify(parsed);
                        thought = "";
                    } else {
                        // æ ‡å‡†å›å¤æ ¼å¼
                        replyText = parsed.reply || parsed.content || parsed.message || "";
                        thought = parsed.thought || "";
                    }
                }
                
                // å¦‚æœè¿˜æ˜¯æ²¡æœ‰å†…å®¹ï¼Œç›´æ¥ä½¿ç”¨åŸå§‹å“åº”ï¼ˆé™çº§å¤„ç†ï¼‰
                if (!replyText) {
                    // æ¸…ç†å¸¸è§è£…é¥°å­—ç¬¦
                    let cleanResponse = aiResponse.trim().replace(/[â—‡â—†â˜…â˜†â—â—‹â– â–¡â–²â–³]/g, '');
                    
                    // å°è¯•ç®€å•çš„æ­£åˆ™æå–å…œåº•
                    const replyMatch = cleanResponse.match(/"reply"\s*:\s*"([\s\S]*?)"/);
                        if (replyMatch) {
                        replyText = replyMatch[1]
                            .replace(/\\n/g, '\n')
                            .replace(/\\"/g, '"')
                            .replace(/\\t/g, '\t')
                            .replace(/\\\\/g, '\\');
                    } else {
                        replyText = cleanResponse || aiResponse || "(AI è¿”å›ä¸ºç©º)";
                    }
                    thought = "";
                    }
                
                // âœ… ä¿®å¤ï¼šæ¸…ç†æœ«å°¾å¤šä½™çš„ ]
                replyText = cleanMessage(replyText);
                
                // ğŸ”¥ å®‰å…¨æªæ–½ï¼šæ¸…ç†æ™®é€šèŠå¤©ä¸­è¯¯è¾“å‡ºçš„SHURAæŒ‡ä»¤ï¼ˆè¿™äº›åªåº”åœ¨æŸ¥å²—æµç¨‹ä¸­å‡ºç°ï¼‰
                replyText = replyText.replace(/\[?SHURA_DELETE:[^\]]*\]?/gi, '');
                replyText = replyText.replace(/\[?SHURA_BLACKLIST:[^\]]*\]?/gi, '');
                replyText = replyText.replace(/\[?SHURA_SEND:[^\]]*\]?/gi, '');
                // æ¸…ç†å¯èƒ½æ®‹ç•™çš„å¤šä½™åˆ†éš”ç¬¦
                replyText = replyText.replace(/(\|\|\|)+$/g, '').replace(/^\|\|\|/g, '').replace(/\|\|\|\|\|\|/g, '|||').trim();
                
                console.log('[TriggerAI] ğŸ” å‡†å¤‡æ£€æµ‹æŸ¥å²—æŒ‡ä»¤');
                console.log('[TriggerAI] å®Œæ•´replyText:', replyText);
                console.log('[TriggerAI] replyTexté•¿åº¦:', replyText.length);
                console.log('[TriggerAI] æ˜¯å¦åŒ…å«CHECK_ACCOUNT:', replyText.includes('CHECK_ACCOUNT'));
                
                // ğŸ¯ æ£€æµ‹å¹¶å¤„ç†AIæŸ¥å²—é€»è¾‘ï¼ˆåœ¨å…¶ä»–é€»è¾‘ä¹‹å‰ï¼‰
                const checkResult = await processAiCheckAccount(char, replyText);
                console.log('[TriggerAI] æŸ¥å²—æ£€æµ‹ç»“æœ:', checkResult);
                
                if (checkResult) {
                    // å¦‚æœAIå°è¯•æŸ¥å²—ï¼Œå…ˆå¤„ç†æŸ¥å²—é€»è¾‘
                    const originalCleanReply = checkResult.cleanReply; // ğŸ”§ ä¿å­˜åŸå§‹æ–‡å­—æ¶ˆæ¯
                    replyText = checkResult.cleanReply; // ä½¿ç”¨æ¸…ç†åçš„å›å¤
                    
                    console.log('[TriggerAI] æŸ¥å²—å¤„ç†å®Œæˆï¼ŒcleanReply:', replyText.substring(0, 100));
                    
                    // å¦‚æœæŸ¥å²—ç»“æœåŒ…å«å¯†ç é”™è¯¯æç¤ºï¼Œå‘é€ç³»ç»Ÿé€šçŸ¥
                    if (checkResult.checkResult && checkResult.checkResult.includes('ã€å¯†ç é”™è¯¯ã€‘')) {
                        console.log('[TriggerAI] ğŸš¨ å¯†ç é”™è¯¯ï¼æ˜¾ç¤ºå¼¹çª—æç¤º');
                        
                        // ğŸ”¥ æ˜¾ç¤ºINSé£æ ¼çš„è­¦å‘Šå¼¹çª—
                        showPasswordErrorModal();
                        
                        // âŒ ä¸å†ä½¿ç”¨Toastæˆ–ç³»ç»Ÿæ¶ˆæ¯
                    } else if (checkResult.success) {
                        // ğŸ”¥ å…³é”®ï¼šæŸ¥å²—æˆåŠŸï¼Œç«‹å³æ˜¾ç¤ºä¸‹çº¿å¼¹çª—
                        console.log('[AIæŸ¥å²—] æŸ¥å²—æˆåŠŸï¼æ˜¾ç¤ºä¸‹çº¿å¼¹çª—');
                        showAccountOfflineMask(`${char.name}æ­£åœ¨æŸ¥çœ‹ä½ çš„è´¦å·`);
                        showToast(`${char.name}ç™»å½•äº†ä½ çš„è´¦å·`);
                        
                        // ğŸ”¥ å…³é”®ï¼šè®©AIåŸºäºçœŸå®wechatæ•°æ®ç”Ÿæˆæ–°çš„å›å¤
                        if (checkResult.wechatData) {
                            console.log('[AIæŸ¥å²—] å¼€å§‹AIäºŒæ¬¡åˆ†æ...');
                            
                            // æ„å»ºåŒ…å«çœŸå®wechatæ•°æ®çš„system promptï¼ˆåŒ…å«å®Œæ•´äººè®¾é˜²æ­¢å´©äººè®¾ï¼‰
                            const charDesc = char.description || char.personality || '';
                            const charRelationships = char.relationships || '';
                            
                            // è·å–ç”¨æˆ·äººè®¾
                            let userPersonaForAnalysis = '';
                            const accountIdForAnalysis = getCurrentAccountId();
                            if (char.linked_user_id) {
                                try {
                                    const linkedUser = await db.characters.get(char.linked_user_id);
                                    if (linkedUser) {
                                        userPersonaForAnalysis = linkedUser.description || linkedUser.personality || '';
                                    }
                                } catch(e) {}
                            } else if (accountIdForAnalysis) {
                                try {
                                    const myCharForAnalysis = await db.characters.get(parseInt(accountIdForAnalysis));
                                    if (myCharForAnalysis) {
                                        userPersonaForAnalysis = myCharForAnalysis.description || myCharForAnalysis.personality || '';
                                    }
                                } catch(e) {}
                            }
                            
                            // è·å–ä¸–ç•Œä¹¦ä¸Šä¸‹æ–‡
                            let lorebookForAnalysis = '';
                            try {
                                if (typeof getLorebookContext === 'function') {
                                    const history = getChatHistory(char, accountIdForAnalysis);
                                    lorebookForAnalysis = await getLorebookContext(char, history);
                                }
                            } catch(e) {}
                            
                            let analysisPrompt = `ã€ä½ çš„äººè®¾æ¡£æ¡ˆï¼ˆå¿…é¡»ä¸¥æ ¼éµå®ˆï¼‰ã€‘
${charDesc}
${charRelationships ? `\nã€ä½ å’Œå¯¹æ–¹çš„å…³ç³»ã€‘\n${charRelationships}` : ''}
${userPersonaForAnalysis ? `\nã€å¯¹æ–¹ï¼ˆ${myChar?.name || 'ç”¨æˆ·'}ï¼‰çš„ä¿¡æ¯ã€‘\n${userPersonaForAnalysis}` : ''}
${lorebookForAnalysis ? `\nã€ä¸–ç•Œä¹¦/èƒŒæ™¯è®¾å®šã€‘\n${lorebookForAnalysis}` : ''}

---

${checkResult.checkResult}

ä½ ä¹‹å‰è¯´çš„è¯æ˜¯ï¼šã€Œ${originalCleanReply.replace(/\|\|\|/g, 'ã€ã€Œ')}ã€
ç°åœ¨è¯·ä½ ä½œä¸º ${char.name}ï¼ŒåŸºäºä¸Šè¿°ã€çœŸå®çš„WeChatæ•°æ®ã€‘å’Œä½ çš„äººè®¾ï¼Œç”Ÿæˆä½ æŸ¥çœ‹å®Œè´¦å·åçš„å›å¤ã€‚

è¦æ±‚ï¼š
1. æåŠä½ çœ‹åˆ°çš„å…·ä½“ä¿¡æ¯ï¼ˆå¥½å‹åå­—ã€èŠå¤©å†…å®¹ã€ä½™é¢ç­‰ï¼‰
2. ç”¨ä½ çš„æ€§æ ¼å’Œå¹³æ—¶çš„èŠå¤©æ–¹å¼æ¥è¡¨è¾¾
3. ç”¨ ${char.reply_min_count || 1}-${char.reply_max_count || 3} æ¡çŸ­æ¶ˆæ¯å›å¤ï¼Œç”¨|||åˆ†éš”
4. æ¯æ¡æ¶ˆæ¯ä¸è¦å¤ªé•¿ åƒçœŸäººèŠå¤©
5. å£è¯­åŒ– å°‘ç”¨æ ‡ç‚¹
6. æ³¨æ„ï¼šè¿™åªæ˜¯æŸ¥å²—åçš„å›å¤ï¼Œä½ ä¹‹å‰è¯´çš„è¯å·²ç»å‘é€è¿‡äº†ï¼Œä¸è¦é‡å¤`;

                            // ğŸ”¥ ä¿®ç½—åœºæ¨¡å¼ï¼šåœ¨äºŒæ¬¡åˆ†æä¸­ä¹ŸåŠ å…¥æ“ä½œæŒ‡ä»¤
                            if (char.allow_shura_mode) {
                                const accountId = getCurrentAccountId();
                                const myChar = accountId ? await db.characters.get(parseInt(accountId)) : null;
                                const myName = myChar ? myChar.name : 'ç”¨æˆ·';
                                
                                analysisPrompt += `

ã€ä¿®ç½—åœºæ¨¡å¼ - ä½ å¯ä»¥æ“ä½œ${myName}çš„è´¦å·ã€‘
ä½ å·²ç»æˆåŠŸç™»å½•äº†${myName}çš„è´¦å·ï¼Œä½ å¯ä»¥ç›´æ¥æ“ä½œã€‚

**å¯ç”¨æ“ä½œæŒ‡ä»¤ï¼š**
1. åˆ é™¤å¥½å‹ï¼š[SHURA_DELETE:å¥½å‹åå­—]
2. æ‹‰é»‘å¥½å‹ï¼š[SHURA_BLACKLIST:å¥½å‹åå­—]
3. ä»¥${myName}èº«ä»½å‘æ¶ˆæ¯ç»™æŸä¸ªå¥½å‹ï¼š[SHURA_SEND:å¥½å‹åå­—:æ¶ˆæ¯å†…å®¹1///æ¶ˆæ¯å†…å®¹2///æ¶ˆæ¯å†…å®¹3]ï¼ˆç”¨///åˆ†éš”å¤šæ¡æ¶ˆæ¯ï¼‰

æ ¹æ®ä½ çœ‹åˆ°çš„å†…å®¹å’Œä½ çš„æ€§æ ¼ï¼Œè‡ªè¡Œå†³å®šæ˜¯å¦æ“ä½œã€å¦‚ä½•æ“ä½œã€‚
æ“ä½œæŒ‡ä»¤æ”¾åœ¨replyæœ€åï¼Œç”¨|||åˆ†éš”ã€‚`;
                            }

                            analysisPrompt += `

è¯·ä»¥JSONæ ¼å¼è¿”å›ï¼ˆæ¯æ¡æ¶ˆæ¯è¦çŸ­ ä¸è¦æŠŠå¾ˆå¤šè¯æŒ¤åœ¨ä¸€ä¸ªæ°”æ³¡é‡Œï¼‰ï¼š
{
  "reply": "ç¬¬ä¸€æ¡çŸ­æ¶ˆæ¯|||ç¬¬äºŒæ¡çŸ­æ¶ˆæ¯|||ç¬¬ä¸‰æ¡çŸ­æ¶ˆæ¯",
  "thought": "ä½ æ­¤åˆ»çš„å¿ƒç†æ´»åŠ¨"
}`;

                            // è°ƒç”¨AIè¿›è¡ŒäºŒæ¬¡åˆ†æ
                            try {
                                const analysisMessages = [
                                    { role: 'system', content: analysisPrompt },
                                    { role: 'user', content: '(ä½ å·²ç»æˆåŠŸç™»å½•å¹¶æŸ¥çœ‹äº†WeChatæ•°æ®)' }
                                ];
                                
                                const analysisResponse = await callAI(analysisMessages);
                                const analysisParsed = extractAndParseJSON(analysisResponse);
                                
                                if (analysisParsed && analysisParsed.reply) {
                                    // ğŸ”§ ä¿®å¤ï¼šå…ˆä¿ç•™åŸå§‹æ–‡å­—æ¶ˆæ¯ï¼Œå†è¿½åŠ æŸ¥å²—åçš„å›å¤
                                    // åŸæ¥æ˜¯å®Œå…¨è¦†ç›–ï¼Œå¯¼è‡´åŸå§‹æ–‡å­—æ¶ˆæ¯ä¸¢å¤±
                                    if (originalCleanReply && originalCleanReply.trim()) {
                                        replyText = originalCleanReply.trim() + '|||' + analysisParsed.reply;
                                        console.log('[AIæŸ¥å²—] å·²æ‹¼æ¥åŸå§‹æ¶ˆæ¯ + æŸ¥å²—åˆ†æå›å¤');
                                    } else {
                                        replyText = analysisParsed.reply;
                                    }
                                    
                                    // æ›´æ–°å¿ƒå£°
                                    if (analysisParsed.thought) {
                                        thought = analysisParsed.thought;
                                    }
                                    
                                    console.log('[AIæŸ¥å²—] äºŒæ¬¡åˆ†æå®Œæˆï¼Œç”Ÿæˆäº†åŸºäºçœŸå®æ•°æ®çš„å›å¤');
                                    
                                    // ğŸ”¥ ä¿®ç½—åœºæ¨¡å¼ï¼šè§£æå¹¶æ‰§è¡ŒAIæ“ä½œæŒ‡ä»¤
                                    if (char.allow_shura_mode) {
                                        console.log('[ä¿®ç½—åœº] å¼€å§‹è§£æAIå›å¤ä¸­çš„æ“ä½œæŒ‡ä»¤...');
                                        const shuraResult = await processShuraActions(char, replyText);
                                        if (shuraResult.actions.length > 0) {
                                            replyText = shuraResult.cleanReply;
                                            console.log('[ä¿®ç½—åœº] æ“ä½œæ‰§è¡Œå®Œæˆï¼Œå·²æ¸…ç†å›å¤æ–‡æœ¬');
                                        }
                                    }
                                    
                                    // ğŸ¯ æŸ¥å²—å®Œæˆï¼Œ4ç§’åè‡ªåŠ¨å…³é—­å¼¹çª—
                                    autoCloseOfflineMask(4);
                                } else {
                                    console.warn('[AIæŸ¥å²—] äºŒæ¬¡åˆ†æè¿”å›æ ¼å¼ä¸æ­£ç¡®ï¼Œä½¿ç”¨åŸå›å¤');
                                    // å³ä½¿å¤±è´¥ä¹Ÿè¦å…³é—­å¼¹çª—
                                    autoCloseOfflineMask(3);
                                }
                            } catch (error) {
                                console.error('[AIæŸ¥å²—] äºŒæ¬¡åˆ†æå¤±è´¥:', error);
                                // å¤±è´¥æ—¶ä¿æŒåŸå›å¤ï¼Œå¹¶å…³é—­å¼¹çª—
                                autoCloseOfflineMask(3);
                            }
                        } else {
                            // æ²¡æœ‰wechatæ•°æ®ï¼Œä¹Ÿè¦å…³é—­å¼¹çª—
                            autoCloseOfflineMask(3);
                        }
                    }
                }
                    
                    // å­˜å‚¨å¿ƒå£°åˆ°è§’è‰²å¯¹è±¡
                    if (thought && thought.trim()) {
                        const freshChar = await db.characters.get(targetCharId);
                        if (freshChar) {
                            if (!freshChar.thoughts) freshChar.thoughts = [];
                            freshChar.thoughts.push({
                                content: thought.trim(),
                                time: Date.now(),
                                messageIndex: freshChar.chat_history ? freshChar.chat_history.length : 0
                            });
                            // åªä¿ç•™æœ€è¿‘50æ¡å¿ƒå£°
                            if (freshChar.thoughts.length > 50) {
                                freshChar.thoughts = freshChar.thoughts.slice(-50);
                            }
                            await db.characters.put(freshChar);
                        }
                    }

                // 3. æ¢å¤æ ‡é¢˜
                if (chatTitleEl) chatTitleEl.innerText = originalTitle;
                
                // ğŸ”§ ç»Ÿä¸€çš„è¡¨æƒ…åŒ…æ›¿æ¢å‡½æ•°
                const replaceStickerTags = (text) => {
                    if (!text || !/\[sticker:[^\]]+\]/i.test(text)) return text;
                    
                    if (_mountedStickersList.length === 0) {
                        console.warn('[replaceStickerTags] è§’è‰²æ²¡æœ‰æŒ‚è½½è¡¨æƒ…åŒ…ï¼Œç§»é™¤æ ‡ç­¾');
                        return text.replace(/\[sticker:[^\]]+\]/gi, '');
                    }
                    
                    return text.replace(/\[sticker:([^\]]+)\]/gi, (match, keyword) => {
                        const stickerKeyword = keyword.trim();
                        
                        // æŒ‰ç¼–å·åŒ¹é…
                        const numMatch = stickerKeyword.match(/^\d+$/);
                        if (numMatch) {
                            const requestedNum = parseInt(numMatch[0]);
                            const idx = requestedNum - 1;
                            if (idx >= 0 && idx < _mountedStickersList.length) {
                                console.log(`[replaceStickerTags] âœ… åŒ¹é…è¡¨æƒ…åŒ… #${idx + 1}: ${_mountedStickersList[idx].description}`);
                                return `[img:${_mountedStickersList[idx].url}]`;
                            } else {
                                const randomIdx = Math.floor(Math.random() * _mountedStickersList.length);
                                console.warn(`[replaceStickerTags] âš ï¸ ç¼–å· ${requestedNum} è¶…å‡ºèŒƒå›´ï¼Œéšæœºé€‰æ‹©`);
                                return `[img:${_mountedStickersList[randomIdx].url}]`;
                            }
                        }
                        
                        // ä»æ–‡æœ¬æå–æ•°å­—
                        const numInText = stickerKeyword.match(/(\d+)/);
                        if (numInText) {
                            const requestedNum = parseInt(numInText[1]);
                            const idx = requestedNum - 1;
                            if (idx >= 0 && idx < _mountedStickersList.length) {
                                return `[img:${_mountedStickersList[idx].url}]`;
                            }
                        }
                        
                        // éšæœºé€‰æ‹©
                        const randomSticker = _mountedStickersList[Math.floor(Math.random() * _mountedStickersList.length)];
                        console.log(`[replaceStickerTags] âš ï¸ éšæœºé€‰æ‹©è¡¨æƒ…åŒ…: ${randomSticker.description}`);
                        return `[img:${randomSticker.url}]`;
                    });
                };
                
                // ğŸ”§ æ‹†åˆ†åŒ…å«å›¾ç‰‡çš„æ¶ˆæ¯ï¼ˆç¡®ä¿å›¾ç‰‡å•ç‹¬æ˜¾ç¤ºï¼‰
                const splitMessageWithImages = (text) => {
                    // å…ˆæ›¿æ¢è¡¨æƒ…åŒ…æ ‡ç­¾
                    text = replaceStickerTags(text);
                    
                    // å¦‚æœæ²¡æœ‰å›¾ç‰‡æ ‡ç­¾ï¼Œç›´æ¥è¿”å›
                    if (!text.includes('[img:')) {
                        return [text];
                    }
                    
                    // æ‹†åˆ†æ–‡å­—å’Œå›¾ç‰‡
                    const parts = [];
                    const regex = /(\[img:[^\]]+\])/g;
                    let lastIndex = 0;
                    let match;
                    
                    while ((match = regex.exec(text)) !== null) {
                        // æ·»åŠ å›¾ç‰‡å‰çš„æ–‡å­—
                        if (match.index > lastIndex) {
                            const beforeText = text.substring(lastIndex, match.index).trim();
                            if (beforeText) {
                                parts.push(beforeText);
                            }
                        }
                        // æ·»åŠ å›¾ç‰‡
                        parts.push(match[0]);
                        lastIndex = regex.lastIndex;
                    }
                    
                    // æ·»åŠ æœ€åå‰©ä½™çš„æ–‡å­—
                    if (lastIndex < text.length) {
                        const afterText = text.substring(lastIndex).trim();
                        if (afterText) {
                            parts.push(afterText);
                        }
                    }
                    
                    return parts.length > 0 ? parts : [text];
                };
                
                // ğŸ¯ æ£€æµ‹è§’è‰²åˆ é™¤/æ‹‰é»‘ç”¨æˆ·æŒ‡ä»¤ - åœ¨æ‹†åˆ†å‰å…ˆæ£€æµ‹
                const deleteUserMatchReply = replyText.match(/\(\(DELETE_USER\)\)/i);
                if (deleteUserMatchReply) {
                    console.log(`[TriggerAI] æ£€æµ‹åˆ°è§’è‰²åˆ é™¤ç”¨æˆ·æŒ‡ä»¤...`);
                    const textBeforeDelete = cleanMessage(replyText.substring(0, deleteUserMatchReply.index).trim());
                    if (textBeforeDelete && textBeforeDelete.trim()) {
                        const freshChar = await db.characters.get(targetCharId);
                        if (freshChar) {
                            let history = getChatHistory(freshChar, accountId);
                            const textSegments = textBeforeDelete.split('|||').map(s => s.trim()).filter(s => s.length > 0);
                            for (const seg of textSegments) {
                                // ğŸ”§ æ‹†åˆ†åŒ…å«å›¾ç‰‡çš„æ¶ˆæ¯ï¼ˆç¡®ä¿è¡¨æƒ…åŒ…å•ç‹¬æ˜¾ç¤ºï¼‰
                                const subParts = splitMessageWithImages(cleanMessage(seg));
                                
                                for (const part of subParts) {
                                    history.push({ role: 'char', content: part, time: Date.now() });
                                    await setChatHistory(freshChar, accountId, history);
                                    if (currentChatCharId === targetCharId) {
                                        await appendMessageToUI('char', part);
                                    }
                                    await new Promise(r => setTimeout(r, 300));
                                }
                            }
                        }
                    }
                    await executeCharDeleteUser(targetCharId, accountId);
                    return;
                }
                
                const blockUserMatchReply = replyText.match(/\(\(BLOCK_USER\)\)/i);
                if (blockUserMatchReply) {
                    console.log(`[TriggerAI] æ£€æµ‹åˆ°è§’è‰²æ‹‰é»‘ç”¨æˆ·æŒ‡ä»¤...`);
                    const textBeforeBlock = cleanMessage(replyText.substring(0, blockUserMatchReply.index).trim());
                    if (textBeforeBlock && textBeforeBlock.trim()) {
                        const freshChar = await db.characters.get(targetCharId);
                        if (freshChar) {
                            let history = getChatHistory(freshChar, accountId);
                            const textSegments = textBeforeBlock.split('|||').map(s => s.trim()).filter(s => s.length > 0);
                            for (const seg of textSegments) {
                                // ğŸ”§ æ‹†åˆ†åŒ…å«å›¾ç‰‡çš„æ¶ˆæ¯ï¼ˆç¡®ä¿è¡¨æƒ…åŒ…å•ç‹¬æ˜¾ç¤ºï¼‰
                                const subParts = splitMessageWithImages(cleanMessage(seg));
                                
                                for (const part of subParts) {
                                    history.push({ role: 'char', content: part, time: Date.now() });
                                    await setChatHistory(freshChar, accountId, history);
                                    if (currentChatCharId === targetCharId) {
                                        await appendMessageToUI('char', part);
                                    }
                                    await new Promise(r => setTimeout(r, 300));
                                }
                            }
                        }
                    }
                    await executeCharBlockUser(targetCharId, accountId);
                    return;
                }
                
                // ğŸ¯ æ£€æµ‹NPCåŠ å¥½å‹æŒ‡ä»¤ï¼ˆé¢„å¤„ç†ï¼‰- ä¸returnï¼Œç»§ç»­å¤„ç†æ¶ˆæ¯
                const npcAddMatchReplyPre = replyText.match(/\(\(NPC_ADD_FRIEND:\s*(.+?)\s*\)\)/i);
                if (npcAddMatchReplyPre) {
                    const npcNameReplyPre = npcAddMatchReplyPre[1].trim();
                    console.log(`[TriggerAI] æ£€æµ‹åˆ°NPCåŠ å¥½å‹æŒ‡ä»¤ï¼ˆé¢„å¤„ç†ï¼‰: ${npcNameReplyPre}`);
                    try {
                        await executeNpcAddFriend(char, npcNameReplyPre, accountId);
                    } catch (e) {
                        console.error('[TriggerAI] NPCåŠ å¥½å‹å¤±è´¥:', e);
                    }
                    replyText = replyText.replace(/\(\(NPC_ADD_FRIEND:\s*.+?\s*\)\)/gi, '').trim();
                }

                // âœ… å…³é”®æ”¹åŠ¨ï¼šåœ¨æ‹†åˆ†å‰ï¼Œå…ˆæ£€æµ‹æ˜¯å¦åŒ…å«"æŒ‡ä»¤å‹æ¶ˆæ¯"ï¼ˆè½¬è´¦ç­‰ï¼‰
                // æ£€æµ‹ ((TRANSFER: é‡‘é¢, å¤‡æ³¨)) æ ¼å¼
                const transferMatch = replyText.match(/\(\(TRANSFER:\s*(\d+(\.\d+)?)(?:,\s*(.+?))?\)\)/i);
                
                if (transferMatch) {
                    // æå–è½¬è´¦ä¿¡æ¯
                    const amount = parseFloat(transferMatch[1]);
                    let note = transferMatch[3] || 'è½¬è´¦';
                    // é™åˆ¶å¤‡æ³¨é•¿åº¦ï¼Œä¸è¶…è¿‡10ä¸ªå­—
                    if (note.length > 10) {
                        note = note.substring(0, 10);
                    }
                    
                    // æå–è½¬è´¦å‰é¢çš„æ–‡å­—å†…å®¹ï¼ˆå¦‚æœæœ‰ï¼‰
                    const textBeforeTransfer = replyText.substring(0, transferMatch.index).trim();
                    // ğŸ”¥ ä¿®å¤ï¼šæå–è½¬è´¦åé¢çš„æ–‡å­—å†…å®¹
                    const textAfterTransfer = replyText.substring(transferMatch.index + transferMatch[0].length).trim();
                    
                    const freshChar = await db.characters.get(targetCharId);
                    if (freshChar) {
                        let history = getChatHistory(freshChar, accountId);
                        
                        // 1. å…ˆå‘é€æ–‡å­—æ¶ˆæ¯ï¼ˆå¦‚æœæœ‰ï¼‰- æ”¯æŒåˆ†å‰²æˆå¤šæ¡
                        if (textBeforeTransfer) {
                            // å¯¹è½¬è´¦å‰çš„æ–‡å­—è¿›è¡Œåˆ†å‰²å¤„ç†
                            let textSegments = [];
                            const textToSplit = textBeforeTransfer.replace(/[,ï¼Œ]/g, ' ');
                            if (textToSplit.includes('|||')) {
                                textSegments = textToSplit.split('|||').map(s => s.trim()).filter(s => s.length > 0);
                            } else {
                                textSegments = splitMessage(textToSplit);
                            }
                            
                            // è¿‡æ»¤å¤ªçŸ­çš„æ®µè½
                            textSegments = textSegments.filter(seg => seg.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦\s]/g, '').length >= 2);
                            
                            // å¦‚æœåˆ†å‰²åä¸ºç©ºï¼Œä½†åŸæ–‡æœ¬æœ‰å†…å®¹ï¼Œä½¿ç”¨åŸæ–‡æœ¬
                            if (textSegments.length === 0 && textBeforeTransfer.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦\s]/g, '').length > 0) {
                                textSegments = [textBeforeTransfer];
                            }
                            
                            // é€æ¡å‘é€æ–‡å­—æ¶ˆæ¯
                            let msgIndex = 0;
                            for (let i = 0; i < textSegments.length; i++) {
                                let seg = textSegments[i];
                                // ğŸ”§ æ‹†åˆ†åŒ…å«å›¾ç‰‡çš„æ¶ˆæ¯ï¼ˆç¡®ä¿è¡¨æƒ…åŒ…å•ç‹¬æ˜¾ç¤ºï¼‰
                                const subParts = splitMessageWithImages(seg);
                                
                                for (const part of subParts) {
                                    const textMsg = {
                                        role: 'char',
                                        content: part,
                                        time: Date.now() + msgIndex // ç¡®ä¿æ—¶é—´æˆ³é€’å¢
                                    };
                                    history.push(textMsg);
                                    await setChatHistory(freshChar, accountId, history);
                                    
                                    // æ¸²æŸ“æ–‡å­—æ¶ˆæ¯
                                    if (currentChatCharId === targetCharId) {
                                        await appendMessageToUI('char', part, freshChar.avatar);
                                    }
                                    
                                    // æ¯æ¡æ¶ˆæ¯ä¹‹é—´ç¨å¾®å»¶æ—¶
                                    await new Promise(r => setTimeout(r, 300));
                                    msgIndex++;
                                }
                            }
                            
                            // æœ€åä¸€æ¡æ–‡å­—æ¶ˆæ¯åç¨å¾®å»¶æ—¶å†å‘è½¬è´¦
                            await new Promise(r => setTimeout(r, 500));
                        }
                        
                        // 2. å†å‘é€è½¬è´¦å¡ç‰‡
                        const transferData = {
                            amount: amount.toFixed(2),
                            desc: note,
                            status: 'sent'
                        };
                        
                        const transferMsg = { 
                            role: 'char', 
                            type: 'transfer', // æ˜ç¡®æ ‡è®°ä¸ºè½¬è´¦æ¶ˆæ¯
                            content: JSON.stringify(transferData), 
                            time: Date.now(),
                            id: 'trans_' + Date.now()
                        };
                        
                        // é‡æ–°è·å–æœ€æ–°çš„å†å²è®°å½•ï¼ˆå› ä¸ºåˆšæ‰å¯èƒ½æ’å…¥äº†æ–‡å­—æ¶ˆæ¯ï¼‰
                        history = getChatHistory(freshChar, accountId);
                        history.push(transferMsg);
                        await setChatHistory(freshChar, accountId, history);
                        
                        // æ¸²æŸ“è½¬è´¦å¡ç‰‡ - ä½¿ç”¨ appendMessageToUI è¿½åŠ ï¼Œé¿å…é‡æ–°æ¸²æŸ“æ•´ä¸ªèŠå¤©
                        if (currentChatCharId === targetCharId) {
                            await appendMessageToUI('char', JSON.stringify(transferData), freshChar.avatar);
                        } else {
                            sendSystemNotification(freshChar.name, '[è½¬è´¦]');
                        }
                        
                        await new Promise(r => setTimeout(r, 500));
                    }
                    
                    // ğŸ”¥ ä¿®å¤ï¼šå¦‚æœè½¬è´¦åè¿˜æœ‰å†…å®¹ï¼Œç»§ç»­å¤„ç†
                    if (textAfterTransfer) {
                        console.log('[TriggerAI] è½¬è´¦åè¿˜æœ‰å†…å®¹ï¼Œç»§ç»­å¤„ç†:', textAfterTransfer.substring(0, 50));
                        replyText = textAfterTransfer;
                        // ç»§ç»­æ‰§è¡Œåç»­çš„æ™®é€šæ¶ˆæ¯å¤„ç†é€»è¾‘ï¼Œä¸è¦return
                    } else {
                        return; // è½¬è´¦å¤„ç†å®Œæˆä¸”æ²¡æœ‰åç»­å†…å®¹
                    }
                }
                
                // ğŸ¯ æ£€æµ‹äº²å±å¡èµ é€æŒ‡ä»¤ ((FAMILY_CARD: é¢åº¦))
                const familyCardMatch2 = replyText.match(/\(\(FAMILY_CARD:\s*(\d+)\)\)/i);
                if (familyCardMatch2) {
                    const monthlyLimit = parseInt(familyCardMatch2[1]) || 0;
                    
                    // æå–äº²å±å¡æŒ‡ä»¤å‰é¢çš„æ–‡å­—å†…å®¹
                    const textBeforeFamilyCard = replyText.substring(0, familyCardMatch2.index).trim();
                    // ğŸ”¥ ä¿®å¤ï¼šæå–äº²å±å¡åé¢çš„æ–‡å­—å†…å®¹
                    const textAfterFamilyCard = replyText.substring(familyCardMatch2.index + familyCardMatch2[0].length).trim();
                    
                    const freshChar = await db.characters.get(targetCharId);
                    if (freshChar) {
                        let history = getChatHistory(freshChar, accountId);
                        
                        // 1. å…ˆå‘é€æ–‡å­—æ¶ˆæ¯ï¼ˆå¦‚æœæœ‰ï¼‰
                        if (textBeforeFamilyCard) {
                            let textSegments = [];
                            const textToSplit = textBeforeFamilyCard.replace(/[,ï¼Œ]/g, ' ');
                            if (textToSplit.includes('|||')) {
                                textSegments = textToSplit.split('|||').map(s => s.trim()).filter(s => s.length > 0);
                            } else {
                                textSegments = splitMessage(textToSplit);
                            }
                            textSegments = textSegments.filter(seg => seg.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦\s]/g, '').length >= 2);
                            if (textSegments.length === 0 && textBeforeFamilyCard.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦\s]/g, '').length > 0) {
                                textSegments = [textBeforeFamilyCard];
                            }
                            
                            let msgIndex = 0;
                            for (let i = 0; i < textSegments.length; i++) {
                                let seg = textSegments[i];
                                // ğŸ”§ æ‹†åˆ†åŒ…å«å›¾ç‰‡çš„æ¶ˆæ¯ï¼ˆç¡®ä¿è¡¨æƒ…åŒ…å•ç‹¬æ˜¾ç¤ºï¼‰
                                const subParts = splitMessageWithImages(seg);
                                
                                for (const part of subParts) {
                                    history.push({ role: 'char', content: part, time: Date.now() + msgIndex });
                                    await setChatHistory(freshChar, accountId, history);
                                    if (currentChatCharId === targetCharId) {
                                        await appendMessageToUI('char', part, freshChar.avatar);
                                    }
                                    await new Promise(r => setTimeout(r, 300));
                                    msgIndex++;
                                }
                            }
                            await new Promise(r => setTimeout(r, 500));
                        }
                        
                        // 2. å‘é€äº²å±å¡æ¶ˆæ¯
                        const user = await db.characters.get(parseInt(currentMyCharId));
                        
                        // åœ¨è§’è‰²æ•°æ®ä¸­æ·»åŠ "æˆ‘èµ é€çš„"
                        if (!freshChar.identity) freshChar.identity = {};
                        if (!freshChar.identity.familyCardsGiven) freshChar.identity.familyCardsGiven = [];
                        freshChar.identity.familyCardsGiven.push({
                            charId: parseInt(currentMyCharId),
                            monthlyLimit: monthlyLimit,
                            usedThisMonth: 0,
                            records: [],
                            createdAt: Date.now()
                        });
                        await db.characters.put(freshChar);
                        
                        // åœ¨ç”¨æˆ·æ•°æ®ä¸­æ·»åŠ "æˆ‘æ”¶åˆ°çš„"
                        if (user) {
                            if (!user.identity) user.identity = {};
                            if (!user.identity.familyCardsReceived) user.identity.familyCardsReceived = [];
                            user.identity.familyCardsReceived.push({
                                charId: freshChar.id,
                                monthlyLimit: monthlyLimit,
                                usedThisMonth: 0,
                                records: [],
                                createdAt: Date.now()
                            });
                            await db.characters.put(user);
                        }
                        
                        // å‘é€äº²å±å¡æ¶ˆæ¯åˆ°èŠå¤©
                        const familyCardMsg = {
                            role: 'char',
                            type: 'familyCard',
                            content: JSON.stringify({
                                fromName: freshChar.name,
                                monthlyLimit: monthlyLimit,
                                status: 'sent'
                            }),
                            time: Date.now()
                        };
                        
                        history = getChatHistory(freshChar, accountId);
                        history.push(familyCardMsg);
                        await setChatHistory(freshChar, accountId, history);
                        
                        if (currentChatCharId === targetCharId) {
                            renderChatBody(freshChar);
                        }
                        
                        showToast(`${freshChar.name} èµ é€äº†äº²å±å¡`);
                        
                        await new Promise(r => setTimeout(r, 500));
                    }
                    
                    // ğŸ”¥ ä¿®å¤ï¼šå¦‚æœäº²å±å¡åè¿˜æœ‰å†…å®¹ï¼Œç»§ç»­å¤„ç†
                    if (textAfterFamilyCard) {
                        console.log('[TriggerAI] äº²å±å¡åè¿˜æœ‰å†…å®¹ï¼Œç»§ç»­å¤„ç†:', textAfterFamilyCard.substring(0, 50));
                        replyText = textAfterFamilyCard;
                        // ç»§ç»­æ‰§è¡Œåç»­çš„æ™®é€šæ¶ˆæ¯å¤„ç†é€»è¾‘ï¼Œä¸è¦return
                    } else {
                        return; // äº²å±å¡å¤„ç†å®Œæˆä¸”æ²¡æœ‰åç»­å†…å®¹
                    }
                }
                
                // ğŸ¯ æ£€æµ‹å¤–å–å¡ç‰‡æŒ‡ä»¤ ((EMEI_ORDER: åº—é“º, å•†å“, é‡‘é¢)) / ((EMEI_PAY: ...)) / ((EMEI_SHARE: ...))
                const emeiOrderMatch = replyText.match(/\(\(EMEI_ORDER:\s*(.+?),\s*(.+?),\s*(\d+(?:\.\d+)?)\)\)/i);
                const emeiPayMatch = replyText.match(/\(\(EMEI_PAY:\s*(.+?),\s*(.+?),\s*(\d+(?:\.\d+)?)\)\)/i);
                const emeiShareMatch = replyText.match(/\(\(EMEI_SHARE:\s*(.+?),\s*(.+?),\s*(\d+(?:\.\d+)?)\)\)/i);
                const emeiMatch = emeiOrderMatch || emeiPayMatch || emeiShareMatch;
                
                if (emeiMatch) {
                    const emeiType = emeiOrderMatch ? 'order' : (emeiPayMatch ? 'pay' : 'share');
                    const emeiStore = emeiMatch[1].trim();
                    const emeiItems = emeiMatch[2].trim();
                    const emeiTotal = parseFloat(emeiMatch[3]);
                    
                    // æå–å¤–å–æŒ‡ä»¤å‰é¢çš„æ–‡å­—å†…å®¹
                    const textBeforeEmei = replyText.substring(0, emeiMatch.index).trim();
                    // ğŸ”¥ ä¿®å¤ï¼šæå–å¤–å–åé¢çš„æ–‡å­—å†…å®¹
                    const textAfterEmei = replyText.substring(emeiMatch.index + emeiMatch[0].length).trim();
                    
                    const freshChar = await db.characters.get(targetCharId);
                    if (freshChar) {
                        let history = getChatHistory(freshChar, accountId);
                        
                        // 1. å…ˆå‘é€æ–‡å­—æ¶ˆæ¯ï¼ˆå¦‚æœæœ‰ï¼‰
                        if (textBeforeEmei) {
                            let textSegments = [];
                            const textToSplit = textBeforeEmei.replace(/[,ï¼Œ]/g, ' ');
                            if (textToSplit.includes('|||')) {
                                textSegments = textToSplit.split('|||').map(s => s.trim()).filter(s => s.length > 0);
                            } else {
                                textSegments = splitMessage(textToSplit);
                            }
                            textSegments = textSegments.filter(seg => seg.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦\s]/g, '').length >= 2);
                            if (textSegments.length === 0 && textBeforeEmei.replace(/[.,ï¼Œã€‚!?ï¼ï¼Ÿ~â€¦\s]/g, '').length > 0) {
                                textSegments = [textBeforeEmei];
                            }
                            
                            let msgIndex = 0;
                            for (let i = 0; i < textSegments.length; i++) {
                                let seg = textSegments[i];
                                // ğŸ”§ æ‹†åˆ†åŒ…å«å›¾ç‰‡çš„æ¶ˆæ¯ï¼ˆç¡®ä¿è¡¨æƒ…åŒ…å•ç‹¬æ˜¾ç¤ºï¼‰
                                const subParts = splitMessageWithImages(seg);
                                
                                for (const part of subParts) {
                                    history.push({ role: 'char', content: part, time: Date.now() + msgIndex });
                                    await setChatHistory(freshChar, accountId, history);
                                    if (currentChatCharId === targetCharId) {
                                        await appendMessageToUI('char', part, freshChar.avatar);
                                    }
                                    await new Promise(r => setTimeout(r, 300));
                                    msgIndex++;
                                }
                            }
                            await new Promise(r => setTimeout(r, 500));
                        }
                        
                        // 2. æ„å»ºå°ç¥¨é£æ ¼å¡ç‰‡HTML
                        const emeiItemList = emeiItems.split(/[/\/ã€]/).map(item => item.trim());
                        const emeiItemsHtml = emeiItemList.map(item => {
                            const priceEach = (emeiTotal / emeiItemList.length).toFixed(2);
                            return `<div style="display:flex;justify-content:space-between;margin-bottom:6px;font-size:13px;"><span style="color:#333;font-weight:600;">${item}</span><span style="font-family:Arial,sans-serif;">Â¥${priceEach}</span></div>`;
                        }).join('');
                        
                        let emeiTitle, emeiHint, emeiBtnHtml, emeiTag;
                        if (emeiType === 'order') {
                            emeiTitle = `${emeiStore} Â· ç»™ä½ ç‚¹çš„`;
                            emeiHint = `${freshChar.name}ç»™ä½ ç‚¹äº†å¤–å–~`;
                            emeiBtnHtml = '';
                            emeiTag = 'emei_order';
                        } else if (emeiType === 'pay') {
                            emeiTitle = `${emeiStore} Â· ä»£ä»˜è¯·æ±‚`;
                            emeiHint = 'å¸®æˆ‘ä»˜ä¸€ä¸‹å¤–å–~';
                            emeiBtnHtml = `<div onclick="handlePaymentRequest(this)" data-amount="${emeiTotal.toFixed(2)}" data-pay-type="user_pay" style="display:block;width:100%;padding:10px;background:#ff4d4f;color:white;text-align:center;border-radius:4px;font-family:sans-serif;font-weight:bold;letter-spacing:1px;cursor:pointer;box-sizing:border-box;margin-top:4px;">å¸®TAæ”¯ä»˜</div>`;
                            emeiTag = 'payment_request';
                        } else {
                            emeiTitle = `ğŸ›µ ${emeiStore} Â· å¤–å–åˆ†äº«`;
                            emeiHint = 'æˆ‘åˆšç‚¹äº†å¤–å– åˆ†äº«ç»™ä½ çœ‹çœ‹~';
                            emeiBtnHtml = '';
                            emeiTag = 'emei_share';
                        }
                        
                        const emeiCardHtml = `<div style="width:260px;background:#fff;padding:16px;box-shadow:0 4px 15px rgba(0,0,0,0.1);position:relative;font-family:'Courier New',Courier,monospace;box-sizing:border-box;"><div style="position:absolute;top:-5px;left:0;width:100%;height:10px;background:linear-gradient(135deg,transparent 5px,#fff 5px) 0 0,linear-gradient(225deg,transparent 5px,#fff 5px) 0 0;background-size:20px 20px;background-repeat:repeat-x;"></div><div style="position:absolute;bottom:-10px;left:0;width:100%;height:10px;background:linear-gradient(45deg,transparent 5px,#fff 5px) 0 0,linear-gradient(-45deg,transparent 5px,#fff 5px) 0 0;background-size:20px 20px;background-repeat:repeat-x;"></div><div style="text-align:center;font-weight:800;font-size:16px;color:#333;margin-bottom:5px;border-bottom:2px dashed #ddd;padding-bottom:12px;">${emeiTitle}</div><div style="text-align:center;font-size:12px;color:#888;margin:8px 0;">${emeiHint}</div><div style="margin:12px 0;font-size:13px;color:#555;">${emeiItemsHtml}</div><div style="border-top:1px dashed #ccc;margin:12px 0;"></div><div style="display:flex;justify-content:space-between;font-size:16px;font-weight:900;color:#000;margin-bottom:8px;"><span>åˆè®¡</span><span style="font-family:Arial,sans-serif;${emeiType === 'pay' ? 'color:#ff4d4f;' : ''}">Â¥${emeiTotal.toFixed(2)}</span></div>${emeiBtnHtml}<div style="text-align:center;font-size:10px;color:#aaa;margin-top:10px;font-family:Arial,sans-serif;">${new Date().toLocaleString('zh-CN')}</div></div>`;
                        
                        // 3. å‘é€å¡ç‰‡æ¶ˆæ¯
                        const emeiCardMsg = {
                            role: 'char',
                            content: `[${emeiTag}]${emeiCardHtml}`,
                            time: Date.now()
                        };
                        history = getChatHistory(freshChar, accountId);
                        history.push(emeiCardMsg);
                        await setChatHistory(freshChar, accountId, history);
                        
                        if (currentChatCharId === targetCharId) {
                            renderChatBody(freshChar);
                        } else {
                            const tagNames = { 'emei_order': 'å¤–å–è®¢å•', 'payment_request': 'ä»£ä»˜è¯·æ±‚', 'emei_share': 'å¤–å–åˆ†äº«' };
                            sendSystemNotification(freshChar.name, `[${tagNames[emeiTag]}]`);
                        }
                        
                        showToast(`${freshChar.name} å‘é€äº†${emeiType === 'order' ? 'å¤–å–è®¢å•' : emeiType === 'pay' ? 'ä»£ä»˜è¯·æ±‚' : 'å¤–å–åˆ†äº«'}`);
                        
                        await new Promise(r => setTimeout(r, 500));
                    }
                    
                    // ğŸ”¥ ä¿®å¤ï¼šå¦‚æœå¤–å–åè¿˜æœ‰å†…å®¹ï¼Œç»§ç»­å¤„ç†
                    if (textAfterEmei) {
                        console.log('[TriggerAI] å¤–å–åè¿˜æœ‰å†…å®¹ï¼Œç»§ç»­å¤„ç†:', textAfterEmei.substring(0, 50));
                        replyText = textAfterEmei;
                        // ç»§ç»­æ‰§è¡Œåç»­çš„æ™®é€šæ¶ˆæ¯å¤„ç†é€»è¾‘ï¼Œä¸è¦return
                    } else {
                        return; // å¤–å–å¤„ç†å®Œæˆä¸”æ²¡æœ‰åç»­å†…å®¹
                    }
                }
                
                // ğŸ¯ æ£€æµ‹æœ‹å‹åœˆå‘å¸ƒæŒ‡ä»¤ [MOMENTS] - æ”¯æŒå¤šç§æ ¼å¼
                // æ ¼å¼1: [MOMENTS] content: xxx images: N
                let momentsMatch = replyText.match(/\[MOMENTS\]\s*content:\s*([^\n]+)(?:\s*images?:\s*(\d+))?/i);
                // æ ¼å¼2: ((MOMENTS: å†…å®¹))
                if (!momentsMatch) {
                    momentsMatch = replyText.match(/\(\(MOMENTS:\s*(.+?)\)\)/i);
                    if (momentsMatch) {
                        momentsMatch = [momentsMatch[0], momentsMatch[1], '0'];
                    }
                }
                // æ ¼å¼3: ã€æœ‹å‹åœˆï¼šå†…å®¹ã€‘
                if (!momentsMatch) {
                    momentsMatch = replyText.match(/ã€æœ‹å‹åœˆ[ï¼š:]\s*(.+?)ã€‘/);
                    if (momentsMatch) {
                        momentsMatch = [momentsMatch[0], momentsMatch[1], '0'];
                    }
                }
                
                if (momentsMatch) {
                    let momentContent = momentsMatch[1].trim();
                    let imageCount = momentsMatch[2] ? parseInt(momentsMatch[2]) : 0;
                    let imageDesc = '';
                    
                    // ğŸ”¥ ä¿®å¤ï¼šæå– [imgcard:] ä½œä¸ºæœ‹å‹åœˆé…å›¾æè¿°
                    const afterMoments = replyText.substring(momentsMatch.index + momentsMatch[0].length);
                    const imgcardMatch = afterMoments.match(/\[imgcard:([^\]]+)\]/i);
                    if (imgcardMatch) {
                        imageDesc = imgcardMatch[1].trim();
                        if (imageCount === 0) imageCount = 1; // æœ‰å›¾ç‰‡æè¿°åˆ™è‡³å°‘1å¼ 
                        console.log(`[TriggerAI] æå–åˆ°æœ‹å‹åœˆé…å›¾æè¿°: ${imageDesc}`);
                    }
                    // ä¹Ÿæ£€æŸ¥ content ä¸­æ˜¯å¦å†…åµŒäº† [imgcard:]
                    const contentImgcard = momentContent.match(/\[imgcard:([^\]]+)\]/i);
                    if (contentImgcard) {
                        imageDesc = imageDesc || contentImgcard[1].trim();
                        momentContent = momentContent.replace(/\[imgcard:[^\]]+\]/gi, '').trim();
                        if (imageCount === 0) imageCount = 1;
                    }
                    // ä¹Ÿä» MOMENTS ä¹‹å‰çš„æ–‡æœ¬ä¸­æå–ï¼ˆAIæœ‰æ—¶æŠŠimgcardæ”¾å‰é¢ï¼‰
                    const beforeMoments = replyText.substring(0, momentsMatch.index);
                    const beforeImgcard = beforeMoments.match(/\[imgcard:([^\]]+)\]/i);
                    if (beforeImgcard && !imageDesc) {
                        imageDesc = beforeImgcard[1].trim();
                        if (imageCount === 0) imageCount = 1;
                    }
                    
                    // æå–æœ‹å‹åœˆæŒ‡ä»¤å‰é¢çš„æ–‡å­—å†…å®¹ï¼ˆå¦‚æœæœ‰ï¼‰
                    let textBeforeMoments = replyText.substring(0, momentsMatch.index).trim();
                    // æ¸…ç†æ‰ [imgcard:] éƒ¨åˆ†ï¼Œä¸è¦ä½œä¸ºèŠå¤©æ¶ˆæ¯å‘é€
                    textBeforeMoments = textBeforeMoments.replace(/\[imgcard:[^\]]+\]/gi, '').trim();
                    
                    // ğŸ”¥ ä¿®å¤ï¼šæå–æœ‹å‹åœˆåé¢çš„æ–‡å­—å†…å®¹
                    let textAfterMoments = afterMoments.replace(/\[imgcard:[^\]]+\]/gi, '').trim();
                    
                    const freshChar = await db.characters.get(targetCharId);
                    if (freshChar) {
                        let history = getChatHistory(freshChar, accountId);
                        
                        // 1. å…ˆå‘é€æ–‡å­—æ¶ˆæ¯ï¼ˆå¦‚æœæœ‰ï¼‰- ğŸ”¥ ä¿®å¤ï¼šæŒ‰ ||| åˆ†å‰²å¤šæ¡æ¶ˆæ¯ï¼Œé¿å…æ ¼å¼ä¸¢å¤±
                        if (textBeforeMoments) {
                            const msgSegments = textBeforeMoments.split('|||')
                                .map(s => cleanMessage(s.trim()))
                                .filter(s => s && s.length > 0);
                            
                            console.log(`[TriggerAI] æœ‹å‹åœˆå‰æ–‡å­—æŒ‰|||åˆ†å‰²ä¸º ${msgSegments.length} æ¡æ¶ˆæ¯`);
                            
                            let msgIndex = 0;
                            for (let i = 0; i < msgSegments.length; i++) {
                                // ğŸ”§ æ‹†åˆ†åŒ…å«å›¾ç‰‡çš„æ¶ˆæ¯ï¼ˆç¡®ä¿è¡¨æƒ…åŒ…å•ç‹¬æ˜¾ç¤ºï¼‰
                                const subParts = splitMessageWithImages(msgSegments[i]);
                                
                                for (const part of subParts) {
                                    const textMsg = {
                                        role: 'char',
                                        content: part,
                                        time: Date.now() + msgIndex
                                    };
                                    history.push(textMsg);
                                    await setChatHistory(freshChar, accountId, history);
                                    
                                    // æ¸²æŸ“æ–‡å­—æ¶ˆæ¯
                                    if (currentChatCharId === targetCharId) {
                                        appendMessageToUI('char', part, freshChar.avatar);
                                    }
                                    msgIndex++;
                                }
                                
                                // æ¶ˆæ¯é—´å»¶æ—¶ï¼ˆæ¨¡æ‹Ÿè¿å‘ï¼‰
                                if (i < msgSegments.length - 1) {
                                    await new Promise(r => setTimeout(r, 300 + Math.random() * 400));
                                }
                            }
                            
                            // ç¨å¾®å»¶æ—¶å†å‘æœ‹å‹åœˆ
                            await new Promise(r => setTimeout(r, 500));
                        }
                        
                        // 2. å‘å¸ƒæœ‹å‹åœˆï¼ˆä¼ å…¥å›¾ç‰‡æè¿°ï¼‰
                        await publishMomentsByCharacter(freshChar, momentContent, imageCount, imageDesc);
                        
                        console.log(`[TriggerAI] ${freshChar.name} å‘å¸ƒäº†æœ‹å‹åœˆ${imageDesc ? ` [é…å›¾: ${imageDesc}]` : ''}`);
                        
                        // å‘é€é€šçŸ¥
                        sendSystemNotification(freshChar.name, '[æœ‹å‹åœˆ]');
                        
                        await new Promise(r => setTimeout(r, 500));
                    }
                    
                    // ğŸ”¥ ä¿®å¤ï¼šå¦‚æœæœ‹å‹åœˆåè¿˜æœ‰å†…å®¹ï¼Œç»§ç»­å¤„ç†
                    if (textAfterMoments) {
                        console.log('[TriggerAI] æœ‹å‹åœˆåè¿˜æœ‰å†…å®¹ï¼Œç»§ç»­å¤„ç†:', textAfterMoments.substring(0, 50));
                        replyText = textAfterMoments;
                        // ç»§ç»­æ‰§è¡Œåç»­çš„æ™®é€šæ¶ˆæ¯å¤„ç†é€»è¾‘ï¼Œä¸è¦return
                    } else {
                        return; // æœ‹å‹åœˆå¤„ç†å®Œæˆä¸”æ²¡æœ‰åç»­å†…å®¹
                    }
                }
                
                // ğŸ¯ æ£€æµ‹"å¹»è§‰"ï¼šAIè¯´å‘äº†æœ‹å‹åœˆä½†æ²¡æœ‰æŒ‡ä»¤
                const hasMomentsClaim = /å‘äº†.*?æœ‹å‹åœˆ|æœ‹å‹åœˆ.*?å‘äº†|å‘å¸ƒ.*?åŠ¨æ€|æ›´æ–°.*?æœ‹å‹åœˆ|å‘ä¸ªæœ‹å‹åœˆ/i.test(replyText);
                if (hasMomentsClaim) {
                    console.warn(`[TriggerAI] âš ï¸ AIå¹»è§‰æ£€æµ‹ï¼šè§’è‰²è¯´å‘äº†æœ‹å‹åœˆï¼Œä½†æ²¡æœ‰è¿”å›æ­£ç¡®çš„æŒ‡ä»¤æ ¼å¼ï¼`);
                    console.warn(`[TriggerAI] æ­£ç¡®æ ¼å¼ç¤ºä¾‹ï¼š[MOMENTS] content: å†…å®¹ images: 1`);
                    showToast(`è§’è‰²è¯´å‘äº†æœ‹å‹åœˆï¼Œä½†æ ¼å¼ä¸å¯¹ï¼Œæœªå®é™…å‘å¸ƒ`);
                }
                
                // å…œåº•ï¼šæ£€æµ‹æ˜¯å¦æ˜¯è½¬è´¦ JSONï¼ˆå…¼å®¹æ—§æ ¼å¼ï¼‰
                let trimmedReply = replyText.trim();
                if (trimmedReply.startsWith('{') && trimmedReply.includes('"amount"')) {
                    try {
                        const parsed = JSON.parse(trimmedReply);
                        if (parsed.amount && parsed.desc !== undefined && parsed.status) {
                            const freshChar = await db.characters.get(targetCharId);
                            if (freshChar) {
                                let history = getChatHistory(freshChar, accountId);
                                
                                const newMsg = { 
                                    role: 'char', 
                                    type: 'transfer',
                                    content: trimmedReply, 
                                    time: Date.now(),
                                    id: 'trans_' + Date.now()
                                };
                                
                                history.push(newMsg);
                                await setChatHistory(freshChar, accountId, history);
                                
                                if (currentChatCharId === targetCharId) {
                                    renderChatBody(freshChar);
                                } else {
                                    sendSystemNotification(freshChar.name, '[è½¬è´¦]');
                                }
                            }
                            return;
                        }
                    } catch(e) {
                        // ä¸æ˜¯æœ‰æ•ˆçš„ JSONï¼Œç»§ç»­å½“æ™®é€šæ¶ˆæ¯
                    }
                }
                
                // 4. æ™®é€šæ¶ˆæ¯ï¼šå¼ºåˆ¶æ¸…æ´—é€—å· + æ‹†åˆ†
                // ğŸ”§ ä¿®å¤ä¸å®Œæ•´çš„è¡¨æƒ…åŒ…æ ‡ç­¾ï¼ˆç¼ºå°‘å³æ‹¬å·ï¼‰
                replyText = replyText.replace(/\[sticker:(\d+)(?![\]])/g, '[sticker:$1]');
                console.log('[TriggerAI] ğŸ”§ ä¿®å¤ä¸å®Œæ•´çš„è¡¨æƒ…åŒ…æ ‡ç­¾å:', replyText);
                
                let cleanText = replyText.replace(/[,ï¼Œ]/g, ' ');
                let segments = [];
                
                // è°ƒè¯•æ—¥å¿—ï¼šæ£€æŸ¥åˆ†å‰²å‰çš„å†…å®¹
                console.log('[TriggerAI] ğŸ“ å‡†å¤‡åˆ†å‰²æ¶ˆæ¯');
                console.log('[TriggerAI] - åŸå§‹replyText:', replyText);
                console.log('[TriggerAI] - cleanText:', cleanText);
                console.log('[TriggerAI] - æ˜¯å¦åŒ…å«|||:', cleanText.includes('|||'));
                console.log('[TriggerAI] - ||| çš„ä½ç½®:', cleanText.indexOf('|||'));
                
                // ğŸ”¥ å¢å¼ºï¼šä¼˜å…ˆä½¿ç”¨ ||| æ‹†åˆ†ï¼Œå¹¶è¿›è¡Œæ›´ä¸¥æ ¼çš„æ¸…ç†
                if (cleanText.includes('|||')) {
                    segments = cleanText.split('|||')
                        .map(s => {
                            let cleaned = s.trim();
                            
                            // å¯¹æ¯æ¡æ¶ˆæ¯å†æ¬¡æ¸…ç†æŸ¥å²—æŒ‡ä»¤æ®‹ç•™
                            cleaned = cleanMessage(cleaned)
                                .replace(/\[CHECK_ACCOUNT(?::.*?)?\]/gi, '')
                                .replace(/\[CHECK_ACCOUNT:[^\]]*$/gi, '')
                                .replace(/\[CHECK_ACCOUNT$/gi, '')
                                .replace(/\[\d{4,10}$/gi, '')
                                .replace(/CHECK_ACCOUNT/gi, '')
                                .trim();
                            
                            // ğŸ”¥ å¢å¼ºï¼šå¦‚æœå•æ¡æ¶ˆæ¯è¿‡é•¿ï¼ˆè¶…è¿‡100å­—ï¼‰ï¼Œå°è¯•æ™ºèƒ½åˆ†å‰²
                            if (cleaned.length > 100 && !cleaned.startsWith('[') && !cleaned.startsWith('((')) {
                                // âœ… ä¿®å¤ï¼šå…ˆç§»é™¤ç¿»è¯‘æ‹¬å·å†åˆ¤æ–­æ–­å¥ç‚¹ï¼Œé¿å…æ‹†æ•£ç¿»è¯‘
                                const withoutTranslation = cleaned.replace(/[ï¼ˆ(][^ï¼‰)]*[\u4e00-\u9fff][^ï¼‰)]*[ï¼‰)]/g, '');
                                const naturalBreaks = withoutTranslation.match(/[^ã€‚ï¼ï¼Ÿ!?]+[ã€‚ï¼ï¼Ÿ!?]+/g);
                                if (naturalBreaks && naturalBreaks.length > 1) {
                                    // ä½¿ç”¨ä¸ç ´åç¿»è¯‘æ‹¬å·çš„æ–¹å¼åˆ†å‰²
                                    const smartSegments = smartSplitWithTranslation(cleaned);
                                    if (smartSegments.length > 1) {
                                        console.log(`[TriggerAI] âš ï¸ å•æ¡æ¶ˆæ¯è¿‡é•¿(${cleaned.length}å­—)ï¼Œæ™ºèƒ½åˆ†å‰²ä¸º${smartSegments.length}æ¡`);
                                        return smartSegments;
                                    }
                                }
                            }
                            
                            return cleaned;
                        })
                        .flat() // å±•å¹³å¯èƒ½çš„åµŒå¥—æ•°ç»„
                        .filter(s => s && s.length > 0);
                    
                    console.log('[TriggerAI] âœ… ä½¿ç”¨|||åˆ†å‰²ï¼Œå¾—åˆ°', segments.length, 'æ¡æ¶ˆæ¯');
                    segments.forEach((seg, i) => console.log(`  [${i}]: ${seg.substring(0, 50)}${seg.length > 50 ? '...' : ''}`));
                } else {
                    // å›é€€åˆ°æ ‡ç‚¹æ‹†åˆ†é€»è¾‘ (ä½†é€—å·å·²ç»è¢«å¹²æ‰äº†)
                    segments = splitMessage(cleanText);
                    console.log('[TriggerAI] â„¹ï¸ æœªæ‰¾åˆ°|||ï¼Œä½¿ç”¨æ ‡ç‚¹åˆ†å‰²ï¼Œå¾—åˆ°', segments.length, 'æ¡æ¶ˆæ¯');
                }
                
                // ğŸ”¥ å¢å¼ºï¼šå¦‚æœåˆ†å‰²åçš„æ¶ˆæ¯å¤ªå°‘ä½†æ€»é•¿åº¦å¾ˆé•¿ï¼Œå¼ºåˆ¶å†æ¬¡åˆ†å‰²
                if (segments.length === 1 && segments[0].length > 150) {
                    console.log('[TriggerAI] âš ï¸ åªæœ‰1æ¡æ¶ˆæ¯ä½†é•¿åº¦è¿‡é•¿(', segments[0].length, ')ï¼Œå¼ºåˆ¶æ™ºèƒ½åˆ†å‰²');
                    const longMsg = segments[0];
                    // âœ… ä¿®å¤ï¼šä½¿ç”¨ä¸ç ´åç¿»è¯‘æ‹¬å·çš„æ™ºèƒ½åˆ†å‰²
                    const smartSegments = smartSplitWithTranslation(longMsg);
                    if (smartSegments.length > 1) {
                        segments = smartSegments;
                        console.log('[TriggerAI] âœ… å¼ºåˆ¶åˆ†å‰²ä¸º', segments.length, 'æ¡');
                    }
                }
                
                // å…œåº•ï¼šå¦‚æœæ²¡æ‹†å‡ºæ¥ï¼Œä½†æœ‰å†…å®¹ï¼Œå°±å½“æˆä¸€æ¡
                if (segments.length === 0 && cleanText.trim()) {
                    segments.push(cleanMessage(cleanText.trim()));
                }

                for (let i = 0; i < segments.length; i++) {
                    let seg = segments[i];
                    
                    // ğŸ¯ æ£€æµ‹æ¢å¤´åƒæŒ‡ä»¤ ((CHANGE_AVATAR)) - åœ¨åˆ†æ®µä¸­æ£€æµ‹
                    if (/\(\(CHANGE_AVATAR\)\)/i.test(seg)) {
                        console.log(`[AiReply] æ£€æµ‹åˆ°æ¢å¤´åƒæŒ‡ä»¤ï¼Œæ‰§è¡Œæ¢å¤´åƒ...`);
                        try {
                            await executeChangeAvatar(targetCharId, accountId);
                        } catch (e) {
                            console.error('[AiReply] æ¢å¤´åƒå¤±è´¥:', e);
                        }
                        // ç§»é™¤æŒ‡ä»¤æ–‡æœ¬ï¼Œä¿ç•™å…¶ä»–å†…å®¹
                        seg = seg.replace(/\(\(CHANGE_AVATAR\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æƒ…å¤´é‚€è¯·æŒ‡ä»¤ ((COUPLE_AVATAR)) - åœ¨åˆ†æ®µä¸­æ£€æµ‹
                    if (/\(\(COUPLE_AVATAR\)\)/i.test(seg)) {
                        console.log(`[AiReply] æ£€æµ‹åˆ°æƒ…å¤´é‚€è¯·æŒ‡ä»¤...`);
                        try {
                            await sendCoupleAvatarCard(targetCharId, accountId);
                        } catch (e) {
                            console.error('[AiReply] å‘é€æƒ…å¤´é‚€è¯·å¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(COUPLE_AVATAR\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æ¢å›å•äººå¤´åƒæŒ‡ä»¤ ((REVERT_COUPLE_AVATAR)) - åœ¨åˆ†æ®µä¸­æ£€æµ‹
                    if (/\(\(REVERT_COUPLE_AVATAR\)\)/i.test(seg)) {
                        console.log(`[AiReply] æ£€æµ‹åˆ°æ¢å›å•äººå¤´åƒæŒ‡ä»¤...`);
                        try {
                            await executeRevertCoupleAvatar(targetCharId, accountId);
                        } catch (e) {
                            console.error('[AiReply] æ¢å›å•äººå¤´åƒå¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(REVERT_COUPLE_AVATAR\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹ä½¿ç”¨å›¾ç‰‡å½“å¤´åƒæŒ‡ä»¤ ((USE_IMAGE_AS_AVATAR: N)) - åœ¨åˆ†æ®µä¸­æ£€æµ‹
                    const useImgMatchReply = seg.match(/\(\(USE_IMAGE_AS_AVATAR(?::\s*(\d+))?\)\)/i);
                    if (useImgMatchReply) {
                        const imgIdx = useImgMatchReply[1] ? parseInt(useImgMatchReply[1]) : 1;
                        console.log(`[AiReply] æ£€æµ‹åˆ°ä½¿ç”¨å›¾ç‰‡å½“å¤´åƒæŒ‡ä»¤ï¼Œé€‰æ‹©ç¬¬${imgIdx}å¼ ...`);
                        try {
                            await executeUseImageAsAvatar(targetCharId, accountId, imgIdx);
                        } catch (e) {
                            console.error('[AiReply] ä½¿ç”¨å›¾ç‰‡å½“å¤´åƒå¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(USE_IMAGE_AS_AVATAR(?::\s*\d+)?\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æˆ³ä¸€æˆ³æŒ‡ä»¤ ((POKE: åŠ¨ä½œ, éƒ¨ä½)) - åœ¨åˆ†æ®µä¸­æ£€æµ‹
                    const pokeMatchReply = seg.match(/\(\(POKE:\s*(.+?)\)\)/i);
                    if (pokeMatchReply) {
                        console.log(`[AiReply] æ£€æµ‹åˆ°æˆ³ä¸€æˆ³æŒ‡ä»¤...`);
                        try {
                            const pokeContent = pokeMatchReply[1].trim();
                            let pokeAction, pokePart;
                            if (pokeContent.includes(',') || pokeContent.includes('ï¼Œ')) {
                                const parts = pokeContent.split(/[,ï¼Œ]/);
                                pokeAction = parts[0].trim();
                                pokePart = parts.slice(1).join('').trim();
                            } else {
                                const spaceIdx = pokeContent.indexOf(' ');
                                if (spaceIdx > 0) {
                                    pokeAction = pokeContent.substring(0, spaceIdx).trim();
                                    pokePart = pokeContent.substring(spaceIdx + 1).trim();
                                } else {
                                    pokeAction = pokeContent;
                                    pokePart = '';
                                }
                            }
                            const freshChar = await db.characters.get(targetCharId);
                            const myChar = accountId ? await db.characters.get(parseInt(accountId)) : null;
                            const userName = myChar ? (myChar.nick || myChar.name) : 'ç”¨æˆ·';
                            const pokeText = pokePart ? `${freshChar.name}${pokeAction}${userName}çš„${pokePart}` : `${freshChar.name}${pokeAction}${userName}`;
                            
                            let history = getChatHistory(freshChar, accountId);
                            history.push({ role: 'system', content: pokeText, time: Date.now(), type: 'poke' });
                            await setChatHistory(freshChar, accountId, history);
                            
                            if (currentChatCharId === targetCharId) {
                                await appendMessageToUI('system', pokeText);
                            }
                            console.log(`[AiReply] æˆ³ä¸€æˆ³: ${pokeText}`);
                        } catch (e) {
                            console.error('[AiReply] æˆ³ä¸€æˆ³å¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(POKE:\s*(.+?)\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æ‰“å¼€APPæŒ‡ä»¤ ((OPEN_APP: APPåç§°)) - åœ¨åˆ†æ®µä¸­æ£€æµ‹
                    const appMatchReply = seg.match(/\(\(OPEN_APP:\s*(.+?)\)\)/i);
                    if (appMatchReply) {
                        console.log(`[AiReply] æ£€æµ‹åˆ°æ‰“å¼€APPæŒ‡ä»¤...`);
                        try {
                            const appName = appMatchReply[1].trim();
                            const freshChar = await db.characters.get(targetCharId);
                            const appText = `${freshChar.name} æ‰“å¼€äº† "${appName}"`;
                            
                            let history = getChatHistory(freshChar, accountId);
                            history.push({ role: 'system', content: appText, time: Date.now(), type: 'open_app' });
                            await setChatHistory(freshChar, accountId, history);
                            
                            if (currentChatCharId === targetCharId) {
                                await appendMessageToUI('system', appText);
                            }
                            console.log(`[AiReply] æ‰“å¼€APP: ${appText}`);
                        } catch (e) {
                            console.error('[AiReply] æ‰“å¼€APPå¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(OPEN_APP:\s*(.+?)\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æ”¹ç½‘åæŒ‡ä»¤ ((SET_NICKNAME: æ–°ç½‘å)) - åœ¨åˆ†æ®µä¸­æ£€æµ‹
                    const nicknameMatchReply = seg.match(/\(\(SET_NICKNAME:\s*(.+?)\)\)/i);
                    if (nicknameMatchReply) {
                        console.log(`[AiReply] æ£€æµ‹åˆ°æ”¹ç½‘åæŒ‡ä»¤...`);
                        try {
                            const newNickname = nicknameMatchReply[1].trim();
                            const freshChar = await db.characters.get(targetCharId);
                            const oldNickname = freshChar.wx_nickname || freshChar.name;
                            freshChar.wx_nickname = newNickname;
                            await db.characters.put(freshChar);
                            
                            const nicknameText = `${oldNickname} å°†ç½‘åæ”¹ä¸º "${newNickname}"`;
                            let history = getChatHistory(freshChar, accountId);
                            history.push({ role: 'system', content: nicknameText, time: Date.now(), type: 'set_nickname' });
                            await setChatHistory(freshChar, accountId, history);
                            
                            if (currentChatCharId === targetCharId) {
                                await appendMessageToUI('system', nicknameText);
                                if (!freshChar.remark) {
                                    document.getElementById('chat-title').innerText = newNickname;
                                }
                                const nicknameEl = document.getElementById('detail-char-nickname');
                                if (nicknameEl) nicknameEl.innerText = newNickname;
                            }
                            console.log(`[AiReply] æ”¹ç½‘å: ${nicknameText}`);
                        } catch (e) {
                            console.error('[AiReply] æ”¹ç½‘åå¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(SET_NICKNAME:\s*(.+?)\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æ”¹ä¸ªæ€§ç­¾åæŒ‡ä»¤ ((SET_SIGNATURE: æ–°ç­¾å)) - åœ¨åˆ†æ®µä¸­æ£€æµ‹
                    const signatureMatchReply = seg.match(/\(\(SET_SIGNATURE:\s*(.+?)\)\)/i);
                    if (signatureMatchReply) {
                        console.log(`[AiReply] æ£€æµ‹åˆ°æ”¹ä¸ªæ€§ç­¾åæŒ‡ä»¤...`);
                        try {
                            const newSignature = signatureMatchReply[1].trim();
                            const freshChar = await db.characters.get(targetCharId);
                            freshChar.wx_signature = newSignature;
                            await db.characters.put(freshChar);
                            
                            const sigText = `${freshChar.wx_nickname || freshChar.name} æ›´æ–°äº†ä¸ªæ€§ç­¾å: "${newSignature}"`;
                            let history = getChatHistory(freshChar, accountId);
                            history.push({ role: 'system', content: sigText, time: Date.now(), type: 'set_signature' });
                            await setChatHistory(freshChar, accountId, history);
                            
                            if (currentChatCharId === targetCharId) {
                                await appendMessageToUI('system', sigText);
                                const sigEl = document.getElementById('detail-char-signature');
                                if (sigEl) sigEl.innerText = newSignature;
                            }
                            console.log(`[AiReply] æ”¹ç­¾å: ${sigText}`);
                        } catch (e) {
                            console.error('[AiReply] æ”¹ç­¾åå¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(SET_SIGNATURE:\s*(.+?)\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹åˆ é™¤å¥½å‹æŒ‡ä»¤ ((DELETE_USER)) - åœ¨åˆ†æ®µä¸­æ£€æµ‹
                    if (/\(\(DELETE_USER\)\)/i.test(seg)) {
                        console.log(`[AiReply] æ£€æµ‹åˆ°è§’è‰²åˆ é™¤ç”¨æˆ·æŒ‡ä»¤...`);
                        try {
                            await executeCharDeleteUser(targetCharId, accountId);
                        } catch (e) {
                            console.error('[AiReply] è§’è‰²åˆ é™¤ç”¨æˆ·å¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(DELETE_USER\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æ‹‰é»‘å¥½å‹æŒ‡ä»¤ ((BLOCK_USER)) - åœ¨åˆ†æ®µä¸­æ£€æµ‹
                    if (/\(\(BLOCK_USER\)\)/i.test(seg)) {
                        console.log(`[AiReply] æ£€æµ‹åˆ°è§’è‰²æ‹‰é»‘ç”¨æˆ·æŒ‡ä»¤...`);
                        try {
                            await executeCharBlockUser(targetCharId, accountId);
                        } catch (e) {
                            console.error('[AiReply] è§’è‰²æ‹‰é»‘ç”¨æˆ·å¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(BLOCK_USER\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹NPCåŠ å¥½å‹æŒ‡ä»¤ ((NPC_ADD_FRIEND: NPCåå­—)) - åœ¨åˆ†æ®µä¸­æ£€æµ‹
                    const npcAddMatchReply = seg.match(/\(\(NPC_ADD_FRIEND:\s*(.+?)\s*\)\)/i);
                    if (npcAddMatchReply) {
                        const npcName = npcAddMatchReply[1].trim();
                        console.log(`[AiReply] æ£€æµ‹åˆ°NPCåŠ å¥½å‹æŒ‡ä»¤: ${npcName}`);
                        try {
                            await executeNpcAddFriend(char, npcName, accountId);
                        } catch (e) {
                            console.error('[AiReply] NPCåŠ å¥½å‹å¤±è´¥:', e);
                        }
                        seg = seg.replace(/\(\(NPC_ADD_FRIEND:\s*.+?\s*\)\)/gi, '').trim();
                        if (!seg) continue;
                    }
                    
                    // ğŸ¯ æ£€æµ‹æ’¤å›æŒ‡ä»¤ - åœ¨åˆ†æ®µä¸­æ£€æµ‹
                    if (/^\s*\(\(RECALL\)\)\s*$/i.test(seg)) {
                        console.log(`[AiReply] æ£€æµ‹åˆ°æ’¤å›æŒ‡ä»¤ï¼Œæ‰§è¡Œæ’¤å›...`);
                        const freshChar = await db.characters.get(targetCharId);
                        if (freshChar) {
                            let history = getChatHistory(freshChar, accountId);
                            
                            // æ‰¾AIæœ€åä¸€æ¡æ¶ˆæ¯ï¼ˆéæ’¤å›çŠ¶æ€ï¼‰
                            let targetIndex = -1;
                            for (let j = history.length - 1; j >= 0; j--) {
                                if (history[j].role === 'char' && !history[j].isRecalled) {
                                    targetIndex = j;
                                    break;
                                }
                            }
                            
                            if (targetIndex >= 0) {
                                const originalContent = history[targetIndex].content;
                                history[targetIndex].recalledContent = originalContent;
                                history[targetIndex].isRecalled = true;
                                history[targetIndex].content = "";
                                await setChatHistory(freshChar, accountId, history);
                                
                                console.log(`[AiReply] ${freshChar.name} æ’¤å›äº†æ¶ˆæ¯`);
                                
                                // æ›´æ–°UI - å±…ä¸­ç³»ç»Ÿæç¤ºæ ·å¼
                                if (currentChatCharId === targetCharId) {
                                    const chatBody = document.getElementById('chat-body');
                                    const messageRows = chatBody.querySelectorAll('.message-row');
                                    if (messageRows[targetIndex]) {
                                        const msgRow = messageRows[targetIndex];
                                        msgRow.className = 'message-row recalled-system-row';
                                        msgRow.innerHTML = '';
                                        
                                        const capturedContent = originalContent;
                                        const capturedName = freshChar.name;
                                        const systemTip = document.createElement('div');
                                        systemTip.className = 'recalled-system-tip';
                                        systemTip.innerHTML = `"${capturedName}"æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯`;
                                        systemTip.style.cursor = 'pointer';
                                        systemTip.onclick = (e) => {
                                            e.stopPropagation();
                                            showRecalledContent(capturedName, capturedContent);
                                        };
                                        msgRow.appendChild(systemTip);
                                    }
                                }
                                
                                sendSystemNotification(freshChar.name, 'æ’¤å›äº†ä¸€æ¡æ¶ˆæ¯');
                            }
                        }
                        continue; // è·³è¿‡è¿™ä¸ªåˆ†æ®µï¼Œä¸ä½œä¸ºæ¶ˆæ¯å‘é€
                    }
                    
                    // ğŸ¯ æ£€æµ‹è¡¨æƒ…åŒ…æŒ‡ä»¤ [sticker:æè¿°/ç¼–å·] - åœ¨åˆ†æ®µä¸­æ£€æµ‹å¹¶æ›¿æ¢ä¸ºå®é™…è¡¨æƒ…åŒ…å›¾ç‰‡
                    if (/\[sticker:[^\]]+\]/i.test(seg)) {
                        if (_mountedStickersList.length > 0) {
                            seg = seg.replace(/\[sticker:([^\]]+)\]/gi, (match, keyword) => {
                                const stickerKeyword = keyword.trim();
                                console.log(`[AiReply] æ£€æµ‹åˆ°è¡¨æƒ…åŒ…æŒ‡ä»¤: ${stickerKeyword}`);
                                
                                // ğŸ”¢ ä¼˜å…ˆï¼šæŒ‰ç¼–å·åŒ¹é…ï¼ˆAIç”¨ [sticker:1] æ ¼å¼ï¼‰
                                const numMatch = stickerKeyword.match(/^\d+$/);
                                if (numMatch) {
                                    const idx = parseInt(numMatch[0]) - 1; // ç¼–å·ä»1å¼€å§‹
                                    if (idx >= 0 && idx < _mountedStickersList.length) {
                                        console.log(`[AiReply] âœ… æŒ‰ç¼–å·åŒ¹é…åˆ°è¡¨æƒ…åŒ… #${idx + 1}: ${_mountedStickersList[idx].description}`);
                                        return `[img:${_mountedStickersList[idx].url}]`;
                                    }
                                }
                                
                                // ğŸ”¢ å°è¯•ä»æ–‡æœ¬ä¸­æå–æ•°å­—ï¼ˆå¦‚ "ç¼–å·3"ã€"ç¬¬3ä¸ª"ï¼‰
                                const numInText = stickerKeyword.match(/(\d+)/);
                                if (numInText) {
                                    const idx = parseInt(numInText[1]) - 1;
                                    if (idx >= 0 && idx < _mountedStickersList.length) {
                                        console.log(`[AiReply] âœ… ä»æ–‡æœ¬æå–ç¼–å·åŒ¹é…åˆ°è¡¨æƒ…åŒ… #${idx + 1}: ${_mountedStickersList[idx].description}`);
                                        return `[img:${_mountedStickersList[idx].url}]`;
                                    }
                                }
                                
                                // ğŸ“ å…¶æ¬¡ï¼šæŒ‰æè¿°æ¨¡ç³ŠåŒ¹é…
                                const stickerKeywordLower = stickerKeyword.toLowerCase();
                                let bestMatch = null;
                                let bestScore = 0;
                                
                                for (const s of _mountedStickersList) {
                                    const desc = s.description.toLowerCase();
                                    // å®Œå…¨åŒ¹é…
                                    if (desc === stickerKeywordLower) {
                                        bestMatch = s;
                                        bestScore = 100;
                                        break;
                                    }
                                    // æè¿°åŒ…å«å…³é”®è¯
                                    if (desc.includes(stickerKeywordLower) && stickerKeywordLower.length > 1) {
                                        const score = stickerKeywordLower.length / desc.length * 80;
                                        if (score > bestScore) { bestMatch = s; bestScore = score; }
                                    }
                                    // å…³é”®è¯åŒ…å«æè¿°
                                    if (stickerKeywordLower.includes(desc) && desc.length > 1) {
                                        const score = desc.length / stickerKeywordLower.length * 70;
                                        if (score > bestScore) { bestMatch = s; bestScore = score; }
                                    }
                                    // å…³é”®è¯çš„éƒ¨åˆ†è¯åŒ¹é…ï¼ˆæ¯ä¸ªå­—éƒ½å°è¯•ï¼‰
                                    const keywords = stickerKeywordLower.split(/[\s,ï¼Œã€]+/).filter(k => k.length > 0);
                                    let matchCount = 0;
                                    for (const kw of keywords) {
                                        if (desc.includes(kw)) matchCount++;
                                    }
                                    if (matchCount > 0) {
                                        const score = matchCount / keywords.length * 60;
                                        if (score > bestScore) { bestMatch = s; bestScore = score; }
                                    }
                                    // å•å­—ç¬¦åŒ¹é…ï¼ˆé’ˆå¯¹ä¸­æ–‡ï¼šé€å­—æ£€æŸ¥ï¼‰
                                    if (bestScore < 30) {
                                        let charMatch = 0;
                                        for (const ch of stickerKeywordLower) {
                                            if (desc.includes(ch)) charMatch++;
                                        }
                                        if (charMatch > 0 && stickerKeywordLower.length > 0) {
                                            const score = charMatch / stickerKeywordLower.length * 40;
                                            if (score > bestScore) { bestMatch = s; bestScore = score; }
                                        }
                                    }
                                }
                                
                                if (bestMatch && bestScore >= 15) {
                                    console.log(`[AiReply] âœ… åŒ¹é…åˆ°è¡¨æƒ…åŒ…: ${bestMatch.description} (å¾—åˆ†: ${bestScore})`);
                                    return `[img:${bestMatch.url}]`;
                                } else {
                                    // æ²¡æ‰¾åˆ°åŒ¹é…ï¼Œéšæœºé€‰ä¸€ä¸ª
                                    const randomSticker = _mountedStickersList[Math.floor(Math.random() * _mountedStickersList.length)];
                                    console.log(`[AiReply] âš ï¸ AIæé€ äº†è¡¨æƒ…åŒ…"${stickerKeyword}"ï¼Œéšæœºé€‰æ‹©: ${randomSticker.description}`);
                                    return `[img:${randomSticker.url}]`;
                                }
                            });
                        } else {
                            // æ²¡æœ‰æŒ‚è½½è¡¨æƒ…åŒ…ä½†AIä»ç„¶è¾“å‡ºäº†[sticker:]ï¼Œæ¸…é™¤æ‰
                            console.log(`[AiReply] âš ï¸ è§’è‰²æ²¡æœ‰æŒ‚è½½è¡¨æƒ…åŒ…ï¼Œä½†AIè¾“å‡ºäº†[sticker:]ï¼Œæ¸…é™¤`);
                            seg = seg.replace(/\[sticker:[^\]]+\]/gi, '').trim();
                            if (!seg) continue; // å¦‚æœæ¸…é™¤åä¸ºç©ºï¼Œè·³è¿‡æ­¤æ®µ
                        }
                    }
                    
                    // å»¶æ—¶ï¼šç¬¬ä¸€æ¡ç›´æ¥å‘(å‰é¢loadingå·²ç»æ˜¯ç­‰å¾…äº†)ï¼Œåç»­æ¨¡æ‹Ÿæ‰“å­—
                    if (i > 0) {
                        // åŸºç¡€ 500ms + æ¯å­— 80ms
                        const delay = 500 + Math.min(seg.length * 80, 3000);
                        await new Promise(r => setTimeout(r, delay));
                    }

                    // å§‹ç»ˆå­˜å…¥ DB
                    const freshChar = await db.characters.get(targetCharId);
                    if (freshChar) {
                        let history = getChatHistory(freshChar, accountId);
                        
                        const newMsg = { 
                            role: 'char', 
                            content: seg, 
                            time: Date.now()
                        };
                        
                        history.push(newMsg);
                        await setChatHistory(freshChar, accountId, history);
                        
                        // åªæœ‰åœ¨å½“å‰çª—å£åŒ¹é…æ—¶æ‰æ¸²æŸ“ UI
                        if (currentChatCharId === targetCharId) {
                            console.log(`[AiReply] User is viewing ${freshChar.name}'s chat, appending to UI`);
                            showDebugToast(`AIå›å¤: æ­£åœ¨æŸ¥çœ‹${freshChar.name}ï¼Œæ˜¾ç¤ºåœ¨UI`);
                            appendMessageToUI('char', seg, freshChar.avatar);
                        } else {
                            // ä¸åœ¨å½“å‰çª—å£æ—¶ï¼Œå‘é€ç³»ç»Ÿé€šçŸ¥
                            console.log(`[AiReply] User is NOT viewing ${freshChar.name}'s chat (current: ${currentChatCharId}), sending notification`);
                            showDebugToast(`AIå›å¤: ä¸åœ¨${freshChar.name}èŠå¤©ä¸­(å½“å‰:${currentChatCharId})ï¼Œå‘é€é€šçŸ¥`);
                            sendSystemNotification(freshChar.name, seg);
                        }
                    }
                }
                
                // âœ… AIå›å¤å®Œæˆåï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦è‡ªåŠ¨æ€»ç»“
                try {
                    await checkAutoSummary('private', targetCharId, accountId);
                } catch (summaryError) {
                    console.error('[AutoSummary] æ£€æŸ¥è‡ªåŠ¨æ€»ç»“å¤±è´¥:', summaryError);
                }
                
            } catch (err) {
                console.error("AI å›å¤å¤±è´¥", err);
                if (chatTitleEl) chatTitleEl.innerText = originalTitle;
                
                // ä½¿ç”¨å¼¹çª—æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯ï¼Œè€Œä¸æ˜¯åœ¨èŠå¤©ç•Œé¢æ·»åŠ æ¶ˆæ¯
                showApiErrorToast(err.message || 'API è¯·æ±‚å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ– API é…ç½®');
            } finally {
                // ğŸ”§ æ— è®ºæˆåŠŸè¿˜æ˜¯å¤±è´¥ï¼Œéƒ½è¦é‡Šæ”¾é”ï¼Œå…è®¸ä¸‹æ¬¡è°ƒç”¨
                window._isGeneratingReply = false;
            }
        }

        // é‡æ–°ç”Ÿæˆå›å¤ï¼ˆåˆ é™¤ä¸Šä¸€æ¬¡AIå›å¤çš„æ‰€æœ‰æ¶ˆæ¯å¹¶é‡æ–°ç”Ÿæˆï¼Œä¸åˆ é™¤ç”¨æˆ·æ¶ˆæ¯ï¼‰
        async function regenerateLastReply() {
            // ç¾¤èŠé‡å›
            if (window.currentGroupChatId) {
                await regenerateGroupReply();
                return;
            }
            
            if (!currentChatCharId) return;
            
            const char = await db.characters.get(currentChatCharId);
            const accountId = getCurrentAccountId();
            const history = getChatHistory(char, accountId);
            
            if (!char || !history || history.length === 0) {
                // æ²¡æœ‰èŠå¤©è®°å½•ï¼Œæ— æ³•é‡æ–°ç”Ÿæˆ
                return;
            }
            
            // æ‰¾åˆ°ä¸Šä¸€æ¬¡AIå›å¤çš„æ‰€æœ‰æ¶ˆæ¯ï¼ˆä»æœ€åå¾€å‰æ‰¾ï¼Œç›´åˆ°é‡åˆ°ç”¨æˆ·æ¶ˆæ¯ï¼‰
            let lastAiMessageStartIndex = -1;
            let lastAiMessageEndIndex = -1;
            
            // ä»åå¾€å‰æ‰¾æœ€åä¸€æ¡AIæ¶ˆæ¯
            for (let i = history.length - 1; i >= 0; i--) {
                if (history[i].role === 'char') {
                    lastAiMessageEndIndex = i;
                    break;
                }
            }
            
            // å¦‚æœæ²¡æœ‰AIå›å¤ï¼Œç›´æ¥ç”Ÿæˆæ–°çš„
            if (lastAiMessageEndIndex === -1) {
                closeChatPanel();
                await triggerAiReply();
                return;
            }
            
            // ä»æœ€åä¸€æ¡AIæ¶ˆæ¯å¾€å‰æ‰¾ï¼Œæ‰¾åˆ°è¿ç»­çš„æ‰€æœ‰AIæ¶ˆæ¯
            lastAiMessageStartIndex = lastAiMessageEndIndex;
            for (let i = lastAiMessageEndIndex - 1; i >= 0; i--) {
                if (history[i].role === 'user') {
                    // é‡åˆ°ç”¨æˆ·æ¶ˆæ¯ï¼Œåœæ­¢
                    break;
                }
                // è¿˜æ˜¯AIçš„æ¶ˆæ¯ï¼Œç»§ç»­å¾€å‰
                lastAiMessageStartIndex = i;
            }
            
            // åˆ é™¤æ‰€æœ‰è¿ç»­çš„AIæ¶ˆæ¯ï¼ˆä¸åˆ é™¤ç”¨æˆ·æ¶ˆæ¯ï¼‰
            const deleteCount = lastAiMessageEndIndex - lastAiMessageStartIndex + 1;
            history.splice(lastAiMessageStartIndex, deleteCount);
            await setChatHistory(char, accountId, history);
            await db.characters.put(char);
            
            // é‡æ–°æ¸²æŸ“èŠå¤©ç•Œé¢ï¼ˆç§»é™¤AIå›å¤æ¶ˆæ¯ï¼‰
            renderChatBody(char);
            
            // å…³é—­é¢æ¿
            closeChatPanel();
            
            // é‡æ–°ç”Ÿæˆå›å¤ï¼ˆåŸºäºåˆ é™¤åçš„å†å²è®°å½•ï¼Œç”¨æˆ·æ¶ˆæ¯è¿˜åœ¨ï¼‰
            await triggerAiReply();
        }
        
        // ç¾¤èŠé‡æ–°ç”Ÿæˆå›å¤
        async function regenerateGroupReply() {
            if (!window.currentGroupChatId) return;
            
            let group = await db.group_chats.get(window.currentGroupChatId);
            if (!group || !group.chat_history || group.chat_history.length === 0) {
                showToast('æ²¡æœ‰èŠå¤©è®°å½•');
                return;
            }
            
            const history = group.chat_history;
            
            // æ‰¾åˆ°ä¸Šä¸€æ¬¡AIå›å¤çš„æ‰€æœ‰æ¶ˆæ¯ï¼ˆä»æœ€åå¾€å‰æ‰¾ï¼Œç›´åˆ°é‡åˆ°ç”¨æˆ·æ¶ˆæ¯æˆ–ç³»ç»Ÿæ¶ˆæ¯ï¼‰
            let lastAiMessageStartIndex = -1;
            let lastAiMessageEndIndex = -1;
            
            // ä»åå¾€å‰æ‰¾æœ€åä¸€æ¡AIè§’è‰²æ¶ˆæ¯
            for (let i = history.length - 1; i >= 0; i--) {
                if (history[i].role === 'char') {
                    lastAiMessageEndIndex = i;
                    break;
                }
            }
            
            // å¦‚æœæ²¡æœ‰AIå›å¤ï¼Œç›´æ¥ç”Ÿæˆæ–°çš„
            if (lastAiMessageEndIndex === -1) {
                closeChatPanel();
                await triggerAiReply();
                return;
            }
            
            // ä»æœ€åä¸€æ¡AIæ¶ˆæ¯å¾€å‰æ‰¾ï¼Œæ‰¾åˆ°è¿ç»­çš„æ‰€æœ‰AIæ¶ˆæ¯ï¼ˆä¸åŒ…æ‹¬ç³»ç»Ÿæ¶ˆæ¯ï¼‰
            lastAiMessageStartIndex = lastAiMessageEndIndex;
            for (let i = lastAiMessageEndIndex - 1; i >= 0; i--) {
                if (history[i].role === 'user') {
                    // é‡åˆ°ç”¨æˆ·æ¶ˆæ¯ï¼Œåœæ­¢
                    break;
                }
                if (history[i].role === 'system') {
                    // ç³»ç»Ÿæ¶ˆæ¯ä¹Ÿç®—ä½œåˆ†éš”ï¼Œä½†å¦‚æœæ˜¯é¢†å–çº¢åŒ…ç­‰ç³»ç»Ÿæ¶ˆæ¯ï¼Œä¹Ÿåˆ é™¤
                    const content = history[i].content || '';
                    if (content.includes('é¢†å–äº†çº¢åŒ…') || content.includes('å°†è‡ªå·±çš„ç¾¤æ˜µç§°æ”¹ä¸º')) {
                        lastAiMessageStartIndex = i;
                        continue;
                    }
                    break;
                }
                // è¿˜æ˜¯AIçš„æ¶ˆæ¯ï¼Œç»§ç»­å¾€å‰
                lastAiMessageStartIndex = i;
            }
            
            // åˆ é™¤æ‰€æœ‰è¿ç»­çš„AIæ¶ˆæ¯å’Œç›¸å…³ç³»ç»Ÿæ¶ˆæ¯
            const deleteCount = lastAiMessageEndIndex - lastAiMessageStartIndex + 1;
            history.splice(lastAiMessageStartIndex, deleteCount);
            
            group.chat_history = history;
            group.updated_at = Date.now();
            await db.group_chats.put(group);
            
            // é‡æ–°æ¸²æŸ“ç¾¤èŠç•Œé¢
            await renderGroupChatBody(group);
            
            // å…³é—­é¢æ¿
            closeChatPanel();
            
            // é‡æ–°ç”Ÿæˆç¾¤èŠå›å¤
            await triggerAiReply();
        }

// --- è§’è‰²æ¡£æ¡ˆ (Character) é€»è¾‘ ---
function showCharacterPage() {
    document.getElementById('character-page').style.display = 'flex';
    loadCharacterList();
}

        function hideCharacterPage() {
            const page = document.getElementById('character-page');
            page.style.transform = 'scale(0.95)';
            page.style.opacity = '0';
            setTimeout(() => {
                page.style.display = 'none';
                page.style.transform = ''; 
                page.style.opacity = '';
            }, 200);
        }

        function switchCharacterTab(type) {
            currentCharacterType = type;
            
            // æ›´æ–°åº•éƒ¨æ ·å¼
            ['char', 'npc', 'user'].forEach(t => {
                const el = document.getElementById(`tab-${t}`);
                if (t === type) {
                    el.style.color = 'var(--ins-pink)';
                } else {
                    el.style.color = '#999';
                }
            });
            
            loadCharacterList();
        }

        async function loadCharacterList() {
            const container = document.getElementById('character-list');
            container.innerHTML = '';
            
            // ä»æ•°æ®åº“è·å–æŒ‡å®šç±»å‹çš„è§’è‰²
            const list = await db.characters.where('type').equals(currentCharacterType).toArray();
            
            if (list.length === 0) {
                container.innerHTML = `
                    <div style="grid-column: span 2; text-align:center; color:#999; margin-top:60px; display:flex; flex-direction:column; align-items:center; gap:10px;">
                        <svg class="svg-icon" style="width:40px; height:40px; stroke:#ccc;" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><line x1="8" y1="15" x2="16" y2="15"></line><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line></svg>
                        <div>è¿™é‡Œè¿˜æ²¡äººå“¦</div>
                    </div>
                `;
                return;
            }

            list.forEach(char => {
                const div = document.createElement('div');
                div.className = 'char-card';
                div.onclick = () => editCharacter(char.id);
                
                // é»˜è®¤å¤´åƒ
                let bgStyle = 'background-color: #eee;';
                if (char.avatar) {
                    bgStyle = `background-image: url(${char.avatar});`;
                }
                
                div.innerHTML = `
                    <div class="char-card-img" style="${bgStyle}"></div>
                    <div class="char-card-info">
                        <div class="char-name">${char.name || 'æœªå‘½å'}</div>
                        <div class="char-nick">${char.nick || ''}</div>
                    </div>
                `;
                container.appendChild(div);
            });
        }

        function createNewCharacter() {
            editingCharId = null;
            document.getElementById('char-editor-title').innerText = "æ–°å»ºè§’è‰²";
            document.getElementById('char-name').value = '';
            document.getElementById('char-nick').value = '';
            document.getElementById('char-desc').value = '';
            document.getElementById('char-type').value = currentCharacterType; // é»˜è®¤é€‰ä¸­å½“å‰ Tab ç±»å‹
            document.getElementById('char-avatar-preview').style.backgroundImage = '';
            document.getElementById('char-avatar-placeholder').style.display = 'flex';
            
            // éšè—NPCç¼–è¾‘æç¤º
            const descHint = document.getElementById('char-desc-hint');
            if (descHint) descHint.style.display = 'none';
            
            // ğŸ¯ è‡ªåŠ¨ç”Ÿæˆæ‰‹æœºå·ï¼ˆå‰7ä½å›ºå®š 1380000ï¼Œå4ä½éšæœºï¼‰
            const autoGeneratedPhone = generateRandomPhone();
            console.log('[åˆ›å»ºè§’è‰²] è‡ªåŠ¨ç”Ÿæˆæ‰‹æœºå·:', autoGeneratedPhone);
            
            // æ¸…ç©ºè™šæ‹Ÿèº«ä»½ä¿¡æ¯
            document.getElementById('char-identity-account').value = '';
            document.getElementById('char-identity-password').value = '';
            document.getElementById('char-identity-phone').value = autoGeneratedPhone; // è‡ªåŠ¨å¡«å……æ‰‹æœºå·
            document.getElementById('char-identity-address').value = '';
            document.getElementById('char-identity-id').value = '';
            document.getElementById('char-identity-bank').value = '';
            document.getElementById('char-identity-bank-pass').value = '';

            document.getElementById('character-editor-page').style.display = 'flex';
            
            // ğŸ‰ æ˜¾ç¤ºæ‰‹æœºå·åˆ†é…å¼¹çª—
            setTimeout(() => {
                showPhoneAssignedModal(autoGeneratedPhone);
            }, 300); // ç¨å¾®å»¶è¿Ÿï¼Œç­‰å¾…ç¼–è¾‘å™¨é¡µé¢æ‰“å¼€
        }

        async function editCharacter(id) {
            editingCharId = id;
            const char = await db.characters.get(id);
            if (!char) return;
            
            document.getElementById('char-editor-title').innerText = "ç¼–è¾‘è§’è‰²";
            document.getElementById('char-name').value = char.name || '';
            document.getElementById('char-nick').value = char.nick || '';
            document.getElementById('char-desc').value = char.description || '';
            document.getElementById('char-type').value = char.type || 'char';
            
            // å¦‚æœæ˜¯NPCä¸”æœ‰æè¿°ï¼Œæ˜¾ç¤ºæç¤º
            const descHint = document.getElementById('char-desc-hint');
            if (char.type === 'npc' && char.description) {
                descHint.style.display = 'block';
            } else {
                descHint.style.display = 'none';
            }
            
            // å›æ˜¾è™šæ‹Ÿèº«ä»½ä¿¡æ¯
            const idData = char.identity || {};
            document.getElementById('char-identity-account').value = idData.account || '';
            document.getElementById('char-identity-password').value = idData.password || '';
            document.getElementById('char-identity-phone').value = idData.phone || '';
            document.getElementById('char-identity-address').value = idData.address || '';
            document.getElementById('char-identity-id').value = idData.id_card || '';
            document.getElementById('char-identity-bank').value = idData.bank_card || '';
            document.getElementById('char-identity-bank-pass').value = idData.bank_password || '';

            if (char.avatar) {
                document.getElementById('char-avatar-preview').style.backgroundImage = `url(${char.avatar})`;
                document.getElementById('char-avatar-placeholder').style.display = 'none';
            } else {
                document.getElementById('char-avatar-preview').style.backgroundImage = '';
                document.getElementById('char-avatar-placeholder').style.display = 'flex';
            }
            
            // æ¸²æŸ“å…³ç³»åˆ—è¡¨
            renderRelationList(char);

            document.getElementById('character-editor-page').style.display = 'flex';
        }

        // æ¸²æŸ“ç¼–è¾‘é¡µçš„å…³ç³»åˆ—è¡¨
        async function renderRelationList(char) {
            const container = document.getElementById('char-relation-list');
            container.innerHTML = '';
            
            if (!char.relationships || char.relationships.length === 0) {
                container.innerHTML = '<div style="text-align:center; color:#ccc; font-size:12px; padding:10px;">æš‚æ— å…³ç³»è®°å½•ï¼Œç‚¹å‡»ã€Œæ·»åŠ å…³ç³»ã€å¼€å§‹æ„å»ºäººé™…å…³ç³»ç½‘</div>';
                return;
            }

            // relationships: [{ targetId, targetName, relation, desc }]
            for (let i = 0; i < char.relationships.length; i++) {
                const rel = char.relationships[i];
                // å°è¯•è·å–æœ€æ–°çš„å¤´åƒ
                let avatarUrl = '';
                if (rel.targetId) {
                    const target = await db.characters.get(rel.targetId);
                    if (target && target.avatar) avatarUrl = target.avatar;
                }
                
                const item = document.createElement('div');
                item.className = 'relation-item';
                item.innerHTML = `
                    <div class="relation-avatar" style="${avatarUrl ? `background-image:url(${avatarUrl})` : ''}"></div>
                    <div class="relation-info">
                        <div class="relation-name">${rel.targetName} <span class="relation-tag">${rel.relation}</span></div>
                        <div class="relation-desc">${rel.desc || ''}</div>
                    </div>
                    <div class="relation-actions">
                        <button title="ç¼–è¾‘å…³ç³»" onclick="editRelation(${i})">âœï¸</button>
                        <button title="åˆ é™¤å…³ç³»" onclick="deleteRelation(${i})" style="color:#ff3b30;">âœ•</button>
                    </div>
                `;
                container.appendChild(item);
            }
        }

        // ========== æ‰‹åŠ¨æ·»åŠ /ç¼–è¾‘/åˆ é™¤å…³ç³» ==========
        let _relationEditIndex = -1; // ç¼–è¾‘æ¨¡å¼ä¸‹çš„ç´¢å¼•ï¼Œ-1è¡¨ç¤ºæ–°å¢

        // æ˜¾ç¤ºæ·»åŠ å…³ç³»å¼¹çª—
        async function showAddRelationModal() {
            if (!editingCharId) {
                alert("è¯·å…ˆä¿å­˜å½“å‰è§’è‰²åå†æ·»åŠ å…³ç³»");
                return;
            }
            _relationEditIndex = -1;
            
            // é‡ç½®è¡¨å•
            document.getElementById('relation-type-custom').value = '';
            document.getElementById('relation-desc-input').value = '';
            document.getElementById('relation-reverse-type').value = '';
            document.getElementById('relation-bidirectional').checked = true;
            document.getElementById('relation-reverse-section').style.display = 'block';
            document.querySelectorAll('.relation-type-tag').forEach(t => t.classList.remove('active'));
            
            // åŠ è½½è§’è‰²ä¸‹æ‹‰åˆ—è¡¨
            await loadRelationCharSelect();
            
            document.getElementById('add-relation-modal').style.display = 'flex';
        }
        window.showAddRelationModal = showAddRelationModal;

        // åŠ è½½è§’è‰²ä¸‹æ‹‰åˆ—è¡¨
        async function loadRelationCharSelect(selectedId) {
            const select = document.getElementById('relation-char-select');
            if (!select) return;
            
            const allChars = await db.characters.toArray();
            const currentChar = await db.characters.get(editingCharId);
            const existingIds = (currentChar?.relationships || []).map(r => r.targetId);
            
            // è¿‡æ»¤ï¼šæ’é™¤è‡ªå·±ã€æ’é™¤userç±»å‹ã€æ–°å¢æ¨¡å¼ä¸‹æ’é™¤å·²æœ‰å…³ç³»
            const available = allChars.filter(c => {
                if (c.id === editingCharId) return false;
                if (c.type === 'user') return false;
                if (_relationEditIndex === -1 && existingIds.includes(c.id)) return false;
                return true;
            });
            
            select.innerHTML = '<option value="">-- è¯·é€‰æ‹©è§’è‰² --</option>';
            
            // æŒ‰ç±»å‹åˆ†ç»„ï¼šå…ˆè§’è‰²åNPC
            const chars = available.filter(c => c.type === 'char');
            const npcs = available.filter(c => c.type === 'npc');
            const others = available.filter(c => c.type !== 'char' && c.type !== 'npc');
            
            if (chars.length > 0) {
                const group = document.createElement('optgroup');
                group.label = 'è§’è‰² (Char)';
                chars.forEach(c => {
                    const opt = document.createElement('option');
                    opt.value = c.id;
                    opt.textContent = c.name + (c.nick ? ' (' + c.nick + ')' : '');
                    if (selectedId && c.id === selectedId) opt.selected = true;
                    group.appendChild(opt);
                });
                select.appendChild(group);
            }
            if (npcs.length > 0) {
                const group = document.createElement('optgroup');
                group.label = 'NPC';
                npcs.forEach(c => {
                    const opt = document.createElement('option');
                    opt.value = c.id;
                    opt.textContent = c.name + (c.nick ? ' (' + c.nick + ')' : '');
                    if (selectedId && c.id === selectedId) opt.selected = true;
                    group.appendChild(opt);
                });
                select.appendChild(group);
            }
            if (others.length > 0) {
                const group = document.createElement('optgroup');
                group.label = 'å…¶ä»–';
                others.forEach(c => {
                    const opt = document.createElement('option');
                    opt.value = c.id;
                    opt.textContent = c.name + (c.nick ? ' (' + c.nick + ')' : '');
                    if (selectedId && c.id === selectedId) opt.selected = true;
                    group.appendChild(opt);
                });
                select.appendChild(group);
            }
        }

        // é€‰æ‹©å…³ç³»ç±»å‹æ ‡ç­¾
        function selectRelationType(el, type) {
            document.querySelectorAll('.relation-type-tag').forEach(t => t.classList.remove('active'));
            el.classList.add('active');
            el.dataset.relation = type;
            document.getElementById('relation-type-custom').value = '';
            
            // è‡ªåŠ¨å¡«å……åå‘å…³ç³»
            document.getElementById('relation-reverse-type').value = getDefaultReverseRelation(type);
        }
        window.selectRelationType = selectRelationType;

        // è·å–é»˜è®¤åå‘å…³ç³»
        function getDefaultReverseRelation(relation) {
            const reverseMap = {
                'æ‹äºº': 'æ‹äºº',
                'æœ‹å‹': 'æœ‹å‹',
                'å®¶äºº': 'å®¶äºº',
                'åŒäº‹': 'åŒäº‹',
                'åŒå­¦': 'åŒå­¦',
                'å¸ˆç”Ÿ': 'å­¦ç”Ÿ',
                'å­¦ç”Ÿ': 'å¸ˆç”Ÿ',
                'è€å¸ˆ': 'å­¦ç”Ÿ',
                'ä¸Šä¸‹çº§': 'ä¸‹å±',
                'ä¸‹å±': 'ä¸Šçº§',
                'ä¸Šçº§': 'ä¸‹å±',
                'å¯¹æ‰‹': 'å¯¹æ‰‹',
                'æš§æ˜§': 'æš§æ˜§',
                'å‰ä»»': 'å‰ä»»',
                'ä»‡äºº': 'ä»‡äºº',
                'é™Œç”Ÿäºº': 'é™Œç”Ÿäºº',
                'å…³è”ä¸»è§’': 'å…³è”NPC'
            };
            return reverseMap[relation] || relation;
        }

        // ç¡®è®¤æ·»åŠ å…³ç³»
        async function confirmAddRelation() {
            if (!editingCharId) return;
            
            // ä»ä¸‹æ‹‰æ¡†è·å–é€‰ä¸­çš„è§’è‰²ID
            const selectEl = document.getElementById('relation-char-select');
            const selectedCharId = selectEl ? parseInt(selectEl.value) : null;
            
            if (!selectedCharId) {
                alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè§’è‰²');
                return;
            }
            
            // è·å–å…³ç³»ç±»å‹
            const activeTag = document.querySelector('.relation-type-tag.active');
            const customType = document.getElementById('relation-type-custom').value.trim();
            const relationType = customType || (activeTag ? activeTag.dataset.relation : '');
            
            if (!relationType) {
                alert('è¯·é€‰æ‹©æˆ–è¾“å…¥å…³ç³»ç±»å‹');
                return;
            }
            
            const desc = document.getElementById('relation-desc-input').value.trim();
            const bidirectional = document.getElementById('relation-bidirectional').checked;
            const reverseType = document.getElementById('relation-reverse-type').value.trim() || getDefaultReverseRelation(relationType);
            
            // è·å–é€‰ä¸­è§’è‰²ä¿¡æ¯
            const targetChar = await db.characters.get(selectedCharId);
            if (!targetChar) {
                alert('é€‰ä¸­çš„è§’è‰²ä¸å­˜åœ¨');
                return;
            }
            
            // è·å–å½“å‰è§’è‰²
            const currentChar = await db.characters.get(editingCharId);
            if (!currentChar) return;
            
            if (!currentChar.relationships) currentChar.relationships = [];
            
            if (_relationEditIndex >= 0) {
                // ç¼–è¾‘æ¨¡å¼ï¼šå…ˆåˆ é™¤æ—§çš„åå‘å…³ç³»
                const oldRel = currentChar.relationships[_relationEditIndex];
                if (oldRel && oldRel.targetId) {
                    const oldTarget = await db.characters.get(oldRel.targetId);
                    if (oldTarget && oldTarget.relationships) {
                        oldTarget.relationships = oldTarget.relationships.filter(r => r.targetId !== editingCharId);
                        await db.characters.put(oldTarget);
                    }
                }
                // æ›´æ–°å…³ç³»
                currentChar.relationships[_relationEditIndex] = {
                    targetId: targetChar.id,
                    targetName: targetChar.name,
                    relation: relationType,
                    desc: desc
                };
            } else {
                // æ–°å¢æ¨¡å¼ï¼šæ£€æŸ¥æ˜¯å¦é‡å¤
                const exists = currentChar.relationships.some(r => r.targetId === targetChar.id);
                if (exists) {
                    alert(`å·²ç»ä¸ ${targetChar.name} å»ºç«‹äº†å…³ç³»`);
                    return;
                }
                
                currentChar.relationships.push({
                    targetId: targetChar.id,
                    targetName: targetChar.name,
                    relation: relationType,
                    desc: desc
                });
            }
            
            await db.characters.put(currentChar);
            
            // åŒå‘å…³ç³»ï¼šåœ¨å¯¹æ–¹çš„å…³ç³»åˆ—è¡¨ä¸­ä¹Ÿæ·»åŠ 
            if (bidirectional) {
                if (!targetChar.relationships) targetChar.relationships = [];
                // ç§»é™¤æ—§çš„æŒ‡å‘å½“å‰è§’è‰²çš„å…³ç³»ï¼ˆå¦‚æœæœ‰ï¼‰
                targetChar.relationships = targetChar.relationships.filter(r => r.targetId !== editingCharId);
                // æ·»åŠ æ–°çš„åå‘å…³ç³»
                targetChar.relationships.push({
                    targetId: currentChar.id,
                    targetName: currentChar.name,
                    relation: reverseType,
                    desc: desc
                });
                await db.characters.put(targetChar);
            }
            
            // åˆ·æ–°å…³ç³»åˆ—è¡¨
            renderRelationList(currentChar);
            closeModal('add-relation-modal');
            
            console.log(`[å…³ç³»] âœ… ${currentChar.name} â†” ${targetChar.name}: ${relationType}${bidirectional ? ` (åŒå‘: ${reverseType})` : ''}`);
        }
        window.confirmAddRelation = confirmAddRelation;

        // ç¼–è¾‘å…³ç³»
        async function editRelation(index) {
            if (!editingCharId) return;
            const currentChar = await db.characters.get(editingCharId);
            if (!currentChar || !currentChar.relationships || !currentChar.relationships[index]) return;
            
            const rel = currentChar.relationships[index];
            _relationEditIndex = index;
            
            // è®¾ç½®å…³ç³»ç±»å‹æ ‡ç­¾
            document.querySelectorAll('.relation-type-tag').forEach(t => {
                t.classList.remove('active');
                if (t.dataset.relation === rel.relation) {
                    t.classList.add('active');
                }
            });
            document.getElementById('relation-type-custom').value = '';
            const matchedTag = document.querySelector('.relation-type-tag.active');
            if (!matchedTag) {
                document.getElementById('relation-type-custom').value = rel.relation;
            }
            
            document.getElementById('relation-desc-input').value = rel.desc || '';
            document.getElementById('relation-bidirectional').checked = true;
            document.getElementById('relation-reverse-type').value = getDefaultReverseRelation(rel.relation);
            document.getElementById('relation-reverse-section').style.display = 'block';
            
            // åŠ è½½è§’è‰²ä¸‹æ‹‰å¹¶é€‰ä¸­å½“å‰å…³ç³»ç›®æ ‡
            await loadRelationCharSelect(rel.targetId);
            
            document.getElementById('add-relation-modal').style.display = 'flex';
        }
        window.editRelation = editRelation;

        // åˆ é™¤å…³ç³»
        async function deleteRelation(index) {
            if (!editingCharId) return;
            const currentChar = await db.characters.get(editingCharId);
            if (!currentChar || !currentChar.relationships || !currentChar.relationships[index]) return;
            
            const rel = currentChar.relationships[index];
            const confirmDel = confirm(`ç¡®å®šåˆ é™¤ä¸ ${rel.targetName} çš„ã€Œ${rel.relation}ã€å…³ç³»å—ï¼Ÿ`);
            if (!confirmDel) return;
            
            // åŒæ—¶åˆ é™¤å¯¹æ–¹çš„åå‘å…³ç³»
            if (rel.targetId) {
                const targetChar = await db.characters.get(rel.targetId);
                if (targetChar && targetChar.relationships) {
                    targetChar.relationships = targetChar.relationships.filter(r => r.targetId !== editingCharId);
                    await db.characters.put(targetChar);
                }
            }
            
            // åˆ é™¤å½“å‰è§’è‰²çš„å…³ç³»
            currentChar.relationships.splice(index, 1);
            await db.characters.put(currentChar);
            
            // åˆ·æ–°åˆ—è¡¨
            renderRelationList(currentChar);
            console.log(`[å…³ç³»] ğŸ—‘ï¸ å·²åˆ é™¤ ${currentChar.name} ä¸ ${rel.targetName} çš„å…³ç³»`);
        }
        window.deleteRelation = deleteRelation;

        // åŒå‘å¤é€‰æ¡†äº‹ä»¶
        document.addEventListener('change', function(e) {
            if (e.target && e.target.id === 'relation-bidirectional') {
                document.getElementById('relation-reverse-section').style.display = e.target.checked ? 'block' : 'none';
            }
        });

        // æ˜¾ç¤ºç”Ÿæˆ NPC å¼¹çª—
        function showNpcGenModal() {
            if (!editingCharId) {
                alert("è¯·å…ˆä¿å­˜å½“å‰è§’è‰²åå†ç”Ÿæˆå…³è” NPC");
                return;
            }
            document.getElementById('npc-gen-modal').style.display = 'flex';
        }

        // æ‰§è¡Œç”Ÿæˆé€»è¾‘
        async function doGenerateNpcs() {
            const count = document.getElementById('gen-count-range').value;
            const req = document.getElementById('gen-prompt-req').value.trim();
            const btn = document.getElementById('btn-do-gen');
            
            // è·å–æºè§’è‰²ä¿¡æ¯
            const sourceChar = await db.characters.get(editingCharId);
            if (!sourceChar) return;

            btn.innerText = "ç”Ÿæˆä¸­...";
            btn.disabled = true;

            try {
                // 1. æ„å»º Prompt
                let loreContext = "";
                let entriesCount = 0;
                const sourceLorebookIds = sourceChar.lorebookIds || (sourceChar.lorebookId ? [sourceChar.lorebookId] : []);
                if (sourceLorebookIds.length > 0) {
                    // åˆå¹¶å¤šä¸ªä¸–ç•Œä¹¦çš„æ‰€æœ‰è¯æ¡
                    let allEntries = [];
                    for (const bookId of sourceLorebookIds) {
                        const book = await db.lorebooks.get(bookId);
                        if (book && book.content && book.content.entries) {
                            const bookEntries = Object.values(book.content.entries)
                                .filter(e => e.enabled)
                                .map(e => `[è¯æ¡: ${e.key}]\n${e.content}`);
                            allEntries = allEntries.concat(bookEntries);
                        }
                    }
                    
                    entriesCount = allEntries.length;
                    if (entriesCount > 0) {
                        // ä¸ºäº†é˜²æ­¢Tokenæº¢å‡ºï¼ŒæŒ‰é•¿åº¦æˆªæ–­ï¼ˆå‡è®¾çº¦ 12000 å­—ç¬¦ä¸ºå®‰å…¨åŒºï¼Œç•™ç»™ Response å’Œ Promptï¼‰
                        const entriesText = allEntries.join('\n\n');
                        loreContext = `ã€ä¸–ç•Œè§‚èƒŒæ™¯ (Lorebook - å…±${entriesCount}æ¡è®¾å®š)ã€‘\n${entriesText.slice(0, 12000)}\n`;
                        if (entriesText.length > 12000) loreContext += `\n...(éƒ¨åˆ†è®¾å®šå› è¿‡é•¿å·²çœç•¥)`;
                    }
                }

                const prompt = `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„TRPG/å°è¯´è§’è‰²è®¾è®¡åŠ©æ‰‹ã€‚è¯·æ ¹æ®ä»¥ä¸‹ã€ä¸»è§’ä¿¡æ¯ã€‘å’Œã€ä¸–ç•Œè§‚èƒŒæ™¯ã€‘ï¼Œæ·±åº¦åˆ›ä½œ ${count} ä¸ªç›¸å…³çš„ NPC è§’è‰²ã€‚
${req ? `>>> ç‰¹åˆ«å‰§æƒ…è¦æ±‚ï¼š${req} <<<` : ''}

ã€ä¸»è§’ä¿¡æ¯ã€‘
åå­—ï¼š${sourceChar.name}
è®¾å®šï¼š${sourceChar.description}

${loreContext}

ã€ç”Ÿæˆè¦æ±‚ã€‘
1. **æ·±åº¦å…³è”**ï¼šNPC å¿…é¡»ä¸ä¸–ç•Œè§‚ï¼ˆLorebookï¼‰ç´§å¯†ç»“åˆã€‚è¯·å¼•ç”¨ä¸–ç•Œä¹¦ä¸­çš„åœ°åã€ç»„ç»‡ã€ç§æ—æˆ–å†å²äº‹ä»¶ã€‚
2. **ç»†èŠ‚ä¸°å¯Œ**ï¼šè¯·è¯¦ç»†æå†™å¤–è²Œï¼ˆè¡£ç€ã€ç‰¹å¾ï¼‰ã€æ€§æ ¼ï¼ˆå£ç™–ã€å¿ƒç†ï¼‰å’ŒèƒŒæ™¯æ•…äº‹ã€‚æ‹’ç»ç©ºæ´çš„æè¿°ã€‚
3. **å¤šæ ·æ€§**ï¼šç”Ÿæˆçš„è§’è‰²æ€§æ ¼å’Œèº«ä»½åº”å„ä¸ç›¸åŒï¼Œé™¤éã€ç‰¹åˆ«å‰§æƒ…è¦æ±‚ã€‘å¦æœ‰æŒ‡å®šã€‚

è¯·è¿”å›ä¸€ä¸ª JSON æ•°ç»„ï¼Œæ¯ä¸ªå¯¹è±¡åŒ…å«ï¼š
- name: åå­—
- nickname: æ˜µç§° (å¯é€‰)
- gender: æ€§åˆ« (ç”·/å¥³/æœªçŸ¥)
- appearance: å¤–è²Œæå†™ (è¯¦ç»†ï¼Œå¦‚å‘è‰²ã€ç³è‰²ã€æœè£…é£æ ¼)
- personality: æ€§æ ¼ç‰¹å¾ (è¯¦ç»†ï¼Œå¦‚é«˜å†·ã€çƒ­è¡€ã€è…¹é»‘)
- background: èƒŒæ™¯æ•…äº‹ (ç»“åˆä¸–ç•Œè§‚çš„ä¸ªäººç»å†)
- identity_job: èŒä¸šæˆ–èº«ä»½
- relation: ä¸ä¸»è§’çš„å…³ç³»ç±»å‹
- relation_desc: å…³ç³»è¯¦æƒ…æè¿° (å…·ä½“çš„äº’åŠ¨æ¨¡å¼)

è¯·ä¸¥æ ¼è¿”å› JSON æ ¼å¼ï¼Œä¸è¦åŒ…å« Markdown ä»£ç å—æ ‡è®°ã€‚`;

                // 2. è°ƒç”¨ AI
                const resultStr = await callAI([
                    { role: "system", content: "ä½ æ˜¯ä¸€ä¸ªåªè¾“å‡º JSON æ•°ç»„çš„è¾…åŠ©ç³»ç»Ÿã€‚" },
                    { role: "user", content: prompt }
                ]);

                // 3. è§£æ JSON
                const npcs = extractAndParseJSON(resultStr);
                if (!Array.isArray(npcs)) throw new Error("AI è¿”å›æ ¼å¼é”™è¯¯ (ä¸æ˜¯æ•°ç»„) æˆ–è§£æå¤±è´¥");

                // 4. æ‰¹é‡å†™å…¥ DB å¹¶å»ºç«‹å…³ç³»
                let newCount = 0;
                for (const npcData of npcs) {
                    // æ•´åˆè¯¦ç»†æè¿°
                    const fullDesc = `ã€å¤–è²Œã€‘\n${npcData.appearance || 'æ— '}\n\nã€æ€§æ ¼ã€‘\n${npcData.personality || 'æ— '}\n\nã€èƒŒæ™¯ã€‘\n${npcData.background || npcData.description || 'æ— '}`;
                    
                    // æ„é€  NPC æ•°æ®
                    const newNpc = {
                        name: npcData.name,
                        nick: npcData.nickname || '',
                        description: fullDesc, // å­˜å…¥æ•´åˆåçš„è¯¦ç»†æè¿°
                        type: 'npc', // é»˜è®¤ä¸º NPC ç±»å‹
                        avatar: '', // æš‚æ—¶ç•™ç©º
                        lorebookIds: sourceLorebookIds.length > 0 ? sourceLorebookIds : null, // ç»§æ‰¿å¤šä¸ªä¸–ç•Œä¹¦
                        lorebookId: sourceLorebookIds.length > 0 ? sourceLorebookIds[0] : null, // å…¼å®¹å­—æ®µ
                        identity: {
                            // åŸºç¡€èº«ä»½å ä½
                            job: npcData.identity_job
                        },
                        relationships: [
                            // å†™å…¥æŒ‡å‘ä¸»è§’çš„å…³ç³»
                            {
                                targetId: sourceChar.id,
                                targetName: sourceChar.name,
                                relation: "å…³è”ä¸»è§’", // ç›¸å¯¹å…³ç³»ï¼Œæˆ–è€…è®©AIç”Ÿæˆåå‘å…³ç³»æ¯”è¾ƒå¤æ‚ï¼Œè¿™é‡Œç®€åŒ–
                                desc: "ç”Ÿæˆæ¥æº"
                            }
                        ],
                        updated_at: Date.now()
                    };
                    
                    const newId = await db.characters.add(newNpc);
                    newCount++;
                    
                    // NPCç”Ÿæˆåé»˜è®¤ä¸ºé™Œç”Ÿäººï¼Œéœ€è¦ç”¨æˆ·è‡ªå·±æ·»åŠ å¥½å‹
                    console.log(`[NPCç”Ÿæˆ] âœ… ${newNpc.name} å·²åˆ›å»ºï¼ˆé»˜è®¤é™Œç”Ÿäººï¼Œéœ€æ‰‹åŠ¨æ·»åŠ å¥½å‹ï¼‰`);

                    // 5. æ›´æ–°ä¸»è§’çš„å…³ç³»åˆ—è¡¨
                    if (!sourceChar.relationships) sourceChar.relationships = [];
                    sourceChar.relationships.push({
                        targetId: newId,
                        targetName: newNpc.name,
                        relation: npcData.relation,
                        desc: npcData.relation_desc
                    });
                }
                
                // ä¿å­˜ä¸»è§’æ›´æ–°
                await db.characters.put(sourceChar);

                // 6. åˆ·æ–°ç•Œé¢
                alert(`âœ… æˆåŠŸç”Ÿæˆ ${newCount} ä¸ª NPCï¼\n\nğŸ’¡ æç¤ºï¼šä½ å¯ä»¥åœ¨ã€Œè§’è‰²æ¡£æ¡ˆ > NPCã€æ ‡ç­¾é¡µä¸­æŸ¥çœ‹å’Œç¼–è¾‘è¿™äº›ç”Ÿæˆçš„NPCã€‚`);
                closeModal('npc-gen-modal');
                // åˆ·æ–°ç¼–è¾‘é¡µçš„å…³ç³»åˆ—è¡¨
                renderRelationList(sourceChar);
                // åˆ·æ–°å¤–éƒ¨åˆ—è¡¨ (å¦‚æœåœ¨åˆ—è¡¨é¡µçš„è¯ï¼Œè™½ç„¶ç°åœ¨åœ¨å¼¹çª—é‡Œ)
                loadCharacterList();

            } catch (err) {
                console.error(err);
                alert("ç”Ÿæˆå¤±è´¥: " + err.message);
            } finally {
                btn.innerText = "å¼€å§‹ç”Ÿæˆ";
                btn.disabled = false;
            }
        }

        function hideCharacterEditor() {
            document.getElementById('character-editor-page').style.display = 'none';
            editingCharId = null;
        }

        function setCharAvatar(input) {
            const file = input.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = e => {
                    document.getElementById('char-avatar-preview').style.backgroundImage = `url(${e.target.result})`;
                    document.getElementById('char-avatar-placeholder').style.display = 'none';
                };
                reader.readAsDataURL(file);
            }
        }

        async function saveCharacter() {
            const name = document.getElementById('char-name').value.trim();
            const nick = document.getElementById('char-nick').value.trim();
            const desc = document.getElementById('char-desc').value;
            const type = document.getElementById('char-type').value;
            
            // å¦‚æœæ˜¯æ›´æ–°ï¼Œå…ˆè·å–æ—§æ•°æ®ä»¥ä¿ç•™ lorebookId, wechat_registered ç­‰å­—æ®µ
            let oldData = {};
            if (editingCharId) {
                oldData = await db.characters.get(editingCharId) || {};
            }
            
            // è·å–è™šæ‹Ÿèº«ä»½æ•°æ®ï¼ˆåˆå¹¶æ—§æ•°æ®ï¼Œä¿ç•™ wechat_registered, registered_at ç­‰æ³¨å†ŒçŠ¶æ€ï¼‰
            const identity = {
                ...(oldData.identity || {}), // ä¿ç•™å·²æœ‰çš„ wechat_registered, registered_at ç­‰å­—æ®µ
                account: document.getElementById('char-identity-account').value.trim(),
                password: document.getElementById('char-identity-password').value.trim(),
                phone: document.getElementById('char-identity-phone').value.trim(),
                address: document.getElementById('char-identity-address').value.trim(),
                id_card: document.getElementById('char-identity-id').value.trim(),
                bank_card: document.getElementById('char-identity-bank').value.trim(),
                bank_password: document.getElementById('char-identity-bank-pass').value.trim()
            };

            // è·å–å¤´åƒ Base64
            let avatar = '';
            const bgImage = document.getElementById('char-avatar-preview').style.backgroundImage;
            if (bgImage && bgImage !== 'none') {
                avatar = bgImage.replace(/url\(|\)|"/g, '');
            }
            
            if (!name) {
                alert("è¯·è¾“å…¥è§’è‰²åå­—");
                return;
            }

            const charData = {
                ...oldData, // ä¿ç•™åŸæœ‰çš„ lorebookId, original_data ç­‰
                name,
                nick,
                description: desc,
                type,
                avatar,
                identity, // ä¿å­˜èº«ä»½ä¿¡æ¯
                updated_at: Date.now()
            };
            
            if (editingCharId) {
                await db.characters.put(charData); // ä½¿ç”¨ put è¦†ç›–å®Œæ•´å¯¹è±¡
            } else {
                await db.characters.add(charData);
            }
            
            hideCharacterEditor();
            // å¦‚æœä¿®æ”¹äº†ç±»å‹ï¼Œå¯èƒ½éœ€è¦è·³è½¬åˆ°å¯¹åº” Tab æ‰èƒ½çœ‹åˆ°ï¼Œæˆ–è€…ç›´æ¥åˆ·æ–°å½“å‰ Tab
            if (type !== currentCharacterType) {
                switchCharacterTab(type);
            } else {
                loadCharacterList();
            }
        }

        // æå–å¹¶è§£æ JSON çš„é€šç”¨è¾…åŠ©å‡½æ•° (å¢å¼ºé²æ£’æ€§)
        function extractAndParseJSON(text) {
            if (!text) return null;
            let str = text.trim();
            
            // 1. å°è¯•æå–æœ€å¤–å±‚çš„ { ... } æˆ– [ ... ]
            // è¿™èƒ½æœ‰æ•ˆå¿½ç•¥å‰åçš„æ‚è´¨ï¼ˆå¦‚ç”¨æˆ·çš„ ]{...} æƒ…å†µï¼‰
            const firstBrace = str.indexOf('{');
            const firstBracket = str.indexOf('[');
            
            let startIdx = -1;
            let isArray = false;
            
            // ç¡®å®šæ˜¯å¯¹è±¡è¿˜æ˜¯æ•°ç»„å¼€å§‹å¾—æ›´æ—©
            if (firstBrace !== -1 && (firstBracket === -1 || firstBrace < firstBracket)) {
                startIdx = firstBrace;
            } else if (firstBracket !== -1) {
                startIdx = firstBracket;
                isArray = true;
            }
            
            if (startIdx !== -1) {
                const endChar = isArray ? ']' : '}';
                const endIdx = str.lastIndexOf(endChar);
                
                if (endIdx !== -1 && endIdx > startIdx) {
                    const jsonCandidate = str.substring(startIdx, endIdx + 1);
                    try {
                        return JSON.parse(jsonCandidate);
                    } catch (e) {
                        // console.warn("[extractJSON] æå–ç‰‡æ®µè§£æå¤±è´¥:", e);
                    }
                }
            }
            
            // 2. å¦‚æœæå–å¤±è´¥ï¼Œå°è¯•æ¸…ç† Markdown æ ‡è®°åç›´æ¥è§£æ
            const cleanStr = str.replace(/^```json\s*/i, '').replace(/^```\s*/, '').replace(/\s*```$/, '');
            try {
                return JSON.parse(cleanStr);
            } catch (e) {
                return null;
            }
        }

        // ========== å¤–è¯­+ä¸­æ–‡ç¿»è¯‘è¯†åˆ«åŠŸèƒ½ ==========
        // è§£æAIè¿”å›çš„å¤–è¯­+ä¸­æ–‡ç»„åˆæ¶ˆæ¯
        // æ”¯æŒæ ¼å¼ï¼š
        // 1. "å¤–è¯­ï¼ˆä¸­æ–‡ç¿»è¯‘ï¼‰" æˆ– "å¤–è¯­(ä¸­æ–‡ç¿»è¯‘)"
        // 2. "å¤–è¯­ã€Œä¸­æ–‡ç¿»è¯‘ã€"
        function parseForeignWithTranslation(text) {
            if (!text) return null;
            
            // æ¨¡å¼1: ä»»æ„å†…å®¹ï¼ˆä¸­æ–‡ç¿»è¯‘ï¼‰æˆ– ä»»æ„å†…å®¹(ä¸­æ–‡ç¿»è¯‘) - æ‹¬å·åœ¨æœ«å°¾
            const pattern1 = /^(.+?)[ï¼ˆ(]([^ï¼‰)]+)[ï¼‰)]$/s;
            let match = text.match(pattern1);
            if (match) {
                const foreign = match[1].trim();
                const chinese = match[2].trim();
                // éªŒè¯ï¼šæ‹¬å·å†…åº”è¯¥åŒ…å«ä¸­æ–‡ï¼Œä¸”å¤–è¯­éƒ¨åˆ†ä¸ä¸ºç©º
                if (foreign && containsChinese(chinese)) {
                    return { foreign, chinese };
                }
            }
            
            // æ¨¡å¼2: ä»»æ„å†…å®¹ã€Œä¸­æ–‡ç¿»è¯‘ã€
            const pattern2 = /^(.+?)ã€Œ([^ã€]+)ã€$/s;
            match = text.match(pattern2);
            if (match) {
                const foreign = match[1].trim();
                const chinese = match[2].trim();
                if (foreign && containsChinese(chinese)) {
                    return { foreign, chinese };
                }
            }
            
            return null;
        }
        
        // æ£€æŸ¥æ–‡æœ¬æ˜¯å¦åŒ…å«ä¸­æ–‡
        function containsChinese(text) {
            if (!text) return false;
            const chineseRegex = /[\u4e00-\u9fff]/;
            return chineseRegex.test(text);
        }
        
        // é€šç”¨ AI è°ƒç”¨å‡½æ•°
        async function callAI(messages, options = {}) {
            let urlValue = '';
            let apiKeyValue = '';
            let modelValue = '';
            let temperature = 0.7;
            
            try {
                const url = await db.dexiData.get('aiBaseUrl');
                const key = await db.dexiData.get('aiApiKey');
                const model = await db.dexiData.get('aiCurrentModel');
                
                urlValue = url?.value?.trim() || '';
                apiKeyValue = key?.value?.trim() || '';
                modelValue = model?.value?.trim() || '';
                
                // è·å–æ¸©åº¦é…ç½®
                const tempItem = await db.dexiData.get('aiTemperature');
                temperature = tempItem ? parseFloat(tempItem.value) : 0.7;
                
                // ğŸ”§ å¦‚æœä»DBè¯»åˆ°äº†æœ‰æ•ˆå€¼ï¼Œæ›´æ–°å†…å­˜ç¼“å­˜
                if (urlValue && apiKeyValue && modelValue) {
                    _apiConfigCache = { url: urlValue, key: apiKeyValue, model: modelValue, temp: String(temperature) };
                }
            } catch (dbErr) {
                console.warn('[callAI] æ•°æ®åº“è¯»å–å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨å†…å­˜ç¼“å­˜:', dbErr.message);
            }
            
            // ğŸ”§ å¦‚æœDBè¯»å–ç»“æœä¸ºç©ºï¼Œå°è¯•ä½¿ç”¨å†…å­˜ç¼“å­˜
            if (!urlValue && _apiConfigCache.url) {
                console.warn('[callAI] DBä¸­APIåœ°å€ä¸ºç©ºï¼Œä½¿ç”¨å†…å­˜ç¼“å­˜');
                urlValue = _apiConfigCache.url;
            }
            if (!apiKeyValue && _apiConfigCache.key) {
                console.warn('[callAI] DBä¸­APIå¯†é’¥ä¸ºç©ºï¼Œä½¿ç”¨å†…å­˜ç¼“å­˜');
                apiKeyValue = _apiConfigCache.key;
            }
            if (!modelValue && _apiConfigCache.model) {
                console.warn('[callAI] DBä¸­æ¨¡å‹ä¸ºç©ºï¼Œä½¿ç”¨å†…å­˜ç¼“å­˜');
                modelValue = _apiConfigCache.model;
            }
            
            // ğŸ”§ å¦‚æœå†…å­˜ç¼“å­˜ä¹Ÿæ¢å¤äº†æœ‰æ•ˆå€¼ï¼Œå†™å›DBä¿®å¤
            if (urlValue && apiKeyValue && modelValue) {
                // å¼‚æ­¥ä¿®å¤DBï¼ˆä¸é˜»å¡å½“å‰è°ƒç”¨ï¼‰
                db.dexiData.get('aiBaseUrl').then(existing => {
                    if (!existing || !existing.value) {
                        console.log('[callAI] ğŸ”§ è‡ªåŠ¨ä¿®å¤DBä¸­ä¸¢å¤±çš„APIé…ç½®');
                        db.dexiData.put({ key: 'aiBaseUrl', value: urlValue });
                        db.dexiData.put({ key: 'aiApiKey', value: apiKeyValue });
                        db.dexiData.put({ key: 'aiCurrentModel', value: modelValue });
                    }
                }).catch(() => {});
            }
            
            if (!urlValue) {
                throw new Error("è¯·å…ˆåœ¨è®¾ç½®ä¸­é…ç½® API åœ°å€");
            }
            if (!apiKeyValue) {
                throw new Error("API å¯†é’¥ä¸èƒ½ä¸ºç©ºï¼Œè¯·åœ¨è®¾ç½®ä¸­é…ç½®");
            }
            if (!modelValue) {
                throw new Error("æ¨¡å‹åç§°ä¸èƒ½ä¸ºç©ºï¼Œè¯·åœ¨è®¾ç½®ä¸­é€‰æ‹©æ¨¡å‹");
            }
            
            // æ£€æŸ¥ API Key æ ¼å¼ï¼ˆåŸºæœ¬æ£€æŸ¥ï¼‰
            if (apiKeyValue.length < 10) {
                console.warn('[callAI] API Key é•¿åº¦å¼‚å¸¸ï¼Œå¯èƒ½æ— æ•ˆ:', apiKeyValue.length);
            }
            
            // éªŒè¯æ¸©åº¦å€¼
            if (isNaN(temperature) || temperature < 0 || temperature > 2) {
                console.warn('[callAI] æ¸©åº¦å€¼æ— æ•ˆ:', temperature, 'ï¼Œä½¿ç”¨é»˜è®¤å€¼ 0.7');
                temperature = 0.7;
            }
            
            // è·å– max_tokens é…ç½®ï¼ˆå¦‚æœæä¾›ï¼‰
            const maxTokens = options.max_tokens || options.maxTokens;

            const requestUrl = getSmartUrl(urlValue, '/chat/completions');
            
            // âœ… å…¨å±€é˜²å¾¡ï¼šæ¸…æ´— messagesï¼Œé˜²æ­¢ç©ºå†…å®¹æˆ–éæ³•æ ¼å¼å¯¼è‡´ 400 é”™è¯¯
            // æ”¯æŒå¤šæ¨¡æ€æ¶ˆæ¯æ ¼å¼ï¼ˆå›¾ç‰‡è¯†åˆ«ï¼‰ï¼šcontent å¯ä»¥æ˜¯å­—ç¬¦ä¸²æˆ–æ•°ç»„
            const cleanMessages = messages.map(m => {
                // éªŒè¯ role å­—æ®µ
                let role = m.role;
                if (!role || !['system', 'user', 'assistant'].includes(role)) {
                    console.warn('[callAI] æ— æ•ˆçš„ role:', role, 'ï¼Œä½¿ç”¨ user');
                    role = 'user';
                }
                
                let content = m.content;
                
                // æ”¯æŒå¤šæ¨¡æ€å†…å®¹ï¼ˆæ•°ç»„æ ¼å¼ï¼Œç”¨äºå›¾ç‰‡è¯†åˆ«ï¼‰
                if (Array.isArray(content)) {
                    // éªŒè¯æ•°ç»„ä¸­æ¯ä¸ªå…ƒç´ 
                    const validParts = content.filter(part => {
                        if (part.type === 'text') return part.text && part.text.trim().length > 0;
                        if (part.type === 'image_url') return part.image_url && part.image_url.url;
                        return false;
                    });
                    if (validParts.length === 0) return { role, content: '' };
                    // ğŸ”§ æ ‡è®°åŒ…å«å›¾ç‰‡çš„æ¶ˆæ¯ï¼Œåç»­å¼‚æ­¥è½¬æ¢æ ¼å¼
                    return { role, content: validParts, _hasImage: true };
                }
                
                // ç¡®ä¿ content æ˜¯å­—ç¬¦ä¸²
                if (content === null || content === undefined) content = "";
                if (typeof content !== 'string') content = String(content);
                
                return {
                    role: role,
                    content: content.trim()
                };
            }).filter(m => {
                if (Array.isArray(m.content)) return m.content.length > 0;
                return m.content.length > 0;
            }); // å†æ¬¡è¿‡æ»¤ç©ºæ¶ˆæ¯

            // ğŸ”§ å¼‚æ­¥è½¬æ¢å›¾ç‰‡æ ¼å¼ï¼šå°† avif/webp ç­‰ä¸å…¼å®¹æ ¼å¼è½¬ä¸º JPEGï¼ŒHTTP URL è½¬ä¸º base64
            for (let i = 0; i < cleanMessages.length; i++) {
                const msg = cleanMessages[i];
                if (msg._hasImage && Array.isArray(msg.content)) {
                    for (let j = msg.content.length - 1; j >= 0; j--) {
                        const part = msg.content[j];
                        if (part.type === 'image_url' && part.image_url && part.image_url.url) {
                            const url = part.image_url.url;
                            // å¤„ç† HTTP URLï¼šå…ˆè½¬ä¸º base64
                            if (url.startsWith('http')) {
                                try {
                                    const base64Url = await convertHttpImageToBase64(url);
                                    if (base64Url.startsWith('data:image')) {
                                        part.image_url.url = await convertImageForAI(base64Url);
                                    } else {
                                        // CORS å¤±è´¥ï¼Œç§»é™¤å›¾ç‰‡éƒ¨åˆ†ï¼Œä¿ç•™æ–‡å­—æè¿°
                                        console.warn('[callAI] HTTPå›¾ç‰‡æ— æ³•è½¬ä¸ºbase64ï¼ˆCORSï¼‰ï¼Œç§»é™¤å›¾ç‰‡éƒ¨åˆ†');
                                        msg.content.splice(j, 1);
                                    }
                                } catch (e) {
                                    console.warn('[callAI] HTTPå›¾ç‰‡è½¬æ¢å¤±è´¥ï¼Œç§»é™¤å›¾ç‰‡éƒ¨åˆ†:', e);
                                    msg.content.splice(j, 1);
                                }
                            }
                            // å¤„ç† data: URLï¼šæ ¼å¼è½¬æ¢
                            else if (url.startsWith('data:image')) {
                                try {
                                    const converted = await convertImageForAI(url);
                                    part.image_url.url = converted;
                                } catch (e) {
                                    console.warn('[callAI] å›¾ç‰‡æ ¼å¼è½¬æ¢å¤±è´¥ï¼Œä½¿ç”¨åŸå§‹æ ¼å¼:', e);
                                }
                            }
                        }
                    }
                    delete msg._hasImage; // æ¸…ç†æ ‡è®°
                    // å¦‚æœå›¾ç‰‡éƒ½è¢«ç§»é™¤äº†ï¼Œä¸”åªå‰©æ–‡å­—ï¼Œè½¬å›å­—ç¬¦ä¸²æ ¼å¼
                    const hasImage = msg.content.some(p => p.type === 'image_url');
                    if (!hasImage && msg.content.length === 1 && msg.content[0].type === 'text') {
                        msg.content = msg.content[0].text;
                    }
                }
            }

            // å¦‚æœè¿‡æ»¤ååªå‰©ä¸‹ system æ¶ˆæ¯ï¼Œæœ‰äº›æ¨¡å‹å¯èƒ½ä¼šæŠ¥é”™ï¼Œä½†å¤§å¤šæ•°æ”¯æŒã€‚
            // è¿™é‡Œæˆ‘ä»¬ä¸åš System çš„å¼ºåˆ¶æ£€æŸ¥ï¼Œåªè¦ä¸ä¸ºç©ºå³å¯ã€‚
            if (cleanMessages.length === 0) {
                throw new Error("è¯·æ±‚ä¸­æ­¢ï¼šæ²¡æœ‰æœ‰æ•ˆçš„æ¶ˆæ¯å†…å®¹ï¼ˆå¯èƒ½æ˜¯å› ä¸ºæ¶ˆæ¯è¢«æ’¤å›æˆ–ä¸ºç©ºï¼‰");
            }
            
            // éªŒè¯æ˜¯å¦è‡³å°‘æœ‰ä¸€æ¡é system æ¶ˆæ¯
            const hasNonSystemMessage = cleanMessages.some(m => m.role !== 'system');
            if (!hasNonSystemMessage) {
                console.warn('[callAI] åªæœ‰ system æ¶ˆæ¯ï¼Œæ·»åŠ ä¸€ä¸ªå ä½ user æ¶ˆæ¯');
                // ğŸ”§ ä¿®å¤ï¼šæ·»åŠ æ›´å®Œæ•´çš„å ä½æ¶ˆæ¯ï¼Œé¿å… Gemini ä»£ç†è¿”å›ç©º choices
                cleanMessages.push({
                    role: 'user',
                    content: 'è¯·æ ¹æ®ä½ çš„äººè®¾ï¼Œå‘é€ä¸€æ¡æ¶ˆæ¯ã€‚ä¿æŒè§’è‰²æ‰®æ¼”ï¼Œè‡ªç„¶åœ°å¼€å§‹æˆ–ç»§ç»­å¯¹è¯ã€‚'
                });
            }

            let rawText = '';
            
            // æ„å»ºè¯·æ±‚ä½“
            const requestBody = {
                apiUrl: requestUrl,
                apiKey: apiKeyValue,
                model: modelValue,
                messages: cleanMessages,
                temperature: temperature
            };
            
            // æ·»åŠ è¯¦ç»†çš„è°ƒè¯•æ—¥å¿—
            console.log('[callAI] ğŸš€ å‡†å¤‡å‘é€è¯·æ±‚');
            console.log('[callAI] API URL:', requestUrl);
            console.log('[callAI] Model:', modelValue);
            console.log('[callAI] API Key length:', apiKeyValue.length);
            console.log('[callAI] Temperature:', temperature);
            console.log('[callAI] Messages count:', cleanMessages.length);
            console.log('[callAI] Messages preview:', cleanMessages.map(m => ({
                role: m.role,
                content: Array.isArray(m.content) 
                    ? `[å¤šæ¨¡æ€: ${m.content.map(p => p.type === 'image_url' ? 'ğŸ–¼ï¸å›¾ç‰‡' : p.text?.substring(0, 50)).join(' + ')}]`
                    : m.content.substring(0, 100) + (m.content.length > 100 ? '...' : '')
            })));
            
            // çº¯å‰ç«¯ï¼šç›´æ¥è°ƒç”¨ AI APIï¼ˆéœ€è¦é…ç½®æ”¯æŒ CORS çš„ API ç«¯ç‚¹ï¼‰
            try {
                const res = await fetch(requestUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKeyValue}`
                    },
                    body: JSON.stringify({
                        model: modelValue,
                        messages: cleanMessages,
                        temperature: temperature
                    })
                });

                if (!res.ok) {
                    const errText = await res.text();
                    console.error('[callAI] âŒ API è¯·æ±‚å¤±è´¥');
                    console.error('[callAI] çŠ¶æ€ç :', res.status);
                    console.error('[callAI] é”™è¯¯å“åº”:', errText);
                    
                    try {
                        const errJson = JSON.parse(errText);
                        console.error('[callAI] è§£æåçš„é”™è¯¯:', errJson);
                        if (errJson.error) {
                            const errorMsg = `AIè¯·æ±‚å¤±è´¥ (${res.status}): ${errJson.error}${errJson.details ? '\nè¯¦æƒ…: ' + errJson.details : ''}`;
                            throw new Error(errorMsg);
                        }
                    } catch(parseErr) {
                        // å¦‚æœä¸æ˜¯ JSON æ ¼å¼çš„é”™è¯¯
                        if (parseErr instanceof SyntaxError) {
                            console.error('[callAI] é”™è¯¯å“åº”ä¸æ˜¯ JSON æ ¼å¼');
                        }
                    }
                    
                    throw new Error(`API è¯·æ±‚å¤±è´¥: ${res.status} - ${errText.substring(0, 200)}`);
                }

                // âœ… å…³é”®æ”¹åŠ¨ï¼šå…ˆè·å–åŸå§‹æ–‡æœ¬ï¼Œè€Œä¸æ˜¯ç›´æ¥ .json()
                rawText = await res.text();
                
                // å°è¯•è§£æä¸º JSON
                let data;
                try {
                    data = JSON.parse(rawText);
                } catch (parseErr) {
                    // è¿”å›çš„ä¸æ˜¯ JSONï¼ˆå¯èƒ½æ˜¯ HTML é”™è¯¯é¡µã€çº¯æ–‡æœ¬ç­‰ï¼‰
                    console.warn('[callAI] è¿”å›å†…å®¹ä¸æ˜¯æœ‰æ•ˆçš„ JSONï¼Œç›´æ¥ä½¿ç”¨åŸå§‹æ–‡æœ¬');
                    console.log('[callAI] åŸå§‹è¿”å›:', rawText.substring(0, 500));
                    
                    // ç›´æ¥è¿”å›åŸå§‹æ–‡æœ¬ï¼ˆå»é™¤ HTML æ ‡ç­¾å’Œç‰¹æ®Šå­—ç¬¦ï¼‰
                    return rawText
                        .replace(/<[^>]*>/g, '') // ç§»é™¤ HTML æ ‡ç­¾
                        .replace(/[â—‡â—†â˜…â˜†â—â—‹â– â–¡â–²â–³]/g, '') // ç§»é™¤è£…é¥°å­—ç¬¦
                        .trim();
                }
                
                // ğŸš¨ æ£€æµ‹ç©ºçš„ choices æ•°ç»„ï¼ˆAPIè°ƒç”¨æˆåŠŸä½†æ²¡æœ‰è¿”å›å†…å®¹ï¼‰
                if (data?.choices && Array.isArray(data.choices) && data.choices.length === 0) {
                    console.error('[callAI] âŒ APIè¿”å›äº†ç©ºçš„choicesæ•°ç»„');
                    console.error('[callAI] å®Œæ•´å“åº”:', JSON.stringify(data, null, 2));
                    
                    let errorMsg = 'APIè°ƒç”¨æˆåŠŸï¼Œä½†æ²¡æœ‰è¿”å›å†…å®¹';
                    
                    // æ£€æŸ¥usageä¿¡æ¯ï¼Œåˆ¤æ–­å¯èƒ½çš„åŸå› 
                    if (data.usage) {
                        const { prompt_tokens, completion_tokens, total_tokens } = data.usage;
                        if (prompt_tokens === 0 && completion_tokens === 0) {
                            errorMsg += '\n\nğŸ’¡ å¯èƒ½çš„åŸå› ï¼š\n';
                            errorMsg += '- å†…å®¹è¢«å®‰å…¨è¿‡æ»¤æ‹¦æˆª\n';
                            errorMsg += '- æ¨¡å‹ä¸æ”¯æŒå½“å‰è¯·æ±‚\n';
                            errorMsg += '- APIé…é¢ä¸è¶³æˆ–é™æµ\n';
                            errorMsg += '- è¯·æ±‚å‚æ•°æ ¼å¼é”™è¯¯';
                        }
                    }
                    
                    throw new Error(errorMsg);
                }
                
                // âœ… å…¼å®¹å¤šç§è¿”å›è·¯å¾„ï¼ˆåŒ…æ‹¬Geminiï¼‰
                let content = '';
                
                // 1. Geminiæ ¼å¼ï¼šdata.candidates[0].content.parts[0].text
                if (data?.candidates?.[0]?.content?.parts?.[0]?.text) {
                    content = data.candidates[0].content.parts[0].text;
                    console.log('[callAI] âœ… ä½¿ç”¨Geminiæ ¼å¼æå–å†…å®¹');
                }
                // 2. OpenAIæ ‡å‡†æ ¼å¼ï¼šdata.choices[0].message.content
                else if (data?.choices?.[0]?.message?.content) {
                    content = data.choices[0].message.content;
                    console.log('[callAI] âœ… ä½¿ç”¨OpenAIæ ¼å¼æå–å†…å®¹');
                }
                // 3. å…¶ä»–å…¼å®¹æ ¼å¼
                else {
                    content = 
                        data?.choices?.[0]?.text ??              // ä¸€äº›æ—§ç‰ˆ API
                        data?.output_text ??                     // ä¸€äº›è‡ªå®šä¹‰æ ¼å¼
                        data?.message ??                         // ç®€åŒ–æ ¼å¼
                        data?.content ??                         // ç›´æ¥è¿”å›å†…å®¹
                        data?.reply ??                           // è‡ªå®šä¹‰å­—æ®µ
                        '';
                }
                
                if (!content) {
                    // å¦‚æœæ‰€æœ‰è·¯å¾„éƒ½æ²¡æœ‰å†…å®¹ï¼Œè®°å½•è¯¦ç»†æ—¥å¿—
                    console.error('[callAI] âŒ æ— æ³•ä»ä»»ä½•è·¯å¾„æå–å†…å®¹');
                    console.error('[callAI] å®Œæ•´å“åº”ç»“æ„:', JSON.stringify(data, null, 2).substring(0, 1000));
                    
                    // æ£€æŸ¥æ˜¯å¦æ˜¯Geminiçš„ç©ºè¿”å›
                    if (data?.candidates && Array.isArray(data.candidates) && data.candidates.length === 0) {
                        throw new Error('Gemini APIè¿”å›äº†ç©ºçš„candidatesæ•°ç»„ï¼Œå¯èƒ½æ˜¯å†…å®¹è¢«è¿‡æ»¤æˆ–è¯·æ±‚æ ¼å¼é”™è¯¯');
                    }
                    
                    // å¦‚æœdataæœ¬èº«å°±æ˜¯å­—ç¬¦ä¸²ï¼Œæ£€æŸ¥æ˜¯å¦æ˜¯JSONå­—ç¬¦ä¸²
                    if (typeof data === 'string') {
                        // å¦‚æœæ˜¯JSONå­—ç¬¦ä¸²ï¼Œå°è¯•è§£æ
                        try {
                            const parsed = JSON.parse(data);
                            // å¦‚æœè§£ææˆåŠŸï¼Œé€’å½’è°ƒç”¨æå–é€»è¾‘
                            if (parsed.candidates?.[0]?.content?.parts?.[0]?.text) {
                                return parsed.candidates[0].content.parts[0].text;
                            }
                            if (parsed.choices?.[0]?.message?.content) {
                                return parsed.choices[0].message.content;
                            }
                        } catch {
                            // ä¸æ˜¯JSONï¼Œç›´æ¥è¿”å›å­—ç¬¦ä¸²
                            return data;
                        }
                    }
                    
                    // ğŸš¨ æœ€åæ£€æŸ¥ï¼šå¦‚æœrawTextçœ‹èµ·æ¥åƒJSONå¯¹è±¡ï¼Œä¸è¦è¿”å›å®ƒ
                    if (rawText.trim().startsWith('{') && rawText.trim().endsWith('}')) {
                        console.error('[callAI] âŒ æ£€æµ‹åˆ°è¿”å›çš„æ˜¯åŸå§‹JSONå¯¹è±¡ï¼Œä¸åº”è¯¥æ˜¾ç¤ºç»™ç”¨æˆ·');
                        throw new Error('APIè¿”å›äº†åŸå§‹JSONå¯¹è±¡è€Œéæ–‡æœ¬å†…å®¹ã€‚è¿™å¯èƒ½æ˜¯APIé…ç½®é—®é¢˜æˆ–æ¨¡å‹å“åº”æ ¼å¼é”™è¯¯ã€‚');
                    }
                    
                    // æœ€åå°è¯•ï¼šè¿”å›æ¸…ç†åçš„åŸå§‹æ–‡æœ¬ï¼ˆä½†è¿™ç§æƒ…å†µä¸åº”è¯¥å‘ç”Ÿï¼‰
                    const fallback = rawText
                        .replace(/<[^>]*>/g, '')
                        .replace(/[â—‡â—†â˜…â˜†â—â—‹â– â–¡â–²â–³]/g, '')
                        .trim();
                    
                    if (fallback && fallback.length > 10 && !fallback.startsWith('{')) {
                        console.warn('[callAI] âš ï¸ ä½¿ç”¨åŸå§‹æ–‡æœ¬ä½œä¸ºfallback');
                        return fallback;
                    }
                    
                    throw new Error('APIè¿”å›äº†ç©ºå†…å®¹ï¼Œæ— æ³•æå–æœ‰æ•ˆæ–‡æœ¬ã€‚è¯·æ£€æŸ¥APIé…ç½®å’Œæ¨¡å‹å“åº”ã€‚');
                }
                
                return content;
                
            } catch (err) {
                console.error("[callAI] é”™è¯¯è¯¦æƒ…:", err);
                console.log("[callAI] åŸå§‹è¿”å›å†…å®¹:", rawText.substring(0, 500));
                throw err;
            }
        }

        // ç”Ÿæˆè™šæ‹Ÿèº«ä»½
        async function generateIdentity() {
            const name = document.getElementById('char-name').value;
            const desc = document.getElementById('char-desc').value;
            
            if (!name) {
                alert("è¯·å…ˆè¾“å…¥è§’è‰²åå­—");
                return;
            }

            const btnText = document.getElementById('gen-btn-text');
            const spinner = document.getElementById('gen-spinner');
            btnText.style.display = 'none';
            spinner.style.display = 'block';

            try {
                const prompt = `ä½ æ˜¯ä¸€ä¸ªè§’è‰²å¡è¾…åŠ©å·¥å…·ã€‚è¯·æ ¹æ®è§’è‰²ã€${name}ã€‘çš„è®¾å®šï¼ˆ${desc || 'æš‚æ— è¯¦ç»†æè¿°'}ï¼‰ï¼Œä¸ºä»–/å¥¹ç”Ÿæˆä¸€å¥—è™šæ‹Ÿçš„ç°ä»£ç¤¾ä¼šèº«ä»½ä¿¡æ¯ã€‚
è¯·ä¸¥æ ¼è¿”å›çº¯ JSON æ ¼å¼æ•°æ®ï¼ˆä¸è¦åŒ…å« Markdown ä»£ç å—æ ‡è®°ï¼‰ï¼ŒåŒ…å«ä»¥ä¸‹å­—æ®µï¼š
- account: è™šæ‹Ÿç¤¾äº¤è´¦å·ï¼ˆè‹±æ–‡+æ•°å­—ï¼‰
- password: ç™»å½•å¯†ç ï¼ˆå¤æ‚ä¸€ç‚¹ï¼‰
- phone: æ‰‹æœºå·ï¼ˆå¿…é¡»ä¸¥æ ¼ä¸º 7 ä½æ•°å­—ï¼‰
- address: å®¶åº­ä½å€ï¼ˆç¬¦åˆè§’è‰²èƒŒæ™¯çš„è™šæ„åœ°å€ï¼‰
- id_card: èº«ä»½è¯å·ï¼ˆå¿…é¡»ä¸¥æ ¼ä¸º 9 ä½æ•°å­—ï¼‰
- bank_card: é“¶è¡Œå¡å·ï¼ˆå¿…é¡»ä¸¥æ ¼ä¸º 8 ä½æ•°å­—ï¼‰
- bank_password: é“¶è¡Œå¡å¯†ç ï¼ˆå¿…é¡»ä¸¥æ ¼ä¸º 4 ä½æ•°å­—ï¼‰`;

                const content = await callAI([
                    { role: "system", content: "ä½ æ˜¯ä¸€ä¸ªåªè¾“å‡º JSON çš„æ•°æ®ç”ŸæˆåŠ©æ‰‹ã€‚" },
                    { role: "user", content: prompt }
                ]);

                const data = extractAndParseJSON(content);
                if (!data) throw new Error("æ— æ³•è§£æ AI è¿”å›çš„ JSON æ•°æ®");
                
                // å¡«å…¥è¡¨å•
                document.getElementById('char-identity-account').value = data.account || '';
                document.getElementById('char-identity-password').value = data.password || '';
                document.getElementById('char-identity-phone').value = data.phone || '';
                document.getElementById('char-identity-address').value = data.address || '';
                document.getElementById('char-identity-id').value = data.id_card || '';
                document.getElementById('char-identity-bank').value = data.bank_card || '';
                document.getElementById('char-identity-bank-pass').value = data.bank_password || '';

            } catch (err) {
                console.error(err);
                alert("ç”Ÿæˆå¤±è´¥: " + err.message);
            } finally {
                btnText.style.display = 'inline';
                spinner.style.display = 'none';
            }
        }

        async function deleteCharacter() {
            if (!editingCharId) return;
            if (confirm("ç¡®å®šè¦åˆ é™¤è¿™ä¸ªè§’è‰²å—ï¼Ÿ")) {
                await db.characters.delete(editingCharId);
                hideCharacterEditor();
                loadCharacterList();
            }
        }

        // è¾…åŠ©å‡½æ•°ï¼šè‡ªåŠ¨å¯¼å…¥å†…åµŒçš„ä¸–ç•Œä¹¦
        async function importCharacterBook(bookData, charName) {
            if (!bookData) return null;
            
            try {
                const bookName = bookData.name || `${charName}çš„ä¸–ç•Œä¹¦`;
                
                // å­˜å…¥ lorebooks è¡¨
                const id = await db.lorebooks.add({
                    name: bookName,
                    content: bookData,
                    created_at: Date.now()
                });
                
                return id;
            } catch (e) {
                console.error("å¯¼å…¥ä¸–ç•Œä¹¦å¤±è´¥", e);
                return null;
            }
        }

        // å¯¼å…¥è§’è‰²å¯†ç éªŒè¯
        function requestImportCharacter() {
            // å¦‚æœå·²ç»éªŒè¯è¿‡ï¼Œç›´æ¥æ‰“å¼€æ–‡ä»¶é€‰æ‹©
            if (sessionStorage.getItem('import_char_unlocked') === '1') {
                document.getElementById('character-import').click();
                return;
            }
            
            // åˆ›å»ºå¯†ç éªŒè¯å¼¹çª—
            const overlay = document.createElement('div');
            overlay.id = 'import-lock-modal';
            overlay.dataset.target = 'character';
            overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.3);display:flex;align-items:center;justify-content:center;z-index:99999;';
            overlay.onclick = (e) => { if (e.target === overlay) overlay.remove(); };
            
            overlay.innerHTML = `
                <div style="background:#fff;border-radius:14px;padding:28px 24px;width:280px;box-shadow:0 8px 30px rgba(0,0,0,0.08);font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;">
                    <div style="text-align:center;margin-bottom:20px;">
                        <svg viewBox="0 0 24 24" style="width:32px;height:32px;fill:none;stroke:#333;stroke-width:1.5;stroke-linecap:round;stroke-linejoin:round;margin-bottom:8px;"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>
                        <div style="font-size:15px;font-weight:600;color:#262626;letter-spacing:0.3px;">å¯¼å…¥éœ€è¦éªŒè¯</div>
                        <div style="font-size:12px;color:#8e8e8e;margin-top:4px;">è¯·è¾“å…¥å¯†ç ä»¥è§£é”å¯¼å…¥åŠŸèƒ½</div>
                    </div>
                    <input type="password" id="import-lock-pwd" placeholder="è¯·è¾“å…¥å¯†ç " 
                        style="width:100%;padding:12px 14px;border:1px solid #efefef;border-radius:10px;font-size:14px;outline:none;box-sizing:border-box;background:#fafafa;transition:border 0.2s;"
                        onfocus="this.style.borderColor='#333'" onblur="this.style.borderColor='#efefef'">
                    <div id="import-lock-error" style="color:#ff3b30;font-size:12px;margin-top:6px;text-align:center;min-height:16px;"></div>
                    <div style="display:flex;gap:10px;margin-top:14px;">
                        <div onclick="this.closest('#import-lock-modal').remove()" 
                            style="flex:1;text-align:center;padding:11px;border-radius:10px;font-size:14px;color:#8e8e8e;background:#f5f5f5;cursor:pointer;">å–æ¶ˆ</div>
                        <div onclick="verifyImportPassword()" 
                            style="flex:1;text-align:center;padding:11px;border-radius:10px;font-size:14px;color:#fff;background:#262626;cursor:pointer;font-weight:500;">ç¡®è®¤</div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // è‡ªåŠ¨èšç„¦ & å›è½¦æäº¤
            setTimeout(() => {
                const pwdInput = document.getElementById('import-lock-pwd');
                if (pwdInput) {
                    pwdInput.focus();
                    pwdInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') verifyImportPassword();
                    });
                }
            }, 100);
        }
        
        function verifyImportPassword() {
            const pwd = document.getElementById('import-lock-pwd').value;
            const modal = document.getElementById('import-lock-modal');
            const target = modal ? modal.dataset.target : 'character';
            
            if (pwd === 'kkk200856') {
                if (target === 'lorebook') {
                    sessionStorage.setItem('import_lorebook_unlocked', '1');
                } else {
                    sessionStorage.setItem('import_char_unlocked', '1');
                }
                if (modal) modal.remove();
                // éªŒè¯æˆåŠŸï¼Œæ‰“å¼€å¯¹åº”çš„æ–‡ä»¶é€‰æ‹©
                if (target === 'lorebook') {
                    document.getElementById('lorebook-import').click();
                } else {
                    document.getElementById('character-import').click();
                }
            } else {
                const errEl = document.getElementById('import-lock-error');
                if (errEl) errEl.textContent = 'å¯†ç é”™è¯¯ï¼Œè¯·é‡è¯•';
                const pwdInput = document.getElementById('import-lock-pwd');
                if (pwdInput) {
                    pwdInput.value = '';
                    pwdInput.style.borderColor = '#ff3b30';
                    pwdInput.focus();
                    setTimeout(() => { pwdInput.style.borderColor = '#efefef'; }, 1500);
                }
            }
        }

        // å¯¼å…¥è§’è‰² (JSON æˆ– PNG)
        function importCharacterFile(input) {
            const file = input.files[0];
            if (!file) return;
            
            if (file.type.includes('image') || file.name.endsWith('.png')) {
                // å¤„ç† PNG
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        // 1. å…ˆå°è¯•å½“åšå›¾ç‰‡è¯»å–æ˜¾ç¤º
                        const avatarBase64 = e.target.result;
                        
                        // 2. è§£æ PNG å…ƒæ•°æ®ä¸­çš„ JSON
                        const arrayBuffer = await file.arrayBuffer();
                        const jsonStr = extractPngText(new Uint8Array(arrayBuffer));
                        
                        if (!jsonStr) {
                            alert("æœªåœ¨è¿™å¼ å›¾ç‰‡ä¸­æ‰¾åˆ°è§’è‰²æ•°æ® (tEXt chunk)");
                            createNewCharacter();
                            document.getElementById('char-avatar-preview').style.backgroundImage = `url(${avatarBase64})`;
                            document.getElementById('char-avatar-placeholder').style.display = 'none';
                            input.value = '';
                            return;
                        }
                        
                        const json = JSON.parse(jsonStr);
                        // å¤„ç†ä¸åŒæ ¼å¼ (TavernAI V1/V2)
                        let charData = {};
                        if (json.data) {
                            // V2 spec
                            charData = json.data;
                        } else {
                            // V1 æˆ–ç›´æ¥ç»“æ„
                            charData = json;
                        }
                        
                        // å°è¯•å¯¼å…¥ä¸–ç•Œä¹¦
                        let lorebookId = null;
                        if (charData.character_book) {
                             lorebookId = await importCharacterBook(charData.character_book, charData.name);
                        }
                        
                        // å­˜å…¥ DB
                        await db.characters.add({
                            name: charData.name || 'æœªå‘½å',
                            nick: charData.nickname || '', 
                            description: charData.description || charData.personality || '', 
                            type: currentCharacterType, 
                            avatar: avatarBase64,
                            original_data: json,
                            lorebookIds: lorebookId ? [lorebookId] : null, // å…³è”ä¸–ç•Œä¹¦IDæ•°ç»„
                            lorebookId: lorebookId, // å…¼å®¹å­—æ®µ
                            updated_at: Date.now()
                        });
                        
                        let msg = `âœ… æˆåŠŸå¯¼å…¥è§’è‰²: ${charData.name}`;
                        if (lorebookId) msg += `\nğŸ“š å¹¶è‡ªåŠ¨å¯¼å…¥äº†ä¸–ç•Œä¹¦`;
                        alert(msg);
                        loadCharacterList();
                        
                    } catch (err) {
                        console.error(err);
                        alert("è§£æ PNG å¤±è´¥: " + err.message);
                    }
                };
                reader.readAsDataURL(file);
                
            } else {
                // å¤„ç† JSON
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const json = JSON.parse(e.target.result);
                        // å…¼å®¹æ€§å¤„ç†
                        let charData = json;
                        if (json.data) charData = json.data; // Spec V2
                        
                        // å°è¯•å¯¼å…¥ä¸–ç•Œä¹¦
                        let lorebookId = null;
                        if (charData.character_book) {
                             lorebookId = await importCharacterBook(charData.character_book, charData.name);
                        }
                        
                        await db.characters.add({
                            name: charData.name || 'æœªå‘½å',
                            nick: charData.nickname || '',
                            description: charData.description || charData.personality || '',
                            type: currentCharacterType,
                            avatar: '', 
                            original_data: json,
                            lorebookId: lorebookId, // å…³è”ä¸–ç•Œä¹¦ID
                            updated_at: Date.now()
                        });
                        
                        let msg = `âœ… æˆåŠŸå¯¼å…¥è§’è‰²: ${charData.name}`;
                        if (lorebookId) msg += `\nğŸ“š å¹¶è‡ªåŠ¨å¯¼å…¥äº†ä¸–ç•Œä¹¦`;
                        alert(msg);
                        loadCharacterList();
                    } catch (err) {
                        alert("JSON è§£æå¤±è´¥: " + err.message);
                    }
                };
                reader.readAsText(file);
            }
            input.value = '';
        }

        // ç®€æ˜“ PNG tEXt æå–å™¨ (ä¿®å¤ä¸­æ–‡ä¹±ç ç‰ˆ)
        function extractPngText(uint8Array) {
            // PNG Header: 89 50 4E 47 0D 0A 1A 0A
            let offset = 8;
            const textDecoder = new TextDecoder();
            
            while (offset < uint8Array.length) {
                // è¯»å– Chunk Length (4 bytes, Big Endian)
                const length = (uint8Array[offset] << 24) | (uint8Array[offset+1] << 16) | (uint8Array[offset+2] << 8) | uint8Array[offset+3];
                offset += 4;
                
                // è¯»å– Chunk Type (4 bytes)
                const type = String.fromCharCode(...uint8Array.slice(offset, offset + 4));
                offset += 4;
                
                if (type === 'tEXt') {
                    const data = uint8Array.slice(offset, offset + length);
                    // tEXt æ ¼å¼: Keyword + null separator + Text string
                    // æŸ¥æ‰¾ null separator (0x00)
                    let nullIndex = -1;
                    for (let i = 0; i < length; i++) {
                        if (data[i] === 0) {
                            nullIndex = i;
                            break;
                        }
                    }
                    
                    if (nullIndex > -1) {
                        const keyword = textDecoder.decode(data.slice(0, nullIndex));
                        const textBytes = data.slice(nullIndex + 1);
                        const text = textDecoder.decode(textBytes);
                        
                        if (keyword === 'chara') {
                            // TavernAI æ ¼å¼é€šå¸¸æ˜¯ Base64 ç¼–ç çš„ JSON
                            try {
                                // ä¿®å¤ä¹±ç çš„å…³é”®æ­¥éª¤ï¼š
                                // 1. atob è§£ç  base64 -> binary string
                                const binaryString = atob(text);
                                // 2. binary string -> Uint8Array
                                const bytes = new Uint8Array(binaryString.length);
                                for (let i = 0; i < binaryString.length; i++) {
                                    bytes[i] = binaryString.charCodeAt(i);
                                }
                                // 3. TextDecoder è§£ç  utf-8
                                const decoded = new TextDecoder('utf-8').decode(bytes);
                                return decoded;
                            } catch (e) {
                                // ä¹Ÿè®¸ä¸æ˜¯ Base64ï¼Œæˆ–è€…è§£ç å¤±è´¥ï¼Œç›´æ¥è¿”å›åŸå§‹æ–‡æœ¬
                                return text;
                            }
                        }
                    }
                }
                
                // è·³è¿‡ Data å’Œ CRC (4 bytes)
                offset += length + 4;
                
                if (type === 'IEND') break;
            }
            return null;
        }

        // --- ä¸–ç•Œä¹¦ (Lorebook) é€»è¾‘ ---
function showLorebookPage() {
    document.getElementById('lorebook-page').style.display = 'flex';
    loadLorebookList();
}

        function hideLorebookPage() {
            const page = document.getElementById('lorebook-page');
            page.style.transform = 'scale(0.95)';
            page.style.opacity = '0';
            setTimeout(() => {
                page.style.display = 'none';
                page.style.transform = ''; 
                page.style.opacity = '';
            }, 200);
        }

        async function loadLorebookList() {
            const list = await db.lorebooks.toArray();
            const container = document.getElementById('lorebook-list');
            container.innerHTML = '';
            
            if (list.length === 0) {
                container.innerHTML = `
                    <div style="text-align:center; color:#999; margin-top:40px; font-size:14px; display:flex; flex-direction:column; align-items:center; gap:10px;">
                        <svg class="svg-icon" style="width:40px; height:40px; stroke:#ccc;" viewBox="0 0 24 24"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg>
                        <div>ç©ºç©ºå¦‚ä¹Ÿ<br>ç‚¹å‡»ä¸Šæ–¹å¯¼å…¥æˆ–æ–°å»º</div>
                    </div>
                `;
                return;
            }

            list.forEach(book => {
                const count = book.content && book.content.entries ? Object.keys(book.content.entries).length : 0;
                const scope = book.scope || 'personal';
                const scopeLabel = scope === 'global' ? 'å…¨å±€' : 'å•äºº';
                const scopeColor = scope === 'global' ? '#34c759' : '#007aff';
                
                const div = document.createElement('div');
                div.className = 'lorebook-card';
                div.innerHTML = `
                    <div class="lorebook-info">
                        <div style="display:flex; align-items:center; gap:6px;">
                            <h3 style="margin:0;">${book.name}</h3>
                            <span class="lb-scope-badge" style="background:${scopeColor};" onclick="event.stopPropagation(); toggleLorebookScope(${book.id})" title="ç‚¹å‡»åˆ‡æ¢">${scopeLabel}</span>
                        </div>
                        <p>${count} ä¸ªè¯æ¡</p>
                    </div>
                    <div class="lorebook-actions">
                        <div class="lorebook-btn lb-edit" onclick="editLorebook(${book.id})">ç¼–è¾‘</div>
                        <div class="lorebook-btn lb-del" onclick="deleteLorebook(${book.id})">åˆ é™¤</div>
                    </div>
                `;
                container.appendChild(div);
            });
        }

        // ä¸–ç•Œä¹¦å¯¼å…¥åŠ é”
        function requestImportLorebook() {
            if (sessionStorage.getItem('import_lorebook_unlocked') === '1') {
                document.getElementById('lorebook-import').click();
                return;
            }
            // åˆ›å»ºå¯†ç éªŒè¯å¼¹çª—
            const existing = document.getElementById('import-lock-modal');
            if (existing) existing.remove();
            
            const overlay = document.createElement('div');
            overlay.id = 'import-lock-modal';
            overlay.dataset.target = 'lorebook';
            overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.3);display:flex;align-items:center;justify-content:center;z-index:99999;';
            overlay.onclick = (e) => { if (e.target === overlay) overlay.remove(); };
            
            overlay.innerHTML = `
                <div style="background:#fff;border-radius:14px;padding:28px 24px;width:280px;box-shadow:0 8px 30px rgba(0,0,0,0.08);font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;">
                    <div style="text-align:center;margin-bottom:20px;">
                        <svg viewBox="0 0 24 24" style="width:32px;height:32px;fill:none;stroke:#333;stroke-width:1.5;stroke-linecap:round;stroke-linejoin:round;margin-bottom:8px;"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>
                        <div style="font-size:15px;font-weight:600;color:#262626;letter-spacing:0.3px;">å¯¼å…¥éœ€è¦éªŒè¯</div>
                        <div style="font-size:12px;color:#8e8e8e;margin-top:4px;">è¯·è¾“å…¥å¯†ç ä»¥è§£é”å¯¼å…¥åŠŸèƒ½</div>
                    </div>
                    <input type="password" id="import-lock-pwd" placeholder="è¯·è¾“å…¥å¯†ç " 
                        style="width:100%;padding:12px 14px;border:1px solid #efefef;border-radius:10px;font-size:14px;outline:none;box-sizing:border-box;background:#fafafa;transition:border 0.2s;"
                        onfocus="this.style.borderColor='#333'" onblur="this.style.borderColor='#efefef'">
                    <div id="import-lock-error" style="color:#ff3b30;font-size:12px;margin-top:6px;text-align:center;min-height:16px;"></div>
                    <div style="display:flex;gap:10px;margin-top:14px;">
                        <div onclick="this.closest('#import-lock-modal').remove()" 
                            style="flex:1;text-align:center;padding:11px;border-radius:10px;font-size:14px;color:#8e8e8e;background:#f5f5f5;cursor:pointer;">å–æ¶ˆ</div>
                        <div onclick="verifyImportPassword()" 
                            style="flex:1;text-align:center;padding:11px;border-radius:10px;font-size:14px;color:#fff;background:#262626;cursor:pointer;font-weight:500;">ç¡®è®¤</div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            setTimeout(() => {
                const pwdInput = document.getElementById('import-lock-pwd');
                if (pwdInput) {
                    pwdInput.focus();
                    pwdInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') verifyImportPassword();
                    });
                }
            }, 100);
        }

        // å¯¼å…¥ä¸–ç•Œä¹¦æ–‡ä»¶ï¼ˆæ”¯æŒ .json å’Œ .txtï¼‰
        function importLorebookFile(input) {
            const file = input.files[0];
            if (!file) return;
            
            const fileName = file.name.toLowerCase();
            const isTxt = fileName.endsWith('.txt');
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    let name = file.name.replace(/\.(json|txt)$/i, '');
                    
                    if (isTxt) {
                        // TXT æ ¼å¼ï¼šæŒ‰è¡Œè§£æä¸ºè¯æ¡
                        const text = e.target.result;
                        const lines = text.split(/\r?\n/).filter(l => l.trim());
                        
                        if (lines.length === 0) {
                            alert('âŒ æ–‡ä»¶ä¸ºç©º');
                            input.value = '';
                            return;
                        }
                        
                        // æ„å»º entries å¯¹è±¡
                        const entries = {};
                        let entryIndex = 0;
                        let currentKey = '';
                        let currentContent = '';
                        
                        for (const line of lines) {
                            // æ”¯æŒæ ¼å¼1ï¼škey: contentï¼ˆå†’å·åˆ†éš”çš„é”®å€¼å¯¹ï¼‰
                            // æ”¯æŒæ ¼å¼2ï¼škey:: contentï¼ˆåŒå†’å·åˆ†éš”ï¼ŒSillyTaverné£æ ¼ï¼‰
                            // æ”¯æŒæ ¼å¼3ï¼šçº¯æ–‡æœ¬ï¼Œæ¯è¡Œä½œä¸ºä¸€ä¸ªè¯æ¡
                            const colonMatch = line.match(/^(.+?)::?\s+(.+)$/);
                            
                            if (colonMatch) {
                                // æœ‰é”®å€¼å¯¹æ ¼å¼
                                const key = colonMatch[1].trim();
                                const content = colonMatch[2].trim();
                                entries[String(entryIndex)] = {
                                    uid: entryIndex,
                                    key: key.split(/[,ï¼Œã€]/).map(k => k.trim()).filter(k => k),
                                    content: content,
                                    comment: key,
                                    enabled: true
                                };
                                entryIndex++;
                            } else {
                                // çº¯æ–‡æœ¬è¡Œï¼Œæ•´è¡Œä½œä¸º contentï¼Œç¬¬ä¸€ä¸ªè¯ä½œä¸º key
                                const trimmed = line.trim();
                                const firstWord = trimmed.split(/[\s,ï¼Œã€]/)[0];
                                entries[String(entryIndex)] = {
                                    uid: entryIndex,
                                    key: [firstWord],
                                    content: trimmed,
                                    comment: `è¯æ¡ #${entryIndex}`,
                                    enabled: true
                                };
                                entryIndex++;
                            }
                        }
                        
                        const newId = await db.lorebooks.add({
                            name: name,
                            content: { entries: entries },
                            scope: 'personal',
                            created_at: Date.now()
                        });
                        
                        alert(`âœ… æˆåŠŸå¯¼å…¥: ${name}ï¼ˆ${Object.keys(entries).length} ä¸ªè¯æ¡ï¼‰`);
                        loadLorebookList();
                        showLorebookDetail(newId);
                        
                    } else {
                        // JSON æ ¼å¼
                        const json = JSON.parse(e.target.result);
                        // ç®€å•çš„æ ¼å¼æ ¡éªŒï¼šé€šå¸¸æœ‰ entries
                        if (!json.entries && !Array.isArray(json)) {
                            if(!confirm("è¿™ä¼¼ä¹ä¸æ˜¯æ ‡å‡†çš„ SillyTavern æ ¼å¼ï¼Œç¡®å®šè¦å¯¼å…¥å—ï¼Ÿ")) {
                                input.value = '';
                                return;
                            }
                        }
                        
                        if (json.name) name = json.name;

                        const newId = await db.lorebooks.add({
                            name: name,
                            content: json,
                            scope: 'personal',
                            created_at: Date.now()
                        });
                        
                        alert(`âœ… æˆåŠŸå¯¼å…¥: ${name}`);
                        loadLorebookList();
                        showLorebookDetail(newId);
                    }
                } catch (err) {
                    alert('âŒ è§£æå¤±è´¥: ' + err.message);
                }
            };
            reader.readAsText(file);
            input.value = '';
        }

        async function createNewLorebook() {
            const name = prompt("è¯·è¾“å…¥æ–°ä¸–ç•Œä¹¦åç§°ï¼š", "æ–°ä¸–ç•Œä¹¦");
            if (!name) return;
            
            // åˆå§‹åŒ–ç©ºç»“æ„ï¼Œé»˜è®¤ä¸ºå•äºº
            const newBook = {
                entries: {}
            };
            
            const newId = await db.lorebooks.add({
                name: name,
                content: newBook,
                scope: 'personal',
                created_at: Date.now()
            });
            loadLorebookList();
            // åˆ›å»ºåç›´æ¥æ‰“å¼€ç¼–è¾‘é¡µï¼Œå¯åœ¨é‡Œé¢è®¾ç½®ä½œç”¨åŸŸ
            showLorebookDetail(newId);
        }

        async function deleteLorebook(id) {
            if (confirm("ç¡®å®šè¦åˆ é™¤è¿™æœ¬ä¸–ç•Œä¹¦å—ï¼Ÿæ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚")) {
                await db.lorebooks.delete(id);
                loadLorebookList();
            }
        }

        // åˆ‡æ¢ä¸–ç•Œä¹¦ä½œç”¨åŸŸï¼ˆå…¨å±€ <-> å•äººï¼‰â€”â€” ä»å¡ç‰‡ä¸Šç‚¹å‡»å¾½ç« 
        async function toggleLorebookScope(id) {
            const book = await db.lorebooks.get(id);
            if (!book) return;
            const currentScope = book.scope || 'personal';
            book.scope = currentScope === 'global' ? 'personal' : 'global';
            await db.lorebooks.put(book);
            loadLorebookList();
        }

        // åœ¨è¯¦æƒ…é¡µä¸­åˆ‡æ¢ä¸–ç•Œä¹¦ä½œç”¨åŸŸ
        async function saveLorebookScope(scope) {
            if (!currentBookId) return;
            const book = await db.lorebooks.get(currentBookId);
            if (!book) return;
            book.scope = scope;
            await db.lorebooks.put(book);
            // æ›´æ–°æ ‡é¢˜
            const scopeLabel = scope === 'global' ? ' [å…¨å±€]' : ' [å•äºº]';
            document.getElementById('lb-detail-title').innerText = book.name + scopeLabel;
            // æ›´æ–°é€‰ä¸­çŠ¶æ€
            document.querySelectorAll('.lb-scope-option').forEach(el => {
                el.classList.toggle('active', el.dataset.scope === scope);
            });
        }

        // å…¨å±€å˜é‡ï¼šå½“å‰æ“ä½œçš„ä¸–ç•Œä¹¦IDå’Œè¯æ¡ID
        let currentBookId = null;
        let currentEntryId = null;

        function editLorebook(id) {
            showLorebookDetail(id);
        }

        // æ˜¾ç¤ºä¸–ç•Œä¹¦è¯¦æƒ… (è¯æ¡åˆ—è¡¨)
        async function showLorebookDetail(id) {
            currentBookId = id;
            const book = await db.lorebooks.get(id);
            if (!book) return;

            const scope = book.scope || 'personal';
            const scopeLabel = scope === 'global' ? ' [å…¨å±€]' : ' [å•äºº]';
            document.getElementById('lb-detail-title').innerText = book.name + scopeLabel;
            document.getElementById('lb-detail-page').style.display = 'flex';
            
            // è®¾ç½®ä½œç”¨åŸŸé€‰æ‹©å™¨çŠ¶æ€
            document.querySelectorAll('.lb-scope-option').forEach(el => {
                el.classList.toggle('active', el.dataset.scope === scope);
            });
            
            renderEntryList(book.content.entries);
        }

        function hideLorebookDetail() {
            const page = document.getElementById('lb-detail-page');
            page.style.display = 'none';
            currentBookId = null;
            loadLorebookList(); // è¿”å›æ—¶åˆ·æ–°åˆ—è¡¨
        }

        // ä¿å­˜æŒ‰é’®ï¼šåˆ·æ–°åˆ—è¡¨å¹¶æç¤º
        async function saveAndRefreshLorebook() {
            await loadLorebookList();
            // çŸ­æš‚æç¤º
            const btn = event.target;
            const origText = btn.innerText;
            btn.innerText = 'å·²ä¿å­˜ âœ“';
            btn.style.color = '#34c759';
            setTimeout(() => {
                btn.innerText = origText;
                btn.style.color = '';
            }, 1200);
        }

        // æ¸²æŸ“è¯æ¡åˆ—è¡¨
        function renderEntryList(entries) {
            const container = document.getElementById('lb-entry-list');
            container.innerHTML = '';
            
            if (!entries || Object.keys(entries).length === 0) {
                container.innerHTML = `<div style="text-align:center; color:#999; margin-top:40px;">æš‚æ— è¯æ¡</div>`;
                return;
            }

            // æŒ‰ key æ’åº (é€šå¸¸æ˜¯æ•°å­—ç´¢å¼•ï¼Œä½†ä¹Ÿå¯èƒ½æ˜¯éšæœºå­—ç¬¦ä¸²)
            const keys = Object.keys(entries).sort((a,b) => parseInt(a) - parseInt(b));

            keys.forEach(key => {
                const entry = entries[key];
                const title = entry.comment || entry.key?.join(', ') || `è¯æ¡ #${key}`;
                const keysText = entry.key ? entry.key.join(', ') : 'æ— å…³é”®å­—';
                const isEnabled = entry.enabled !== false; // é»˜è®¤å¯ç”¨
                
                const div = document.createElement('div');
                div.className = 'lb-entry-item';
                div.style.opacity = isEnabled ? '1' : '0.5';
                div.innerHTML = `
                    <label class="lb-entry-toggle" onclick="event.stopPropagation();">
                        <input type="checkbox" ${isEnabled ? 'checked' : ''} onchange="toggleEntryEnabled('${key}', this.checked)">
                        <span class="lb-toggle-slider"></span>
                    </label>
                    <div style="flex:1; overflow:hidden; cursor:pointer;" onclick="showEntryEditor(currentBookId, '${key}')">
                        <div class="lb-entry-title">${title}</div>
                        <div class="lb-entry-keys">${keysText}</div>
                    </div>
                    <div style="color:#c7c7cc; cursor:pointer;" onclick="showEntryEditor(currentBookId, '${key}')">â€º</div>
                `;
                container.appendChild(div);
            });
        }

        // æ˜¾ç¤ºè¯æ¡ç¼–è¾‘å™¨
        async function showEntryEditor(bookId, entryId) {
            currentEntryId = entryId;
            const page = document.getElementById('lb-entry-page');
            const titleDom = document.getElementById('lb-entry-title');
            const keysInput = document.getElementById('entry-keys');
            const contentInput = document.getElementById('entry-content');
            
            // æ¸…ç©ºè¾“å…¥
            keysInput.value = '';
            contentInput.value = '';

            if (entryId !== null) {
                // ç¼–è¾‘ç°æœ‰è¯æ¡
                titleDom.innerText = "ç¼–è¾‘è¯æ¡";
                const book = await db.lorebooks.get(bookId);
                const entry = book.content.entries[entryId];
                if (entry) {
                    keysInput.value = entry.key ? entry.key.join(', ') : '';
                    contentInput.value = entry.content || '';
                }
            } else {
                // æ–°å»ºè¯æ¡
                titleDom.innerText = "æ–°å»ºè¯æ¡";
            }

            page.style.display = 'flex';
        }

        function hideEntryEditor() {
            document.getElementById('lb-entry-page').style.display = 'none';
            currentEntryId = null;
        }

        // ä¿å­˜è¯æ¡
        async function saveEntry() {
            if (!currentBookId) return;

            const keysStr = document.getElementById('entry-keys').value.trim();
            const content = document.getElementById('entry-content').value;
            
            // ç®€å•çš„æ ¡éªŒ
            if (!content && !keysStr) {
                alert("è¯·å¡«å†™å†…å®¹æˆ–å…³é”®å­—");
                return;
            }

            // å¤„ç†å…³é”®å­—æ•°ç»„
            const keys = keysStr.split(/[,ï¼Œ]/).map(k => k.trim()).filter(k => k);

            try {
                const book = await db.lorebooks.get(currentBookId);
                if (!book) return;

                // ç¡®ä¿ entries å¯¹è±¡å­˜åœ¨
                if (!book.content.entries) book.content.entries = {};

                let entryId = currentEntryId;
                if (entryId === null) {
                    // ç”Ÿæˆæ–°IDï¼šæ‰¾åˆ°æœ€å¤§ID + 1
                    const existingIds = Object.keys(book.content.entries).map(k => parseInt(k)).filter(n => !isNaN(n));
                    const maxId = existingIds.length > 0 ? Math.max(...existingIds) : -1;
                    entryId = (maxId + 1).toString();
                }

                // æ„é€ è¯æ¡å¯¹è±¡ (ä¿ç•™å…¶ä»–æœªä¿®æ”¹å­—æ®µå¦‚æœå­˜åœ¨)
                const oldEntry = book.content.entries[entryId] || {};
                book.content.entries[entryId] = {
                    ...oldEntry,
                    uid: oldEntry.uid !== undefined ? oldEntry.uid : entryId, // SillyTavern å¸¸ç”¨ uid
                    key: keys,
                    content: content,
                    comment: keys[0] || `è¯æ¡ #${entryId}`, // ç”¨ç¬¬ä¸€ä¸ªå…³é”®å­—åšæ³¨é‡Šå
                    enabled: true
                };

                await db.lorebooks.put(book);
                
                // åˆ·æ–°åˆ—è¡¨å¹¶å…³é—­ç¼–è¾‘å™¨
                renderEntryList(book.content.entries);
                hideEntryEditor();

            } catch (err) {
                alert("ä¿å­˜å¤±è´¥: " + err.message);
            }
        }

        // åˆ é™¤è¯æ¡
        async function deleteEntry() {
            if (!currentBookId || currentEntryId === null) return;
            
            if (!confirm("ç¡®å®šè¦åˆ é™¤æ­¤è¯æ¡å—ï¼Ÿ")) return;

            try {
                const book = await db.lorebooks.get(currentBookId);
                if (book && book.content.entries) {
                    delete book.content.entries[currentEntryId];
                    await db.lorebooks.put(book);
                    
                    renderEntryList(book.content.entries);
                    hideEntryEditor();
                }
            } catch (err) {
                alert("åˆ é™¤å¤±è´¥: " + err.message);
            }
        }

        // åˆ‡æ¢æ¡ç›®å¯ç”¨/ç¦ç”¨
        async function toggleEntryEnabled(entryKey, enabled) {
            if (!currentBookId) return;
            try {
                const book = await db.lorebooks.get(currentBookId);
                if (book && book.content && book.content.entries && book.content.entries[entryKey]) {
                    book.content.entries[entryKey].enabled = enabled;
                    await db.lorebooks.put(book);
                    renderEntryList(book.content.entries);
                }
            } catch (err) {
                console.error('åˆ‡æ¢æ¡ç›®çŠ¶æ€å¤±è´¥:', err);
            }
        }

        async function exportLorebook(id) {
            const book = await db.lorebooks.get(id);
            if (!book) return;
            
            const blob = new Blob([JSON.stringify(book.content, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${book.name}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // æ ¸å¿ƒï¼šä»DEXieæ¢å¤æ‰€æœ‰è®¾ç½®
        async function restoreSetting() {
            // è·å–æ‰€æœ‰å­˜å‚¨çš„æ•°æ®
            const allData = await db.dexiData.toArray();
            const dataMap = {};
            allData.forEach(item => {
                dataMap[item.key] = item.value;
            });
            
            // API é…ç½®æ— éœ€åœ¨é¦–é¡µæ˜¾ç¤ºï¼Œåªåœ¨å±•å¼€æ—¶åŠ è½½

            // æ¢å¤å£çº¸
            if (dataMap.wallpaper) document.getElementById('desktop-body').style.backgroundImage = `url(${dataMap.wallpaper})`;
            // æ¢å¤å°ç»„ä»¶
            if (dataMap.widgetIcon) document.getElementById('widget-icon').style.backgroundImage = `url(${dataMap.widgetIcon})`;
            if (dataMap.widgetTitle) document.getElementById('widget-title').innerText = dataMap.widgetTitle;
            if (dataMap.widgetSubtext) document.getElementById('widget-subtext').innerText = dataMap.widgetSubtext;
            // æ¢å¤æ‹ç«‹å¾—
            if (dataMap.photoLeft) document.getElementById('img-left').style.backgroundImage = `url(${dataMap.photoLeft})`;
            if (dataMap.photoRight) document.getElementById('img-right').style.backgroundImage = `url(${dataMap.photoRight})`;
            // æ¢å¤å¤´åƒ
            if (dataMap.avatar1) {
                const img1 = document.getElementById('avatar-img-1');
                img1.style.backgroundImage = `url(${dataMap.avatar1})`;
                img1.classList.add('has-image');
            }
            if (dataMap.avatar2) {
                const img2 = document.getElementById('avatar-img-2');
                img2.style.backgroundImage = `url(${dataMap.avatar2})`;
                img2.classList.add('has-image');
            }
            if (dataMap.avatar1Bubble) {
                document.getElementById('avatar-bubble1').innerText = dataMap.avatar1Bubble;
                const input1b = document.getElementById('avatar1-bubble-input');
                if (input1b) input1b.value = dataMap.avatar1Bubble;
            }
            if (dataMap.avatar1Name) {
                document.getElementById('avatar-name1').innerText = dataMap.avatar1Name;
                const input1n = document.getElementById('avatar1-name-input');
                if (input1n) input1n.value = dataMap.avatar1Name;
            }
            if (dataMap.avatar2Bubble) {
                document.getElementById('avatar-bubble2').innerText = dataMap.avatar2Bubble;
                const input2b = document.getElementById('avatar2-bubble-input');
                if (input2b) input2b.value = dataMap.avatar2Bubble;
            }
            if (dataMap.avatar2Name) {
                document.getElementById('avatar-name2').innerText = dataMap.avatar2Name;
                const input2n = document.getElementById('avatar2-name-input');
                if (input2n) input2n.value = dataMap.avatar2Name;
            }
            // æ¢å¤å€’æ•°æ—¥
            if (dataMap.daysText) {
                document.getElementById('days-text').innerText = dataMap.daysText;
                const daysInput = document.getElementById('days-input');
                if (daysInput) daysInput.value = dataMap.daysText;
            }
            // æ¢å¤å°ç»„ä»¶æ–‡æœ¬åˆ°è¾“å…¥æ¡†
            if (dataMap.widgetTitle) {
                const wtInput = document.getElementById('widget-title-input');
                if (wtInput) wtInput.value = dataMap.widgetTitle;
            }
            if (dataMap.widgetSubtext) {
                const wsInput = document.getElementById('widget-subtext-input');
                if (wsInput) wsInput.value = dataMap.widgetSubtext;
            }
            // æ¢å¤åº”ç”¨å›¾æ ‡
            const iconIds = ['appstore','notes','remind','facetime','photo','xianyu','cabin','icity'];
            iconIds.forEach(id => {
                const key = `icon${id.charAt(0).toUpperCase() + id.slice(1)}`;
                const el = document.getElementById(`icon-${id}`)?.querySelector('.icon');
                if (dataMap[key] && el) el.style.backgroundImage = `url(${dataMap[key]})`;
            });
            // æ¢å¤Dockå›¾æ ‡
            const dockIds = ['setting','custom','message','phone'];
            dockIds.forEach(id => {
                const key = `dock${id.charAt(0).toUpperCase() + id.slice(1)}`;
                const el = document.getElementById(`dock-${id}`)?.querySelector('.icon');
                if (dataMap[key] && el) el.style.backgroundImage = `url(${dataMap[key]})`;
            });
            
        // æ¢å¤æ¤­åœ†å½¢é¢œè‰²
        if (dataMap.heartColor) {
            document.documentElement.style.setProperty('--heart-color', dataMap.heartColor);
            const hcInput = document.getElementById('heart-color-input');
            if (hcInput) hcInput.value = dataMap.heartColor;
        }
        if (dataMap.capsuleColor) {
            document.documentElement.style.setProperty('--capsule-bg', dataMap.capsuleColor);
            const ccInput = document.getElementById('capsule-color-input');
            if (ccInput) ccInput.value = dataMap.capsuleColor;
        }
        if (dataMap.bubbleColor) {
            document.documentElement.style.setProperty('--bubble-bg', dataMap.bubbleColor);
            const bcInput = document.getElementById('bubble-color-input');
            if (bcInput) bcInput.value = dataMap.bubbleColor;
        }
        
        // æ¢å¤æ¡Œé¢æ–‡å­—é¢œè‰²
        if (dataMap.desktopTextColor && dataMap.desktopTextColor !== '#999999') {
            applyDesktopTextColor(dataMap.desktopTextColor);
            const dtcInput = document.getElementById('desktop-text-color-input');
            if (dtcInput) dtcInput.value = dataMap.desktopTextColor;
        }
        
        // æ¢å¤è‡ªå®šä¹‰å­—ä½“
        if (dataMap.customFontUrl && dataMap.customFontName) {
            // å¡«å……è¾“å…¥æ¡†
            document.getElementById('custom-font-input').value = dataMap.customFontUrl;
            document.getElementById('custom-font-name-input').value = dataMap.customFontName;
            // åŠ è½½å¹¶åº”ç”¨å…¨å±€å­—ä½“
            loadCustomFont(dataMap.customFontUrl, dataMap.customFontName, false);
        }

        // æ¢å¤è‡ªå®šä¹‰CSS
        if (dataMap.customCssCode) {
            const cssInput = document.getElementById('custom-css-input');
            if (cssInput) cssInput.value = dataMap.customCssCode;
            applyCustomCSS();
        }
    }

    // ===== è‡ªå®šä¹‰CSSåŠŸèƒ½ =====

    // åº”ç”¨è‡ªå®šä¹‰CSS
    function applyCustomCSS() {
        const cssCode = document.getElementById('custom-css-input').value;
        let styleEl = document.getElementById('user-custom-css');
        if (!styleEl) {
            styleEl = document.createElement('style');
            styleEl.id = 'user-custom-css';
            document.head.appendChild(styleEl);
        }
        styleEl.textContent = cssCode || '';
    }

    // æ¸…ç©ºè‡ªå®šä¹‰CSS
    function clearCustomCSS() {
        document.getElementById('custom-css-input').value = '';
        applyCustomCSS();
        if (typeof showToast === 'function') showToast('å·²æ¸…ç©ºè‡ªå®šä¹‰CSS');
    }

// --- å…¨å±€è¡¨æƒ…åŒ…ç®¡ç†é€»è¾‘ ---
function showStickerPage() {
    console.log('[showStickerPage] Function called');
    const page = document.getElementById('sticker-page');
    console.log('[showStickerPage] sticker-page element:', page);
    if (!page) {
        console.error('[showStickerPage] sticker-page element not found');
        return;
    }
    console.log('[showStickerPage] Setting display to flex and ensuring position fixed');
    // ç¡®ä¿é¡µé¢æ˜¯ fixed å®šä½å¹¶æ˜¾ç¤º
    page.style.position = 'fixed';
    page.style.top = '0';
    page.style.left = '0';
    page.style.width = '100vw';
    page.style.height = '100vh';
    page.style.zIndex = '200';
    page.style.display = 'flex';
    console.log('[showStickerPage] Calling renderStickerCategories');
    // ç¡®ä¿æ˜¾ç¤ºåˆ—è¡¨è§†å›¾
    const listView = document.getElementById('sticker-list-view');
    const detailView = document.getElementById('sticker-detail-view');
    if (listView) listView.style.display = 'flex';
    if (detailView) detailView.style.display = 'none';
    currentStickerCategoryId = null;
    renderStickerCategories();
    console.log('[showStickerPage] Done');
}
// ç¡®ä¿å‡½æ•°åœ¨å…¨å±€ä½œç”¨åŸŸå¯è®¿é—®
window.showStickerPage = showStickerPage;

function hideStickerPage() {
    const page = document.getElementById('sticker-page');
    if (!page) {
        console.error('sticker-page element not found');
        return;
    }
    page.style.transform = 'scale(0.95)';
    page.style.opacity = '0';
    setTimeout(() => {
        page.style.display = 'none';
        page.style.transform = ''; 
        page.style.opacity = '';
    }, 200);
}
// ç¡®ä¿å‡½æ•°åœ¨å…¨å±€ä½œç”¨åŸŸå¯è®¿é—®
window.hideStickerPage = hideStickerPage;

async function renderStickerCategories() {
    const list = await db.sticker_categories.toArray();
    const listContainer = document.getElementById('sticker-category-list');
    
    if (!listContainer) {
        console.error('sticker-category-list element not found');
        return;
    }
    
    // å¦‚æœæ²¡æœ‰åˆ†ç±»ï¼Œæ˜¾ç¤ºç©ºçŠ¶æ€
    if (list.length === 0) {
        listContainer.innerHTML = `
            <div class="sticker-empty-state">
                <svg class="svg-icon" style="width:64px; height:64px; stroke:#e5e5ea;" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><path d="M8 14s1.5 2 4 2 4-2 4-2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line></svg>
                <div style="color:#999; margin-top:16px;">æš‚æ— è¡¨æƒ…åŒ…åˆ†ç±»</div>
                <button onclick="showCreateCategoryModal()" style="margin-top:20px; padding:8px 20px; background:var(--ins-pink); color:#fff; border:none; border-radius:20px; font-size:14px;">æ–°å»ºåˆ†ç±»</button>
                <div style="margin-top:10px;">
                    <input type="file" id="import-sticker-json" accept=".json" style="display:none" onchange="importStickerCategory(this)">
                    <button onclick="document.getElementById('import-sticker-json').click()" style="padding:8px 20px; background:#f2f2f7; color:#333; border:none; border-radius:20px; font-size:14px;">å¯¼å…¥é…ç½®</button>
                </div>
            </div>
        `;
        return;
    }

    // æ¸²æŸ“åˆ†ç±»åˆ—è¡¨
    listContainer.innerHTML = list.map(cat => {
        const stickerCount = (cat.stickers || []).length;
        return `
            <div class="sticker-category-item" onclick="openStickerCategoryDetail(${cat.id})">
                <div style="flex:1;">
                    <div style="font-size:16px; font-weight:500; color:#333; margin-bottom:4px;">${cat.name}</div>
                    <div style="font-size:12px; color:#999;">${stickerCount} ä¸ªè¡¨æƒ…</div>
                </div>
                <div style="display:flex; gap:8px; align-items:center;">
                    <div class="sticker-category-action" onclick="event.stopPropagation(); exportStickerCategory(${cat.id})" style="padding:6px 12px; background:var(--ins-pink-light); color:var(--ins-pink); border-radius:6px; font-size:12px;">å¯¼å‡º</div>
                    <div class="sticker-category-action" onclick="event.stopPropagation(); deleteStickerCategory(${cat.id})" style="padding:6px 12px; background:#ffe5e5; color:#ff3b30; border-radius:6px; font-size:12px;">åˆ é™¤</div>
                    <svg class="svg-icon" style="width:16px; height:16px; color:#ccc;" viewBox="0 0 24 24"><polyline points="9 18 15 12 9 6"></polyline></svg>
                </div>
            </div>
        `;
    }).join('');
}

// æ‰“å¼€åˆ†ç±»è¯¦æƒ…é¡µ
async function openStickerCategoryDetail(id) {
    currentStickerCategoryId = id;
    const listView = document.getElementById('sticker-list-view');
    const detailView = document.getElementById('sticker-detail-view');
    
    if (listView) listView.style.display = 'none';
    if (detailView) detailView.style.display = 'flex';
    
    await renderStickerCategoryDetail();
}

// è¿”å›åˆ†ç±»åˆ—è¡¨
function backToStickerList() {
    const listView = document.getElementById('sticker-list-view');
    const detailView = document.getElementById('sticker-detail-view');
    
    if (listView) listView.style.display = 'flex';
    if (detailView) detailView.style.display = 'none';
    
    currentStickerCategoryId = null;
    renderStickerCategories();
}

// æ¸²æŸ“åˆ†ç±»è¯¦æƒ…
async function renderStickerCategoryDetail() {
    if (!currentStickerCategoryId) return;
    
    const cat = await db.sticker_categories.get(currentStickerCategoryId);
    if (!cat) return;
    
    const titleEl = document.getElementById('sticker-detail-title');
    const contentEl = document.getElementById('sticker-detail-content');
    
    if (titleEl) titleEl.innerText = cat.name;
    if (!contentEl) return;
    
    contentEl.innerHTML = `
        <div style="padding: 16px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px; padding:12px; background:#f9f9f9; border-radius:12px;">
                <div>
                    <div style="font-size:14px; color:#999; margin-bottom:4px;">è¡¨æƒ…æ•°é‡</div>
                    <div style="font-size:20px; font-weight:600; color:#333;">${(cat.stickers || []).length}</div>
                </div>
                <div style="display:flex; gap:10px; flex-wrap:wrap;">
                    <button onclick="exportStickerCategory(${cat.id})" style="padding:8px 16px; background:var(--ins-pink-light); color:var(--ins-pink); border:none; border-radius:8px; font-size:14px; font-weight:500;">å¯¼å‡º</button>
                    <input type="file" id="import-sticker-json-detail" accept=".json" style="display:none" onchange="importStickerCategory(this)">
                    <button onclick="document.getElementById('import-sticker-json-detail').click()" style="padding:8px 16px; background:#f2f2f7; color:#666; border:none; border-radius:8px; font-size:14px; font-weight:500;">å¯¼å…¥</button>
                    <input type="file" id="batch-import-sticker-txt" accept=".txt,.text,.md,.docx,.doc" style="display:none" onchange="batchImportStickersFromText(this)">
                    <button onclick="document.getElementById('batch-import-sticker-txt').click()" style="padding:8px 16px; background:#e8f5e9; color:#2e7d32; border:none; border-radius:8px; font-size:14px; font-weight:500;" title="æ”¯æŒ.txt/.md/.docxæ–‡ä»¶ï¼Œæ ¼å¼ï¼šæè¿°ï¼šå›¾ç‰‡é“¾æ¥">æ‰¹é‡å¯¼å…¥</button>
                </div>
            </div>
            
            <div class="sticker-grid-view">
                <!-- æ·»åŠ æŒ‰é’® -->
                <div class="sticker-grid-item add-btn" onclick="showAddStickerModal()">
                    <svg class="svg-icon" style="width:24px; height:24px;" viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
                    <div style="font-size:12px; color:#999; margin-top:8px;">æ·»åŠ è¡¨æƒ…</div>
                </div>
                ${(cat.stickers || []).map((s, idx) => `
                    <div class="sticker-grid-item" onclick="previewSticker(${idx})">
                        <img src="${s.url}" class="sticker-img" style="object-fit:cover;" onerror="this.onerror=null; this.style.cssText='width:100%; height:100%; display:flex; align-items:center; justify-content:center; background:#f5f5f5; border-radius:8px;'; this.outerHTML='<div class=\\'sticker-img\\' style=\\'display:flex; align-items:center; justify-content:center; background:#f5f5f5; color:#ccc; font-size:10px;\\'>å¤±è´¥</div>';" />
                        ${s.description ? `<div class="sticker-desc-tag">AIå¯è¯†</div>` : ''}
                        <div class="sticker-del-btn" onclick="deleteSticker(${idx}, event)">
                            <svg style="width:12px; height:12px; stroke:#fff; stroke-width:2;" viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                        </div>
                    </div>
                `).join('')}
            </div>
        </div>
    `;
}

// æ˜¾ç¤ºåˆ›å»ºåˆ†ç±»å¼¹çª—
function showCreateCategoryModal() {
    const name = prompt("è¯·è¾“å…¥åˆ†ç±»åç§°", "æˆ‘çš„è¡¨æƒ…");
    if (name && name.trim()) {
        createNewStickerCategory(name.trim());
    }
}

async function createNewStickerCategory(name) {
    try {
        const id = await db.sticker_categories.add({
            name: name,
            stickers: []
        });
        renderStickerCategories();
    } catch (err) {
        console.error('åˆ›å»ºåˆ†ç±»å¤±è´¥:', err);
        alert('åˆ›å»ºåˆ†ç±»å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
}

async function deleteStickerCategory(id) {
    if (confirm("ç¡®å®šè¦åˆ é™¤è¿™ä¸ªåˆ†ç±»å—ï¼Ÿåˆ é™¤åæ— æ³•æ¢å¤ï¼")) {
        try {
            await db.sticker_categories.delete(id);
            if (currentStickerCategoryId === id) {
                // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰æŸ¥çœ‹çš„åˆ†ç±»ï¼Œè¿”å›åˆ—è¡¨
                backToStickerList();
            } else {
                renderStickerCategories();
            }
        } catch (err) {
            console.error('åˆ é™¤åˆ†ç±»å¤±è´¥:', err);
            alert('åˆ é™¤å¤±è´¥ï¼Œè¯·é‡è¯•');
        }
    }
}

    // æ˜¾ç¤ºæ·»åŠ è¡¨æƒ…å¼¹çª—
    function showAddStickerModal() {
        const modal = document.createElement('div');
        modal.className = 'sticker-modal-overlay';
        modal.id = 'add-sticker-modal';
        modal.innerHTML = `
            <div class="sticker-modal-box">
                <h3 style="text-align:center; margin-bottom:20px;">æ·»åŠ è¡¨æƒ…</h3>
                
                <div style="margin-bottom:16px;">
                    <label style="display:block; color:#666; font-size:14px; margin-bottom:8px;">å›¾ç‰‡æ¥æº</label>
                    <div style="display:flex; gap:10px;">
                        <button onclick="document.getElementById('sticker-file-input').click()" style="flex:1; padding:10px; background:#f5f5f5; border:1px solid #eee; border-radius:8px;">æœ¬åœ°ä¸Šä¼ </button>
                        <input type="file" id="sticker-file-input" accept="image/*" style="display:none" onchange="handleStickerFileSelect(this)">
                    </div>
                    <div id="sticker-preview-area" style="margin-top:10px; height:100px; background:#f9f9f9; border-radius:8px; display:none; align-items:center; justify-content:center; background-size:contain; background-repeat:no-repeat; background-position:center;"></div>
                </div>

                <div style="margin-bottom:16px;">
                    <label style="display:block; color:#666; font-size:14px; margin-bottom:8px;">å›¾ç‰‡é“¾æ¥ (å¯é€‰)</label>
                    <input type="text" id="sticker-url-input" placeholder="https://..." style="width:100%; padding:10px; border:1px solid #eee; border-radius:8px; outline:none;" oninput="handleStickerUrlInput(this)">
                </div>

                <div style="margin-bottom:20px;">
                    <label style="display:block; color:#666; font-size:14px; margin-bottom:8px;">æè¿° (AIè¯†åˆ«ç”¨)</label>
                    <input type="text" id="sticker-desc-input" placeholder="ä¾‹å¦‚ï¼šä¸€åªæƒŠè®¶çš„ç™½çŒ«" style="width:100%; padding:10px; border:1px solid #eee; border-radius:8px; outline:none;">
                </div>

                <div style="display:flex; gap:10px;">
                    <button onclick="document.getElementById('add-sticker-modal').remove()" style="flex:1; padding:12px; background:#f2f2f7; border:none; border-radius:8px;">å–æ¶ˆ</button>
                    <button onclick="confirmAddSticker()" style="flex:1; padding:12px; background:var(--ins-pink); color:#white; border:none; border-radius:8px; color:#fff;">æ·»åŠ </button>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
    }

    let tempStickerData = null; // ä¸´æ—¶å­˜å‚¨ä¸Šä¼ çš„ base64 æˆ– URL

    function handleStickerFileSelect(input) {
        const file = input.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = e => {
                tempStickerData = e.target.result;
                const preview = document.getElementById('sticker-preview-area');
                preview.style.display = 'flex';
                preview.style.backgroundImage = `url(${tempStickerData})`;
                document.getElementById('sticker-url-input').value = ''; // æ¸…ç©ºURLè¾“å…¥
            };
            reader.readAsDataURL(file);
        }
    }

    function handleStickerUrlInput(input) {
        const url = input.value.trim();
        if (url) {
            tempStickerData = url;
            const preview = document.getElementById('sticker-preview-area');
            preview.style.display = 'flex';
            preview.style.backgroundImage = `url(${url})`;
        }
    }

    async function confirmAddSticker() {
        const desc = document.getElementById('sticker-desc-input').value.trim();
        
        if (!tempStickerData) {
            alert("è¯·å…ˆä¸Šä¼ å›¾ç‰‡æˆ–è¾“å…¥é“¾æ¥");
            return;
        }
        
        if (!desc) {
             if(!confirm("æœªå¡«å†™æè¿°ï¼ŒAIå¯èƒ½æ— æ³•å‡†ç¡®ç†è§£è¿™ä¸ªè¡¨æƒ…ã€‚ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ")) return;
        }

        const cat = await db.sticker_categories.get(currentStickerCategoryId);
        if (cat) {
            cat.stickers.push({
                url: tempStickerData,
                description: desc,
                created_at: Date.now()
            });
            await db.sticker_categories.put(cat);
            renderStickerCategoryDetail();
            document.getElementById('add-sticker-modal').remove();
            tempStickerData = null;
        }
    }

async function deleteSticker(index, e) {
    e.stopPropagation();
    if (confirm("åˆ é™¤è¿™å¼ è¡¨æƒ…ï¼Ÿ")) {
        const cat = await db.sticker_categories.get(currentStickerCategoryId);
        cat.stickers.splice(index, 1);
        await db.sticker_categories.put(cat);
        renderStickerCategoryDetail();
    }
}

// é¢„è§ˆè¡¨æƒ…è¯¦æƒ…ï¼ˆå¯ç¼–è¾‘æè¿°ï¼‰
async function previewSticker(index) {
    const cat = await db.sticker_categories.get(currentStickerCategoryId);
    const sticker = cat.stickers[index];
    
    const newDesc = prompt("ç¼–è¾‘æè¿° (AIè¯†åˆ«ç”¨)", sticker.description || "");
    if (newDesc !== null) {
        sticker.description = newDesc;
        await db.sticker_categories.put(cat);
        renderStickerCategoryDetail();
    }
}

    // å¯¼å‡ºåˆ†ç±»
    async function exportStickerCategory(id) {
        const cat = await db.sticker_categories.get(id);
        const blob = new Blob([JSON.stringify(cat, null, 2)], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `è¡¨æƒ…åŒ…-${cat.name}.json`;
        a.click();
        URL.revokeObjectURL(url);
    }

// å¯¼å…¥åˆ†ç±»
function importStickerCategory(input) {
    const file = input.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const json = JSON.parse(e.target.result);
            // ç®€å•çš„æ ¼å¼æ ¡éªŒ
            if (!json.name || !Array.isArray(json.stickers)) {
                throw new Error("æ ¼å¼ä¸æ­£ç¡®");
            }
            
            // å¦‚æœå½“å‰åœ¨è¯¦æƒ…é¡µï¼Œè¯¢é—®æ˜¯å¯¼å…¥ä¸ºæ–°åˆ†ç±»è¿˜æ˜¯æ›¿æ¢å½“å‰åˆ†ç±»
            if (currentStickerCategoryId) {
                const action = confirm(`å¯¼å…¥æ–¹å¼ï¼š\nç¡®å®š = æ›¿æ¢å½“å‰åˆ†ç±»\nå–æ¶ˆ = åˆ›å»ºæ–°åˆ†ç±»`);
                if (action) {
                    // æ›¿æ¢å½“å‰åˆ†ç±»
                    const cat = await db.sticker_categories.get(currentStickerCategoryId);
                    if (cat) {
                        cat.name = json.name;
                        cat.stickers = json.stickers;
                        await db.sticker_categories.put(cat);
                        alert(`æˆåŠŸå¯¼å…¥å¹¶æ›¿æ¢åˆ†ç±»ï¼š${json.name}`);
                        renderStickerCategoryDetail();
                    }
                } else {
                    // åˆ›å»ºæ–°åˆ†ç±»
                    delete json.id;
                    await db.sticker_categories.add(json);
                    alert(`æˆåŠŸå¯¼å…¥ä¸ºæ–°åˆ†ç±»ï¼š${json.name}`);
                    backToStickerList();
                }
            } else {
                // åœ¨åˆ—è¡¨é¡µï¼Œåˆ›å»ºæ–°åˆ†ç±»
                delete json.id;
                await db.sticker_categories.add(json);
                alert(`æˆåŠŸå¯¼å…¥åˆ†ç±»ï¼š${json.name}`);
                renderStickerCategories();
            }
        } catch (err) {
            alert("å¯¼å…¥å¤±è´¥: " + err.message);
        }
        // æ¸…ç©ºinputï¼Œå…è®¸é‡å¤å¯¼å…¥åŒä¸€æ–‡ä»¶
        input.value = '';
    };
    reader.readAsText(file);
}
// æ‰¹é‡å¯¼å…¥è¡¨æƒ…åŒ…ï¼ˆä»æ–‡æœ¬æ–‡ä»¶ï¼‰
async function batchImportStickersFromText(input) {
    const file = input.files[0];
    if (!file) return;
    
    if (!currentStickerCategoryId) {
        alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªåˆ†ç±»');
        input.value = '';
        return;
    }
    
    const fileName = file.name.toLowerCase();
    const isDocx = fileName.endsWith('.docx') || fileName.endsWith('.doc');
    
    // å¦‚æœæ˜¯ .docx æ–‡ä»¶ï¼Œä½¿ç”¨ JSZip è§£æ
    if (isDocx) {
        try {
            const arrayBuffer = await file.arrayBuffer();
            const zip = await JSZip.loadAsync(arrayBuffer);
            const docXml = await zip.file('word/document.xml').async('string');
            
            // ç®€å•æå–æ–‡æœ¬å†…å®¹ï¼ˆæå– <w:t> æ ‡ç­¾ä¸­çš„æ–‡æœ¬ï¼‰
            const textMatches = docXml.match(/<w:t[^>]*>([^<]+)<\/w:t>/g) || [];
            const extractedText = textMatches.map(match => {
                const content = match.replace(/<w:t[^>]*>/, '').replace(/<\/w:t>/, '');
                return content;
            }).join('');
            
            // å¤„ç†æå–çš„æ–‡æœ¬
            await processStickerText(extractedText, input);
        } catch (err) {
            console.error('è§£æ .docx æ–‡ä»¶å¤±è´¥:', err);
            alert('è§£æ Word æ–‡æ¡£å¤±è´¥ï¼Œè¯·ç¡®ä¿æ–‡ä»¶æ ¼å¼æ­£ç¡®ã€‚\nå»ºè®®ï¼šå°† Word æ–‡æ¡£å¦å­˜ä¸º .txt çº¯æ–‡æœ¬æ–‡ä»¶åå†å¯¼å…¥ã€‚\n\né”™è¯¯ä¿¡æ¯: ' + err.message);
            input.value = '';
        }
        return;
    }
    
    // å¤„ç†çº¯æ–‡æœ¬æ–‡ä»¶ (.txt, .md ç­‰)
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const text = e.target.result;
            await processStickerText(text, input);
        } catch (err) {
            console.error('æ‰¹é‡å¯¼å…¥å¤±è´¥:', err);
            alert('å¯¼å…¥å¤±è´¥: ' + err.message);
            input.value = '';
        }
    };
    reader.readAsText(file, 'UTF-8');
}

// å¤„ç†è¡¨æƒ…åŒ…æ–‡æœ¬å†…å®¹çš„é€šç”¨å‡½æ•°
async function processStickerText(text, input) {
    try {
        const lines = text.split(/\r?\n/).filter(line => line.trim());
        
        if (lines.length === 0) {
            alert('æ–‡ä»¶ä¸ºç©ºæˆ–æ ¼å¼ä¸æ­£ç¡®');
            input.value = '';
            return;
        }
        
        const stickers = [];
        let successCount = 0;
        let failCount = 0;
        const errors = [];
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line) continue;
            
            // è§£ææ ¼å¼ï¼šæè¿°ï¼šurl æˆ– æè¿°:urlï¼ˆæ”¯æŒä¸­æ–‡å’Œè‹±æ–‡å†’å·ï¼‰
            const match = line.match(/^(.+?)[ï¼š:]\s*(.+)$/);
            if (match) {
                const description = match[1].trim();
                const url = match[2].trim();
                
                // éªŒè¯URLæ ¼å¼
                if (url && (url.startsWith('http://') || url.startsWith('https://') || url.startsWith('data:image'))) {
                    stickers.push({
                        url: url,
                        description: description,
                        created_at: Date.now()
                    });
                    successCount++;
                } else {
                    failCount++;
                    errors.push(`ç¬¬${i+1}è¡Œï¼šURLæ ¼å¼ä¸æ­£ç¡® - ${line}`);
                }
            } else {
                // å¦‚æœæ²¡æœ‰å†’å·ï¼Œå°è¯•ä½œä¸ºçº¯URLå¤„ç†
                if (line.startsWith('http://') || line.startsWith('https://') || line.startsWith('data:image')) {
                    stickers.push({
                        url: line,
                        description: '',
                        created_at: Date.now()
                    });
                    successCount++;
                } else {
                    failCount++;
                    errors.push(`ç¬¬${i+1}è¡Œï¼šæ ¼å¼ä¸æ­£ç¡® - ${line}`);
                }
            }
        }
        
        if (stickers.length === 0) {
            alert('æœªèƒ½è§£æå‡ºä»»ä½•è¡¨æƒ…åŒ…ã€‚\næ ¼å¼åº”ä¸ºï¼šæè¿°ï¼šå›¾ç‰‡é“¾æ¥\nä¾‹å¦‚ï¼šä¸€åªçŒ«ï¼šhttps://example.com/cat.jpg');
            input.value = '';
            return;
        }
        
        // æ·»åŠ åˆ°åˆ†ç±»
        const cat = await db.sticker_categories.get(currentStickerCategoryId);
        if (!cat) {
            alert('åˆ†ç±»ä¸å­˜åœ¨');
            input.value = '';
            return;
        }
        
        if (!cat.stickers) cat.stickers = [];
        cat.stickers.push(...stickers);
        await db.sticker_categories.put(cat);
        
        // æ˜¾ç¤ºç»“æœ
        let message = `âœ… æˆåŠŸå¯¼å…¥ ${successCount} ä¸ªè¡¨æƒ…åŒ…`;
        if (failCount > 0) {
            message += `\nâŒ å¤±è´¥ ${failCount} ä¸ª`;
            if (errors.length <= 5) {
                message += '\n\né”™è¯¯è¯¦æƒ…ï¼š\n' + errors.join('\n');
            } else {
                message += `\n\nå‰5ä¸ªé”™è¯¯ï¼š\n${errors.slice(0, 5).join('\n')}\n...è¿˜æœ‰${errors.length - 5}ä¸ªé”™è¯¯`;
            }
            message += '\n\næç¤ºï¼šæ ¼å¼åº”ä¸º"æè¿°ï¼šå›¾ç‰‡é“¾æ¥"ï¼Œä¾‹å¦‚ï¼š\nä¸€åªçŒ«ï¼šhttps://example.com/cat.jpg';
        }
        
        // ä½¿ç”¨æ›´å‹å¥½çš„æç¤ºæ–¹å¼
        if (failCount === 0) {
            alert(message);
        } else {
            // å¦‚æœæœ‰é”™è¯¯ï¼Œä½¿ç”¨confirmè®©ç”¨æˆ·é€‰æ‹©æ˜¯å¦æŸ¥çœ‹è¯¦æƒ…
            const showDetails = confirm(message + '\n\næ˜¯å¦æŸ¥çœ‹è¯¦ç»†é”™è¯¯ä¿¡æ¯ï¼Ÿ');
            if (showDetails && errors.length > 0) {
                alert('è¯¦ç»†é”™è¯¯ä¿¡æ¯ï¼š\n\n' + errors.join('\n'));
            }
        }
        
        // åˆ·æ–°é¡µé¢
        renderStickerCategoryDetail();
        input.value = '';
    } catch (err) {
        console.error('å¤„ç†è¡¨æƒ…åŒ…æ–‡æœ¬å¤±è´¥:', err);
        alert('å¯¼å…¥å¤±è´¥: ' + err.message);
        input.value = '';
    }
}

// ç¡®ä¿å‡½æ•°åœ¨å…¨å±€ä½œç”¨åŸŸå¯è®¿é—®
window.importStickerCategory = importStickerCategory;
window.openStickerCategoryDetail = openStickerCategoryDetail;
window.backToStickerList = backToStickerList;
window.showCreateCategoryModal = showCreateCategoryModal;
window.batchImportStickersFromText = batchImportStickersFromText;
window.processStickerText = processStickerText;
window.switchStickerCategory = switchStickerCategory;
window.searchStickers = searchStickers;
window.detectAndSuggestStickers = detectAndSuggestStickers;
window.sendSuggestedSticker = sendSuggestedSticker;

// å½“å‰é€‰ä¸­çš„è¡¨æƒ…åŒ…åˆ†ç±»ID
let currentActiveStickerCategoryId = null;

// æ›´æ–°èŠå¤©é¢æ¿ä¸­çš„è¡¨æƒ…åˆ—è¡¨ï¼ˆåœ¨æ‰“å¼€é¢æ¿æ—¶è°ƒç”¨ï¼‰
// æ³¨æ„ï¼šç”¨æˆ·å¯ä»¥çœ‹åˆ°æ‰€æœ‰è¡¨æƒ…åŒ…ï¼Œä½†è§’è‰²åªèƒ½ä½¿ç”¨æŒ‚è½½çš„
async function updateChatStickerPanel() {
    const tabsContainer = document.getElementById('sticker-category-tabs');
    const contentContainer = document.getElementById('sticker-content');
    if (!tabsContainer || !contentContainer) return;
    
    // è·å–æ‰€æœ‰è¡¨æƒ…åŒ…åˆ†ç±»ï¼ˆç”¨æˆ·å¯ä»¥çœ‹åˆ°æ‰€æœ‰ï¼‰
    const allCategories = await db.sticker_categories.toArray();
    
    if (allCategories.length === 0) {
        tabsContainer.innerHTML = '';
        contentContainer.innerHTML = `<div style="text-align:center; grid-column:span 4; color:#999; margin-top:20px;">æš‚æ— è¡¨æƒ…åŒ…<br>è¯·å»ã€æˆ‘-è¡¨æƒ…ã€‘æ·»åŠ </div>`;
        return;
    }
    
    // è·å–å½“å‰è§’è‰²æŒ‚è½½çš„åˆ†ç±»IDï¼ˆç”¨äºé™åˆ¶å‘é€ï¼‰
    let mountedIds = [];
    if (currentChatCharId) {
        const char = await db.characters.get(currentChatCharId);
        mountedIds = char.mounted_sticker_categories || [];
    }
    
    // è¿‡æ»¤å‡ºæœ‰è¡¨æƒ…åŒ…çš„åˆ†ç±»
    const validCategories = allCategories.filter(cat => cat.stickers && cat.stickers.length > 0);
    
    if (validCategories.length === 0) {
        tabsContainer.innerHTML = '';
        contentContainer.innerHTML = `<div style="text-align:center; grid-column:span 4; color:#999; margin-top:20px;">æš‚æ— è¡¨æƒ…åŒ…<br>è¯·å»ã€æˆ‘-è¡¨æƒ…ã€‘æ·»åŠ </div>`;
        return;
    }
    
    // å¦‚æœè¿˜æ²¡æœ‰é€‰ä¸­çš„åˆ†ç±»ï¼Œé»˜è®¤é€‰ä¸­ç¬¬ä¸€ä¸ª
    if (!currentActiveStickerCategoryId || !validCategories.find(c => c.id === currentActiveStickerCategoryId)) {
        currentActiveStickerCategoryId = validCategories[0].id;
    }
    
    // ç”Ÿæˆåˆ†ç±»æ ‡ç­¾
    let tabsHtml = '';
    for (const cat of validCategories) {
        const isActive = cat.id === currentActiveStickerCategoryId;
        const isMounted = mountedIds.includes(cat.id);
        const mountTag = isMounted ? 'âœ“' : '';
        tabsHtml += `
            <div class="sticker-category-tab ${isActive ? 'active' : ''}" onclick="switchStickerCategory(${cat.id})" style="
                flex-shrink: 0;
                padding: 10px 16px;
                font-size: 13px;
                color: ${isActive ? 'var(--ins-pink)' : '#666'};
                border-bottom: 2px solid ${isActive ? 'var(--ins-pink)' : 'transparent'};
                cursor: pointer;
                white-space: nowrap;
                transition: all 0.2s;
            ">
                ${cat.name} ${mountTag}
            </div>
        `;
    }
    tabsContainer.innerHTML = tabsHtml;
    
    // æ˜¾ç¤ºå½“å‰é€‰ä¸­åˆ†ç±»çš„è¡¨æƒ…åŒ…
    const currentCategory = validCategories.find(c => c.id === currentActiveStickerCategoryId);
    if (!currentCategory) return;
    
    let contentHtml = '';
    currentCategory.stickers.forEach(s => {
        const safeUrl = s.url.replace(/'/g, "\\'").replace(/"/g, '&quot;');
        const safeDesc = (s.description || '').replace(/'/g, "\\'").replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        contentHtml += `<div class="emoji-item" onclick="sendGlobalSticker(${currentCategory.id}, '${safeUrl}')" style="display:flex; flex-direction:column; align-items:center; gap:4px; cursor:pointer;">
            <img src="${s.url}" style="width:60px; height:60px; border-radius:8px; object-fit:cover;" onerror="this.onerror=null; this.style.cssText='width:60px; height:60px; display:flex; align-items:center; justify-content:center; background:#f5f5f5; border-radius:8px;'; this.outerHTML='<div style=\\'width:60px; height:60px; display:flex; align-items:center; justify-content:center; background:#f5f5f5; border-radius:8px; color:#ccc; font-size:10px;\\'>å¤±è´¥</div>';" />
            ${safeDesc ? `<div style="font-size:10px; color:#999; text-align:center; max-width:60px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${safeDesc}</div>` : ''}
        </div>`;
    });
    
    contentContainer.innerHTML = contentHtml;
}

// åˆ‡æ¢è¡¨æƒ…åŒ…åˆ†ç±»
async function switchStickerCategory(categoryId) {
    currentActiveStickerCategoryId = categoryId;
    // æ¸…ç©ºæœç´¢æ¡†
    const searchInput = document.getElementById('sticker-search-input');
    if (searchInput) searchInput.value = '';
    await updateChatStickerPanel();
}

// æœç´¢è¡¨æƒ…åŒ…
async function searchStickers(keyword) {
    const contentContainer = document.getElementById('sticker-content');
    const tabsContainer = document.getElementById('sticker-category-tabs');
    if (!contentContainer) return;
    
    keyword = keyword.trim().toLowerCase();
    
    // å¦‚æœæœç´¢ä¸ºç©ºï¼Œæ¢å¤æ­£å¸¸æ˜¾ç¤º
    if (!keyword) {
        if (tabsContainer) tabsContainer.style.display = 'flex';
        await updateChatStickerPanel();
        return;
    }
    
    // éšè—åˆ†ç±»æ ‡ç­¾
    if (tabsContainer) tabsContainer.style.display = 'none';
    
    // è·å–æ‰€æœ‰è¡¨æƒ…åŒ…åˆ†ç±»
    const allCategories = await db.sticker_categories.toArray();
    
    // æœç´¢åŒ¹é…çš„è¡¨æƒ…åŒ…
    let matchedStickers = [];
    for (const cat of allCategories) {
        if (cat.stickers && cat.stickers.length > 0) {
            cat.stickers.forEach(s => {
                if (s.description && s.description.toLowerCase().includes(keyword)) {
                    matchedStickers.push({
                        ...s,
                        categoryId: cat.id,
                        categoryName: cat.name
                    });
                }
            });
        }
    }
    
    // æ˜¾ç¤ºæœç´¢ç»“æœ
    if (matchedStickers.length === 0) {
        contentContainer.innerHTML = `<div style="text-align:center; grid-column:span 4; color:#999; margin-top:20px;">æœªæ‰¾åˆ°ç›¸å…³è¡¨æƒ…åŒ…</div>`;
        return;
    }
    
    let contentHtml = '';
    matchedStickers.forEach(s => {
        const safeUrl = s.url.replace(/'/g, "\\'").replace(/"/g, '&quot;');
        const safeDesc = (s.description || '').replace(/'/g, "\\'").replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        contentHtml += `<div class="emoji-item" onclick="sendGlobalSticker(${s.categoryId}, '${safeUrl}')" style="display:flex; flex-direction:column; align-items:center; gap:4px; cursor:pointer;">
            <img src="${s.url}" style="width:60px; height:60px; border-radius:8px; object-fit:cover;" onerror="this.onerror=null; this.style.cssText='width:60px; height:60px; display:flex; align-items:center; justify-content:center; background:#f5f5f5; border-radius:8px;'; this.outerHTML='<div style=\\'width:60px; height:60px; display:flex; align-items:center; justify-content:center; background:#f5f5f5; border-radius:8px; color:#ccc; font-size:10px;\\'>å¤±è´¥</div>';" />
            ${safeDesc ? `<div style="font-size:10px; color:#999; text-align:center; max-width:60px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${safeDesc}</div>` : ''}
        </div>`;
    });
    
    contentContainer.innerHTML = contentHtml;
}

// æ™ºèƒ½è¡¨æƒ…æ¨èï¼ˆåœ¨è¾“å…¥æ¡†è¾“å…¥æ—¶è§¦å‘ï¼‰
let stickerSuggestionDebounce = null;
async function detectAndSuggestStickers(inputText) {
    const suggestionBar = document.getElementById('sticker-suggestion-bar');
    if (!suggestionBar) return;
    
    // æ¸…é™¤ä¹‹å‰çš„é˜²æŠ–
    if (stickerSuggestionDebounce) {
        clearTimeout(stickerSuggestionDebounce);
    }
    
    // é˜²æŠ–ï¼š300ms åæ‰§è¡Œ
    stickerSuggestionDebounce = setTimeout(async () => {
        const text = inputText.trim().toLowerCase();
        
        // å¦‚æœè¾“å…¥ä¸ºç©ºæˆ–å¤ªçŸ­ï¼Œéšè—æ¨èæ 
        if (!text || text.length < 2) {
            suggestionBar.style.display = 'none';
            return;
        }
        
        // è·å–æ‰€æœ‰è¡¨æƒ…åŒ…
        const allCategories = await db.sticker_categories.toArray();
        
        // æŸ¥æ‰¾åŒ¹é…çš„è¡¨æƒ…åŒ…ï¼ˆæœ€å¤šæ˜¾ç¤º 8 ä¸ªï¼‰
        let matchedStickers = [];
        for (const cat of allCategories) {
            if (cat.stickers && cat.stickers.length > 0) {
                for (const s of cat.stickers) {
                    if (s.description && s.description.toLowerCase().includes(text)) {
                        matchedStickers.push({
                            ...s,
                            categoryId: cat.id
                        });
                        if (matchedStickers.length >= 8) break;
                    }
                }
                if (matchedStickers.length >= 8) break;
            }
        }
        
        // å¦‚æœæ²¡æœ‰åŒ¹é…çš„ï¼Œéšè—æ¨èæ 
        if (matchedStickers.length === 0) {
            suggestionBar.style.display = 'none';
            return;
        }
        
        // æ˜¾ç¤ºæ¨èçš„è¡¨æƒ…åŒ…
        let html = '';
        matchedStickers.forEach(s => {
            const safeUrl = s.url.replace(/'/g, "\\'").replace(/"/g, '&quot;');
            html += `<div onclick="sendSuggestedSticker(${s.categoryId}, '${safeUrl}')" style="
                display: inline-flex;
                flex-direction: column;
                align-items: center;
                margin-right: 8px;
                cursor: pointer;
                vertical-align: top;
            ">
                <img src="${s.url}" style="width:50px; height:50px; border-radius:8px; object-fit:cover; border: 2px solid transparent; transition: border-color 0.2s;" onmouseover="this.style.borderColor='var(--ins-pink)'" onmouseout="this.style.borderColor='transparent'" onerror="this.onerror=null; this.style.cssText='width:50px; height:50px; display:flex; align-items:center; justify-content:center; background:#f5f5f5; border-radius:8px;'; this.outerHTML='<div style=\\'width:50px; height:50px; display:flex; align-items:center; justify-content:center; background:#f5f5f5; border-radius:8px; color:#ccc; font-size:9px;\\'>å¤±è´¥</div>';" />
            </div>`;
        });
        
        suggestionBar.innerHTML = html;
        suggestionBar.style.display = 'block';
    }, 300);
}

// å‘é€æ¨èçš„è¡¨æƒ…åŒ…
async function sendSuggestedSticker(catId, url) {
    // æ¸…ç©ºè¾“å…¥æ¡†
    const inputBox = document.getElementById('chat-input-box');
    if (inputBox) inputBox.value = '';
    
    // éšè—æ¨èæ 
    const suggestionBar = document.getElementById('sticker-suggestion-bar');
    if (suggestionBar) suggestionBar.style.display = 'none';
    
    // éšè—å‘é€æŒ‰é’®ï¼Œæ˜¾ç¤ºæ›´å¤šæŒ‰é’®
    const btnSend = document.getElementById('btn-send');
    const btnMore = document.getElementById('btn-more');
    if (btnSend) btnSend.style.display = 'none';
    if (btnMore) btnMore.style.display = 'flex';
    
    // å‘é€è¡¨æƒ…åŒ…
    await sendGlobalSticker(catId, url);
}

async function sendGlobalSticker(catId, url) {
    // ç”¨æˆ·å‘é€è¡¨æƒ…åŒ…ï¼šå¯ä»¥å‘é€æ‰€æœ‰è¡¨æƒ…åŒ…ï¼Œä¸éœ€è¦æ£€æŸ¥æŒ‚è½½
    // è§’è‰²å‘é€è¡¨æƒ…åŒ…ï¼šåªèƒ½å‘é€æŒ‚è½½çš„ï¼ˆè¿™ä¸ªé™åˆ¶åœ¨è§’è‰²è‡ªåŠ¨å›å¤æ—¶æ£€æŸ¥ï¼‰
    
    const msgContent = `[img:${url}]`; // å›¾ç‰‡æ˜¾ç¤ºå†…å®¹
    
    // âœ… æ”¯æŒç¾¤èŠæ¨¡å¼ï¼šå’Œç§èŠä¸€æ ·ï¼Œè¿½åŠ æ¶ˆæ¯åˆ°UIå³å¯
    if (window.currentGroupChatId) {
        const group = await db.group_chats.get(window.currentGroupChatId);
        if (!group) return;
        
        if (!group.chat_history) group.chat_history = [];
        const msg = {
            role: 'user',
            content: msgContent,
            time: Date.now()
        };
        group.chat_history.push(msg);
        group.updated_at = Date.now();
        await db.group_chats.put(group);
        
        await appendUserGroupMessageToUI(msg, group);
        closeChatPanel();
        return;
    }
    
    if (!currentChatCharId) {
        alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠå¤©å¯¹è±¡');
        return;
    }
    
    let char = await db.characters.get(currentChatCharId);
    const accountId = getCurrentAccountId();
    
    // æŸ¥æ‰¾æè¿°
    let desc = '';
    const cat = await db.sticker_categories.get(catId);
    if (cat) {
        const s = cat.stickers.find(sticker => sticker.url === url);
        if (s) desc = s.description;
    }
    
    // å‘é€æ¶ˆæ¯ - ä½¿ç”¨æŒ‰è´¦å·éš”ç¦»çš„èŠå¤©è®°å½•
    let history = getChatHistory(char, accountId);
    
    history.push({
        role: 'user',
        content: msgContent,
        imageDescription: desc, // æ–°å¢å­—æ®µï¼šå›¾ç‰‡æè¿°
        time: Date.now()
    });
    
    await setChatHistory(char, accountId, history);
    appendMessageToUI('user', msgContent);
    closeChatPanel();
    
    // âœ… å¦‚æœæ˜¯è”æœºå¥½å‹ï¼Œå‘é€è¡¨æƒ…åŒ…åˆ°æœåŠ¡å™¨
    if (char.isOnlineFriend && char.onlineData?.wx_account) {
        const onlineUserChar = await getOrCreateOnlineUserChar();
        
        if (onlineUserChar && onlineConnected) {
            const fromWxAccount = onlineUserChar.identity.account;
            const toWxAccount = char.onlineData.wx_account;
            const sent = sendOnlineMessage(toWxAccount, msgContent, fromWxAccount);
            if (sent) {
                console.log('[Online] è¡¨æƒ…åŒ…å·²å‘é€åˆ°æœåŠ¡å™¨:', url);
            } else {
                console.warn('[Online] è¡¨æƒ…åŒ…å‘é€å¤±è´¥');
                showToast('è¡¨æƒ…åŒ…å‘é€å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨è¿æ¥');
            }
        } else {
            console.warn('[Online] æ— æ³•å‘é€è”æœºè¡¨æƒ…åŒ…ï¼šæœªè¿æ¥æœåŠ¡å™¨');
            showToast('è¯·ç¡®ä¿å·²è¿æ¥æœåŠ¡å™¨');
        }
    }
    
    // âœ… ä¸å†è‡ªåŠ¨è§¦å‘ AI å›å¤ï¼Œéœ€è¦ç”¨æˆ·ç‚¹å‡»"æ¥å—å›å¤"æŒ‰é’®
    // triggerAiReply();
}

// --- æ¡Œé¢å›¾æ ‡æ‹–æ‹½é€»è¾‘ ---
let desktopSortable = null;

function initDesktopDrag() {
    const grid = document.getElementById('app-grid');
    if (!grid) return;

    // æ£€æµ‹æ˜¯å¦æ˜¯ç§»åŠ¨è®¾å¤‡
    const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

    desktopSortable = new Sortable(grid, {
        animation: 350, // åŠ¨ç”»æ—¶é•¿ï¼Œæ¯«ç§’ - ç¨æ…¢ä¸€ç‚¹æ›´åƒiOS
        delay: isTouchDevice ? 150 : 0, // è§¦æ‘¸è®¾å¤‡é•¿æŒ‰150msè§¦å‘ï¼ˆä¼˜åŒ–ï¼šä»300msç¼©çŸ­åˆ°150msï¼Œæ›´çµæ•ï¼‰
        delayOnTouchOnly: true, // ä»…åœ¨è§¦æ‘¸æ—¶å¯ç”¨å»¶è¿Ÿ
        touchStartThreshold: 8, // æ‰‹æŒ‡ç§»åŠ¨è¶…è¿‡8pxå–æ¶ˆé•¿æŒ‰åˆ¤å®šï¼ˆä¼˜åŒ–ï¼šä»5pxå¢åŠ åˆ°8pxï¼Œå‡å°‘è¯¯è§¦å–æ¶ˆï¼‰
        
        // å…³é”®ï¼šä½¿ç”¨éåŸç”Ÿæ‹–æ‹½ï¼Œå®ç°æ›´ä¸æ»‘çš„ JS æ¨¡æ‹Ÿæ•ˆæœ
        forceFallback: true, 
        fallbackTolerance: 3, // é¼ æ ‡æŒ‰ä¸‹ç§»åŠ¨3pxæ‰ç®—æ‹–æ‹½
        fallbackOnBody: true, // å°†æ‹–æ‹½å…ƒç´ è¿½åŠ åˆ° bodyï¼Œé¿å… overflow é—®é¢˜
        
        ghostClass: 'sortable-ghost', // å ä½ç¬¦æ ·å¼ç±» (æ‹–æ‹½åŸä½ç½®çš„è™šå½±)
        dragClass: 'sortable-drag',   // æ‹–æ‹½ä¸­å…ƒç´ æ ·å¼ç±» (è·Ÿéšé¼ æ ‡çš„é‚£ä¸ª)
        chosenClass: 'sortable-chosen', // é€‰ä¸­é¡¹æ ·å¼
        
        easing: "cubic-bezier(0.2, 0.8, 0.2, 1)", // iOS é£æ ¼ç¼“åŠ¨

        // æ»šåŠ¨é…ç½®ä¼˜åŒ–
        scroll: true, 
        scrollSensitivity: 60, // è·ç¦»è¾¹ç¼˜å¤šå°‘åƒç´ å¼€å§‹æ»šåŠ¨
        scrollSpeed: 15, // æ»šåŠ¨é€Ÿåº¦
        
        onStart: function (evt) {
            // éœ‡åŠ¨åé¦ˆ
            if (navigator.vibrate) navigator.vibrate(50);
            // æ‹–æ‹½å¼€å§‹æ—¶ï¼Œç»™ body æ·»åŠ ç±»ä»¥ä¾¿æ§åˆ¶å…¨å±€å…‰æ ‡
            document.body.classList.add('dragging-mode');
        },
        onEnd: function (evt) {
            saveDesktopOrder();
            document.body.classList.remove('dragging-mode');
        }
    });
}

async function saveDesktopOrder() {
    const grid = document.getElementById('app-grid');
    // è·å–å½“å‰é¡ºåºçš„æ‰€æœ‰å­å…ƒç´ ID
    const order = Array.from(grid.children)
        .map(child => child.id)
        .filter(id => id); // è¿‡æ»¤æ‰æ²¡æœ‰IDçš„å…ƒç´ 
    
    // ä¿å­˜åˆ° Dexie
    try {
        await db.dexiData.put({ key: 'desktopOrder', value: JSON.stringify(order) });
        console.log('[Desktop] Order saved');
    } catch (e) {
        console.error('[Desktop] Failed to save order', e);
    }
}

async function restoreDesktopOrder() {
    try {
        const record = await db.dexiData.get('desktopOrder');
        if (!record || !record.value) return;
        
        const order = JSON.parse(record.value);
        const grid = document.getElementById('app-grid');
        if (!grid) return;
        
        // åˆ›å»ºç°æœ‰å…ƒç´ çš„æ˜ å°„
        const elements = {};
        Array.from(grid.children).forEach(el => {
            if (el.id) elements[el.id] = el;
        });
        
        // åˆ›å»ºæ–‡æ¡£ç‰‡æ®µä»¥ä¼˜åŒ–æ€§èƒ½
        const fragment = document.createDocumentFragment();
        
        // æŒ‰ä¿å­˜çš„é¡ºåºé‡æ–°æ·»åŠ 
        order.forEach(id => {
            const el = elements[id];
            if (el) {
                fragment.appendChild(el);
                delete elements[id]; // æ ‡è®°å·²å¤„ç†
            }
        });
        
        // æ·»åŠ å‰©ä½™çš„å…ƒç´ ï¼ˆå¦‚æœæœ‰æ–°å¢çš„å›¾æ ‡ï¼‰
        Object.values(elements).forEach(el => {
            fragment.appendChild(el);
        });
        
        grid.appendChild(fragment);
        console.log('[Desktop] Order restored');
    } catch (e) {
        console.error('[Desktop] Failed to restore desktop order', e);
    }
}

/* =================
   æœåŠ¡é¡µé¢é€»è¾‘ (ä¼˜åŒ–åŠ¨ç”»ç‰ˆ)
   ================= */

function showServicePage() {
    const page = document.getElementById('service-main-page');
    page.style.display = 'flex';
    page.offsetHeight; 
    page.classList.add('slide-in');
}

function hideServicePage() {
    const page = document.getElementById('service-main-page');
    page.classList.remove('slide-in');
}

// =================
//  æ‰‹æœºå……å€¼åŠŸèƒ½
// =================

// ç”Ÿæˆè™šæ‹Ÿç”µè¯å·ç ï¼ˆå…¨å±€å‡½æ•°ï¼‰
function generateVirtualPhoneNumber(id) {
    // ç®€å•å“ˆå¸Œç”Ÿæˆä¸€ä¸ªä¼ªå·ç 
    let hash = 0;
    for (let i = 0; i < String(id).length; i++) {
        hash = (hash << 5) - hash + String(id).charCodeAt(i);
        hash |= 0;
    }
    return '13' + Math.abs(hash).toString().substring(0, 9).padEnd(9, '0');
}

// ä½™é¢ç®¡ç†
function getPhoneBalance() {
    const balance = localStorage.getItem('phone_balance');
    return balance ? parseFloat(balance) : 50.0; // é»˜è®¤50å…ƒ
}

function setPhoneBalance(amount) {
    localStorage.setItem('phone_balance', amount.toFixed(2));
}

function addPhoneBalance(amount) {
    const current = getPhoneBalance();
    setPhoneBalance(current + amount);
    return getPhoneBalance();
}

function deductPhoneBalance(amount) {
    const current = getPhoneBalance();
    if (current < amount) {
        return false; // ä½™é¢ä¸è¶³
    }
    setPhoneBalance(current - amount);
    return true;
}

// æ˜¾ç¤ºæ”¯ä»˜æ–¹å¼é€‰æ‹©å¼¹çª—ï¼ˆä½™é¢ or äº²å±å¡ï¼‰
async function showPaymentMethodSelection(amount, description) {
    return new Promise(async (resolve) => {
        const accountId = getCurrentAccountId();
        if (!accountId) {
            resolve({ success: false, method: null });
            return;
        }
        
        // è·å–å¯ç”¨çš„äº²å±å¡
        const user = await db.characters.get(parseInt(accountId));
        const familyCards = user?.identity?.familyCardsReceived || [];
        
        // è·å–è”æœºå¥½å‹çš„äº²å±å¡
        let onlineFamilyCards = [];
        if (onlineConnected && onlineSocket) {
            const onlineUserChar = await getOrCreateOnlineUserChar();
            if (onlineUserChar) {
                const myWxAccount = onlineUserChar.identity.account;
                // ä»æœåŠ¡å™¨è·å–äº²å±å¡åˆ—è¡¨ï¼ˆè¿™é‡Œæˆ‘ä»¬éœ€è¦å…ˆå®ç°åŒæ­¥è·å–ï¼‰
                // æš‚æ—¶ä»æœ¬åœ°ç¼“å­˜è·å–
                onlineFamilyCards = JSON.parse(localStorage.getItem('online_family_cards_received') || '[]');
            }
        }
        
        const allFamilyCards = [...familyCards, ...onlineFamilyCards];
        
        // å¦‚æœæ²¡æœ‰äº²å±å¡ï¼Œç›´æ¥ä½¿ç”¨ä½™é¢
        if (allFamilyCards.length === 0) {
            const success = deductPhoneBalance(amount);
            resolve({ success, method: 'balance' });
            return;
        }
        
        // åˆ›å»ºé€‰æ‹©å¼¹çª—
        const modal = document.createElement('div');
        modal.className = 'payment-method-modal';
        modal.innerHTML = `
            <div class="payment-method-overlay"></div>
            <div class="payment-method-content">
                <div class="payment-method-header">
                    <span>é€‰æ‹©æ”¯ä»˜æ–¹å¼</span>
                    <span class="payment-method-amount">Â¥${amount.toFixed(2)}</span>
                </div>
                <div class="payment-method-desc">${description || 'æ¶ˆè´¹'}</div>
                <div class="payment-method-list">
                    <div class="payment-method-item" data-method="balance">
                        <div class="payment-method-icon">ğŸ’°</div>
                        <div class="payment-method-name">
                            <div>é›¶é’±</div>
                            <div class="payment-method-sub">ä½™é¢: Â¥${getPhoneBalance().toFixed(2)}</div>
                        </div>
                        <div class="payment-method-radio"></div>
                    </div>
                    ${allFamilyCards.map((card, index) => {
                        const isOnline = card.from_wx_account !== undefined;
                        const cardName = isOnline ? 'è”æœºå¥½å‹äº²å±å¡' : 'äº²å±å¡';
                        const monthlyLimit = isOnline ? card.monthly_limit : card.monthlyLimit;
                        const usedThisMonth = isOnline ? card.used_this_month : card.usedThisMonth;
                        const limitText = monthlyLimit > 0 ? `æœ¬æœˆå‰©ä½™: Â¥${(monthlyLimit - usedThisMonth).toFixed(2)}` : 'ä¸é™é¢åº¦';
                        
                        return `
                            <div class="payment-method-item" data-method="family_card" data-card-index="${index}" data-is-online="${isOnline}">
                                <div class="payment-method-icon">ğŸ’³</div>
                                <div class="payment-method-name">
                                    <div>${cardName}</div>
                                    <div class="payment-method-sub">${limitText}</div>
                                </div>
                                <div class="payment-method-radio"></div>
                            </div>
                        `;
                    }).join('')}
                </div>
                <div class="payment-method-buttons">
                    <button class="payment-method-cancel">å–æ¶ˆ</button>
                    <button class="payment-method-confirm">ç¡®è®¤æ”¯ä»˜</button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        let selectedMethod = 'balance';
        let selectedCardIndex = -1;
        let selectedIsOnline = false;
        
        // é»˜è®¤é€‰ä¸­ä½™é¢
        modal.querySelector('[data-method="balance"] .payment-method-radio').classList.add('selected');
        
        // é€‰æ‹©æ”¯ä»˜æ–¹å¼
        modal.querySelectorAll('.payment-method-item').forEach(item => {
            item.addEventListener('click', () => {
                modal.querySelectorAll('.payment-method-radio').forEach(r => r.classList.remove('selected'));
                item.querySelector('.payment-method-radio').classList.add('selected');
                selectedMethod = item.dataset.method;
                selectedCardIndex = parseInt(item.dataset.cardIndex) || -1;
                selectedIsOnline = item.dataset.isOnline === 'true';
            });
        });
        
        // å–æ¶ˆæŒ‰é’®
        modal.querySelector('.payment-method-cancel').addEventListener('click', () => {
            document.body.removeChild(modal);
            resolve({ success: false, method: null });
        });
        
        // ç¡®è®¤æ”¯ä»˜æŒ‰é’®
        modal.querySelector('.payment-method-confirm').addEventListener('click', async () => {
            document.body.removeChild(modal);
            
            if (selectedMethod === 'balance') {
                const success = deductPhoneBalance(amount);
                resolve({ success, method: 'balance' });
            } else if (selectedMethod === 'family_card' && selectedCardIndex >= 0) {
                const card = allFamilyCards[selectedCardIndex];
                
                if (selectedIsOnline) {
                    // ä½¿ç”¨è”æœºäº²å±å¡
                    const onlineUserChar = await getOrCreateOnlineUserChar();
                    if (onlineUserChar && onlineConnected) {
                        onlineSocket.send(JSON.stringify({
                            type: 'use_family_card',
                            my_wx_account: onlineUserChar.identity.account,
                            payer_wx_account: card.from_wx_account,
                            amount: amount,
                            description: description || 'æ¶ˆè´¹'
                        }));
                        // ç­‰å¾…æœåŠ¡å™¨å“åº”ï¼ˆæš‚æ—¶å‡è®¾æˆåŠŸï¼‰
                        showToast('äº²å±å¡æ”¯ä»˜ä¸­...');
                        resolve({ success: true, method: 'family_card', isOnline: true });
                    } else {
                        showToast('æœªè¿æ¥æœåŠ¡å™¨');
                        resolve({ success: false, method: null });
                    }
                } else {
                    // ä½¿ç”¨æœ¬åœ°äº²å±å¡
                    const monthlyLimit = card.monthlyLimit || 0;
                    const usedThisMonth = card.usedThisMonth || 0;
                    
                    // æ£€æŸ¥é¢åº¦
                    if (monthlyLimit > 0 && (usedThisMonth + amount) > monthlyLimit) {
                        showToast('äº²å±å¡æœ¬æœˆé¢åº¦ä¸è¶³');
                        resolve({ success: false, method: null });
                        return;
                    }
                    
                    // æ›´æ–°ä½¿ç”¨é‡‘é¢
                    card.usedThisMonth = (usedThisMonth || 0) + amount;
                    if (!card.records) card.records = [];
                    card.records.push({
                        amount: amount,
                        description: description || 'æ¶ˆè´¹',
                        time: Date.now()
                    });
                    
                    // ä¿å­˜åˆ°ç”¨æˆ·æ•°æ®
                    await db.characters.put(user);
                    
                    // é€šçŸ¥ä»˜æ¬¾æ–¹ï¼ˆè§’è‰²ï¼‰
                    const payerChar = await db.characters.get(card.charId);
                    if (payerChar) {
                        // å‘é€æ¶ˆæ¯é€šçŸ¥
                        showToast('äº²å±å¡æ”¯ä»˜æˆåŠŸ');
                    }
                    
                    resolve({ success: true, method: 'family_card', isOnline: false });
                }
            }
        });
    });
}

// å……å€¼è®°å½•ç®¡ç†
function getRechargeHistory() {
    return JSON.parse(localStorage.getItem('phone_recharge_history') || '[]');
}

function addRechargeRecord(amount) {
    const history = getRechargeHistory();
    history.unshift({
        amount: amount,
        time: Date.now(),
        date: new Date().toLocaleString('zh-CN')
    });
    // åªä¿ç•™æœ€è¿‘20æ¡
    if (history.length > 20) {
        history.pop();
    }
    localStorage.setItem('phone_recharge_history', JSON.stringify(history));
}

// æ˜¾ç¤ºå……å€¼é¡µé¢
async function showPhoneRechargePage() {
    const page = document.getElementById('phone-recharge-page');
    page.style.display = 'flex';
    page.offsetHeight;
    page.classList.add('slide-in');
    
    // è·å–å½“å‰è´¦å·çš„æ‰‹æœºå·
    const accountId = getCurrentAccountId();
    let phoneNumber = 'æœªç»‘å®š';
    if (accountId) {
        const myChar = await db.characters.get(parseInt(accountId));
        if (myChar) {
            phoneNumber = myChar.identity?.phone || generateVirtualPhoneNumber(myChar.id);
        }
    }
    
    // æ›´æ–°é¡µé¢ä¿¡æ¯
    document.getElementById('recharge-phone-number').textContent = phoneNumber;
    updateRechargePage();
}

function hidePhoneRechargePage() {
    const page = document.getElementById('phone-recharge-page');
    page.classList.remove('slide-in');
    setTimeout(() => {
        page.style.display = 'none';
    }, 300);
}

// æ›´æ–°å……å€¼é¡µé¢æ˜¾ç¤º
function updateRechargePage() {
    const balance = getPhoneBalance();
    document.getElementById('recharge-balance').textContent = `Â¥${balance.toFixed(2)}`;
    
    // æ›´æ–°å……å€¼è®°å½•
    const history = getRechargeHistory();
    const historyEl = document.getElementById('recharge-history');
    if (history.length === 0) {
        historyEl.textContent = 'æš‚æ— å……å€¼è®°å½•';
        historyEl.style.color = '#999';
    } else {
        historyEl.innerHTML = history.slice(0, 5).map(record => 
            `<div style="display:flex; justify-content:space-between; padding:8px 0; border-bottom:1px solid #f5f5f5;">
                <span>å……å€¼ Â¥${record.amount.toFixed(2)}</span>
                <span style="color:#999; font-size:12px;">${record.date}</span>
            </div>`
        ).join('');
        historyEl.style.color = '#333';
    }
}

// é€‰æ‹©å……å€¼é‡‘é¢
let selectedRechargeAmount = 0;

function selectRechargeAmount(amount) {
    selectedRechargeAmount = amount;
    
    // æ›´æ–°æŒ‰é’®æ ·å¼
    document.querySelectorAll('.recharge-amount-btn').forEach(btn => {
        btn.classList.remove('selected');
        if (parseFloat(btn.dataset.amount) === amount) {
            btn.classList.add('selected');
        }
    });
    
    // å¯ç”¨å……å€¼æŒ‰é’®
    const submitBtn = document.getElementById('recharge-submit-btn');
    submitBtn.disabled = false;
    submitBtn.style.opacity = '1';
    submitBtn.style.cursor = 'pointer';
    submitBtn.textContent = `å……å€¼ Â¥${amount.toFixed(2)}`;
}

// æäº¤å……å€¼
function submitRecharge() {
    if (selectedRechargeAmount <= 0) {
        alert('è¯·é€‰æ‹©å……å€¼é‡‘é¢');
        return;
    }
    
    if (!confirm(`ç¡®è®¤å……å€¼ Â¥${selectedRechargeAmount.toFixed(2)} å—ï¼Ÿ`)) {
        return;
    }
    
    // å¢åŠ ä½™é¢
    const newBalance = addPhoneBalance(selectedRechargeAmount);
    
    // æ·»åŠ å……å€¼è®°å½•
    addRechargeRecord(selectedRechargeAmount);
    
    // æ›´æ–°é¡µé¢
    updateRechargePage();
    
    // é‡ç½®é€‰æ‹©
    selectedRechargeAmount = 0;
    document.querySelectorAll('.recharge-amount-btn').forEach(btn => {
        btn.classList.remove('selected');
    });
    const submitBtn = document.getElementById('recharge-submit-btn');
    submitBtn.disabled = true;
    submitBtn.style.opacity = '0.5';
    submitBtn.style.cursor = 'not-allowed';
    submitBtn.textContent = 'è¯·é€‰æ‹©å……å€¼é‡‘é¢';
    
    alert(`å……å€¼æˆåŠŸï¼å½“å‰ä½™é¢ï¼šÂ¥${newBalance.toFixed(2)}`);
}

// å¯¼å‡ºåˆ°å…¨å±€ä½œç”¨åŸŸ
window.showPhoneRechargePage = showPhoneRechargePage;
window.hidePhoneRechargePage = hidePhoneRechargePage;

// å€Ÿé’±é¡µé¢ç›¸å…³å‡½æ•°
let selectedLoanAmount = 0;
let selectedLoanTerm = 6;

function showLoanPage() {
    const page = document.getElementById('loan-page');
    page.style.display = 'flex';
    page.offsetHeight;
    page.classList.add('slide-in');
    
    // é‡ç½®é€‰æ‹©
    selectedLoanAmount = 0;
    selectedLoanTerm = 6;
    document.getElementById('loan-term-select').value = '6';
    document.getElementById('loan-custom-input').value = '';
    updateLoanButtons();
    updateLoanInfo();
    loadLoanHistory();
}

function hideLoanPage() {
    const page = document.getElementById('loan-page');
    page.classList.remove('slide-in');
    setTimeout(() => {
        page.style.display = 'none';
    }, 300);
}

function selectLoanAmount(amount) {
    selectedLoanAmount = amount;
    // æ¸…é™¤è‡ªå®šä¹‰è¾“å…¥
    document.getElementById('loan-custom-input').value = '';
    // æ›´æ–°æŒ‰é’®çŠ¶æ€
    updateLoanButtons();
    updateLoanInfo();
}

function handleCustomLoanAmount(value) {
    const amount = parseInt(value) || 0;
    if (amount >= 100 && amount <= 50000) {
        selectedLoanAmount = amount;
        // æ¸…é™¤é¢„è®¾æŒ‰é’®é€‰æ‹©
        document.querySelectorAll('.loan-amount-btn').forEach(btn => {
            btn.classList.remove('selected');
        });
        updateLoanInfo();
    } else {
        selectedLoanAmount = 0;
    }
    updateLoanButtons();
}

function updateLoanButtons() {
    const submitBtn = document.getElementById('loan-submit-btn');
    if (selectedLoanAmount > 0) {
        submitBtn.disabled = false;
        submitBtn.textContent = `ç«‹å³å€Ÿæ¬¾ Â¥${selectedLoanAmount.toLocaleString()}`;
    } else {
        submitBtn.disabled = true;
        submitBtn.textContent = 'è¯·é€‰æ‹©å€Ÿæ¬¾é‡‘é¢';
    }
}

function updateLoanInfo() {
    selectedLoanTerm = parseInt(document.getElementById('loan-term-select').value) || 6;
    
    if (selectedLoanAmount > 0) {
        // è®¡ç®—æ€»è¿˜æ¬¾é¢ï¼šæœ¬é‡‘ + åˆ©æ¯
        // æ—¥åˆ©ç‡ 0.05%ï¼Œæœˆåˆ©ç‡çº¦ 1.5%
        const monthlyRate = 0.015;
        const totalInterest = selectedLoanAmount * monthlyRate * selectedLoanTerm;
        const totalAmount = selectedLoanAmount + totalInterest;
        
        document.getElementById('loan-total-amount').textContent = `Â¥${totalAmount.toLocaleString('zh-CN', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
    } else {
        document.getElementById('loan-total-amount').textContent = 'Â¥0.00';
    }
}

async function submitLoan() {
    if (selectedLoanAmount <= 0) {
        return;
    }
    
    // è®¡ç®—è¿˜æ¬¾ä¿¡æ¯
    const monthlyRate = 0.015;
    const totalInterest = selectedLoanAmount * monthlyRate * selectedLoanTerm;
    const totalAmount = selectedLoanAmount + totalInterest;
    const monthlyPayment = totalAmount / selectedLoanTerm;
    
    // ç¡®è®¤å¯¹è¯æ¡†
    const confirmMsg = `ç¡®è®¤å€Ÿæ¬¾ä¿¡æ¯ï¼š\n\nå€Ÿæ¬¾é‡‘é¢ï¼šÂ¥${selectedLoanAmount.toLocaleString()}\nå€Ÿæ¬¾æœŸé™ï¼š${selectedLoanTerm}ä¸ªæœˆ\næ—¥åˆ©ç‡ï¼š0.05%\né¢„è®¡è¿˜æ¬¾æ€»é¢ï¼šÂ¥${totalAmount.toLocaleString('zh-CN', {minimumFractionDigits: 2, maximumFractionDigits: 2})}\næ¯æœˆè¿˜æ¬¾ï¼šÂ¥${monthlyPayment.toLocaleString('zh-CN', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
    
    if (confirm(confirmMsg)) {
        if (!currentMyCharId) {
            alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ª User èº«ä»½');
            return;
        }
        
        // æ·»åŠ å€Ÿæ¬¾é‡‘é¢åˆ°ä½™é¢
        const user = await db.characters.get(parseInt(currentMyCharId));
        if (!user) {
            alert('æœªæ‰¾åˆ°ç”¨æˆ·ä¿¡æ¯');
            return;
        }
        
        let userBalance = parseFloat(user.identity?.balance || 0);
        userBalance = userBalance + selectedLoanAmount;
        
        if (!user.identity) user.identity = {};
        user.identity.balance = userBalance.toFixed(2);
        await db.characters.put(user);
        
        // æ›´æ–°ä½™é¢æ˜¾ç¤º
        await updateBalancePageDisplay();
        await updateWalletBalanceDisplay();
        
        // ä¿å­˜å€Ÿæ¬¾è®°å½•åˆ°æœ¬åœ°å­˜å‚¨
        const now = Date.now();
        const dueTime = now + (selectedLoanTerm * 12 * 60 * 60 * 1000); // 1ä¸ªæœˆ=12å°æ—¶
        
        const loanRecord = {
            id: now,
            amount: selectedLoanAmount,
            term: selectedLoanTerm,
            totalAmount: totalAmount,
            monthlyPayment: monthlyPayment,
            date: new Date().toISOString(),
            dueTime: dueTime, // åˆ°æœŸæ—¶é—´æˆ³
            status: 'pending', // pending, repaid, overdue
            paidAmount: 0, // å·²è¿˜é‡‘é¢
            remainingAmount: totalAmount, // å‰©ä½™åº”è¿˜é‡‘é¢
            firstReminderSent: false, // ç¬¬ä¸€æ¬¡æé†’å·²å‘é€
            secondReminderSent: false, // ç¬¬äºŒæ¬¡æé†’å·²å‘é€
            userId: currentMyCharId // å€Ÿæ¬¾äººID
        };
        
        let loanHistory = JSON.parse(localStorage.getItem('loanHistory') || '[]');
        loanHistory.unshift(loanRecord);
        localStorage.setItem('loanHistory', JSON.stringify(loanHistory));
        
        // æ˜¾ç¤ºæˆåŠŸæç¤º
        alert(`å€Ÿæ¬¾æˆåŠŸ\n\nå€Ÿæ¬¾é‡‘é¢ï¼šÂ¥${selectedLoanAmount.toLocaleString()}\nå·²æ·»åŠ åˆ°é’±åŒ…ä½™é¢`);
        
        // é‡ç½®é¡µé¢
        selectedLoanAmount = 0;
        document.getElementById('loan-custom-input').value = '';
        document.querySelectorAll('.loan-amount-btn').forEach(btn => {
            btn.classList.remove('selected');
        });
        updateLoanButtons();
        updateLoanInfo();
        loadLoanHistory();
    }
}

function loadLoanHistory() {
    const historyList = document.getElementById('loan-history-list');
    const loanHistory = JSON.parse(localStorage.getItem('loanHistory') || '[]');
    
    if (loanHistory.length === 0) {
        historyList.innerHTML = '<div class="loan-empty-state">æš‚æ— å€Ÿæ¬¾è®°å½•</div>';
        return;
    }
    
    historyList.innerHTML = loanHistory.map(record => {
        const date = new Date(record.date);
        const dateStr = date.toLocaleDateString('zh-CN', { year: 'numeric', month: '2-digit', day: '2-digit' });
        const statusText = {
            'pending': 'å¾…è¿˜æ¬¾',
            'repaid': 'å·²è¿˜æ¸…',
            'overdue': 'å·²é€¾æœŸ'
        };
        
        const remainingAmount = record.remainingAmount !== undefined ? record.remainingAmount : record.totalAmount;
        const paidAmount = record.paidAmount || 0;
        
        return `
            <div class="loan-history-item" onclick="showRepayPage(${record.id})" style="cursor: pointer;">
                <div class="loan-history-info">
                    <div class="loan-history-amount">Â¥${record.amount.toLocaleString()}</div>
                    <div class="loan-history-date">${dateStr} Â· ${record.term}ä¸ªæœˆ</div>
                    ${record.status === 'pending' ? `<div style="font-size: 12px; color: #999; margin-top: 4px;">å‰©ä½™åº”è¿˜ï¼šÂ¥${remainingAmount.toFixed(2)}</div>` : ''}
                </div>
                <div style="display: flex; flex-direction: column; align-items: flex-end; gap: 8px;">
                    <div class="loan-history-status ${record.status}">${statusText[record.status]}</div>
                    ${record.status === 'pending' ? '<div class="loan-repay-btn-small">è¿˜æ¬¾</div>' : ''}
                </div>
            </div>
        `;
    }).join('');
}

// åˆå§‹åŒ–å€Ÿæ¬¾é‡‘é¢æŒ‰é’®ç‚¹å‡»äº‹ä»¶
document.addEventListener('DOMContentLoaded', function() {
    // ä¸ºé¢„è®¾é‡‘é¢æŒ‰é’®æ·»åŠ é€‰ä¸­çŠ¶æ€åˆ‡æ¢
    document.querySelectorAll('.loan-amount-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            document.querySelectorAll('.loan-amount-btn').forEach(b => b.classList.remove('selected'));
            this.classList.add('selected');
        });
    });
});

window.showLoanPage = showLoanPage;
window.hideLoanPage = hideLoanPage;
window.selectLoanAmount = selectLoanAmount;
window.handleCustomLoanAmount = handleCustomLoanAmount;
window.updateLoanInfo = updateLoanInfo;
window.submitLoan = submitLoan;

// =================
// è¿˜æ¬¾åŠŸèƒ½
// =================

let currentRepayLoanId = null;
let currentRepayLoan = null;
let selectedRepayAmount = 0;

// æ˜¾ç¤ºè¿˜æ¬¾é¡µé¢
async function showRepayPage(loanId) {
    const page = document.getElementById('repay-page');
    page.style.display = 'flex';
    page.offsetHeight;
    page.classList.add('slide-in');
    
    currentRepayLoanId = loanId;
    
    // åŠ è½½å€Ÿæ¬¾ä¿¡æ¯
    const loanHistory = JSON.parse(localStorage.getItem('loanHistory') || '[]');
    currentRepayLoan = loanHistory.find(loan => loan.id === loanId);
    
    if (!currentRepayLoan) {
        alert('æœªæ‰¾åˆ°å€Ÿæ¬¾è®°å½•');
        hideRepayPage();
        return;
    }
    
    // æ›´æ–°ä½™é¢æ˜¾ç¤º
    await updateRepayBalance();
    
    // æ›´æ–°é¡µé¢ä¿¡æ¯
    updateRepayPageInfo();
    
    // é‡ç½®é€‰æ‹©
    selectedRepayAmount = 0;
    document.getElementById('repay-custom-input').value = '';
    updateRepayButtons();
}

// éšè—è¿˜æ¬¾é¡µé¢
function hideRepayPage() {
    const page = document.getElementById('repay-page');
    page.classList.remove('slide-in');
    setTimeout(() => {
        page.style.display = 'none';
    }, 300);
    
    currentRepayLoanId = null;
    currentRepayLoan = null;
    selectedRepayAmount = 0;
}

// æ›´æ–°ä½™é¢æ˜¾ç¤º
async function updateRepayBalance() {
    if (!currentMyCharId) {
        document.getElementById('repay-current-balance').textContent = 'Â¥0.00';
        return;
    }
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    const balance = user?.identity?.balance || 0;
    document.getElementById('repay-current-balance').textContent = `Â¥${parseFloat(balance).toFixed(2)}`;
}

// æ›´æ–°è¿˜æ¬¾é¡µé¢ä¿¡æ¯
function updateRepayPageInfo() {
    if (!currentRepayLoan) return;
    
    const date = new Date(currentRepayLoan.date);
    const dateStr = date.toLocaleDateString('zh-CN', { year: 'numeric', month: '2-digit', day: '2-digit' });
    
    const remainingAmount = currentRepayLoan.remainingAmount !== undefined ? currentRepayLoan.remainingAmount : currentRepayLoan.totalAmount;
    const paidAmount = currentRepayLoan.paidAmount || 0;
    const monthlyPayment = currentRepayLoan.monthlyPayment || 0;
    
    document.getElementById('repay-loan-amount').textContent = `Â¥${currentRepayLoan.amount.toLocaleString()}`;
    document.getElementById('repay-loan-date').textContent = dateStr;
    document.getElementById('repay-loan-term').textContent = `${currentRepayLoan.term}ä¸ªæœˆ`;
    document.getElementById('repay-total-amount').textContent = `Â¥${currentRepayLoan.totalAmount.toFixed(2)}`;
    document.getElementById('repay-paid-amount').textContent = `Â¥${paidAmount.toFixed(2)}`;
    document.getElementById('repay-remaining-amount').textContent = `Â¥${remainingAmount.toFixed(2)}`;
    
    // æ›´æ–°è¿˜æ¬¾é€‰é¡¹
    document.getElementById('repay-monthly-value').textContent = `Â¥${monthlyPayment.toFixed(2)}`;
    document.getElementById('repay-half-value').textContent = `Â¥${(remainingAmount / 2).toFixed(2)}`;
    document.getElementById('repay-all-value').textContent = `Â¥${remainingAmount.toFixed(2)}`;
}

// é€‰æ‹©è¿˜æ¬¾é‡‘é¢
function selectRepayAmount(type) {
    if (!currentRepayLoan) return;
    
    const remainingAmount = currentRepayLoan.remainingAmount !== undefined ? currentRepayLoan.remainingAmount : currentRepayLoan.totalAmount;
    const monthlyPayment = currentRepayLoan.monthlyPayment || 0;
    
    // æ¸…é™¤è‡ªå®šä¹‰è¾“å…¥
    document.getElementById('repay-custom-input').value = '';
    
    // æ¸…é™¤å…¶ä»–æŒ‰é’®é€‰ä¸­çŠ¶æ€
    document.querySelectorAll('#repay-page .loan-amount-btn').forEach(btn => {
        btn.classList.remove('selected');
    });
    
    // è®¾ç½®é€‰ä¸­é‡‘é¢
    if (type === 'monthly') {
        selectedRepayAmount = Math.min(monthlyPayment, remainingAmount);
        event.target.closest('.loan-amount-btn').classList.add('selected');
    } else if (type === 'half') {
        selectedRepayAmount = remainingAmount / 2;
        event.target.closest('.loan-amount-btn').classList.add('selected');
    } else if (type === 'all') {
        selectedRepayAmount = remainingAmount;
        event.target.closest('.loan-amount-btn').classList.add('selected');
    }
    
    updateRepayButtons();
}

// å¤„ç†è‡ªå®šä¹‰è¿˜æ¬¾é‡‘é¢
function handleCustomRepayAmount(value) {
    const amount = parseFloat(value) || 0;
    const remainingAmount = currentRepayLoan.remainingAmount !== undefined ? currentRepayLoan.remainingAmount : currentRepayLoan.totalAmount;
    
    if (amount > 0 && amount <= remainingAmount) {
        selectedRepayAmount = amount;
        // æ¸…é™¤é¢„è®¾æŒ‰é’®é€‰æ‹©
        document.querySelectorAll('#repay-page .loan-amount-btn').forEach(btn => {
            btn.classList.remove('selected');
        });
    } else {
        selectedRepayAmount = 0;
    }
    updateRepayButtons();
}

// æ›´æ–°è¿˜æ¬¾æŒ‰é’®çŠ¶æ€
function updateRepayButtons() {
    const submitBtn = document.getElementById('repay-submit-btn');
    if (selectedRepayAmount > 0 && currentRepayLoan) {
        const remainingAmount = currentRepayLoan.remainingAmount !== undefined ? currentRepayLoan.remainingAmount : currentRepayLoan.totalAmount;
        if (selectedRepayAmount <= remainingAmount) {
            submitBtn.disabled = false;
            submitBtn.textContent = `ç¡®è®¤è¿˜æ¬¾ Â¥${selectedRepayAmount.toFixed(2)}`;
        } else {
            submitBtn.disabled = true;
            submitBtn.textContent = 'è¿˜æ¬¾é‡‘é¢ä¸èƒ½è¶…è¿‡å‰©ä½™åº”è¿˜';
        }
    } else {
        submitBtn.disabled = true;
        submitBtn.textContent = 'è¯·é€‰æ‹©è¿˜æ¬¾é‡‘é¢';
    }
}

// æäº¤è¿˜æ¬¾
async function submitRepay() {
    if (!currentMyCharId || !currentRepayLoan || selectedRepayAmount <= 0) {
        return;
    }
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    if (!user) {
        alert('æœªæ‰¾åˆ°ç”¨æˆ·ä¿¡æ¯');
        return;
    }
    
    const remainingAmount = currentRepayLoan.remainingAmount !== undefined ? currentRepayLoan.remainingAmount : currentRepayLoan.totalAmount;
    
    if (selectedRepayAmount > remainingAmount) {
        alert('è¿˜æ¬¾é‡‘é¢ä¸èƒ½è¶…è¿‡å‰©ä½™åº”è¿˜é‡‘é¢');
        return;
    }
    
    let userBalance = parseFloat(user.identity?.balance || 0);
    
    // æ£€æŸ¥ä½™é¢
    if (userBalance < selectedRepayAmount) {
        alert(`ä½™é¢ä¸è¶³\nå½“å‰ä½™é¢ï¼šÂ¥${userBalance.toFixed(2)}\néœ€è¦ï¼šÂ¥${selectedRepayAmount.toFixed(2)}`);
        return;
    }
    
    // ç¡®è®¤å¯¹è¯æ¡†
    const confirmMsg = `ç¡®è®¤è¿˜æ¬¾ä¿¡æ¯ï¼š\n\nè¿˜æ¬¾é‡‘é¢ï¼šÂ¥${selectedRepayAmount.toFixed(2)}\nå‰©ä½™åº”è¿˜ï¼šÂ¥${remainingAmount.toFixed(2)}\n\nç¡®è®¤è¿˜æ¬¾ï¼Ÿ`;
    
    if (confirm(confirmMsg)) {
        // æ‰£æ¬¾
        userBalance = userBalance - selectedRepayAmount;
        if (!user.identity) user.identity = {};
        user.identity.balance = userBalance.toFixed(2);
        await db.characters.put(user);
        
        // æ›´æ–°ä½™é¢æ˜¾ç¤º
        await updateRepayBalance();
        await updateBalancePageDisplay();
        await updateWalletBalanceDisplay();
        
        // æ›´æ–°å€Ÿæ¬¾è®°å½•
        const loanHistory = JSON.parse(localStorage.getItem('loanHistory') || '[]');
        const loanIndex = loanHistory.findIndex(loan => loan.id === currentRepayLoanId);
        
        if (loanIndex !== -1) {
            const loan = loanHistory[loanIndex];
            const newPaidAmount = (loan.paidAmount || 0) + selectedRepayAmount;
            const newRemainingAmount = remainingAmount - selectedRepayAmount;
            
            loan.paidAmount = newPaidAmount;
            loan.remainingAmount = newRemainingAmount;
            
            // å¦‚æœå…¨éƒ¨è¿˜æ¸…ï¼Œæ›´æ–°çŠ¶æ€
            if (newRemainingAmount <= 0.01) {
                loan.status = 'repaid';
                loan.remainingAmount = 0;
            }
            
            loanHistory[loanIndex] = loan;
            localStorage.setItem('loanHistory', JSON.stringify(loanHistory));
            
            // æ›´æ–°å½“å‰æ˜¾ç¤ºçš„å€Ÿæ¬¾ä¿¡æ¯
            currentRepayLoan = loan;
        }
        
        // æ˜¾ç¤ºæˆåŠŸæç¤º
        if (currentRepayLoan.remainingAmount <= 0.01) {
            alert(`è¿˜æ¬¾æˆåŠŸ\n\nå·²è¿˜æ¸…å…¨éƒ¨å€Ÿæ¬¾`);
            hideRepayPage();
        } else {
            alert(`è¿˜æ¬¾æˆåŠŸ\n\nè¿˜æ¬¾é‡‘é¢ï¼šÂ¥${selectedRepayAmount.toFixed(2)}\nå‰©ä½™åº”è¿˜ï¼šÂ¥${currentRepayLoan.remainingAmount.toFixed(2)}`);
        }
        
        // æ›´æ–°é¡µé¢
        updateRepayPageInfo();
        selectedRepayAmount = 0;
        document.getElementById('repay-custom-input').value = '';
        document.querySelectorAll('#repay-page .loan-amount-btn').forEach(btn => {
            btn.classList.remove('selected');
        });
        updateRepayButtons();
        
        // åˆ·æ–°å€Ÿæ¬¾è®°å½•åˆ—è¡¨ï¼ˆå¦‚æœè¿˜åœ¨å€Ÿé’±é¡µé¢ï¼‰
        if (typeof loadLoanHistory === 'function') {
            loadLoanHistory();
        }
    }
}

// å¯¼å‡ºå‡½æ•°
window.showRepayPage = showRepayPage;
window.hideRepayPage = hideRepayPage;
window.selectRepayAmount = selectRepayAmount;
window.handleCustomRepayAmount = handleCustomRepayAmount;
window.submitRepay = submitRepay;

// =================
// å€Ÿæ¬¾é€¾æœŸæé†’ç³»ç»Ÿ
// =================

// æ£€æŸ¥é€¾æœŸå€Ÿæ¬¾å¹¶å‘é€æé†’
async function checkOverdueLoans() {
    const loanHistory = JSON.parse(localStorage.getItem('loanHistory') || '[]');
    const now = Date.now();
    
    let hasChanges = false;
    
    for (let loan of loanHistory) {
        // åªæ£€æŸ¥å¾…è¿˜æ¬¾çŠ¶æ€çš„å€Ÿæ¬¾
        if (loan.status !== 'pending' || !loan.dueTime) continue;
        
        const overdueTime = now - loan.dueTime;
        
        // ç¬¬ä¸€æ¬¡æé†’ï¼šåˆšé€¾æœŸï¼ˆ0-5åˆ†é’Ÿå†…ï¼Œé¿å…é‡å¤æ£€æŸ¥ï¼‰
        if (overdueTime >= 0 && overdueTime < 5 * 60 * 1000 && !loan.firstReminderSent) {
            await sendFirstReminder(loan);
            loan.firstReminderSent = true;
            loan.status = 'overdue';
            hasChanges = true;
            console.log(`[å€Ÿæ¬¾æé†’] ç¬¬ä¸€æ¬¡æé†’å·²å‘é€ - å€Ÿæ¬¾ID: ${loan.id}`);
        }
        
        // ç¬¬äºŒæ¬¡æé†’ï¼šé€¾æœŸ12å°æ—¶å
        const secondReminderTime = 12 * 60 * 60 * 1000; // 12å°æ—¶
        if (overdueTime >= secondReminderTime && !loan.secondReminderSent) {
            await sendSecondReminder(loan);
            loan.secondReminderSent = true;
            hasChanges = true;
            console.log(`[å€Ÿæ¬¾æé†’] ç¬¬äºŒæ¬¡æé†’å·²å‘é€ - å€Ÿæ¬¾ID: ${loan.id}`);
        }
    }
    
    // å¦‚æœæœ‰å˜åŒ–ï¼Œä¿å­˜æ›´æ–°
    if (hasChanges) {
        localStorage.setItem('loanHistory', JSON.stringify(loanHistory));
        // åˆ·æ–°å€Ÿæ¬¾è®°å½•æ˜¾ç¤º
        if (typeof loadLoanHistory === 'function') {
            loadLoanHistory();
        }
    }
}

// ç¬¬ä¸€æ¬¡æé†’ï¼šå‘çŸ­ä¿¡ç»™å€Ÿæ¬¾äººæœ¬äºº
async function sendFirstReminder(loan) {
    if (!loan.userId) return;
    
    const user = await db.characters.get(parseInt(loan.userId));
    if (!user) return;
    
    const borrowDate = new Date(loan.date).toLocaleDateString('zh-CN', { 
        year: 'numeric', 
        month: '2-digit', 
        day: '2-digit' 
    });
    
    const message = `ã€å€Ÿæ¬¾æé†’ã€‘
å°Šæ•¬çš„ç”¨æˆ·ï¼Œæ‚¨äº${borrowDate}å€Ÿæ¬¾Â¥${loan.amount.toLocaleString()}å·²åˆ°æœŸï¼Œå‰©ä½™åº”è¿˜é‡‘é¢Â¥${loan.remainingAmount.toFixed(2)}ã€‚

è¯·å°½å¿«è¿˜æ¬¾ï¼Œé¿å…é€¾æœŸå½±å“ä¿¡ç”¨ã€‚
ç‚¹å‡»æŸ¥çœ‹è¯¦æƒ…å¹¶è¿˜æ¬¾ã€‚

- å¾®ä¿¡æ”¯ä»˜`;
    
    // å‘é€åˆ°ä¿¡æ¯Appï¼ˆçŸ­ä¿¡å½¢å¼ï¼‰
    await sendSystemSMS(loan.userId, message, 'å¾®ä¿¡æ”¯ä»˜');
    
    console.log(`[ç¬¬ä¸€æ¬¡æé†’] å·²å‘é€çŸ­ä¿¡ç»™ç”¨æˆ· ${user.name}`);
}

// ç¬¬äºŒæ¬¡æé†’ï¼šå‘çŸ­ä¿¡ç»™æ‰€æœ‰å¥½å‹
async function sendSecondReminder(loan) {
    if (!loan.userId) return;
    
    const user = await db.characters.get(parseInt(loan.userId));
    if (!user) return;
    
    const overdueHours = Math.floor((Date.now() - loan.dueTime) / (60 * 60 * 1000));
    const overdueMonths = Math.floor(overdueHours / 12); // 12å°æ—¶ = 1ä¸ªæœˆ
    
    // æ ¹æ®é€¾æœŸæ—¶é—´æ˜¾ç¤ºä¸åŒçš„å•ä½
    let overdueText = '';
    if (overdueMonths >= 1) {
        overdueText = `${overdueMonths}ä¸ªæœˆ`;
    } else {
        overdueText = `${overdueHours}å°æ—¶`;
    }
    
    const message = `ã€é€¾æœŸæé†’ã€‘${user.name}åœ¨å¾®ä¿¡å€Ÿæ¬¾Â¥${loan.amount.toLocaleString()}å·²é€¾æœŸ${overdueText}æœªè¿˜ï¼Œå‰©ä½™Â¥${loan.remainingAmount.toFixed(2)}ï¼Œè¯·æé†’TAå°½å¿«è¿˜æ¬¾ã€‚`;
    
    // è·å–æ‰€æœ‰å¥½å‹åˆ—è¡¨
    const friends = await getAllFriends(loan.userId);
    
    // å‘é€ç»™æ¯ä¸ªå¥½å‹ï¼ˆçŸ­ä¿¡å½¢å¼ï¼‰
    for (let friend of friends) {
        if (friend.type === 'local') {
            // æœ¬åœ°è§’è‰²ï¼šå¦‚æœå…³è”äº†Userï¼Œå‘é€çŸ­ä¿¡
            if (friend.linkedUserId) {
                await sendSystemSMS(friend.linkedUserId, message, 'å¾®ä¿¡æ”¯ä»˜');
                console.log(`[ç¬¬äºŒæ¬¡æé†’] å·²å‘é€çŸ­ä¿¡ç»™è§’è‰² ${friend.name} å…³è”çš„User`);
            }
            // åŒæ—¶æ·»åŠ åˆ°AIä¸Šä¸‹æ–‡æç¤º
            await addLoanReminderToCharContext(friend.id, message, user.name);
            
        } else if (friend.type === 'online') {
            // è”æœºå¥½å‹ï¼šå‘é€çŸ­ä¿¡åˆ°ä¿¡æ¯App
            await sendSystemSMS(friend.id, message, 'å¾®ä¿¡æ”¯ä»˜');
            console.log(`[ç¬¬äºŒæ¬¡æé†’] å·²å‘é€çŸ­ä¿¡ç»™è”æœºå¥½å‹ ${friend.name}`);
            
        } else if (friend.type === 'user') {
            // Userç±»å‹ï¼šç›´æ¥å‘é€çŸ­ä¿¡
            await sendSystemSMS(friend.id, message, 'å¾®ä¿¡æ”¯ä»˜');
            console.log(`[ç¬¬äºŒæ¬¡æé†’] å·²å‘é€çŸ­ä¿¡ç»™User ${friend.name}`);
        }
    }
    
    console.log(`[ç¬¬äºŒæ¬¡æé†’] å·²å‘é€çŸ­ä¿¡ç»™ ${friends.length} ä½å¥½å‹`);
}

// è·å–æ‰€æœ‰å¥½å‹ï¼ˆåŒ…æ‹¬æœ¬åœ°è§’è‰²å’Œè”æœºå¥½å‹ï¼‰
async function getAllFriends(userId) {
    const friends = [];
    
    // 1. è·å–æœ¬åœ°è§’è‰²å¥½å‹
    const allChars = await db.characters.toArray();
    for (let char of allChars) {
        // æ’é™¤Userç±»å‹å’Œè‡ªå·±
        if (char.type === 'User' || char.id === parseInt(userId)) continue;
        friends.push({
            id: char.id,
            name: char.name,
            type: 'local',
            linkedUserId: char.linked_user_id // å…³è”çš„User ID
        });
    }
    
    // 2. è·å–è”æœºå¥½å‹ï¼ˆå¦‚æœæœ‰è”æœºåŠŸèƒ½ï¼‰
    try {
        // ä»localStorageè·å–è”æœºå¥½å‹åˆ—è¡¨
        const onlineFriends = JSON.parse(localStorage.getItem('onlineFriends') || '[]');
        for (let friend of onlineFriends) {
            if (friend.id && friend.id !== userId) {
                friends.push({
                    id: friend.accountId || friend.id, // ä½¿ç”¨accountIdä½œä¸ºæ¥æ”¶çŸ­ä¿¡çš„ID
                    name: friend.name || friend.nickname || 'è”æœºå¥½å‹',
                    type: 'online',
                    originalId: friend.id // åŸå§‹ID
                });
            }
        }
    } catch (e) {
        console.warn('[è·å–è”æœºå¥½å‹å¤±è´¥]', e);
    }
    
    // 3. è·å–æ‰€æœ‰Userç±»å‹çš„è§’è‰²ï¼ˆä»–ä»¬ä¹Ÿèƒ½æ”¶åˆ°çŸ­ä¿¡ï¼‰
    const allUsers = allChars.filter(char => char.type === 'User' && char.id !== parseInt(userId));
    for (let user of allUsers) {
        friends.push({
            id: user.id,
            name: user.name,
            type: 'user'
        });
    }
    
    return friends;
}

// æ·»åŠ å€Ÿæ¬¾æé†’åˆ°è§’è‰²AIä¸Šä¸‹æ–‡
async function addLoanReminderToCharContext(charId, message, borrowerName) {
    const char = await db.characters.get(charId);
    if (!char) return;
    
    // åˆå§‹åŒ– loanReminders å­—æ®µ
    if (!char.loanReminders) {
        char.loanReminders = [];
    }
    
    // æ·»åŠ æé†’è®°å½•
    char.loanReminders.push({
        message: message,
        borrowerName: borrowerName,
        timestamp: Date.now(),
        read: false
    });
    
    // ä¿å­˜åˆ°æ•°æ®åº“
    await db.characters.put(char);
    
    console.log(`[å€Ÿæ¬¾æé†’] å·²æ·»åŠ åˆ°è§’è‰² ${char.name} çš„ä¸Šä¸‹æ–‡`);
}

// è¿™ä¸ªå‡½æ•°å·²ä¸å†éœ€è¦ï¼Œç›´æ¥åœ¨ä¸»å¾ªç¯ä¸­å‘é€

// å‘é€ç³»ç»ŸçŸ­ä¿¡ï¼ˆåˆ°ä¿¡æ¯Appï¼‰
async function sendSystemSMS(userId, message, senderName = 'ç³»ç»Ÿé€šçŸ¥') {
    console.log(`[å‘é€çŸ­ä¿¡] ç»™ç”¨æˆ· ${userId}ï¼Œå‘é€è€…ï¼š${senderName}`);
    
    const accountId = String(userId);
    
    // æ·»åŠ åˆ° Dexie æ•°æ®åº“
    await db.sms_messages.add({
        accountId: accountId,
        charId: null, // ç³»ç»Ÿæ¶ˆæ¯æ²¡æœ‰è§’è‰²ID
        type: 'received',  // æ¥æ”¶çš„æ¶ˆæ¯
        sender: senderName,
        number: senderName,
        content: message,
        time: Date.now(),
        read: false
    });
    
    console.log(`[å‘é€çŸ­ä¿¡] âœ… çŸ­ä¿¡å·²æ·»åŠ åˆ°æ•°æ®åº“`);
    
    // åˆ·æ–°ä¸»é¡µé¢çš„æ¶ˆæ¯åˆ—è¡¨
    if (typeof renderMessageList === 'function') {
        await renderMessageList();
        console.log(`[å‘é€çŸ­ä¿¡] âœ… æ¶ˆæ¯åˆ—è¡¨å·²åˆ·æ–°`);
    }
}

// å¯åŠ¨å®šæ—¶æ£€æŸ¥ï¼ˆæ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡ï¼‰
let loanCheckInterval = null;

function startLoanReminderSystem() {
    // æ¸…é™¤æ—§çš„å®šæ—¶å™¨
    if (loanCheckInterval) {
        clearInterval(loanCheckInterval);
    }
    
    // ç«‹å³æ‰§è¡Œä¸€æ¬¡æ£€æŸ¥
    checkOverdueLoans();
    
    // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
    loanCheckInterval = setInterval(() => {
        checkOverdueLoans();
    }, 60 * 1000); // 60ç§’
    
    console.log('[å€Ÿæ¬¾æé†’ç³»ç»Ÿ] å·²å¯åŠ¨ï¼Œæ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡');
}

// é¡µé¢åŠ è½½æ—¶å¯åŠ¨
if (typeof window !== 'undefined') {
    // ç­‰å¾…DOMåŠ è½½å®Œæˆåå¯åŠ¨
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', startLoanReminderSystem);
    } else {
        startLoanReminderSystem();
    }
}

// =================
// æµ‹è¯•åŠŸèƒ½
// =================

let testReminderClickCount = 0;
let testLoanRecord = null;

async function testLoanReminder() {
    const statusDiv = document.getElementById('test-reminder-status');
    
    testReminderClickCount++;
    
    if (testReminderClickCount === 1) {
        // ç¬¬ä¸€æ¬¡ç‚¹å‡»ï¼šåˆ›å»ºæµ‹è¯•å€Ÿæ¬¾å¹¶å‘é€ç¬¬ä¸€æ¬¡æé†’
        if (!currentMyCharId) {
            alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ª User èº«ä»½');
            testReminderClickCount = 0;
            return;
        }
        
        const user = await db.characters.get(parseInt(currentMyCharId));
        if (!user) {
            alert('æœªæ‰¾åˆ°ç”¨æˆ·ä¿¡æ¯');
            testReminderClickCount = 0;
            return;
        }
        
        // åˆ›å»ºä¸€ä¸ªæµ‹è¯•å€Ÿæ¬¾è®°å½•ï¼ˆé€¾æœŸ1ä¸ªæœˆ = 12å°æ—¶ï¼‰
        const now = Date.now();
        const oneMonthAgo = now - (12 * 60 * 60 * 1000); // 12å°æ—¶å‰
        testLoanRecord = {
            id: now,
            amount: 5000,
            term: 3,
            totalAmount: 5225,
            monthlyPayment: 1741.67,
            date: new Date(oneMonthAgo - (3 * 12 * 60 * 60 * 1000)).toISOString(), // å€Ÿæ¬¾æ—¥æœŸï¼š4ä¸ªæœˆå‰
            dueTime: oneMonthAgo, // åˆ°æœŸæ—¶é—´ï¼š1ä¸ªæœˆå‰ï¼ˆå·²é€¾æœŸ12å°æ—¶ï¼‰
            status: 'pending',
            paidAmount: 0,
            remainingAmount: 5225,
            firstReminderSent: false,
            secondReminderSent: false,
            userId: currentMyCharId,
            isTest: true // æ ‡è®°ä¸ºæµ‹è¯•è®°å½•
        };
        
        // å‘é€ç¬¬ä¸€æ¬¡æé†’
        await sendFirstReminder(testLoanRecord);
        testLoanRecord.firstReminderSent = true;
        
        if (statusDiv) {
            statusDiv.textContent = 'âœ… ç¬¬ä¸€æ¬¡æé†’å·²å‘é€ï¼ˆçŸ­ä¿¡ç»™æœ¬äººï¼‰\nå†ç‚¹å‡»ä¸€æ¬¡å‘é€ç¬¬äºŒæ¬¡æé†’';
            statusDiv.style.color = '#07c160';
        }
        
        alert('æµ‹è¯•ï¼šç¬¬ä¸€æ¬¡æé†’å·²å‘é€\n\nå·²å‘é€çŸ­ä¿¡ç»™å€Ÿæ¬¾äººæœ¬äºº\nè¯·æŸ¥çœ‹å¾®ä¿¡æ¶ˆæ¯');
        
    } else if (testReminderClickCount === 2) {
        // ç¬¬äºŒæ¬¡ç‚¹å‡»ï¼šå‘é€ç¬¬äºŒæ¬¡æé†’
        if (!testLoanRecord) {
            alert('è¯·å…ˆç‚¹å‡»ç¬¬ä¸€æ¬¡å‘é€ç¬¬ä¸€æ¬¡æé†’');
            testReminderClickCount = 0;
            return;
        }
        
        // å‘é€ç¬¬äºŒæ¬¡æé†’
        await sendSecondReminder(testLoanRecord);
        testLoanRecord.secondReminderSent = true;
        
        // è·å–å¥½å‹æ•°é‡
        const friends = await getAllFriends(testLoanRecord.userId);
        
        if (statusDiv) {
            statusDiv.textContent = `âœ… ç¬¬äºŒæ¬¡æé†’å·²å‘é€\nå·²é€šçŸ¥ ${friends.length} ä½å¥½å‹ï¼ˆæœ¬åœ°è§’è‰² + è”æœºå¥½å‹ï¼‰`;
            statusDiv.style.color = '#07c160';
        }
        
        alert(`æµ‹è¯•ï¼šç¬¬äºŒæ¬¡æé†’å·²å‘é€\n\nå·²å‘é€ç»™ ${friends.length} ä½å¥½å‹\n\n- æœ¬åœ°è§’è‰²ï¼šä¼šåœ¨èŠå¤©æ—¶æ”¶åˆ°ä¸Šä¸‹æ–‡æç¤º\n- è”æœºå¥½å‹ï¼šä¼šæ”¶åˆ°çŸ­ä¿¡\n\nå†æ¬¡ç‚¹å‡»å¯é‡ç½®æµ‹è¯•`);
        
    } else {
        // ç¬¬ä¸‰æ¬¡ç‚¹å‡»ï¼šé‡ç½®
        testReminderClickCount = 0;
        testLoanRecord = null;
        
        if (statusDiv) {
            statusDiv.textContent = 'å·²é‡ç½®ï¼Œç‚¹å‡»å¼€å§‹æ–°çš„æµ‹è¯•';
            statusDiv.style.color = '#999';
        }
        
        alert('æµ‹è¯•å·²é‡ç½®\n\nç‚¹å‡»æŒ‰é’®å¼€å§‹æ–°çš„æµ‹è¯•');
    }
}

window.testLoanReminder = testLoanReminder;

// =================
// åˆ®åˆ®ä¹åŠŸèƒ½
// =================

const SCRATCH_CARD_PRICE = 10; // æ¯å¼ åˆ®åˆ®ä¹ä»·æ ¼
let currentScratchCard = null; // å½“å‰åˆ®åˆ®ä¹æ•°æ®
let isScratching = false; // æ˜¯å¦æ­£åœ¨åˆ®å¥–
let scratchProgress = 0; // åˆ®å¼€è¿›åº¦ (0-100)

// æ˜¾ç¤ºåˆ®åˆ®ä¹é¡µé¢
async function showScratchCardPage() {
    const page = document.getElementById('scratch-card-page');
    page.style.display = 'flex';
    page.offsetHeight;
    page.classList.add('slide-in');
    
    // æ›´æ–°ä½™é¢æ˜¾ç¤º
    await updateScratchBalance();
    
    // é‡ç½®åˆ®åˆ®ä¹çŠ¶æ€
    resetScratchCard();
    
    // åŠ è½½å†å²è®°å½•
    loadScratchHistory();
}

// éšè—åˆ®åˆ®ä¹é¡µé¢
function hideScratchCardPage() {
    const page = document.getElementById('scratch-card-page');
    page.classList.remove('slide-in');
    setTimeout(() => {
        page.style.display = 'none';
    }, 300);
}

// æ›´æ–°ä½™é¢æ˜¾ç¤º
async function updateScratchBalance() {
    if (!currentMyCharId) {
        document.getElementById('scratch-current-balance').textContent = 'Â¥0.00';
        return;
    }
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    const balance = user?.identity?.balance || 0;
    document.getElementById('scratch-current-balance').textContent = `Â¥${parseFloat(balance).toFixed(2)}`;
    
    // æ›´æ–°è´­ä¹°æŒ‰é’®çŠ¶æ€
    const buyBtn = document.getElementById('scratch-buy-btn');
    if (parseFloat(balance) < SCRATCH_CARD_PRICE) {
        buyBtn.disabled = true;
        buyBtn.querySelector('#scratch-buy-text').textContent = `ä½™é¢ä¸è¶³ (éœ€è¦ Â¥${SCRATCH_CARD_PRICE})`;
    } else {
        buyBtn.disabled = false;
        buyBtn.querySelector('#scratch-buy-text').textContent = `è´­ä¹°åˆ®åˆ®ä¹ (Â¥${SCRATCH_CARD_PRICE})`;
    }
}

// é‡ç½®åˆ®åˆ®ä¹
function resetScratchCard() {
    currentScratchCard = null;
    isScratching = false;
    scratchProgress = 0;
    
    const cover = document.getElementById('scratch-cover');
    const content = document.getElementById('scratch-content');
    const resultIcon = document.getElementById('scratch-result-icon');
    const canvas = cover.querySelector('canvas');
    
    // æ¸…é™¤canvas
    if (canvas) {
        canvas.remove();
    }
    
    cover.classList.remove('scratched');
    cover.style.opacity = '1';
    cover.style.pointerEvents = 'auto';
    
    // é‡ç½®å›¾æ ‡æ˜¾ç¤º
    if (resultIcon) {
        resultIcon.style.display = 'none';
        resultIcon.textContent = '';
    }
    
    // éšè—å†…å®¹
    if (content) {
        content.style.display = 'none';
    }
}

// è´­ä¹°åˆ®åˆ®ä¹
async function buyScratchCard() {
    if (!currentMyCharId) {
        alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ª User èº«ä»½');
        return;
    }
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    if (!user) {
        alert('æœªæ‰¾åˆ°ç”¨æˆ·ä¿¡æ¯');
        return;
    }
    
    let userBalance = parseFloat(user.identity?.balance || 0);
    
    // æ£€æŸ¥ä½™é¢
    if (userBalance < SCRATCH_CARD_PRICE) {
        alert(`ä½™é¢ä¸è¶³ï¼\nå½“å‰ä½™é¢ï¼šÂ¥${userBalance.toFixed(2)}\néœ€è¦ï¼šÂ¥${SCRATCH_CARD_PRICE}`);
        return;
    }
    
    // æ‰£æ¬¾
    userBalance = userBalance - SCRATCH_CARD_PRICE;
    if (!user.identity) user.identity = {};
    user.identity.balance = userBalance.toFixed(2);
    await db.characters.put(user);
    
    // æ›´æ–°ä½™é¢æ˜¾ç¤º
    await updateScratchBalance();
    await updateBalancePageDisplay();
    await updateWalletBalanceDisplay();
    
    // ç”Ÿæˆåˆ®åˆ®ä¹ç»“æœ
    const prize = generateScratchPrize();
    currentScratchCard = {
        prize: prize,
        cost: SCRATCH_CARD_PRICE,
        time: Date.now()
    };
    
    // æ˜¾ç¤ºåˆ®åˆ®ä¹
    showScratchCard(prize);
    
    // åˆå§‹åŒ–åˆ®å¥–äº¤äº’
    initScratchInteraction();
}

// ç”Ÿæˆä¸­å¥–é‡‘é¢ï¼ˆæ¦‚ç‡åˆ†å¸ƒï¼‰
function generateScratchPrize() {
    const rand = Math.random();
    
    // æ¦‚ç‡åˆ†å¸ƒï¼ˆæ¯å¼ Â¥10ï¼‰ï¼š
    // 5%  - æœªä¸­å¥– Â¥0ï¼ˆäºÂ¥10ï¼‰
    // 60% - å›æœ¬åŒº Â¥8~Â¥12ï¼ˆåŸºæœ¬ä¸èµšä¸äºï¼‰
    // 25% - å°èµšåŒº Â¥15~Â¥30ï¼ˆå°èµšï¼‰
    // 7%  - ä¸­å¥–åŒº Â¥50~Â¥100ï¼ˆä¸­ç­‰å¥–ï¼‰
    // 2.5% - å¤§å¥–åŒº Â¥200~Â¥500ï¼ˆå¤§å¥–ï¼‰
    // 0.5% - å¤´å¥– Â¥1000ï¼ˆå¤´å¥–ï¼‰
    
    if (rand < 0.05) {
        return 0; // 5% æœªä¸­å¥–ï¼ˆäºé’±ï¼‰
    } else if (rand < 0.65) {
        return Math.floor(Math.random() * 5) + 8; // 60% å›æœ¬åŒº Â¥8~Â¥12
    } else if (rand < 0.90) {
        return Math.floor(Math.random() * 16) + 15; // 25% å°èµš Â¥15~Â¥30
    } else if (rand < 0.97) {
        return Math.floor(Math.random() * 51) + 50; // 7% ä¸­ç­‰å¥– Â¥50~Â¥100
    } else if (rand < 0.995) {
        return Math.floor(Math.random() * 301) + 200; // 2.5% å¤§å¥– Â¥200~Â¥500
    } else {
        return 1000; // 0.5% å¤´å¥– Â¥1000
    }
}

// æ˜¾ç¤ºåˆ®åˆ®ä¹
function showScratchCard(prize) {
    const cover = document.getElementById('scratch-cover');
    const content = document.getElementById('scratch-content');
    const resultIcon = document.getElementById('scratch-result-icon');
    const resultText = document.getElementById('scratch-result-text');
    const resultAmount = document.getElementById('scratch-result-amount');
    
    // æ˜¾ç¤ºå†…å®¹å±‚
    content.style.display = 'flex';
    
    // è®¾ç½®ç»“æœ
    if (prize === 0) {
        resultIcon.textContent = '';
        resultIcon.style.display = 'none';
        resultText.textContent = 'å¾ˆé—æ†¾ï¼Œæœªä¸­å¥–';
        resultAmount.textContent = 'Â¥0';
        resultAmount.style.color = '#999';
    } else {
        resultIcon.textContent = '';
        resultIcon.style.display = 'none';
        resultText.textContent = 'æ­å–œä¸­å¥–';
        resultAmount.textContent = `Â¥${prize}`;
        resultAmount.style.color = '#ffb6c1';
    }
    
    // é‡ç½®è¦†ç›–å±‚
    cover.style.opacity = '1';
    cover.style.pointerEvents = 'auto';
    cover.classList.remove('scratched');
    scratchProgress = 0;
}

// åˆå§‹åŒ–åˆ®å¥–äº¤äº’
function initScratchInteraction() {
    const cover = document.getElementById('scratch-cover');
    const card = document.getElementById('scratch-card');
    
    // æ¸…é™¤æ—§çš„canvas
    const oldCanvas = cover.querySelector('canvas');
    if (oldCanvas) {
        oldCanvas.remove();
    }
    
    // åˆ›å»ºcanvasç”¨äºåˆ®å¥–æ•ˆæœ
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const rect = card.getBoundingClientRect();
    
    canvas.width = rect.width;
    canvas.height = rect.height;
    canvas.style.position = 'absolute';
    canvas.style.top = '0';
    canvas.style.left = '0';
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.zIndex = '3';
    canvas.style.mixBlendMode = 'destination-out';
    
    // åˆå§‹åŒ–canvasä¸ºä¸é€æ˜
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    cover.appendChild(canvas);
    
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    
    // è·å–åæ ‡
    function getCoordinates(e) {
        const rect = card.getBoundingClientRect();
        if (e.touches) {
            return {
                x: e.touches[0].clientX - rect.left,
                y: e.touches[0].clientY - rect.top
            };
        } else {
            return {
                x: e.offsetX,
                y: e.offsetY
            };
        }
    }
    
    // ç»˜åˆ¶åˆ®ç—•
    function drawScratch(x, y) {
        ctx.globalCompositeOperation = 'destination-out';
        ctx.beginPath();
        ctx.arc(x, y, 25, 0, Math.PI * 2);
        ctx.fill();
        
        // å¦‚æœèµ·ç‚¹å’Œç»ˆç‚¹éƒ½æœ‰ï¼Œç”»ä¸€æ¡çº¿
        if (lastX > 0 && lastY > 0) {
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(x, y);
            ctx.lineWidth = 50;
            ctx.lineCap = 'round';
            ctx.strokeStyle = 'rgba(0,0,0,1)';
            ctx.globalCompositeOperation = 'destination-out';
            ctx.stroke();
        }
        
        lastX = x;
        lastY = y;
        
        // è®¡ç®—åˆ®å¼€è¿›åº¦ï¼ˆä½¿ç”¨é‡‡æ ·æ–¹å¼æé«˜æ€§èƒ½ï¼‰
        if (Math.random() < 0.1) { // åªé‡‡æ ·10%çš„æ£€æŸ¥ï¼Œå‡å°‘æ€§èƒ½æ¶ˆè€—
            const sampleSize = 100;
            const stepX = Math.floor(canvas.width / sampleSize);
            const stepY = Math.floor(canvas.height / sampleSize);
            let transparentCount = 0;
            
            for (let sy = 0; sy < canvas.height; sy += stepY) {
                for (let sx = 0; sx < canvas.width; sx += stepX) {
                    const imageData = ctx.getImageData(sx, sy, 1, 1);
                    if (imageData.data[3] === 0) { // alphaä¸º0è¡¨ç¤ºé€æ˜
                        transparentCount++;
                    }
                }
            }
            
            scratchProgress = (transparentCount / (sampleSize * sampleSize)) * 100;
            
            // å¦‚æœåˆ®å¼€è¶…è¿‡30%ï¼Œè‡ªåŠ¨å®Œæˆ
            if (scratchProgress >= 30) {
                finishScratching();
            }
        } else {
            // ç®€å•ä¼°ç®—ï¼šæ¯æ¬¡ç»˜åˆ¶å¢åŠ ä¸€ç‚¹è¿›åº¦
            scratchProgress = Math.min(scratchProgress + 0.5, 100);
            if (scratchProgress >= 30) {
                finishScratching();
            }
        }
    }
    
    // é¼ æ ‡äº‹ä»¶
    card.onmousedown = (e) => {
        if (currentScratchCard && !isScratching) {
            isDrawing = true;
            const coords = getCoordinates(e);
            lastX = coords.x;
            lastY = coords.y;
            drawScratch(coords.x, coords.y);
        }
    };
    
    card.onmousemove = (e) => {
        if (isDrawing && currentScratchCard && !isScratching) {
            const coords = getCoordinates(e);
            drawScratch(coords.x, coords.y);
        }
    };
    
    card.onmouseup = () => {
        isDrawing = false;
        lastX = 0;
        lastY = 0;
    };
    
    card.onmouseleave = () => {
        isDrawing = false;
        lastX = 0;
        lastY = 0;
    };
    
    // è§¦æ‘¸äº‹ä»¶
    card.ontouchstart = (e) => {
        if (currentScratchCard && !isScratching) {
            e.preventDefault();
            isDrawing = true;
            const coords = getCoordinates(e);
            lastX = coords.x;
            lastY = coords.y;
            drawScratch(coords.x, coords.y);
        }
    };
    
    card.ontouchmove = (e) => {
        if (isDrawing && currentScratchCard && !isScratching) {
            e.preventDefault();
            const coords = getCoordinates(e);
            drawScratch(coords.x, coords.y);
        }
    };
    
    card.ontouchend = () => {
        isDrawing = false;
        lastX = 0;
        lastY = 0;
    };
}

// åˆ®å¥–æ“ä½œï¼ˆå·²åºŸå¼ƒï¼Œä½¿ç”¨canvaså®ç°ï¼‰
function scratchAt(x, y) {
    // æ­¤å‡½æ•°å·²è¢«canvaså®ç°æ›¿ä»£
}

// å®Œæˆåˆ®å¥–
async function finishScratching() {
    if (isScratching || !currentScratchCard) return;
    isScratching = true;
    
    const cover = document.getElementById('scratch-cover');
    const canvas = cover.querySelector('canvas');
    const content = document.getElementById('scratch-content');
    
    // å®Œå…¨æ¸…é™¤è¦†ç›–å±‚
    if (canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
    
    // ç¡®ä¿å†…å®¹å±‚æ˜¾ç¤º
    if (content) {
        content.style.display = 'flex';
    }
    
    // å»¶è¿Ÿæ˜¾ç¤ºå®Œæˆæ•ˆæœ
    setTimeout(() => {
        cover.classList.add('scratched');
        cover.style.opacity = '0';
        cover.style.pointerEvents = 'none';
        
        // ç¡®ä¿é‡‘é¢æ˜¾ç¤ºæ­£ç¡®
        const resultAmount = document.getElementById('scratch-result-amount');
        const resultText = document.getElementById('scratch-result-text');
        const resultIcon = document.getElementById('scratch-result-icon');
        
        if (currentScratchCard) {
            if (currentScratchCard.prize === 0) {
                if (resultIcon) {
                    resultIcon.textContent = '';
                    resultIcon.style.display = 'none';
                }
                if (resultText) resultText.textContent = 'å¾ˆé—æ†¾ï¼Œæœªä¸­å¥–';
                if (resultAmount) {
                    resultAmount.textContent = 'Â¥0';
                    resultAmount.style.color = '#999';
                }
            } else {
                if (resultIcon) {
                    resultIcon.textContent = '';
                    resultIcon.style.display = 'none';
                }
                if (resultText) resultText.textContent = 'æ­å–œä¸­å¥–';
                if (resultAmount) {
                    resultAmount.textContent = `Â¥${currentScratchCard.prize}`;
                    resultAmount.style.color = '#ffb6c1';
                }
            }
        }
        
        // å¦‚æœæœ‰ä¸­å¥–ï¼Œæ·»åŠ åˆ°ä½™é¢
        if (currentScratchCard && currentScratchCard.prize > 0) {
            addScratchPrize(currentScratchCard.prize);
        }
        
        // ä¿å­˜è®°å½•
        saveScratchRecord(currentScratchCard);
        
        // é‡æ–°åŠ è½½å†å²
        loadScratchHistory();
        
        // é‡ç½®çŠ¶æ€ï¼Œå‡†å¤‡ä¸‹ä¸€å¼ 
        setTimeout(() => {
            isScratching = false;
            currentScratchCard = null;
            scratchProgress = 0;
        }, 2000);
    }, 300);
}

// æ·»åŠ ä¸­å¥–é‡‘é¢åˆ°ä½™é¢
async function addScratchPrize(amount) {
    if (!currentMyCharId) return;
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    if (!user) return;
    
    let userBalance = parseFloat(user.identity?.balance || 0);
    userBalance = userBalance + amount;
    
    if (!user.identity) user.identity = {};
    user.identity.balance = userBalance.toFixed(2);
    await db.characters.put(user);
    
    // æ›´æ–°æ˜¾ç¤º
    await updateScratchBalance();
    await updateBalancePageDisplay();
    await updateWalletBalanceDisplay();
    
    // æ˜¾ç¤ºä¸­å¥–æç¤º
    setTimeout(() => {
        alert(`æ­å–œä¸­å¥–\n\nå¥–é‡‘ï¼šÂ¥${amount}\nå·²æ·»åŠ åˆ°é’±åŒ…ä½™é¢`);
    }, 500);
}

// ä¿å­˜åˆ®åˆ®ä¹è®°å½•
function saveScratchRecord(record) {
    let history = JSON.parse(localStorage.getItem('scratchHistory') || '[]');
    history.unshift({
        prize: record.prize,
        cost: record.cost,
        time: record.time,
        net: record.prize - record.cost // å‡€æ”¶ç›Š
    });
    // åªä¿ç•™æœ€è¿‘50æ¡è®°å½•
    if (history.length > 50) {
        history = history.slice(0, 50);
    }
    localStorage.setItem('scratchHistory', JSON.stringify(history));
}

// åŠ è½½å†å²è®°å½•
function loadScratchHistory() {
    const historyList = document.getElementById('scratch-history-list');
    const history = JSON.parse(localStorage.getItem('scratchHistory') || '[]');
    
    if (history.length === 0) {
        historyList.innerHTML = '<div class="loan-empty-state">æš‚æ— ä¸­å¥–è®°å½•</div>';
        return;
    }
    
    historyList.innerHTML = history.map(record => {
        const date = new Date(record.time);
        const dateStr = date.toLocaleDateString('zh-CN', { year: 'numeric', month: '2-digit', day: '2-digit' });
        const timeStr = date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
        const netClass = record.net >= 0 ? 'profit' : 'loss';
        const netText = record.net >= 0 ? `+Â¥${record.net}` : `Â¥${record.net}`;
        
        return `
            <div class="loan-history-item">
                <div class="loan-history-info">
                    <div class="loan-history-amount">${record.prize > 0 ? `ä¸­å¥– Â¥${record.prize}` : 'æœªä¸­å¥–'}</div>
                    <div class="loan-history-date">${dateStr} ${timeStr} Â· èŠ±è´¹ Â¥${record.cost}</div>
                </div>
                <div class="loan-history-status ${netClass}">${netText}</div>
            </div>
        `;
    }).join('');
}

// å¯¼å‡ºå‡½æ•°
window.showScratchCardPage = showScratchCardPage;
window.hideScratchCardPage = hideScratchCardPage;
window.buyScratchCard = buyScratchCard;
window.selectRechargeAmount = selectRechargeAmount;
window.submitRecharge = submitRecharge;

// --- æœ‹å‹åœˆé€»è¾‘ ---
let momentsScrollInit = false;

async function showMomentsPage() {
    const page = document.getElementById('moments-page');
    page.style.display = 'block'; // æœ‹å‹åœˆé¡µé¢æ˜¯ block å¸ƒå±€
    page.offsetHeight; 
    page.classList.add('slide-in');
    
    // åˆå§‹åŒ–æ»šåŠ¨ç›‘å¬
    if (!momentsScrollInit) {
        initMomentsScroll();
        momentsScrollInit = true;
    }
    
    // æ¸²æŸ“ç”¨æˆ·ä¿¡æ¯å’Œå°é¢
    await renderMomentsUserInfo();
    
    // æ¸²æŸ“åˆ—è¡¨
    await renderMomentsList();
}

function hideMomentsPage() {
    const page = document.getElementById('moments-page');
    page.classList.remove('slide-in');
    setTimeout(() => {
        page.style.display = 'none';
    }, 300);
}

function initMomentsScroll() {
    const page = document.getElementById('moments-page');
    const navBar = document.getElementById('moments-nav-bar');
    
    page.addEventListener('scroll', () => {
        if (page.scrollTop > 200) {
            navBar.classList.add('scrolled');
        } else {
            navBar.classList.remove('scrolled');
        }
    });
}

async function renderMomentsUserInfo() {
    // è·å–å½“å‰ User
    let user = null;
    if (currentMyCharId) {
        user = await db.characters.get(parseInt(currentMyCharId));
    }
    
    // å¦‚æœæ²¡æœ‰ Userï¼Œå°è¯•æ‰¾ä¸€ä¸ª
    if (!user) {
        const users = await db.characters.where('type').equals('user').toArray();
        if (users.length > 0) user = users[0];
    }
    
    const nameEl = document.getElementById('moments-user-name');
    const avatarEl = document.getElementById('moments-user-avatar');
    const coverEl = document.getElementById('moments-cover-area');
    
    // ç»™å¤´åƒæ·»åŠ ç‚¹å‡»äº‹ä»¶ï¼Œæ‰“å¼€"æˆ‘çš„æœ‹å‹åœˆ"
    avatarEl.onclick = (e) => {
        e.stopPropagation(); // é˜»æ­¢è§¦å‘å°é¢çš„ç‚¹å‡»äº‹ä»¶
        showMyMomentsPage();
    };
    
    if (user) {
        nameEl.innerText = user.name;
        if (user.avatar) {
            avatarEl.style.backgroundImage = `url(${user.avatar})`;
        } else {
            avatarEl.style.backgroundColor = '#eee';
        }
        
        // å°é¢å›¾ (åªè¯»å–å½“å‰è´¦å·çš„æ•°æ®ï¼Œå®ç°éš”ç¦»)
        const cover = user.identity?.cover;
        if (cover) {
            coverEl.style.backgroundImage = `url(${cover})`;
        } else {
            // å¦‚æœæ²¡è®¾ç½®ï¼Œæ˜¾ç¤ºé»˜è®¤ç°è‰²ï¼Œæ¸…ç©ºå¯èƒ½å­˜åœ¨çš„æ—§å›¾
            coverEl.style.backgroundImage = ''; 
        }
    } else {
        nameEl.innerText = "æœªç™»å½•";
        // æœªç™»å½•æ—¶æ¸…é™¤å°é¢å’Œå¤´åƒ
        avatarEl.style.backgroundImage = '';
        coverEl.style.backgroundImage = '';
    }
}

async function renderMomentsList() {
    const container = document.getElementById('moments-list');
    container.innerHTML = '';
    
    // è·å–å½“å‰è´¦å·ID
    const currentAccountId = currentMyCharId ? parseInt(currentMyCharId) : null;
    if (!currentAccountId) {
        container.innerHTML = `<div style="text-align:center; color:#ccc; margin-top:100px; font-size:14px;">è¯·å…ˆç™»å½•è´¦å·</div>`;
        return;
    }

    // ğŸ¯ ä¿®æ”¹ï¼šè·å–å½“å‰è´¦å·çš„åŠ¨æ€ + æ‰€æœ‰å¥½å‹çš„åŠ¨æ€
    const allChars = await db.characters.toArray();
    const friendIds = allChars
        .filter(char => {
            const status = getFriendStatus(char, currentAccountId);
            return status === 'friend'; // åªæ˜¾ç¤ºå¥½å‹çš„æœ‹å‹åœˆ
        })
        .map(char => char.id);
    
    // åŒ…æ‹¬è‡ªå·±å’Œæ‰€æœ‰å¥½å‹ï¼ˆç»Ÿä¸€è½¬ä¸ºæ•°å­—è¿›è¡Œæ¯”è¾ƒï¼‰
    const visibleUserIds = [currentAccountId, ...friendIds].map(id => parseInt(id));
    
    // è·å–æ‰€æœ‰æœ‹å‹åœˆï¼Œç„¶åè¿‡æ»¤
    let allMoments = await db.moments.toArray();
    let moments = allMoments.filter(m => visibleUserIds.includes(parseInt(m.userId)));
    
    // âœ… æŒ‰ç½®é¡¶å’Œæ—¶é—´æ’åºï¼šç½®é¡¶çš„åœ¨å‰ï¼Œç„¶åæŒ‰æ—¶é—´å€’åºï¼ˆæœ€æ–°çš„åœ¨ä¸Šé¢ï¼‰
    moments.sort((a, b) => {
        // å¦‚æœæ˜¯è‡ªå·±å‘çš„ä¸”ç½®é¡¶äº†ï¼Œæ’åœ¨æœ€å‰é¢
        const aIsPinned = (parseInt(a.userId) === currentAccountId && a.pinned);
        const bIsPinned = (parseInt(b.userId) === currentAccountId && b.pinned);
        
        if (aIsPinned && !bIsPinned) return -1;
        if (bIsPinned && !aIsPinned) return 1;
        
        // éƒ½æ˜¯ç½®é¡¶æˆ–éƒ½ä¸æ˜¯ç½®é¡¶ï¼ŒæŒ‰æ—¶é—´å€’åºï¼ˆæ–°çš„åœ¨å‰ï¼‰
        return (b.time || 0) - (a.time || 0);
    });
    
    if (moments.length === 0) {
        container.innerHTML = `<div style="text-align:center; color:#ccc; margin-top:100px; font-size:14px;">æš‚æ— åŠ¨æ€</div>`;
        return;
    }
    
    // è·å–æ‰€æœ‰è§’è‰²ä¿¡æ¯ç¼“å­˜ï¼Œé¿å…å¾ªç¯æŸ¥è¯¢
    const chars = await db.characters.toArray();
    const charMap = {};
    chars.forEach(c => charMap[c.id] = c);
    
    for (const m of moments) {
        const char = charMap[m.userId]; // userId å¯èƒ½æ˜¯ number æˆ– string
        if (!char) continue;
        
        const div = document.createElement('div');
        div.className = 'moment-item';
        
        // å›¾ç‰‡å±•ç¤º HTML - ä½¿ç”¨æ–‡å­—å›¾ç‰‡å¡ç‰‡å½¢å¼
        let imagesHtml = '';
        // ä¼˜å…ˆä½¿ç”¨æ–°çš„å¡ç‰‡å½¢å¼ï¼ˆimageCount + imageDescï¼‰
        if (m.imageCount && m.imageCount > 0) {
            const desc = m.imageDesc || '';
            const count = Math.min(m.imageCount, 9); // æœ€å¤š9å¼ 
            const gridClass = `grid-${count}`;
            let squares = '';
            for (let imgIdx = 0; imgIdx < count; imgIdx++) {
                squares += `<div class="moment-img-placeholder" onclick="event.stopPropagation(); showMomentImageDesc('${escapeHtml(desc).replace(/'/g, "\\'")}')">
                    <div class="moment-img-placeholder-inner">
                        <svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
                        ${count === 1 ? '<div class="moment-img-placeholder-hint">ç‚¹å‡»æŸ¥çœ‹æ–‡å­—</div>' : ''}
                    </div>
                </div>`;
            }
            imagesHtml = `<div class="moment-image-grid ${gridClass}">${squares}</div>`;
        }
        // å…¼å®¹æ—§æ•°æ®ï¼šå¦‚æœæœ‰çœŸå®å›¾ç‰‡URL
        else if (m.images && m.images.length > 0) {
            let gridClass = 'cols-3';
            if (m.images.length === 1) gridClass = 'cols-1';
            else if (m.images.length === 2 || m.images.length === 4) gridClass = 'cols-2';
            
            imagesHtml = `<div class="moment-grid ${gridClass}">
                ${m.images.map(img => `<div class="moment-img" style="background-image:url(${img})" onclick="previewImage('${img}')"></div>`).join('')}
            </div>`;
        }
        
        // æ—¶é—´æ ¼å¼åŒ–
        const date = new Date(m.time);
        const timeStr = `${date.getMonth()+1}æœˆ${date.getDate()}æ—¥ ${date.getHours()}:${date.getMinutes().toString().padStart(2,'0')}`;
        
        // åˆ é™¤æŒ‰é’® (å¦‚æœæ˜¯è‡ªå·±å‘çš„)
        const isSelf = (currentMyCharId && parseInt(currentMyCharId) == m.userId);
        const delBtn = isSelf ? `<span class="moment-delete" onclick="deleteMoment(${m.id})">åˆ é™¤</span>` : '';
        
        // ç½®é¡¶æ ‡è¯†ï¼ˆåªæœ‰è‡ªå·±å‘çš„ä¸”ç½®é¡¶äº†æ‰æ˜¾ç¤ºï¼‰
        const pinnedBadge = (isSelf && m.pinned) ? `<span style="display:inline-block; background:#ffc107; color:#fff; font-size:10px; padding:2px 6px; border-radius:3px; margin-left:6px;">ç½®é¡¶</span>` : '';

        // å¤„ç†ç‚¹èµæ˜¾ç¤º
        let likesHtml = '';
        // æ£€æŸ¥æˆ‘æ˜¯å¦ç‚¹èµ
        // likes: [{userId, name}]
        const myLikeIndex = (m.likes || []).findIndex(l => l.userId == currentMyCharId);
        const isLiked = myLikeIndex !== -1;
        
        if (m.likes && m.likes.length > 0) {
            const names = m.likes.map(l => l.name);
            likesHtml = names.join('ï¼Œ');
        }

        // å¤„ç†è¯„è®ºæ˜¾ç¤ºï¼ˆæ”¯æŒå›å¤æ ¼å¼å’Œç‚¹å‡»å›å¤ï¼‰
        let commentsHtml = '';
        if (m.comments && m.comments.length > 0) {
            commentsHtml = m.comments.map((c, idx) => {
                const replyPart = c.replyTo ? ` å›å¤ <span class="comment-user">${escapeHtml(c.replyTo)}</span>` : '';
                const isMyComment = c.userId == currentMyCharId;
                // éè‡ªå·±çš„è¯„è®ºå¯ä»¥ç‚¹å‡»å›å¤
                const clickHandler = !isMyComment ? `onclick="replyToMomentComment(${m.id}, '${escapeHtml(c.name).replace(/'/g, "\\'")}', ${idx})"` : '';
                const cursorStyle = !isMyComment ? 'cursor:pointer;' : '';
                return `<div class="comment-item" ${clickHandler} style="${cursorStyle}">
                    <span class="comment-user">${escapeHtml(c.name)}</span>${replyPart}ï¼š<span class="comment-content">${escapeHtml(c.content)}</span>
                </div>`;
            }).join('');
        }

        const hasLikes = m.likes && m.likes.length > 0;
        const hasComments = m.comments && m.comments.length > 0;
        
        div.innerHTML = `
            <div class="moment-avatar" style="background-image:url(${char.avatar})"></div>
            <div class="moment-content">
                <div class="moment-name">${char.name}${pinnedBadge}</div>
                <div class="moment-text">${escapeHtml(m.content || '')}</div>
                ${imagesHtml}
                <div class="moment-meta">
                    <div style="display:flex; align-items:center;">
                        <span class="moment-time">${timeStr}</span>
                        ${delBtn}
                    </div>
                    <div class="moment-action-area">
                        <!-- å¼¹å‡ºèœå• -->
                        <div class="moment-popup-menu ins-style" id="moment-menu-${m.id}">
                            <div class="moment-menu-item" onclick="likeMoment(${m.id})">
                                <svg viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>
                                <span>${isLiked ? 'å–æ¶ˆ' : 'èµ'}</span>
                            </div>
                            <div class="moment-menu-divider"></div>
                            <div class="moment-menu-item" onclick="commentMoment(${m.id})">
                                <svg viewBox="0 0 24 24"><path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path></svg>
                                <span>è¯„è®º</span>
                            </div>
                        </div>
                        <div class="moment-action-btn" onclick="toggleMomentMenu(${m.id}, event)">
                            <div class="moment-action-dot"></div>
                            <div class="moment-action-dot"></div>
                        </div>
                    </div>
                </div>
                <!-- äº’åŠ¨åŒº -->
                <div class="moment-interactions" style="display: ${hasLikes || hasComments ? 'block' : 'none'}">
                    <div class="moment-likes" style="display: ${hasLikes ? 'flex' : 'none'}">
                        <svg viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>
                        <span>${likesHtml}</span>
                    </div>
                    <div class="moment-comments" style="display: ${hasComments ? 'block' : 'none'}">
                        ${commentsHtml}
                    </div>
                </div>
            </div>
        `;
        container.appendChild(div);
    }
}

// å°é¢æ›´æ¢
function changeMomentsCover() {
    document.getElementById('moments-cover-input').click();
}

function handleCoverChange(input) {
    const file = input.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = async (e) => {
        const base64 = e.target.result;
        document.getElementById('moments-cover-area').style.backgroundImage = `url(${base64})`;
        
        // ä¿å­˜åˆ°å½“å‰ User
        if (currentMyCharId) {
            const user = await db.characters.get(parseInt(currentMyCharId));
            if (user) {
                if (!user.identity) user.identity = {};
                user.identity.cover = base64;
                await db.characters.put(user);
            }
        }
        // åŒæ—¶ä¹Ÿå­˜ä¸€ä»½æœ¬åœ°ç¼“å­˜ï¼Œä½œä¸ºå…œåº•
        localStorage.setItem('moments_cover', base64);
    };
    reader.readAsDataURL(file);
    input.value = '';
}

// å‘å¸ƒåŠ¨æ€é€»è¾‘
let currentMomentPrivacy = 'public'; // é»˜è®¤å…¬å¼€

function showMomentsPublish() {
    document.getElementById('moments-publish-page').style.display = 'block';
    // æ¸…ç©º
    document.getElementById('moments-pub-text').value = '';
    const grid = document.getElementById('moments-pub-grid');
    // ä¿ç•™æ·»åŠ æŒ‰é’®ï¼Œç§»é™¤å›¾ç‰‡
    Array.from(grid.children).forEach(child => {
        if (!child.classList.contains('moments-add-btn')) {
            child.remove();
        }
    });
    window.tempPubImages = [];
    // é‡ç½®æƒé™ä¸ºå…¬å¼€
    currentMomentPrivacy = 'public';
    selectedPrivacyFriends = [];
    document.getElementById('privacy-selected-text').textContent = 'å…¬å¼€';
}

function hideMomentsPublish() {
    document.getElementById('moments-publish-page').style.display = 'none';
}

// æƒé™é€‰æ‹©ç›¸å…³
function showPrivacySelector() {
    document.getElementById('privacy-selector-page').style.display = 'block';
    // æ›´æ–°é€‰ä¸­çŠ¶æ€
    updatePrivacyCheckmarks();
}

function hidePrivacySelector() {
    document.getElementById('privacy-selector-page').style.display = 'none';
}

function selectPrivacy(value, text) {
    currentMomentPrivacy = value;
    document.getElementById('privacy-selected-text').textContent = text;
    updatePrivacyCheckmarks();
    hidePrivacySelector();
}

function updatePrivacyCheckmarks() {
    const options = ['public', 'private'];
    options.forEach(opt => {
        const checkEl = document.getElementById(`privacy-check-${opt}`);
        if (checkEl) {
            checkEl.textContent = (opt === currentMomentPrivacy) ? 'âœ“' : '';
        }
    });
    // æ›´æ–°éƒ¨åˆ†å¯è§å’Œä¸ç»™è°çœ‹çš„æè¿°
    const partialDesc = document.getElementById('partial-desc');
    const excludeDesc = document.getElementById('exclude-desc');
    if (partialDesc) {
        if (currentMomentPrivacy === 'partial' && selectedPrivacyFriends.length > 0) {
            partialDesc.textContent = `å·²é€‰ ${selectedPrivacyFriends.length} äºº`;
        } else {
            partialDesc.textContent = 'é€‰ä¸­çš„æœ‹å‹å¯è§';
        }
    }
    if (excludeDesc) {
        if (currentMomentPrivacy === 'exclude' && selectedPrivacyFriends.length > 0) {
            excludeDesc.textContent = `å·²é€‰ ${selectedPrivacyFriends.length} äºº`;
        } else {
            excludeDesc.textContent = 'é€‰ä¸­çš„æœ‹å‹ä¸å¯è§';
        }
    }
}

// å¥½å‹é€‰æ‹©ç›¸å…³
let selectedPrivacyFriends = []; // é€‰ä¸­çš„å¥½å‹IDåˆ—è¡¨
let currentPrivacyMode = ''; // 'partial' æˆ– 'exclude'

async function showFriendSelector(mode) {
    currentPrivacyMode = mode;
    const page = document.getElementById('friend-selector-page');
    const list = document.getElementById('friend-selector-list');
    const title = document.getElementById('friend-selector-title');
    
    title.textContent = mode === 'partial' ? 'è°å¯ä»¥çœ‹' : 'ä¸ç»™è°çœ‹';
    
    // å¦‚æœåˆ‡æ¢äº†æ¨¡å¼ï¼Œæ¸…ç©ºå·²é€‰æ‹©çš„
    if (currentMomentPrivacy !== mode) {
        selectedPrivacyFriends = [];
    }
    
    // è·å–å¥½å‹åˆ—è¡¨
    const accountId = getCurrentAccountId();
    const allChars = await db.characters.toArray();
    const friends = allChars.filter(char => {
        if (char.id == accountId) return false; // æ’é™¤è‡ªå·±
        const status = getFriendStatus(char, accountId);
        return status === 'friend';
    });
    
    list.innerHTML = '';
    
    if (friends.length === 0) {
        list.innerHTML = '<div style="padding:40px; text-align:center; color:#999;">æš‚æ— å¥½å‹</div>';
    } else {
        for (const friend of friends) {
            const isChecked = selectedPrivacyFriends.includes(friend.id);
            const item = document.createElement('div');
            item.className = 'friend-select-item';
            item.onclick = () => toggleFriendSelection(friend.id);
            item.innerHTML = `
                <div class="friend-select-checkbox ${isChecked ? 'checked' : ''}" id="friend-check-${friend.id}">
                    ${isChecked ? 'âœ“' : ''}
                </div>
                <div class="friend-select-avatar" style="background-image:url(${friend.avatar || ''})"></div>
                <div class="friend-select-name">${friend.remark || friend.wx_nickname || friend.name}</div>
            `;
            list.appendChild(item);
        }
    }
    
    page.style.display = 'block';
}

function hideFriendSelector() {
    document.getElementById('friend-selector-page').style.display = 'none';
}

function toggleFriendSelection(friendId) {
    const idx = selectedPrivacyFriends.indexOf(friendId);
    if (idx > -1) {
        selectedPrivacyFriends.splice(idx, 1);
    } else {
        selectedPrivacyFriends.push(friendId);
    }
    
    // æ›´æ–°UI
    const checkEl = document.getElementById(`friend-check-${friendId}`);
    if (checkEl) {
        const isChecked = selectedPrivacyFriends.includes(friendId);
        checkEl.className = `friend-select-checkbox ${isChecked ? 'checked' : ''}`;
        checkEl.textContent = isChecked ? 'âœ“' : '';
    }
}

function confirmFriendSelection() {
    if (selectedPrivacyFriends.length === 0) {
        alert('è¯·è‡³å°‘é€‰æ‹©ä¸€ä½å¥½å‹');
        return;
    }
    
    currentMomentPrivacy = currentPrivacyMode;
    const text = currentPrivacyMode === 'partial' ? `éƒ¨åˆ†å¯è§(${selectedPrivacyFriends.length}äºº)` : `ä¸ç»™è°çœ‹(${selectedPrivacyFriends.length}äºº)`;
    document.getElementById('privacy-selected-text').textContent = text;
    
    hideFriendSelector();
    hidePrivacySelector();
    updatePrivacyCheckmarks();
}

function handlePubImages(input) {
    const files = input.files;
    if (!files || files.length === 0) return;
    
    if (!window.tempPubImages) window.tempPubImages = [];
    
    const grid = document.getElementById('moments-pub-grid');
    const addBtn = grid.querySelector('.moments-add-btn');
    
    Array.from(files).forEach(file => {
        const reader = new FileReader();
        reader.onload = e => {
            const base64 = e.target.result;
            window.tempPubImages.push(base64);
            
            const div = document.createElement('div');
            div.className = 'moments-pub-img';
            div.style.backgroundImage = `url(${base64})`;
            div.innerHTML = `<div class="moments-pub-img-del" onclick="removePubImage(this, '${base64}')">Ã—</div>`;
            
            grid.insertBefore(div, addBtn);
        };
        reader.readAsDataURL(file);
    });
    
    input.value = '';
}

function removePubImage(el, base64) {
    el.parentElement.remove();
    const idx = window.tempPubImages.indexOf(base64);
    if (idx > -1) window.tempPubImages.splice(idx, 1);
}

async function doPublishMoment() {
    if (!currentMyCharId) {
        alert("è¯·å…ˆè®¾ç½® User èº«ä»½");
        return;
    }
    
    const text = document.getElementById('moments-pub-text').value.trim();
    const images = window.tempPubImages || [];
    
    if (!text && images.length === 0) {
        alert("å†™ç‚¹ä»€ä¹ˆå§...");
        return;
    }
    
    const momentId = await db.moments.add({
        userId: parseInt(currentMyCharId),
        content: text,
        images: images,
        time: Date.now(),
        ownerUserId: parseInt(currentMyCharId), // æ ‡è®°æ‰€å±è´¦å·
        privacy: currentMomentPrivacy, // ä¿å­˜æƒé™è®¾ç½®
        privacyList: selectedPrivacyFriends.slice(), // ä¿å­˜é€‰ä¸­çš„å¥½å‹åˆ—è¡¨
        likes: [],
        comments: []
    });
    
    hideMomentsPublish();
    renderMomentsList();
    renderMyMomentsList();
    
    // æ»šåŠ¨åˆ°é¡¶éƒ¨
    document.getElementById('moments-page').scrollTop = 0;
    
    // âœ… è§¦å‘å¥½å‹è‡ªåŠ¨ç‚¹èµè¯„è®ºï¼ˆå»¶è¿Ÿæ‰§è¡Œï¼Œæ¨¡æ‹ŸçœŸå®åœºæ™¯ï¼‰
    setTimeout(() => {
        generateFriendInteractions(momentId, currentMomentPrivacy, selectedPrivacyFriends.slice());
    }, 2000);
}

// âœ… ç”Ÿæˆå¥½å‹è‡ªåŠ¨ç‚¹èµè¯„è®ºï¼ˆè°ƒç”¨AIï¼‰
async function generateFriendInteractions(momentId, privacy, privacyList) {
    try {
        const moment = await db.moments.get(momentId);
        if (!moment) return;
        
        const accountId = getCurrentAccountId();
        const myChar = await db.characters.get(parseInt(currentMyCharId));
        const myName = myChar?.name || 'æˆ‘';
        
        // è·å–æ‰€æœ‰å¥½å‹ï¼ˆæ’é™¤è”æœºå¥½å‹ï¼‰
        const allChars = await db.characters.toArray();
        let friends = allChars.filter(c => {
            if (c.type === 'user') return false;
            if (c.isOnlineFriend === true) return false; // æ’é™¤è”æœºå¥½å‹
            const status = getFriendStatus(c, accountId);
            return status === 'friend';
        });
        
        // âœ… æ ¹æ®æƒé™è¿‡æ»¤å¥½å‹
        if (privacy === 'partial' && privacyList.length > 0) {
            // éƒ¨åˆ†å¯è§ï¼šåªæœ‰ privacyList ä¸­çš„å¥½å‹å¯ä»¥çœ‹åˆ°
            friends = friends.filter(f => privacyList.includes(f.id));
        } else if (privacy === 'exclude' && privacyList.length > 0) {
            // ä¸ç»™è°çœ‹ï¼šæ’é™¤ privacyList ä¸­çš„å¥½å‹
            friends = friends.filter(f => !privacyList.includes(f.id));
        } else if (privacy === 'private') {
            // ç§å¯†ï¼šæ²¡æœ‰å¥½å‹å¯ä»¥çœ‹åˆ°
            friends = [];
        }
        
        if (friends.length === 0) {
            console.log('[æœ‹å‹åœˆäº’åŠ¨] æ²¡æœ‰å¯è§çš„å¥½å‹ï¼Œè·³è¿‡ç”Ÿæˆäº’åŠ¨');
            return;
        }
        
        console.log(`[æœ‹å‹åœˆäº’åŠ¨] å¼€å§‹ç”Ÿæˆï¼Œå¯è§å¥½å‹: ${friends.length}äºº`);
        
        // éšæœºé€‰æ‹©å¥½å‹æ¥ç‚¹èµï¼ˆ50%-90%çš„å¯è§å¥½å‹ï¼‰
        const likeRatio = 0.5 + Math.random() * 0.4;
        const shuffledForLikes = [...friends].sort(() => Math.random() - 0.5);
        const likersCount = Math.max(1, Math.floor(shuffledForLikes.length * likeRatio));
        const likers = shuffledForLikes.slice(0, likersCount);
        
        // æ‰€æœ‰å¯è§å¥½å‹éƒ½æ¥è¯„è®ºï¼ˆæ‰“ä¹±é¡ºåºè®©è¯„è®ºæ›´è‡ªç„¶ï¼‰
        const commenters = [...friends].sort(() => Math.random() - 0.5);
        
        // ç”Ÿæˆç‚¹èµï¼ˆä½¿ç”¨å¾®ä¿¡æ˜¾ç¤ºåï¼‰
        const likes = likers.map(f => ({
            userId: f.id,
            name: f.remark || f.wx_nickname || f.name
        }));
        
        // âœ… è°ƒç”¨AIç”Ÿæˆè¯„è®º
        const comments = [];
        
        if (commenters.length > 0) {
            try {
                // åˆ†æ‰¹å¤„ç†ï¼ˆæ¯æ‰¹æœ€å¤š15äººï¼Œé¿å…AI tokenæº¢å‡ºï¼‰
                const BATCH_SIZE = 15;
                const batches = [];
                for (let i = 0; i < commenters.length; i += BATCH_SIZE) {
                    batches.push(commenters.slice(i, i + BATCH_SIZE));
                }
                
                for (const batch of batches) {
                    try {
                        // æ„å»ºè§’è‰²ä¿¡æ¯ï¼ˆä½¿ç”¨å¾®ä¿¡æ˜¾ç¤ºåï¼‰
                        const commenterInfos = batch.map(c => {
                            const displayName = c.remark || c.wx_nickname || c.name;
                            return `- ${displayName}ï¼š${c.description || c.personality || 'æ™®é€šæœ‹å‹'}`;
                        }).join('\n');
                        
                        const batchPrompt = `${myName} å‘äº†ä¸€æ¡æœ‹å‹åœˆï¼š
"${moment.content}"
${moment.images?.length > 0 || moment.imageCount > 0 ? `ï¼ˆé™„å¸¦${moment.imageCount || moment.images.length}å¼ å›¾ç‰‡${moment.imageDesc ? 'ï¼š' + moment.imageDesc : ''}ï¼‰` : ''}

ä»¥ä¸‹å¥½å‹çœ‹åˆ°äº†è¿™æ¡æœ‹å‹åœˆï¼Œè¯·ä¸ºæ¯ä¸ªäººç”Ÿæˆä¸€æ¡ç¬¦åˆå…¶æ€§æ ¼çš„è¯„è®ºï¼š
${commenterInfos}

è¦æ±‚ï¼š
1. æ¯æ¡è¯„è®ºç®€çŸ­è‡ªç„¶ï¼ˆ3-20å­—ï¼‰
2. å¯ä»¥ç”¨è¡¨æƒ…ã€è¯­æ°”è¯
3. ç¬¦åˆæ¯ä¸ªè§’è‰²çš„æ€§æ ¼ç‰¹ç‚¹
4. é¼“åŠ±å¥½å‹ä¹‹é—´äº’ç›¸å›å¤ï¼ˆä½¿ç”¨ replyTo å­—æ®µæŒ‡å®šå›å¤çš„äººåï¼‰
5. ä¸æ˜¯æ‰€æœ‰äººéƒ½è¦äº’ç›¸å›å¤ï¼Œä½†è‡³å°‘æœ‰ä¸€äº›å¥½å‹ä¹‹é—´ä¼šæœ‰å¯¹è¯

è¯·è¿”å›JSONæ•°ç»„æ ¼å¼ï¼š
[{"name": "è§’è‰²å", "content": "è¯„è®ºå†…å®¹"}, {"name": "è§’è‰²å", "replyTo": "è¢«å›å¤çš„è§’è‰²å", "content": "å›å¤å†…å®¹"}, ...]`;

                        const result = await callAI([
                            { role: 'system', content: 'ä½ æ˜¯ä¸€ä¸ªç¤¾äº¤åª’ä½“è¯„è®ºç”ŸæˆåŠ©æ‰‹ï¼Œåªè¿”å›JSONæ•°ç»„ï¼Œä¸è¦ä»»ä½•å…¶ä»–æ–‡å­—ã€‚' },
                            { role: 'user', content: batchPrompt }
                        ]);
                        
                        // è§£æç»“æœ
                        let aiComments = [];
                        try {
                            let cleanResult = result.trim();
                            if (cleanResult.startsWith('```')) {
                                cleanResult = cleanResult.replace(/```json?\n?/g, '').replace(/```$/g, '').trim();
                            }
                            aiComments = JSON.parse(cleanResult);
                        } catch (e) {
                            console.warn('[æœ‹å‹åœˆäº’åŠ¨] AIè¯„è®ºè§£æå¤±è´¥ï¼ˆæ‰¹æ¬¡ï¼‰ï¼Œä½¿ç”¨é¢„è®¾è¯„è®º');
                        }
                        
                        // å°†AIç”Ÿæˆçš„è¯„è®ºæ·»åŠ åˆ°åˆ—è¡¨ï¼ˆåŒ¹é…æ˜¾ç¤ºåï¼‰
                        for (const aiComment of aiComments) {
                            const commenter = batch.find(c => {
                                const displayName = c.remark || c.wx_nickname || c.name;
                                return displayName === aiComment.name || c.name === aiComment.name;
                            });
                            if (commenter && aiComment.content) {
                                const commentObj = {
                                    userId: commenter.id,
                                    name: commenter.remark || commenter.wx_nickname || commenter.name,
                                    content: aiComment.content,
                                    time: Date.now() + Math.random() * 60000
                                };
                                // æ”¯æŒå¥½å‹ä¹‹é—´äº’ç›¸å›å¤
                                if (aiComment.replyTo) {
                                    commentObj.replyTo = aiComment.replyTo;
                                }
                                comments.push(commentObj);
                            }
                        }
                    } catch (batchError) {
                        console.warn('[æœ‹å‹åœˆäº’åŠ¨] æ‰¹æ¬¡AIè°ƒç”¨å¤±è´¥:', batchError);
                    }
                }
                
            } catch (apiError) {
                console.warn('[æœ‹å‹åœˆäº’åŠ¨] AIè°ƒç”¨å¤±è´¥ï¼Œä½¿ç”¨é¢„è®¾è¯„è®º:', apiError);
            }
        }
        
        // å¦‚æœAIç”Ÿæˆå¤±è´¥ï¼Œä½¿ç”¨é¢„è®¾è¯„è®º
        if (comments.length === 0 && commenters.length > 0) {
            const presetComments = [
                'ğŸ‘', 'â¤ï¸', 'å¤ªæ£’äº†ï¼', 'çœŸå¥½çœ‹~', 'å“‡ï¼', 'èµï¼',
                'ç¾¡æ…•ï¼', 'å‰å®³å•Š', 'å¤ªç¾äº†', 'ğŸ”¥', 'ç»äº†', 'çˆ±äº†'
            ];
            for (const commenter of commenters) {
                comments.push({
                    userId: commenter.id,
                    name: commenter.remark || commenter.wx_nickname || commenter.name,
                    content: presetComments[Math.floor(Math.random() * presetComments.length)],
                    time: Date.now() + Math.random() * 60000
                });
            }
        }
        
        // æ›´æ–°æœ‹å‹åœˆ
        moment.likes = likes;
        moment.comments = comments;
        await db.moments.put(moment);
        
        console.log(`[æœ‹å‹åœˆäº’åŠ¨] ç”Ÿæˆå®Œæˆ: ${likes.length}ä¸ªç‚¹èµ, ${comments.length}æ¡è¯„è®º`);
        
        // åˆ·æ–°æ˜¾ç¤º
        renderMomentsList();
        
    } catch (error) {
        console.error('[æœ‹å‹åœˆäº’åŠ¨] ç”Ÿæˆå¤±è´¥:', error);
    }
}

async function deleteMoment(id) {
    if (confirm("ç¡®å®šåˆ é™¤è¿™æ¡åŠ¨æ€å—ï¼Ÿ")) {
        await db.moments.delete(id);
        renderMomentsList();
    }
}

// ğŸ¯ è§’è‰²å‘å¸ƒæœ‹å‹åœˆï¼ˆç”±AIè§¦å‘ï¼‰
async function publishMomentsByCharacter(char, content, imageCount = 0, imageDesc = '') {
    // è·å–å½“å‰ç”¨æˆ·IDï¼ˆç”¨äºownerUserIdï¼Œç¡®ä¿æ•°æ®éš”ç¦»æ­£ç¡®ï¼‰
    const currentAccountId = getCurrentAccountId();
    
    const momentData = {
        userId: char.id, // å‘å¸ƒè€…æ˜¯è§’è‰²
        content: content,
        images: [], // ä¸å†ä½¿ç”¨éšæœºå›¾ç‰‡URL
        imageCount: imageCount, // ä¿ç•™å›¾ç‰‡æ•°é‡ä¿¡æ¯
        imageDesc: imageDesc || '', // å›¾ç‰‡æè¿°ï¼Œç”¨äºå¡ç‰‡å±•ç¤º
        time: Date.now(),
        ownerUserId: currentAccountId || char.id,
        likes: [],
        comments: []
    };
    
    const momentId = await db.moments.add(momentData);
    
    console.log(`[Moments] ${char.name} å‘å¸ƒäº†æœ‹å‹åœˆ: ${content}${imageCount > 0 ? ` [é…å›¾${imageCount}å¼ : ${imageDesc}]` : ''}`);
    
    // å¦‚æœå½“å‰åœ¨æœ‹å‹åœˆé¡µé¢ï¼Œåˆ·æ–°åˆ—è¡¨
    const momentsPage = document.getElementById('moments-page');
    if (momentsPage && momentsPage.style.display !== 'none') {
        renderMomentsList();
    }
    
    // ğŸ”¥ è§¦å‘å…±åŒå¥½å‹NPCè‡ªåŠ¨è¯„è®ºï¼ˆå»¶è¿Ÿæ‰§è¡Œï¼Œä¸é˜»å¡å‘å¸ƒæµç¨‹ï¼‰
    setTimeout(() => {
        triggerMutualFriendComments(momentId);
    }, 2000);
}

// ğŸ§ª æµ‹è¯•å‡½æ•°ï¼šæ‰‹åŠ¨è®©å½“å‰èŠå¤©è§’è‰²å‘å¸ƒæœ‹å‹åœˆ
window.testPublishMoments = async function() {
    if (!currentChatCharId) {
        alert('è¯·å…ˆæ‰“å¼€ä¸€ä¸ªèŠå¤©');
        return;
    }
    const char = await db.characters.get(currentChatCharId);
    if (!char) {
        alert('æ‰¾ä¸åˆ°è§’è‰²');
        return;
    }
    
    await publishMomentsByCharacter(char, 'è¿™æ˜¯ä¸€æ¡æµ‹è¯•æœ‹å‹åœˆ~', 1, 'ä¸€å¼ æµ‹è¯•å›¾ç‰‡');
    alert('æœ‹å‹åœˆå‘å¸ƒæˆåŠŸï¼è¯·æŸ¥çœ‹æœ‹å‹åœˆé¡µé¢');
};

// æœ‹å‹åœˆå›¾ç‰‡æè¿°å¼¹çª—
function showMomentImageDesc(desc) {
    if (!desc) {
        showToast('æš‚æ— å›¾ç‰‡æè¿°');
        return;
    }
    const overlay = document.createElement('div');
    overlay.className = 'moment-img-desc-overlay';
    overlay.onclick = () => overlay.remove();
    overlay.innerHTML = `
        <div class="moment-img-desc-content" onclick="event.stopPropagation()">
            <svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
            <p>${escapeHtml(desc)}</p>
            <div class="close-hint">ç‚¹å‡»ç©ºç™½å¤„å…³é—­</div>
        </div>
    `;
    document.body.appendChild(overlay);
}

// ç®€å•çš„é¢„è§ˆå›¾ç‰‡
function previewImage(url) {
    // ç®€å•å…¨å±é¢„è§ˆ
    const div = document.createElement('div');
    div.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:9999;display:flex;align-items:center;justify-content:center;';
    div.innerHTML = `<img src="${url}" style="max-width:100%;max-height:100%;">`;
    div.onclick = () => div.remove();
    document.body.appendChild(div);
}

// æœ‹å‹åœˆäº¤äº’é€»è¾‘
let activeMomentMenuId = null;

function toggleMomentMenu(id, e) {
    e.stopPropagation(); // é˜»æ­¢å†’æ³¡
    
    // å¦‚æœå·²ç»æ‰“å¼€äº†åˆ«çš„ï¼Œå…ˆå…³é—­åˆ«çš„
    if (activeMomentMenuId && activeMomentMenuId !== id) {
        const prev = document.getElementById(`moment-menu-${activeMomentMenuId}`);
        if (prev) prev.classList.remove('show');
    }
    
    const menu = document.getElementById(`moment-menu-${id}`);
    if (menu) {
        if (menu.classList.contains('show')) {
            menu.classList.remove('show');
            activeMomentMenuId = null;
        } else {
            menu.classList.add('show');
            activeMomentMenuId = id;
            
            // ç»‘å®šä¸€æ¬¡æ€§å…¨å±€ç‚¹å‡»äº‹ä»¶æ¥å…³é—­èœå•
            document.addEventListener('click', closeMomentMenuOutside, { once: true });
        }
    }
}

function closeMomentMenuOutside(e) {
    if (activeMomentMenuId) {
        const menu = document.getElementById(`moment-menu-${activeMomentMenuId}`);
        if (menu && !menu.contains(e.target)) {
            menu.classList.remove('show');
            activeMomentMenuId = null;
        }
    }
}

async function likeMoment(id) {
    // ç«‹å³å…³é—­èœå•
    const menu = document.getElementById(`moment-menu-${id}`);
    if (menu) menu.classList.remove('show');
    activeMomentMenuId = null;

    if (!currentMyCharId) return;
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    const moment = await db.moments.get(id);
    
    if (user && moment) {
        if (!moment.likes) moment.likes = [];
        
        const idx = moment.likes.findIndex(l => l.userId == user.id);
        if (idx > -1) {
            // å–æ¶ˆç‚¹èµ
            moment.likes.splice(idx, 1);
        } else {
            // ç‚¹èµ
            moment.likes.push({ userId: user.id, name: user.name });
        }
        
        await db.moments.put(moment);
        renderMomentsList(); // åˆ·æ–°åˆ—è¡¨
    }
}

async function commentMoment(id) {
    // ç«‹å³å…³é—­èœå•
    const menu = document.getElementById(`moment-menu-${id}`);
    if (menu) menu.classList.remove('show');
    activeMomentMenuId = null;

    if (!currentMyCharId) return;
    
    // ä½¿ç”¨ setTimeout è®©èœå•å…ˆå…³é—­ï¼Œå†å¼¹å‡º prompt
    setTimeout(async () => {
        const content = prompt("è¯·è¾“å…¥è¯„è®ºå†…å®¹ï¼š");
        if (content && content.trim()) {
            const user = await db.characters.get(parseInt(currentMyCharId));
            const moment = await db.moments.get(id);
            
            if (user && moment) {
                if (!moment.comments) moment.comments = [];
                
                moment.comments.push({
                    userId: user.id,
                    name: user.name,
                    content: content.trim(),
                    time: Date.now()
                });
                
                await db.moments.put(moment);
                renderMomentsList(); // åˆ·æ–°åˆ—è¡¨
                
                // ğŸ”¥ è§¦å‘æœ‹å‹åœˆå‘å¸ƒè€…AIå›å¤ç”¨æˆ·çš„è¯„è®º
                generateMomentOwnerReply(id, user.name, content.trim());
            }
        }
    }, 50);
}

// å›å¤æœ‹å‹åœˆä¸­æŸä¸ªè§’è‰²çš„è¯„è®º
async function replyToMomentComment(momentId, replyToName, commentIdx) {
    if (!currentMyCharId) return;
    
    setTimeout(async () => {
        const content = prompt(`å›å¤ ${replyToName}ï¼š`);
        if (content && content.trim()) {
            const user = await db.characters.get(parseInt(currentMyCharId));
            const moment = await db.moments.get(momentId);
            
            if (user && moment) {
                if (!moment.comments) moment.comments = [];
                
                // æ·»åŠ ç”¨æˆ·çš„å›å¤
                moment.comments.push({
                    userId: user.id,
                    name: user.name,
                    replyTo: replyToName,
                    content: content.trim(),
                    time: Date.now()
                });
                
                await db.moments.put(moment);
                renderMomentsList();
                
                // è§¦å‘è¢«å›å¤çš„è§’è‰²è‡ªåŠ¨å›å¤
                generateReplyToUserComment(momentId, replyToName, content.trim());
            }
        }
    }, 50);
}

// AIç”Ÿæˆè§’è‰²å¯¹ç”¨æˆ·å›å¤çš„å†å›å¤
async function generateReplyToUserComment(momentId, charName, userComment) {
    try {
        const moment = await db.moments.get(momentId);
        if (!moment) return;
        
        const accountId = getCurrentAccountId();
        const myChar = await db.characters.get(parseInt(currentMyCharId));
        const myName = myChar?.name || 'æˆ‘';
        
        // æ‰¾åˆ°è¿™ä¸ªè§’è‰²
        const allChars = await db.characters.toArray();
        const targetChar = allChars.find(c => {
            const displayName = c.remark || c.wx_nickname || c.name;
            return displayName === charName || c.name === charName;
        });
        
        if (!targetChar) return;
        
        // æ‰¾åˆ°è§’è‰²ä¹‹å‰åœ¨è¿™æ¡æœ‹å‹åœˆä¸‹çš„è¯„è®º
        const charPrevComments = (moment.comments || [])
            .filter(c => {
                const cName = c.name;
                return cName === charName;
            })
            .map(c => c.content)
            .join('ï¼›');
        
        const prompt = `ä½ æ˜¯ ${targetChar.name}ï¼Œä½ åœ¨ ${myName} çš„æœ‹å‹åœˆä¸‹è¯„è®ºäº†ï¼š"${charPrevComments}"
${myName} å›å¤äº†ä½ ï¼š"${userComment}"

è¯·ä»¥ ${targetChar.name} çš„èº«ä»½ï¼Œç”¨ç®€çŸ­è‡ªç„¶çš„è¯­æ°”å†å›å¤ ${myName}ï¼ˆ3-20å­—ï¼Œå¯ä»¥ç”¨è¡¨æƒ…ã€è¯­æ°”è¯ï¼‰ã€‚

äººè®¾å‚è€ƒï¼š${targetChar.description || targetChar.personality || 'æ™®é€šæœ‹å‹'}

åªè¿”å›å›å¤å†…å®¹ï¼Œä¸è¦JSONï¼Œä¸è¦å¼•å·ã€‚`;
        
        const result = await callAI([
            { role: 'system', content: 'ä½ æ˜¯ä¸€ä¸ªç¤¾äº¤åª’ä½“è¯„è®ºè§’è‰²æ‰®æ¼”åŠ©æ‰‹ï¼Œç›´æ¥è¿”å›å›å¤å†…å®¹ï¼Œä¸è¦ä»»ä½•æ ¼å¼æ ‡è®°ã€‚' },
            { role: 'user', content: prompt }
        ]);
        
        const replyContent = result.trim().replace(/^["'"]|["'"]$/g, '');
        if (replyContent) {
            // é‡æ–°è·å–æœ€æ–°çš„momentï¼ˆé˜²æ­¢å¹¶å‘ä¿®æ”¹ï¼‰
            const freshMoment = await db.moments.get(momentId);
            if (freshMoment) {
                if (!freshMoment.comments) freshMoment.comments = [];
                freshMoment.comments.push({
                    userId: targetChar.id,
                    name: targetChar.remark || targetChar.wx_nickname || targetChar.name,
                    replyTo: myName,
                    content: replyContent,
                    time: Date.now()
                });
                await db.moments.put(freshMoment);
                renderMomentsList();
            }
        }
    } catch (err) {
        console.error('[æœ‹å‹åœˆå›å¤] AIå›å¤ç”Ÿæˆå¤±è´¥:', err);
    }
}

// ğŸ”¥ æœ‹å‹åœˆå‘å¸ƒè€…AIå›å¤ç”¨æˆ·çš„è¯„è®º
async function generateMomentOwnerReply(momentId, userName, userComment) {
    try {
        const moment = await db.moments.get(momentId);
        if (!moment) return;
        
        // æ‰¾åˆ°å‘å¸ƒè€…
        const ownerChar = await db.characters.get(moment.userId);
        if (!ownerChar) return;
        
        // å¦‚æœå‘å¸ƒè€…æ˜¯ç”¨æˆ·è‡ªå·±ï¼Œä¸éœ€è¦AIå›å¤
        if (parseInt(currentMyCharId) === ownerChar.id) return;
        
        const myChar = await db.characters.get(parseInt(currentMyCharId));
        const myName = myChar?.name || userName;
        
        // è·å–å·²æœ‰çš„æ‰€æœ‰è¯„è®ºï¼Œç”¨äºä¸Šä¸‹æ–‡
        const existingComments = (moment.comments || []).map(c => {
            const replyPart = c.replyTo ? ` å›å¤ ${c.replyTo}` : '';
            return `${c.name}${replyPart}ï¼š${c.content}`;
        }).join('\n');
        
        const promptText = `ä½ æ˜¯ ${ownerChar.name}ï¼Œä½ å‘äº†ä¸€æ¡æœ‹å‹åœˆï¼š"${moment.content}"

${existingComments ? `æœ‹å‹åœˆä¸‹å·²æœ‰çš„è¯„è®ºï¼š\n${existingComments}\n` : ''}
${myName} è¯„è®ºäº†ä½ çš„æœ‹å‹åœˆï¼š"${userComment}"

è¯·ä»¥ ${ownerChar.name} çš„èº«ä»½å›å¤ ${myName} çš„è¯„è®ºã€‚è¦æ±‚ï¼š
- ç®€çŸ­è‡ªç„¶ï¼ˆ3-30å­—ï¼‰
- ç¬¦åˆä½ çš„æ€§æ ¼å’Œè¯´è¯é£æ ¼
- å¯ä»¥ç”¨è¡¨æƒ…ã€è¯­æ°”è¯
- åƒçœŸäººå›å¤æœ‹å‹åœˆè¯„è®ºä¸€æ ·éšæ„

äººè®¾å‚è€ƒï¼š${ownerChar.description || ownerChar.personality || ''}

åªè¿”å›å›å¤å†…å®¹ï¼Œä¸è¦JSONï¼Œä¸è¦å¼•å·ã€‚`;
        
        // å»¶è¿Ÿ2-5ç§’åå›å¤ï¼Œæ¨¡æ‹ŸçœŸäºº
        const delay = 2000 + Math.random() * 3000;
        await new Promise(r => setTimeout(r, delay));
        
        const result = await callAI([
            { role: 'system', content: 'ä½ æ˜¯ä¸€ä¸ªç¤¾äº¤åª’ä½“è¯„è®ºè§’è‰²æ‰®æ¼”åŠ©æ‰‹ï¼Œç›´æ¥è¿”å›å›å¤å†…å®¹ï¼Œä¸è¦ä»»ä½•æ ¼å¼æ ‡è®°ã€‚' },
            { role: 'user', content: promptText }
        ]);
        
        const replyContent = result.trim().replace(/^["'"""]+|["'"""]+$/g, '');
        if (replyContent) {
            const freshMoment = await db.moments.get(momentId);
            if (freshMoment) {
                if (!freshMoment.comments) freshMoment.comments = [];
                freshMoment.comments.push({
                    userId: ownerChar.id,
                    name: ownerChar.remark || ownerChar.wx_nickname || ownerChar.name,
                    replyTo: myName,
                    content: replyContent,
                    time: Date.now()
                });
                await db.moments.put(freshMoment);
                renderMomentsList();
                console.log(`[æœ‹å‹åœˆ] ${ownerChar.name} å›å¤äº† ${myName} çš„è¯„è®º: ${replyContent}`);
            }
        }
    } catch (err) {
        console.error('[æœ‹å‹åœˆ] å‘å¸ƒè€…AIå›å¤å¤±è´¥:', err);
    }
}

// ğŸ”¥ å…±åŒå¥½å‹NPCè‡ªåŠ¨è¯„è®ºæœ‹å‹åœˆ
async function triggerMutualFriendComments(momentId) {
    try {
        const moment = await db.moments.get(momentId);
        if (!moment) return;
        
        // å¦‚æœå·²ç»è§¦å‘è¿‡NPCè¯„è®ºï¼Œè·³è¿‡ï¼ˆé˜²æ­¢é‡å¤ï¼‰
        if (moment._npcCommented) return;
        
        const accountId = getCurrentAccountId();
        if (!accountId) return;
        
        // æ‰¾åˆ°å‘å¸ƒè€…
        const ownerChar = await db.characters.get(moment.userId);
        if (!ownerChar) return;
        
        // è·å–å‘å¸ƒè€…çš„å…³è”è§’è‰²/NPC
        const relationships = ownerChar.relationships || [];
        if (relationships.length === 0) return;
        
        // æ‰¾åˆ°åŒæ—¶ä¹Ÿæ˜¯ç”¨æˆ·å¥½å‹çš„NPCï¼ˆå…±åŒå¥½å‹ï¼‰
        const allChars = await db.characters.toArray();
        const mutualFriends = [];
        
        for (const rel of relationships) {
            if (!rel.targetId) continue;
            const npc = allChars.find(c => c.id === rel.targetId);
            if (!npc) continue;
            
            // æ£€æŸ¥è¿™ä¸ªNPCæ˜¯å¦ä¹Ÿæ˜¯ç”¨æˆ·çš„å¥½å‹
            const friendStatus = getFriendStatus(npc, accountId);
            if (friendStatus === 'friend') {
                mutualFriends.push({ npc, relation: rel.relation, desc: rel.desc || '' });
            }
        }
        
        if (mutualFriends.length === 0) return;
        
        console.log(`[æœ‹å‹åœˆNPC] å‘ç° ${mutualFriends.length} ä¸ªå…±åŒå¥½å‹å¯ä»¥è¯„è®º ${ownerChar.name} çš„æœ‹å‹åœˆ`);
        
        // æ ‡è®°å·²è§¦å‘NPCè¯„è®º
        const markMoment = await db.moments.get(momentId);
        if (markMoment) {
            markMoment._npcCommented = true;
            await db.moments.put(markMoment);
        }
        
        // éšæœºé€‰å–1-3ä¸ªNPCæ¥è¯„è®ºï¼ˆä¸æ˜¯æ‰€æœ‰äººéƒ½ä¼šè¯„è®ºï¼‰
        const shuffled = mutualFriends.sort(() => Math.random() - 0.5);
        const commentCount = Math.min(shuffled.length, 1 + Math.floor(Math.random() * 3));
        const selectedNPCs = shuffled.slice(0, commentCount);
        
        // æ¯ä¸ªNPCä¾æ¬¡è¯„è®ºï¼Œé—´éš”3-8ç§’
        for (let i = 0; i < selectedNPCs.length; i++) {
            const { npc, relation } = selectedNPCs[i];
            
            // å»¶è¿Ÿï¼šç¬¬ä¸€ä¸ª3-6ç§’ï¼Œåç»­å†åŠ 3-6ç§’
            const delay = (3000 + Math.random() * 3000) * (i + 1);
            
            setTimeout(async () => {
                try {
                    const freshMoment = await db.moments.get(momentId);
                    if (!freshMoment) return;
                    
                    // å·²æœ‰è¯„è®ºä¸Šä¸‹æ–‡
                    const existingComments = (freshMoment.comments || []).map(c => {
                        const replyPart = c.replyTo ? ` å›å¤ ${c.replyTo}` : '';
                        return `${c.name}${replyPart}ï¼š${c.content}`;
                    }).join('\n');
                    
                    const promptText = `ä½ æ˜¯ ${npc.name}ï¼Œä½ å’Œ ${ownerChar.name} çš„å…³ç³»æ˜¯ï¼š${relation}ã€‚
${ownerChar.name} å‘äº†ä¸€æ¡æœ‹å‹åœˆï¼š"${freshMoment.content}"

${existingComments ? `å·²æœ‰è¯„è®ºï¼š\n${existingComments}\n` : ''}
è¯·ä»¥ ${npc.name} çš„èº«ä»½è¯„è®ºè¿™æ¡æœ‹å‹åœˆã€‚è¦æ±‚ï¼š
- ç®€çŸ­è‡ªç„¶ï¼ˆ2-25å­—ï¼‰
- ç¬¦åˆä½ å’Œ ${ownerChar.name} çš„å…³ç³»ï¼ˆ${relation}ï¼‰
- å¯ä»¥ç”¨è¡¨æƒ…ã€è¯­æ°”è¯ã€è°ƒä¾ƒã€å¤¸èµã€åæ§½ç­‰
- åƒçœŸäººåœ¨æœ‹å‹åœˆä¸‹è¯„è®ºä¸€æ ·éšæ„
- ä¸éœ€è¦æ¯æ¬¡éƒ½å¾ˆæ­£ç»ï¼Œå¶å°”å¯ä»¥çš®ä¸€ä¸‹

ä½ çš„äººè®¾ï¼š${npc.description || npc.personality || ''}

åªè¿”å›è¯„è®ºå†…å®¹ï¼Œä¸è¦JSONï¼Œä¸è¦å¼•å·ã€‚`;
                    
                    const result = await callAI([
                        { role: 'system', content: 'ä½ æ˜¯ä¸€ä¸ªç¤¾äº¤åª’ä½“è¯„è®ºè§’è‰²æ‰®æ¼”åŠ©æ‰‹ï¼Œç›´æ¥è¿”å›è¯„è®ºå†…å®¹ï¼Œä¸è¦ä»»ä½•æ ¼å¼æ ‡è®°ã€‚' },
                        { role: 'user', content: promptText }
                    ]);
                    
                    const commentContent = result.trim().replace(/^["'"""]+|["'"""]+$/g, '');
                    if (commentContent) {
                        const latestMoment = await db.moments.get(momentId);
                        if (latestMoment) {
                            if (!latestMoment.comments) latestMoment.comments = [];
                            latestMoment.comments.push({
                                userId: npc.id,
                                name: npc.remark || npc.wx_nickname || npc.name,
                                content: commentContent,
                                time: Date.now()
                            });
                            await db.moments.put(latestMoment);
                            renderMomentsList();
                            console.log(`[æœ‹å‹åœˆNPC] ${npc.name}(${relation}) è¯„è®ºäº† ${ownerChar.name} çš„æœ‹å‹åœˆ: ${commentContent}`);
                        }
                    }
                } catch (err) {
                    console.error(`[æœ‹å‹åœˆNPC] ${npc.name} è¯„è®ºç”Ÿæˆå¤±è´¥:`, err);
                }
            }, delay);
        }
        
        // éƒ¨åˆ†NPCä¹Ÿå¯èƒ½ç‚¹èµï¼ˆéšæœº50%æ¦‚ç‡ï¼‰
        for (const { npc } of mutualFriends) {
            if (Math.random() < 0.5) {
                const likeDelay = 1000 + Math.random() * 5000;
                setTimeout(async () => {
                    try {
                        const latestMoment = await db.moments.get(momentId);
                        if (!latestMoment) return;
                        if (!latestMoment.likes) latestMoment.likes = [];
                        // æ£€æŸ¥æ˜¯å¦å·²ç»ç‚¹èµ
                        if (latestMoment.likes.some(l => l.userId === npc.id)) return;
                        latestMoment.likes.push({
                            userId: npc.id,
                            name: npc.remark || npc.wx_nickname || npc.name
                        });
                        await db.moments.put(latestMoment);
                        renderMomentsList();
                        console.log(`[æœ‹å‹åœˆNPC] ${npc.name} ç‚¹èµäº† ${ownerChar.name} çš„æœ‹å‹åœˆ`);
                    } catch (e) {}
                }, likeDelay);
            }
        }
    } catch (err) {
        console.error('[æœ‹å‹åœˆNPC] å…±åŒå¥½å‹è¯„è®ºè§¦å‘å¤±è´¥:', err);
    }
}

// æ˜¾ç¤º"æˆ‘çš„æœ‹å‹åœˆ"é¡µé¢
async function showMyMomentsPage() {
    const page = document.getElementById('my-moments-page');
    page.style.display = 'block';
    page.offsetHeight;
    page.classList.add('slide-in');
    
    // æ¸²æŸ“ç”¨æˆ·ä¿¡æ¯
    const user = await db.characters.get(parseInt(currentMyCharId));
    if (user) {
        const nameEl = document.getElementById('my-moments-name');
        const avatarEl = document.getElementById('my-moments-avatar');
        const coverEl = document.getElementById('my-moments-cover');
        
        nameEl.innerText = user.name;
        if (user.avatar) {
            avatarEl.style.backgroundImage = `url(${user.avatar})`;
        }
        
        const cover = user.identity?.cover;
        if (cover) {
            coverEl.style.backgroundImage = `url(${cover})`;
        }
    }
    
    // æ¸²æŸ“æœ‹å‹åœˆåˆ—è¡¨ï¼ˆåªæ˜¾ç¤ºè‡ªå·±çš„ï¼‰
    await renderMyMomentsList();
}

function hideMyMomentsPage() {
    const page = document.getElementById('my-moments-page');
    page.classList.remove('slide-in');
    setTimeout(() => {
        page.style.display = 'none';
    }, 300);
}

// æ ¼å¼åŒ–æœ‹å‹åœˆæ—¶é—´
function formatMomentTime(timestamp) {
    const date = new Date(timestamp);
    const now = new Date();
    
    // è®¡ç®—æ—¶é—´å·®
    const diffMs = now - date;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);
    
    // å°äº1åˆ†é’Ÿ
    if (diffMins < 1) {
        return 'åˆšåˆš';
    }
    // å°äº1å°æ—¶
    if (diffMins < 60) {
        return `${diffMins}åˆ†é’Ÿå‰`;
    }
    // å°äº24å°æ—¶
    if (diffHours < 24) {
        return `${diffHours}å°æ—¶å‰`;
    }
    // å°äº7å¤©
    if (diffDays < 7) {
        return `${diffDays}å¤©å‰`;
    }
    
    // è¶…è¿‡7å¤©ï¼Œæ˜¾ç¤ºå…·ä½“æ—¥æœŸ
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    const day = date.getDate();
    const hour = date.getHours();
    const minute = date.getMinutes().toString().padStart(2, '0');
    
    // å¦‚æœæ˜¯ä»Šå¹´ï¼Œä¸æ˜¾ç¤ºå¹´ä»½
    if (year === now.getFullYear()) {
        return `${month}æœˆ${day}æ—¥ ${hour}:${minute}`;
    }
    
    // è·¨å¹´æ˜¾ç¤ºå¹´ä»½
    return `${year}å¹´${month}æœˆ${day}æ—¥`;
}

// æ¸²æŸ“æˆ‘çš„æœ‹å‹åœˆåˆ—è¡¨
async function renderMyMomentsList() {
    const container = document.getElementById('my-moments-list');
    const pinnedContainer = document.getElementById('my-moments-pinned-list');
    const pinnedSection = document.getElementById('my-moments-pinned-section');
    
    container.innerHTML = '';
    pinnedContainer.innerHTML = '';
    
    const currentAccountId = currentMyCharId ? parseInt(currentMyCharId) : null;
    if (!currentAccountId) {
        container.innerHTML = `<div class="wechat-empty-state" style="margin-top:60px;"><div style="color:#999; font-size:14px;">è¯·å…ˆç™»å½•è´¦å·</div></div>`;
        pinnedSection.classList.remove('show');
        return;
    }
    
    // åªè·å–è‡ªå·±å‘çš„æœ‹å‹åœˆ
    const allMoments = await db.moments.toArray();
    let moments = allMoments.filter(m => m.userId == currentAccountId);
    
    // åˆ†ç¦»ç½®é¡¶å’Œæ™®é€šæœ‹å‹åœˆ
    const pinnedMoments = moments.filter(m => m.pinned);
    const normalMoments = moments.filter(m => !m.pinned);
    
    // æŒ‰æ—¶é—´å€’åºæ’åº
    pinnedMoments.sort((a, b) => b.time - a.time);
    normalMoments.sort((a, b) => b.time - a.time);
    
    // è·å–ç”¨æˆ·ä¿¡æ¯
    const user = await db.characters.get(currentAccountId);
    
    // æ¸²æŸ“ç½®é¡¶åŒºåŸŸï¼ˆåªæ˜¾ç¤ºå‰3ä¸ªï¼‰
    if (pinnedMoments.length > 0) {
        pinnedSection.classList.add('show');
        
        // åªæ˜¾ç¤ºå‰3ä¸ªç½®é¡¶å¡ç‰‡
        const displayMoments = pinnedMoments.slice(0, 3);
        for (const moment of displayMoments) {
            const card = createPinnedMomentCard(moment, user);
            pinnedContainer.appendChild(card);
        }
        
        // è®¾ç½®ç®­å¤´ç‚¹å‡»äº‹ä»¶ï¼ˆæŸ¥çœ‹æ‰€æœ‰ç½®é¡¶ï¼‰
        const arrow = pinnedSection.querySelector('.moments-pinned-arrow');
        if (arrow) {
            arrow.onclick = () => showAllPinnedMoments(pinnedMoments, user);
        }
    } else {
        pinnedSection.classList.remove('show');
    }
    
    // æ¸²æŸ“æ™®é€šæœ‹å‹åœˆï¼ˆä¿æŒåŸæ¥çš„å®Œæ•´æ ·å¼ï¼‰
    if (normalMoments.length === 0 && pinnedMoments.length === 0) {
        container.innerHTML = `<div class="wechat-empty-state" style="margin-top:60px;"><div style="color:#999; font-size:14px;">è¿˜æ²¡æœ‰å‘å¸ƒæœ‹å‹åœˆ</div></div>`;
        return;
    }
    
    for (const moment of normalMoments) {
        const itemDiv = createMomentItem(moment, user);
        container.appendChild(itemDiv);
    }
}

// åˆ›å»ºç½®é¡¶æœ‹å‹åœˆå¡ç‰‡ï¼ˆä»¿çœŸå®å¾®ä¿¡æ ·å¼ï¼‰
function createPinnedMomentCard(moment, user) {
    const card = document.createElement('div');
    card.className = 'pinned-moment-card';
    card.onclick = () => showMomentDetail(moment.id);
    
    // å¦‚æœæœ‰å›¾ç‰‡ï¼Œè®¾ç½®ä¸ºèƒŒæ™¯
    if (moment.images && moment.images.length > 0) {
        card.style.backgroundImage = `url(${moment.images[0]})`;
    }
    
    // æ–‡å­—å†…å®¹é¢„è§ˆï¼ˆæ˜¾ç¤ºåœ¨å¡ç‰‡ä¸­å¤®ï¼‰
    const contentText = moment.content || '';
    const shortText = contentText.length > 30 ? contentText.substring(0, 30) + '...' : contentText;
    
    card.innerHTML = `<div class="pinned-moment-text">${shortText}</div>`;
    
    return card;
}

// æ˜¾ç¤ºæ‰€æœ‰ç½®é¡¶æœ‹å‹åœˆé¡µé¢ï¼ˆæ—¶é—´çº¿æ ¼å¼ï¼‰
function showAllPinnedMoments(pinnedMoments, user) {
    const page = document.getElementById('all-pinned-moments-page');
    const list = document.getElementById('all-pinned-list');
    
    list.innerHTML = '';
    
    // æŒ‰å¹´ä»½å’Œæ—¥æœŸåˆ†ç»„
    const groupedByYear = {};
    for (const moment of pinnedMoments) {
        const date = new Date(moment.time);
        const year = date.getFullYear();
        const dateKey = `${date.getMonth() + 1}-${date.getDate()}`; // æœˆ-æ—¥
        
        if (!groupedByYear[year]) groupedByYear[year] = {};
        if (!groupedByYear[year][dateKey]) groupedByYear[year][dateKey] = [];
        groupedByYear[year][dateKey].push(moment);
    }
    
    // æŒ‰å¹´ä»½å€’åºæ¸²æŸ“
    const years = Object.keys(groupedByYear).sort((a, b) => b - a);
    for (const year of years) {
        // å¹´ä»½æ ‡é¢˜
        const yearTitle = document.createElement('div');
        yearTitle.style.cssText = 'font-size:20px; font-weight:700; color:#333; padding:20px 16px 10px;';
        yearTitle.textContent = year + 'å¹´';
        list.appendChild(yearTitle);
        
        // æŒ‰æ—¥æœŸå€’åº
        const dates = Object.keys(groupedByYear[year]).sort((a, b) => {
            const [am, ad] = a.split('-').map(Number);
            const [bm, bd] = b.split('-').map(Number);
            return (bm * 100 + bd) - (am * 100 + ad);
        });
        
        for (const dateKey of dates) {
            const dayMoments = groupedByYear[year][dateKey];
            const item = createPinnedTimelineGroup(dateKey, dayMoments);
            list.appendChild(item);
        }
    }
    
    page.style.display = 'block';
}

// åˆ›å»ºç½®é¡¶é¡µé¢çš„æ—¶é—´çº¿æ¡ç›®ï¼ˆåŒä¸€å¤©çš„åˆå¹¶æ˜¾ç¤ºï¼‰
function createPinnedTimelineGroup(dateKey, moments) {
    const div = document.createElement('div');
    div.style.cssText = 'display:flex; padding:16px; border-bottom:1px solid #f5f5f5;';
    
    const [month, day] = dateKey.split('-');
    
    // æ”¶é›†æ‰€æœ‰å›¾ç‰‡å’Œæ–‡å­—
    let allImages = [];
    let allTexts = [];
    for (const moment of moments) {
        if (moment.images && moment.images.length > 0) {
            allImages = allImages.concat(moment.images);
        }
        if (moment.content) {
            allTexts.push({ id: moment.id, text: moment.content });
        }
    }
    
    // å›¾ç‰‡ç½‘æ ¼ï¼ˆä¸€è¡Œä¸‰ä¸ªï¼‰
    let imagesHtml = '';
    if (allImages.length > 0) {
        imagesHtml = `<div style="display:grid; grid-template-columns:repeat(3, 1fr); gap:4px; margin-bottom:8px;">
            ${allImages.map(img => `<div style="aspect-ratio:1; background-image:url(${img}); background-size:cover; background-position:center; cursor:pointer;" onclick="event.stopPropagation(); previewImage('${img}')"></div>`).join('')}
        </div>`;
    }
    
    // æ–‡å­—å†…å®¹åˆ—è¡¨
    let textsHtml = '';
    for (const item of allTexts) {
        const shortText = item.text.length > 40 ? item.text.substring(0, 40) + '...' : item.text;
        textsHtml += `<div style="font-size:14px; color:#666; line-height:1.6; padding:6px 12px; background:#f8f8f8; border-radius:4px; margin-bottom:6px; cursor:pointer;" onclick="showMomentDetail(${item.id})">${shortText}</div>`;
    }
    
    div.innerHTML = `
        <div style="width:70px; flex-shrink:0; text-align:left;">
            <div style="font-size:28px; font-weight:700; color:#333; line-height:1;">${day.padStart(2, '0')}</div>
            <div style="font-size:12px; color:#999;">${month}æœˆ</div>
        </div>
        <div style="flex:1; min-width:0;">
            ${imagesHtml}
            ${textsHtml}
        </div>
    `;
    
    return div;
}

// éšè—æ‰€æœ‰ç½®é¡¶æœ‹å‹åœˆé¡µé¢
function hideAllPinnedMoments() {
    document.getElementById('all-pinned-moments-page').style.display = 'none';
}

// åˆ›å»ºæœ‹å‹åœˆæ¡ç›®
function createMomentItem(moment, user) {
    const itemDiv = document.createElement('div');
    itemDiv.className = 'moment-item';
    itemDiv.onclick = () => showMomentDetail(moment.id);
    
    // æƒé™æ ‡è¯†
    let privacyText = '';
    if (moment.privacy === 'private') privacyText = 'ç§å¯†';
    else if (moment.privacy === 'friends') privacyText = 'å¥½å‹å¯è§';
    
    const privacyBadge = privacyText ? `<span style="color:#999; font-size:12px; margin-left:8px;">${privacyText}</span>` : '';
    
    // å›¾ç‰‡å±•ç¤º - ä½¿ç”¨æ–‡å­—å›¾ç‰‡å¡ç‰‡å½¢å¼
    let imagesHtml = '';
    if (moment.imageCount && moment.imageCount > 0) {
        const desc = moment.imageDesc || '';
        const count = Math.min(moment.imageCount, 9);
        const gridClass = `grid-${count}`;
        let squares = '';
        for (let imgIdx = 0; imgIdx < count; imgIdx++) {
            squares += `<div class="moment-img-placeholder" onclick="event.stopPropagation(); showMomentImageDesc('${escapeHtml(desc).replace(/'/g, "\\'")}')">
                <div class="moment-img-placeholder-inner">
                    <svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
                    ${count === 1 ? '<div class="moment-img-placeholder-hint">ç‚¹å‡»æŸ¥çœ‹æ–‡å­—</div>' : ''}
                </div>
            </div>`;
        }
        imagesHtml = `<div class="moment-image-grid ${gridClass}">${squares}</div>`;
    }
    // å…¼å®¹æ—§æ•°æ®
    else if (moment.images && moment.images.length > 0) {
        let gridClass = 'cols-3';
        if (moment.images.length === 1) gridClass = 'cols-1';
        else if (moment.images.length === 2 || moment.images.length === 4) gridClass = 'cols-2';
        
        imagesHtml = `<div class="moment-grid ${gridClass}">
            ${moment.images.map(img => `<div class="moment-img" style="background-image:url(${img})" onclick="event.stopPropagation(); previewImage('${img}')"></div>`).join('')}
        </div>`;
    }
    
    itemDiv.innerHTML = `
        <div class="moment-avatar" style="background-image:url(${user?.avatar || ''})"></div>
        <div class="moment-content">
            <div class="moment-name">${user?.name || 'æˆ‘'}${privacyBadge}</div>
            <div class="moment-text">${moment.content}</div>
            ${imagesHtml}
            <div class="moment-meta">
                <span class="moment-time">${formatMomentTime(moment.time)}</span>
            </div>
        </div>
    `;
    
    return itemDiv;
}

// å…¨å±€å˜é‡å­˜å‚¨å½“å‰æŸ¥çœ‹çš„æœ‹å‹åœˆID
let currentMomentId = null;

// æ˜¾ç¤ºæœ‹å‹åœˆè¯¦æƒ…é¡µ
async function showMomentDetail(momentId) {
    currentMomentId = momentId;
    const moment = await db.moments.get(momentId);
    if (!moment) return;
    
    const page = document.getElementById('moment-detail-page');
    const contentDiv = document.getElementById('moment-detail-content');
    const pinSwitch = document.getElementById('moment-pin-switch');
    const privacyText = document.getElementById('moment-privacy-text');
    
    // è·å–ç”¨æˆ·ä¿¡æ¯
    const user = await db.characters.get(moment.userId);
    
    // æ¸²æŸ“å†…å®¹é¢„è§ˆ
    contentDiv.innerHTML = `
        <div style="display:flex; gap:12px; margin-bottom:12px;">
            <div style="width:40px; height:40px; border-radius:50%; background-image:url(${user?.avatar || ''}); background-size:cover; background-position:center; flex-shrink:0;"></div>
            <div style="flex:1;">
                <div style="font-weight:600; margin-bottom:4px;">${user?.name || 'ç”¨æˆ·'}</div>
                <div style="font-size:14px; color:#666; line-height:1.6;">${moment.content}</div>
            </div>
        </div>
        ${moment.images && moment.images.length > 0 ? `
            <div style="display:grid; grid-template-columns:repeat(3, 1fr); gap:4px; margin-top:8px;">
                ${moment.images.map(img => `<div style="padding-bottom:100%; background-image:url(${img}); background-size:cover; background-position:center; border-radius:4px;"></div>`).join('')}
            </div>
        ` : ''}
        <div style="color:#999; font-size:12px; margin-top:8px;">${formatMomentTime(moment.time)}</div>
    `;
    
    // è®¾ç½®ç½®é¡¶å¼€å…³çŠ¶æ€
    pinSwitch.checked = moment.pinned || false;
    
    // è®¾ç½®æƒé™æ˜¾ç¤º
    const privacyMap = {
        'public': 'å…¬å¼€',
        'friends': 'å¥½å‹å¯è§',
        'private': 'ç§å¯†'
    };
    privacyText.innerText = privacyMap[moment.privacy] || 'å…¬å¼€';
    
    page.style.display = 'flex';
    page.offsetHeight;
    page.classList.add('active');
}

function hideMomentDetail() {
    const page = document.getElementById('moment-detail-page');
    page.classList.remove('active');
    setTimeout(() => {
        page.style.display = 'none';
        currentMomentId = null;
    }, 300);
}

// åˆ‡æ¢ç½®é¡¶çŠ¶æ€
async function toggleMomentPin() {
    if (!currentMomentId) return;
    
    const moment = await db.moments.get(currentMomentId);
    if (!moment) return;
    
    moment.pinned = !moment.pinned;
    await db.moments.put(moment);
    
    // æ›´æ–°å¼€å…³çŠ¶æ€
    const pinSwitch = document.getElementById('moment-pin-switch');
    pinSwitch.checked = moment.pinned;
    
    showToast(moment.pinned ? 'å·²ç½®é¡¶' : 'å·²å–æ¶ˆç½®é¡¶');
    
    // åˆ·æ–°åˆ—è¡¨
    await renderMyMomentsList();
}

// æ˜¾ç¤ºæƒé™é€‰é¡¹
async function showMomentPrivacyOptions() {
    if (!currentMomentId) return;
    
    const moment = await db.moments.get(currentMomentId);
    if (!moment) return;
    
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        display: flex;
        align-items: flex-end;
        justify-content: center;
        z-index: 10000;
    `;
    
    const currentPrivacy = moment.privacy || 'public';
    
    modal.innerHTML = `
        <div style="background: #fff; width: 100%; border-radius: 12px 12px 0 0; padding: 16px; animation: slideUp 0.3s;">
            <div style="text-align: center; font-size: 14px; color: #999; margin-bottom: 16px;">è°å¯ä»¥çœ‹</div>
            <div style="display: flex; flex-direction: column; gap: 1px; background: #f5f5f5; border-radius: 8px; overflow: hidden;">
                <div onclick="setMomentPrivacy('public')" style="background: #fff; padding: 16px; text-align: center; cursor: pointer; ${currentPrivacy === 'public' ? 'color: var(--ins-pink); font-weight: 600;' : ''}">
                    å…¬å¼€
                </div>
                <div onclick="setMomentPrivacy('friends')" style="background: #fff; padding: 16px; text-align: center; cursor: pointer; ${currentPrivacy === 'friends' ? 'color: var(--ins-pink); font-weight: 600;' : ''}">
                    å¥½å‹å¯è§
                </div>
                <div onclick="setMomentPrivacy('private')" style="background: #fff; padding: 16px; text-align: center; cursor: pointer; ${currentPrivacy === 'private' ? 'color: var(--ins-pink); font-weight: 600;' : ''}">
                    ä»…è‡ªå·±å¯è§
                </div>
            </div>
            <button onclick="this.parentElement.parentElement.remove()" style="width: 100%; padding: 14px; background: #f5f5f5; border: none; border-radius: 8px; margin-top: 12px; font-size: 16px;">
                å–æ¶ˆ
            </button>
        </div>
    `;
    
    modal.onclick = (e) => {
        if (e.target === modal) modal.remove();
    };
    
    document.body.appendChild(modal);
}

// è®¾ç½®æœ‹å‹åœˆæƒé™
async function setMomentPrivacy(privacy) {
    if (!currentMomentId) return;
    
    const moment = await db.moments.get(currentMomentId);
    if (!moment) return;
    
    moment.privacy = privacy;
    await db.moments.put(moment);
    
    // æ›´æ–°æ˜¾ç¤º
    const privacyMap = {
        'public': 'å…¬å¼€',
        'friends': 'å¥½å‹å¯è§',
        'private': 'ä»…è‡ªå·±å¯è§'
    };
    document.getElementById('moment-privacy-text').innerText = privacyMap[privacy];
    
    // å…³é—­å¼¹çª—
    const modal = document.querySelector('[style*="rgba(0,0,0,0.5)"]');
    if (modal) modal.remove();
    
    showToast('å·²è®¾ç½®');
    
    // åˆ·æ–°åˆ—è¡¨
    await renderMyMomentsList();
}

// ä»è¯¦æƒ…é¡µåˆ é™¤æœ‹å‹åœˆ
async function deleteMomentFromDetail() {
    if (!currentMomentId) return;
    
    if (confirm('ç¡®å®šåˆ é™¤è¿™æ¡æœ‹å‹åœˆå—ï¼Ÿ')) {
        await db.moments.delete(currentMomentId);
        showToast('å·²åˆ é™¤');
        hideMomentDetail();
        await renderMyMomentsList();
        await renderMomentsList(); // ä¹Ÿåˆ·æ–°ä¸»æœ‹å‹åœˆåˆ—è¡¨
    }
}

function showWalletPage() {
    const walletPage = document.getElementById('wallet-page');
    walletPage.style.display = 'flex';
    walletPage.offsetHeight; 
    walletPage.classList.add('active');
    
    // æ›´æ–°æ˜¾ç¤ºçš„ä½™é¢ (ä» currentMyCharId è·å–)
    updateWalletBalanceDisplay();
}

function hideWalletPage() {
    const walletPage = document.getElementById('wallet-page');
    walletPage.classList.remove('active');
    setTimeout(() => {
        walletPage.style.display = 'none';
    }, 350);
}

// ========== è´¦å•é¡µé¢ ==========
let currentBillFilter = 'all';

function showBillPage() {
    const billPage = document.getElementById('bill-page');
    billPage.style.display = 'flex';
    billPage.offsetHeight;
    billPage.classList.add('active');
    currentBillFilter = 'all';
    renderBillList();
}

function hideBillPage() {
    const billPage = document.getElementById('bill-page');
    billPage.classList.remove('active');
    setTimeout(() => {
        billPage.style.display = 'none';
    }, 350);
}

function filterBills(filter) {
    currentBillFilter = filter;
    // æ›´æ–°æŒ‰é’®çŠ¶æ€
    document.querySelectorAll('.bill-filter-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.filter === filter);
    });
    renderBillList();
}

async function renderBillList() {
    const listEl = document.getElementById('bill-list');
    const emptyEl = document.getElementById('bill-empty');
    
    if (!currentMyCharId) {
        listEl.innerHTML = '';
        emptyEl.style.display = 'block';
        return;
    }
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    let transactions = user?.identity?.transactions || [];
    
    // ç­›é€‰
    if (currentBillFilter === 'income') {
        transactions = transactions.filter(t => t.type === 'income');
    } else if (currentBillFilter === 'expense') {
        transactions = transactions.filter(t => t.type === 'expense');
    }
    
    // æŒ‰æ—¶é—´å€’åº
    transactions = [...transactions].sort((a, b) => b.time - a.time);
    
    if (transactions.length === 0) {
        listEl.innerHTML = '';
        emptyEl.style.display = 'block';
        return;
    }
    
    emptyEl.style.display = 'none';
    
    listEl.innerHTML = transactions.map(t => {
        const isIncome = t.type === 'income';
        const iconSvg = isIncome 
            ? '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 19V5M5 12l7-7 7 7"/></svg>'
            : '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12l7 7 7-7"/></svg>';
        
        const date = new Date(t.time);
        const timeStr = `${date.getMonth()+1}æœˆ${date.getDate()}æ—¥ ${date.getHours().toString().padStart(2,'0')}:${date.getMinutes().toString().padStart(2,'0')}`;
        
        return `
            <div class="bill-item">
                <div class="bill-icon ${isIncome ? 'income' : 'expense'}">${iconSvg}</div>
                <div class="bill-info">
                    <div class="bill-title">${t.title || (isIncome ? 'æ”¶æ¬¾' : 'è½¬è´¦')}</div>
                    <div class="bill-desc">${t.desc || ''} Â· ${timeStr}</div>
                </div>
                <div class="bill-amount ${isIncome ? 'income' : 'expense'}">${isIncome ? '+' : '-'}Â¥${t.amount}</div>
            </div>
        `;
    }).join('');
}

// æ·»åŠ äº¤æ˜“è®°å½•
async function addTransaction(type, amount, title, desc) {
    if (!currentMyCharId) return;
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    if (!user) return;
    
    if (!user.identity) user.identity = {};
    if (!user.identity.transactions) user.identity.transactions = [];
    
    user.identity.transactions.push({
        type, // 'income' æˆ– 'expense'
        amount: parseFloat(amount).toFixed(2),
        title,
        desc,
        time: Date.now()
    });
    
    // åªä¿ç•™æœ€è¿‘100æ¡è®°å½•
    if (user.identity.transactions.length > 100) {
        user.identity.transactions = user.identity.transactions.slice(-100);
    }
    
    await db.characters.put(user);
}

// ========== äº²å±å¡é¡µé¢ ==========
let selectedFamilyCardFriendId = null;

async function showFamilyCardPage() {
    const page = document.getElementById('family-card-page');
    page.style.display = 'flex';
    page.offsetHeight;
    page.classList.add('active');
    
    // ğŸ¯ ç›´æ¥æ¸²æŸ“ï¼ˆäº²å±å¡ç°åœ¨ä¿å­˜åœ¨èŠå¤©è®°å½•ä¸­ï¼Œå’Œè½¬è´¦ä¸€æ ·ï¼‰
    renderFamilyCardList();
}

function hideFamilyCardPage() {
    const page = document.getElementById('family-card-page');
    page.classList.remove('active');
    setTimeout(() => {
        page.style.display = 'none';
    }, 350);
}

// æ¸²æŸ“äº²å±å¡åˆ—è¡¨
async function renderFamilyCardList() {
    if (!currentMyCharId) return;
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    if (!user) return;
    
    // ========== æˆ‘èµ é€çš„äº²å±å¡ ==========
    const givenListEl = document.getElementById('family-card-given-list');
    let givenHtml = '';
    
    // 1. æœ¬åœ°äº²å±å¡
    const localGivenCards = user.identity?.familyCardsGiven || [];
    for (const card of localGivenCards) {
        const char = await db.characters.get(card.charId);
        if (char) {
            const usedThisMonth = card.usedThisMonth || 0;
            const limitText = card.monthlyLimit > 0 ? `å·²ç”¨ Â¥${usedThisMonth.toFixed(2)} / Â¥${card.monthlyLimit}` : `å·²ç”¨ Â¥${usedThisMonth.toFixed(2)} (ä¸é™é¢)`;
            givenHtml += `
                <div class="family-card-item">
                    <div class="family-card-avatar" style="background-image:url(${char.avatar})"></div>
                    <div class="family-card-info">
                        <div class="family-card-name">${char.name}</div>
                        <div class="family-card-detail">${limitText}</div>
                    </div>
                    <div class="family-card-actions">
                        <button class="family-card-btn view" onclick="showFamilyCardRecords(${card.charId}, 'given')">è®°å½•</button>
                        <button class="family-card-btn cancel" onclick="cancelFamilyCard(${card.charId}, 'given')">è§£ç»‘</button>
                    </div>
                </div>
            `;
        }
    }
    
    // 2. è”æœºäº²å±å¡ï¼ˆä»èŠå¤©è®°å½•ä¸­æŸ¥æ‰¾ï¼Œå’Œè½¬è´¦ä¸€æ ·ï¼‰
    console.log('[äº²å±å¡] å¼€å§‹æŸ¥æ‰¾è”æœºäº²å±å¡...');
    const allOnlineFriends = await db.characters.where('type').equals('online_friend').toArray();
    console.log('[äº²å±å¡] æ‰¾åˆ°è”æœºå¥½å‹æ•°é‡:', allOnlineFriends.length);
    
    for (const friendChar of allOnlineFriends) {
        const history = getChatHistory(friendChar, accountId);
        if (!history) continue;
        
        // æŸ¥æ‰¾æˆ‘å‘é€çš„äº²å±å¡æ¶ˆæ¯ï¼ˆrole='user' ä¸” type='familyCard'ï¼‰
        const myFamilyCards = history.filter(msg => msg.role === 'user' && msg.type === 'familyCard');
        
        if (myFamilyCards.length > 0) {
            // åªæ˜¾ç¤ºæœ€åä¸€å¼ ï¼ˆæœ€æ–°çš„ï¼‰
            const lastCard = myFamilyCards[myFamilyCards.length - 1];
            let cardData = {};
            try {
                cardData = JSON.parse(lastCard.content);
            } catch (e) {
                cardData = { monthlyLimit: 0 };
            }
            
            const limitText = cardData.monthlyLimit > 0 ? `é¢åº¦ Â¥${cardData.monthlyLimit}` : 'ä¸é™é¢åº¦';
            givenHtml += `
                <div class="family-card-item">
                    <div class="family-card-avatar" style="background-image:url(${friendChar.avatar})"></div>
                    <div class="family-card-info">
                        <div class="family-card-name">${friendChar.name} <span style="font-size:12px;color:#999;">(è”æœº)</span></div>
                        <div class="family-card-detail">${limitText}</div>
                    </div>
                    <div class="family-card-actions">
                        <button class="family-card-btn view" onclick="showToast('è”æœºäº²å±å¡æš‚ä¸æ”¯æŒæŸ¥çœ‹è®°å½•')">è®°å½•</button>
                    </div>
                </div>
            `;
            console.log('[äº²å±å¡] æ‰¾åˆ°èµ é€ç»™', friendChar.name, 'çš„äº²å±å¡');
        }
    }
    
    givenListEl.innerHTML = givenHtml || '';
    
    // ========== æˆ‘æ”¶åˆ°çš„äº²å±å¡ ==========
    const receivedListEl = document.getElementById('family-card-received-list');
    const receivedEmptyEl = document.getElementById('family-card-received-empty');
    let receivedHtml = '';
    
    // 1. æœ¬åœ°äº²å±å¡
    const localReceivedCards = user.identity?.familyCardsReceived || [];
    for (const card of localReceivedCards) {
        const char = await db.characters.get(card.charId);
        if (char) {
            const usedThisMonth = card.usedThisMonth || 0;
            const monthlyLimit = card.monthlyLimit || 0;
            const limitText = monthlyLimit > 0 ? `æœ¬æœˆå¯ç”¨ Â¥${(monthlyLimit - usedThisMonth).toFixed(2)}` : 'ä¸é™é¢';
            receivedHtml += `
                <div class="family-card-item">
                    <div class="family-card-avatar" style="background-image:url(${char.avatar})"></div>
                    <div class="family-card-info">
                        <div class="family-card-name">${char.name} çš„äº²å±å¡</div>
                        <div class="family-card-detail">${limitText}</div>
                    </div>
                    <div class="family-card-actions">
                        <button class="family-card-btn view" onclick="showFamilyCardRecords(${card.charId}, 'received')">è®°å½•</button>
                    </div>
                </div>
            `;
        }
    }
    
    // 2. è”æœºäº²å±å¡ï¼ˆä»èŠå¤©è®°å½•ä¸­æŸ¥æ‰¾ï¼Œå’Œè½¬è´¦ä¸€æ ·ï¼‰
    for (const friendChar of allOnlineFriends) {
        const history = getChatHistory(friendChar, accountId);
        if (!history) continue;
        
        // æŸ¥æ‰¾å¯¹æ–¹å‘é€çš„äº²å±å¡æ¶ˆæ¯ï¼ˆrole='char' ä¸” type='familyCard'ï¼‰
        const receivedFamilyCards = history.filter(msg => msg.role === 'char' && msg.type === 'familyCard');
        
        if (receivedFamilyCards.length > 0) {
            // åªæ˜¾ç¤ºæœ€åä¸€å¼ ï¼ˆæœ€æ–°çš„ï¼‰
            const lastCard = receivedFamilyCards[receivedFamilyCards.length - 1];
            let cardData = {};
            try {
                cardData = JSON.parse(lastCard.content);
            } catch (e) {
                cardData = { monthlyLimit: 0 };
            }
            
            const limitText = cardData.monthlyLimit > 0 ? `é¢åº¦ Â¥${cardData.monthlyLimit}` : 'ä¸é™é¢';
            receivedHtml += `
                <div class="family-card-item">
                    <div class="family-card-avatar" style="background-image:url(${friendChar.avatar})"></div>
                    <div class="family-card-info">
                        <div class="family-card-name">${friendChar.name} çš„äº²å±å¡ <span style="font-size:12px;color:#999;">(è”æœº)</span></div>
                        <div class="family-card-detail">${limitText}</div>
                    </div>
                    <div class="family-card-actions">
                        <button class="family-card-btn view" onclick="showToast('è”æœºäº²å±å¡æš‚ä¸æ”¯æŒæŸ¥çœ‹è®°å½•')">è®°å½•</button>
                    </div>
                </div>
            `;
            console.log('[äº²å±å¡] æ‰¾åˆ°æ¥è‡ª', friendChar.name, 'çš„äº²å±å¡');
        }
    }
    
    if (receivedHtml) {
        receivedEmptyEl.style.display = 'none';
        receivedListEl.innerHTML = receivedHtml;
    } else {
        receivedListEl.innerHTML = '';
        receivedEmptyEl.style.display = 'block';
    }
}

// æ˜¾ç¤ºèµ é€äº²å±å¡å¼¹çª—
async function showGiveFamilyCardModal() {
    selectedFamilyCardFriendId = null;
    
    const modal = document.getElementById('give-family-card-modal');
    const listEl = document.getElementById('family-card-friend-list');
    
    // è·å–å¥½å‹åˆ—è¡¨
    const user = await db.characters.get(parseInt(currentMyCharId));
    const accountId = getCurrentAccountId();
    const allChars = await db.characters.toArray();
    
    // è¿‡æ»¤å‡ºå¥½å‹ï¼ˆåŒ…æ‹¬æœ¬åœ°å¥½å‹å’Œè”æœºå¥½å‹ï¼‰
    const friends = allChars.filter(c => {
        if (c.type === 'user') return false;
        // âœ… åŒ…å«è”æœºå¥½å‹
        if (c.type === 'online_friend') return true;
        // æ£€æŸ¥æ™®é€šå¥½å‹çŠ¶æ€
        const status = getFriendStatus(c, accountId);
        return status === 'friend';
    });
    
    console.log('[äº²å±å¡] æ‰¾åˆ°å¥½å‹æ€»æ•°:', friends.length, 'å…¶ä¸­è”æœºå¥½å‹:', friends.filter(f => f.type === 'online_friend').length);
    
    // æ’é™¤å·²ç»èµ é€è¿‡äº²å±å¡çš„ï¼ˆæœ¬åœ°å¥½å‹ï¼‰
    const givenCards = user?.identity?.familyCardsGiven || [];
    const givenIds = givenCards.map(c => c.charId);
    
    // âœ… æ’é™¤å·²ç»åœ¨èŠå¤©è®°å½•ä¸­èµ é€è¿‡äº²å±å¡çš„ï¼ˆè”æœºå¥½å‹ï¼‰
    const availableFriends = friends.filter(f => {
        // æœ¬åœ°å¥½å‹ï¼šæ£€æŸ¥ givenIds
        if (f.type !== 'online_friend') {
            return !givenIds.includes(f.id);
        }
        
        // è”æœºå¥½å‹ï¼šæ£€æŸ¥èŠå¤©è®°å½•ä¸­æ˜¯å¦æœ‰å·²å‘é€çš„äº²å±å¡
        const history = getChatHistory(f, accountId);
        if (!history) return true;
        const hasSent = history.some(msg => msg.role === 'user' && msg.type === 'familyCard');
        return !hasSent;
    });
    
    if (availableFriends.length === 0) {
        listEl.innerHTML = '<div style="text-align:center; padding:20px; color:#999;">æ²¡æœ‰å¯èµ é€çš„å¥½å‹</div>';
    } else {
        listEl.innerHTML = availableFriends.map(f => {
            // âœ… ç»™è”æœºå¥½å‹æ·»åŠ æ ‡è®°
            const isOnline = f.type === 'online_friend';
            const onlineTag = isOnline ? '<span style="background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); color:#fff; font-size:10px; padding:2px 6px; border-radius:3px; margin-left:6px;">è”æœº</span>' : '';
            
            return `
                <div class="family-card-friend-item" onclick="selectFamilyCardFriend(${f.id}, this)">
                    <div class="family-card-friend-avatar" style="background-image:url(${f.avatar})"></div>
                    <div class="family-card-friend-name">${f.name}${onlineTag}</div>
                    <div class="family-card-friend-check">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="3">
                            <polyline points="20 6 9 17 4 12"></polyline>
                        </svg>
                    </div>
                </div>
            `;
        }).join('');
    }
    
    document.getElementById('family-card-limit-input').value = '0';
    modal.style.display = 'flex';
}

function hideGiveFamilyCardModal() {
    document.getElementById('give-family-card-modal').style.display = 'none';
}

function selectFamilyCardFriend(charId, el) {
    // å–æ¶ˆå…¶ä»–é€‰ä¸­
    document.querySelectorAll('.family-card-friend-item').forEach(item => {
        item.classList.remove('selected');
    });
    el.classList.add('selected');
    selectedFamilyCardFriendId = charId;
}

// ç¡®è®¤èµ é€äº²å±å¡
async function confirmGiveFamilyCard() {
    if (!selectedFamilyCardFriendId) {
        showToast('è¯·é€‰æ‹©ä¸€ä¸ªå¥½å‹');
        return;
    }
    
    const limitInput = document.getElementById('family-card-limit-input');
    const monthlyLimit = parseFloat(limitInput.value) || 0;
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    const char = await db.characters.get(selectedFamilyCardFriendId);
    
    if (!char) {
        showToast('å¥½å‹ä¸å­˜åœ¨');
        return;
    }
    
    const accountId = getCurrentAccountId();
    
    // âœ… åˆ¤æ–­æ˜¯å¦æ˜¯è”æœºå¥½å‹
    if (char.type === 'online_friend') {
        console.log('[äº²å±å¡] æ£€æµ‹åˆ°è”æœºå¥½å‹ï¼Œé€šè¿‡æ¶ˆæ¯é€šé“å‘é€');
        // è”æœºå¥½å‹ - é€šè¿‡æ¶ˆæ¯é€šé“å‘é€ï¼ˆå’Œè½¬è´¦ä¸€æ ·ï¼‰
        const onlineUserChar = await getOrCreateOnlineUserChar();
        
        if (onlineUserChar && onlineConnected && char.onlineData?.wx_account) {
            const fromWxAccount = onlineUserChar.identity.account;
            const toWxAccount = char.onlineData.wx_account;
            
            // é€šè¿‡æ¶ˆæ¯é€šé“å‘é€
            const familyCardContent = JSON.stringify({
                __type: 'familyCard',
                monthlyLimit: monthlyLimit,
                fromName: onlineUserChar.name
            });
            
            const sent = sendOnlineMessage(toWxAccount, familyCardContent, fromWxAccount);
            
            if (sent) {
                // ä¿å­˜åˆ°èŠå¤©è®°å½•
                let history = getChatHistory(char, accountId);
                const familyCardMsg = {
                    role: 'user',
                    type: 'familyCard',
                    content: JSON.stringify({
                        fromName: onlineUserChar.name,
                        monthlyLimit: monthlyLimit,
                        status: 'sent',
                        isOnline: true
                    }),
                    time: Date.now()
                };
                
                history.push(familyCardMsg);
                await setChatHistory(char, accountId, history);
                
                console.log('[äº²å±å¡] âœ… è”æœºäº²å±å¡å·²å‘é€');
                showToast('å·²èµ é€äº²å±å¡');
            } else {
                console.error('[äº²å±å¡] âŒ å‘é€å¤±è´¥');
                showToast('å‘é€å¤±è´¥ï¼Œè¯·æ£€æŸ¥è¿æ¥');
                return;
            }
        } else {
            console.error('[äº²å±å¡] âŒ æ¡ä»¶ä¸æ»¡è¶³');
            showToast('è¯·ç¡®ä¿å·²è¿æ¥æœåŠ¡å™¨');
            return;
        }
    } else {
        // æœ¬åœ°å¥½å‹ - åŸæœ‰é€»è¾‘
        console.log('[äº²å±å¡] æœ¬åœ°å¥½å‹ï¼Œä½¿ç”¨åŸæœ‰é€»è¾‘');
        
        if (!user.identity) user.identity = {};
        if (!user.identity.familyCardsGiven) user.identity.familyCardsGiven = [];
        
        // æ·»åŠ äº²å±å¡è®°å½•
        user.identity.familyCardsGiven.push({
            charId: selectedFamilyCardFriendId,
            monthlyLimit: monthlyLimit,
            usedThisMonth: 0,
            records: [],
            createdAt: Date.now()
        });
        
        await db.characters.put(user);
        
        // åŒæ—¶åœ¨è§’è‰²é‚£è¾¹æ·»åŠ æ”¶åˆ°çš„äº²å±å¡è®°å½•
        if (!char.identity) char.identity = {};
        if (!char.identity.familyCardsReceived) char.identity.familyCardsReceived = [];
        
        char.identity.familyCardsReceived.push({
            charId: parseInt(currentMyCharId),
            monthlyLimit: monthlyLimit,
            usedThisMonth: 0,
            records: [],
            createdAt: Date.now()
        });
        
        await db.characters.put(char);
        
        // å‘é€äº²å±å¡æ¶ˆæ¯åˆ°èŠå¤©
        let history = getChatHistory(char, accountId);
        
        const familyCardMsg = {
            role: 'user',
            type: 'familyCard',
            content: JSON.stringify({
                fromName: user.name,
                monthlyLimit: monthlyLimit,
                status: 'sent'
            }),
            time: Date.now()
        };
        
        history.push(familyCardMsg);
        await setChatHistory(char, accountId, history);
        
        showToast('å·²èµ é€äº²å±å¡');
    }
    
    hideGiveFamilyCardModal();
    hideFamilyCardPage();
    hideWalletPage();
    
    // å¦‚æœå½“å‰æ­£åœ¨å’Œè¿™ä¸ªè§’è‰²èŠå¤©ï¼Œåˆ·æ–°èŠå¤©ç•Œé¢
    if (currentChatCharId === selectedFamilyCardFriendId) {
        const freshChar = await db.characters.get(selectedFamilyCardFriendId);
        renderChatBody(freshChar);
    }
}

// å–æ¶ˆäº²å±å¡
async function cancelFamilyCard(charId, type) {
    if (!confirm('ç¡®å®šè¦è§£ç»‘è¿™å¼ äº²å±å¡å—ï¼Ÿ')) return;
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    
    if (type === 'given') {
        // ä»æˆ‘èµ é€çš„åˆ—è¡¨ä¸­ç§»é™¤
        user.identity.familyCardsGiven = (user.identity.familyCardsGiven || []).filter(c => c.charId !== charId);
        await db.characters.put(user);
        
        // ä»å¯¹æ–¹æ”¶åˆ°çš„åˆ—è¡¨ä¸­ç§»é™¤
        const char = await db.characters.get(charId);
        if (char && char.identity) {
            char.identity.familyCardsReceived = (char.identity.familyCardsReceived || []).filter(c => c.charId !== parseInt(currentMyCharId));
            await db.characters.put(char);
        }
    }
    
    renderFamilyCardList();
    showToast('å·²è§£ç»‘äº²å±å¡');
}

// æ˜¾ç¤ºæ¶ˆè´¹è®°å½•
async function showFamilyCardRecords(charId, type) {
    const modal = document.getElementById('family-card-records-modal');
    const titleEl = document.getElementById('family-card-records-title');
    const listEl = document.getElementById('family-card-records-list');
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    const char = await db.characters.get(charId);
    
    let records = [];
    
    if (type === 'given') {
        // æŸ¥çœ‹æˆ‘èµ é€ç»™å¯¹æ–¹çš„æ¶ˆè´¹è®°å½•
        const card = (user.identity?.familyCardsGiven || []).find(c => c.charId === charId);
        records = card?.records || [];
        titleEl.textContent = `${char?.name || 'æœªçŸ¥'} çš„æ¶ˆè´¹è®°å½•`;
    } else {
        // æŸ¥çœ‹æˆ‘ä½¿ç”¨å¯¹æ–¹äº²å±å¡çš„æ¶ˆè´¹è®°å½•
        const card = (user.identity?.familyCardsReceived || []).find(c => c.charId === charId);
        records = card?.records || [];
        titleEl.textContent = `æˆ‘çš„æ¶ˆè´¹è®°å½•`;
    }
    
    if (records.length === 0) {
        listEl.innerHTML = '<div style="text-align:center; padding:30px; color:#999;">æš‚æ— æ¶ˆè´¹è®°å½•</div>';
    } else {
        listEl.innerHTML = [...records].reverse().map(r => {
            const date = new Date(r.time);
            const timeStr = `${date.getMonth()+1}æœˆ${date.getDate()}æ—¥ ${date.getHours().toString().padStart(2,'0')}:${date.getMinutes().toString().padStart(2,'0')}`;
            return `
                <div class="family-card-record-item">
                    <div class="family-card-record-title">${r.desc || 'æ¶ˆè´¹'}</div>
                    <div class="family-card-record-time">${timeStr}</div>
                    <div class="family-card-record-amount">-Â¥${parseFloat(r.amount).toFixed(2)}</div>
                </div>
            `;
        }).join('');
    }
    
    modal.style.display = 'flex';
}

function hideFamilyCardRecordsModal() {
    document.getElementById('family-card-records-modal').style.display = 'none';
}

// è§’è‰²ä½¿ç”¨äº²å±å¡æ¶ˆè´¹ï¼ˆAIè°ƒç”¨ï¼‰
async function charUseFamilyCard(charId, amount, desc) {
    if (!currentMyCharId) return false;
    
    const user = await db.characters.get(parseInt(currentMyCharId));
    if (!user?.identity?.familyCardsGiven) return false;
    
    const cardIndex = user.identity.familyCardsGiven.findIndex(c => c.charId === charId);
    if (cardIndex === -1) return false;
    
    const card = user.identity.familyCardsGiven[cardIndex];
    
    // æ£€æŸ¥é¢åº¦
    if (card.monthlyLimit > 0 && (card.usedThisMonth + amount) > card.monthlyLimit) {
        return false; // è¶…å‡ºé¢åº¦
    }
    
    // æ‰£æ¬¾
    let userBalance = parseFloat(user.identity.balance || 0);
    if (userBalance < amount) return false; // ä½™é¢ä¸è¶³
    
    user.identity.balance = (userBalance - amount).toFixed(2);
    card.usedThisMonth = (card.usedThisMonth || 0) + amount;
    card.records.push({
        amount: amount,
        desc: desc,
        time: Date.now()
    });
    
    await db.characters.put(user);
    
    // åŒæ—¶æ›´æ–°è§’è‰²é‚£è¾¹çš„è®°å½•
    const char = await db.characters.get(charId);
    if (char?.identity?.familyCardsReceived) {
        const charCard = char.identity.familyCardsReceived.find(c => c.charId === parseInt(currentMyCharId));
        if (charCard) {
            charCard.usedThisMonth = (charCard.usedThisMonth || 0) + amount;
            charCard.records.push({
                amount: amount,
                desc: desc,
                time: Date.now()
            });
            await db.characters.put(char);
        }
    }
    
    // æ·»åŠ åˆ°è´¦å•
    await addTransaction('expense', amount, 'äº²å±å¡æ¶ˆè´¹', `${char?.name || 'æœªçŸ¥'} - ${desc}`);
    
    return true;
}

function showBalancePage() {
    const balancePage = document.getElementById('balance-page');
    balancePage.style.display = 'flex';
    balancePage.offsetHeight; 
    balancePage.classList.add('active');
    
    // æ›´æ–°å¤§å­—ä½™é¢
    updateBalancePageDisplay();
}

function hideBalancePage() {
    const balancePage = document.getElementById('balance-page');
    balancePage.classList.remove('active');
    setTimeout(() => {
        balancePage.style.display = 'none';
    }, 350);
    
    // è¿”å›æ—¶åŒæ—¶ä¹Ÿæ›´æ–°ä¸€ä¸‹é’±åŒ…é¡µçš„ä½™é¢æ˜¾ç¤ºï¼Œä»¥é˜²åˆšæ‰ç”Ÿæˆäº†æ–°çš„
    updateWalletBalanceDisplay();
}

// æ›´æ–°é’±åŒ…é¡µçš„å°ä½™é¢æ˜¾ç¤º
async function updateWalletBalanceDisplay() {
    if (!currentMyCharId) return;
    const user = await db.characters.get(parseInt(currentMyCharId));
    if (user && user.identity && user.identity.balance !== undefined) {
        // å‡è®¾ identity.balance å­˜å‚¨çš„æ˜¯æ•°å­—æˆ–å­—ç¬¦ä¸²
        document.querySelector('#wallet-page .item-right span').innerText = `Â¥${user.identity.balance}`;
        // åŒæ—¶æ›´æ–°æœåŠ¡é¡µçš„ä½™é¢
        const serviceBalance = document.querySelector('.header-item .item-subtitle');
        if (serviceBalance) serviceBalance.style.display = 'none'; // éšè—ä½™é¢
    } else {
         document.querySelector('#wallet-page .item-right span').innerText = `Â¥0.00`;
         const serviceBalance = document.querySelector('.header-item .item-subtitle');
         if (serviceBalance) serviceBalance.style.display = 'none'; // éšè—ä½™é¢
    }
}

// æ›´æ–°é›¶é’±é¡µçš„å¤§ä½™é¢æ˜¾ç¤º
async function updateBalancePageDisplay() {
    if (!currentMyCharId) return;
    const user = await db.characters.get(parseInt(currentMyCharId));
    const amountDisplay = document.getElementById('balance-amount-display');
    if (user && user.identity && user.identity.balance !== undefined) {
        amountDisplay.innerText = `Â¥${user.identity.balance}`;
    } else {
        amountDisplay.innerText = `Â¥0.00`;
    }
}

// AIç”Ÿæˆä½™é¢é€»è¾‘
async function generateUserBalance() {
    if (!currentMyCharId) {
        alert("è¯·å…ˆé€‰æ‹©ä¸€ä¸ª User èº«ä»½");
        return;
    }

    const user = await db.characters.get(parseInt(currentMyCharId));
    if (!user) {
        alert("æœªæ‰¾åˆ°è¯¥è§’è‰²ä¿¡æ¯");
        return;
    }
    
    // è°ƒè¯•æ—¥å¿—ï¼šç¡®è®¤è¯»å–åˆ°çš„ç”¨æˆ·ä¿¡æ¯ï¼ˆè¯»å–å®Œæ•´çš„è§’è‰²æ¡£æ¡ˆï¼‰
    console.log('[generateUserBalance] è¯»å–åˆ°çš„å®Œæ•´è§’è‰²æ¡£æ¡ˆ:', user);
    
    // è¯»å–è§’è‰²æè¿°ï¼ˆä½¿ç”¨ description å­—æ®µï¼Œè€Œä¸æ˜¯ descï¼‰
    const characterDescription = user.description || user.desc || '';
    
    // æ£€æŸ¥äººè®¾æè¿°æ˜¯å¦å­˜åœ¨
    if (!characterDescription || characterDescription.trim() === '' || characterDescription === 'æš‚æ— æè¿°') {
        console.warn('[generateUserBalance] è­¦å‘Šï¼šè§’è‰²æè¿°ä¸ºç©ºæˆ–æœªè®¾ç½®');
        const confirmContinue = confirm("âš ï¸ è¯¥è§’è‰²çš„äººè®¾æè¿°ä¸ºç©ºæˆ–æœªè®¾ç½®ï¼Œç”Ÿæˆçš„ä½™é¢å¯èƒ½ä¸å‡†ç¡®ã€‚\n\næ˜¯å¦ç»§ç»­ç”Ÿæˆï¼Ÿ\nï¼ˆå»ºè®®å…ˆå®Œå–„è§’è‰²äººè®¾æè¿°ï¼‰");
        if (!confirmContinue) {
            return;
        }
    }
    
    const btn = document.querySelector('.btn-generate');
    const originalText = btn.innerHTML;
    btn.innerHTML = `<div class="loading-spinner" style="display:inline-block; border-color:var(--ins-pink); border-top-color:transparent;"></div> ç”Ÿæˆä¸­...`;
    btn.disabled = true;

    try {
        // æ„å»ºå®Œæ•´çš„äººè®¾ä¿¡æ¯ï¼ˆè¯»å–å®Œæ•´çš„è§’è‰²æ¡£æ¡ˆï¼‰
        const characterInfo = [];
        characterInfo.push(`è§’è‰²åç§°ï¼š${user.name || 'æœªå‘½å'}`);
        
        if (user.nick) {
            characterInfo.push(`è§’è‰²æ˜µç§°ï¼š${user.nick}`);
        }
        
        // è¯»å–è§’è‰²æè¿°ï¼ˆä¼˜å…ˆä½¿ç”¨ descriptionï¼Œå…¼å®¹ descï¼‰
        if (characterDescription && characterDescription.trim() && characterDescription !== 'æš‚æ— æè¿°') {
            characterInfo.push(`è§’è‰²äººè®¾æè¿°ï¼š${characterDescription.trim()}`);
        } else {
            characterInfo.push(`è§’è‰²äººè®¾æè¿°ï¼šæš‚æ— è¯¦ç»†æè¿°`);
        }
        
        if (user.type) {
            characterInfo.push(`è§’è‰²ç±»å‹ï¼š${user.type}`);
        }
        
        // è¯»å–å®Œæ•´çš„èº«ä»½ä¿¡æ¯
        if (user.identity) {
            if (user.identity.address) {
                characterInfo.push(`å®¶åº­ä½å€ï¼š${user.identity.address}`);
            }
            if (user.identity.bank_card) {
                characterInfo.push(`é“¶è¡Œå¡å·ï¼š${user.identity.bank_card}`);
            }
        }
        
        const fullCharacterInfo = characterInfo.join('\n');
        
        const systemPrompt = `ä½ æ˜¯ä¸€ä¸ªè¾…åŠ©ç”Ÿæˆè§’è‰²è¯¦ç»†è®¾å®šçš„AIåŠ©æ‰‹ã€‚

ä»¥ä¸‹æ˜¯å½“å‰è§’è‰²çš„å®Œæ•´ä¿¡æ¯ï¼š
${fullCharacterInfo}

è¯·ä»”ç»†åˆ†æä¸Šè¿°è§’è‰²çš„äººè®¾ä¿¡æ¯ï¼ˆç‰¹åˆ«æ˜¯è§’è‰²æè¿°ä¸­çš„èƒŒæ™¯ã€èŒä¸šã€ç»æµçŠ¶å†µã€ç¤¾ä¼šåœ°ä½ç­‰ï¼‰ï¼Œç„¶ååˆç†æ¨æ–­è¯¥è§’è‰²å¾®ä¿¡é’±åŒ…é‡Œçš„"é›¶é’±"ä½™é¢ã€‚

é‡è¦æç¤ºï¼š
1. å¿…é¡»ä¸¥æ ¼æ ¹æ®è§’è‰²äººè®¾æ¥ç”Ÿæˆä½™é¢ï¼Œä¸è¦ä½¿ç”¨é»˜è®¤å€¼æˆ–éšæœºå€¼
2. å¦‚æœè§’è‰²æè¿°ä¸­æåˆ°"å¯ŒäºŒä»£"ã€"å¯Œè£•"ã€"æœ‰é’±"ã€"å®¶å¢ƒä¼˜æ¸¥"ç­‰å…³é”®è¯ï¼Œä½™é¢åº”è¯¥è¾ƒé«˜ï¼ˆå‡ ä¸‡åˆ°å‡ åä¸‡ï¼‰
3. å¦‚æœè§’è‰²æè¿°ä¸­æåˆ°"å­¦ç”Ÿ"ã€"æ™®é€š"ã€"å·¥è–ª"ç­‰å…³é”®è¯ï¼Œä½™é¢åº”è¯¥é€‚ä¸­ï¼ˆå‡ ç™¾åˆ°å‡ åƒï¼‰
4. å¦‚æœè§’è‰²æè¿°ä¸­æåˆ°"è´«å›°"ã€"æ‹®æ®"ç­‰å…³é”®è¯ï¼Œä½™é¢åº”è¯¥è¾ƒä½ï¼ˆå‡ ååˆ°å‡ ç™¾ï¼‰
5. åªè¿”å›ä¸€ä¸ªå…·ä½“çš„æ•°å­—é‡‘é¢ï¼Œä¿ç•™ä¸¤ä½å°æ•°ï¼Œä¸è¦åŒ…å«ä»»ä½•å…¶ä»–æ–‡å­—ã€ç¬¦å·æˆ–è¯´æ˜
6. å¦‚æœæ˜¯å¤ä»£/æ¶ç©ºèƒŒæ™¯ï¼Œè¯·è‡ªåŠ¨æ¢ç®—æˆåˆç†çš„ç°ä»£è´§å¸æ•°å€¼

ç¤ºä¾‹ï¼š
- å¯ŒäºŒä»£è§’è‰²ï¼šåº”è¿”å› 50000.00 æˆ–æ›´é«˜
- æ™®é€šå­¦ç”Ÿï¼šåº”è¿”å› 1500.00 å·¦å³
- æ™®é€šæ‰“å·¥äººï¼šåº”è¿”å› 3000.00 å·¦å³`;

        console.log('[generateUserBalance] å‘é€ç»™AIçš„Prompt:', systemPrompt);
        
        const amountStr = await callAI([
            { role: "system", content: systemPrompt },
            { role: "user", content: "è¯·æ ¹æ®ä¸Šè¿°è§’è‰²äººè®¾ä¿¡æ¯ï¼Œç”Ÿæˆç¬¦åˆè¯¥è§’è‰²ç»æµçŠ¶å†µçš„å¾®ä¿¡é›¶é’±ä½™é¢ã€‚åªè¿”å›æ•°å­—é‡‘é¢ï¼Œä¿ç•™ä¸¤ä½å°æ•°ã€‚" }
        ]);
        
        console.log('[generateUserBalance] AIè¿”å›çš„åŸå§‹å†…å®¹:', amountStr);

        // æå–æ•°å­—
        const match = amountStr.match(/[\d,]+\.\d{2}/) || amountStr.match(/\d+/);
        let balance = "0.00";
        if (match) {
            balance = match[0];
        } else {
            // å…œåº•å°è¯•æ¸…ç†éæ•°å­—å­—ç¬¦
             balance = amountStr.replace(/[^\d.]/g, '');
        }

        // ä¿å­˜åˆ°æ•°æ®åº“
        if (!user.identity) user.identity = {};
        user.identity.balance = balance;
        await db.characters.put(user);

        // æ›´æ–°ç•Œé¢
        document.getElementById('balance-amount-display').innerText = `Â¥${balance}`;
        updateWalletBalanceDisplay(); // åŒæ­¥æ›´æ–°ä¸Šä¸€é¡µ

        // ç®€æ˜“ Toast
        const tip = document.getElementById('save-tip');
        tip.innerText = "ä½™é¢å·²ç”Ÿæˆ";
        tip.style.display = 'block';
        setTimeout(() => { 
            tip.style.display = 'none'; 
            tip.innerText = "ä¿å­˜æˆåŠŸï¼"; // è¿˜åŸé»˜è®¤æ–‡æœ¬
        }, 1500);

    } catch (e) {
        console.error(e);
        const tip = document.getElementById('save-tip');
        tip.innerText = "ç”Ÿæˆå¤±è´¥";
        tip.style.display = 'block';
        setTimeout(() => { tip.style.display = 'none'; }, 1500);
    } finally {
        btn.innerHTML = originalText;
        btn.disabled = false;
    }
}


/* =================
   è½¬è´¦åŠŸèƒ½é€»è¾‘
   ================= */

// ç®€æ˜“Toastå‡½æ•° (å¦‚æœæ²¡æœ‰å®šä¹‰çš„è¯)
function showToast(message) {
    const tip = document.getElementById('save-tip');
    if (tip) {
        tip.innerText = message;
        tip.style.display = 'block';
        setTimeout(() => { 
            tip.style.display = 'none'; 
            tip.innerText = "ä¿å­˜æˆåŠŸï¼"; // è¿˜åŸé»˜è®¤æ–‡æœ¬
        }, 1500);
    } else {
        alert(message);
    }
}

// æ‰“å¼€è½¬è´¦é¡µé¢
async function showTransferPage() {
    // å…³é—­æ›´å¤šé¢æ¿
    closeChatPanel();
    
    // åˆ¤æ–­æ˜¯å¦æ˜¯ç¾¤èŠ
    if (window.currentGroupChatId) {
        // ç¾¤èŠï¼šæ˜¾ç¤ºè½¬è´¦ç±»å‹é€‰æ‹©å¼¹çª—
        document.getElementById('group-transfer-type-modal').style.display = 'flex';
        return;
    }
    
    if (!currentChatCharId) {
        showToast("è¯·å…ˆè¿›å…¥èŠå¤©");
        return;
    }
    
    // è·å–å½“å‰èŠå¤©å¯¹è±¡ä¿¡æ¯
    const chatChar = await db.characters.get(currentChatCharId);
    if (!chatChar) return;
    
    document.getElementById('t-target-name').innerText = chatChar.name;
    document.getElementById('t-target-avatar').style.backgroundImage = 'url(' + chatChar.avatar + ')';
    
    // é‡ç½®è¾“å…¥
    document.getElementById('t-amount-input').value = '';
    document.getElementById('t-note-input').value = '';
    document.getElementById('btn-do-transfer').disabled = true;
    
    const page = document.getElementById('transfer-page');
    page.style.display = 'flex';
}

function hideTransferPage() {
    document.getElementById('transfer-page').style.display = 'none';
}

/* =================
   ç¾¤çº¢åŒ…åŠŸèƒ½
   ================= */

let currentRedPacketType = 'lucky'; // é»˜è®¤æ‹¼æ‰‹æ°”çº¢åŒ…

// æ˜¾ç¤ºç¾¤çº¢åŒ…é¡µé¢
function showGroupRedPacketPage() {
    closeModal('group-transfer-type-modal');
    
    // é‡ç½®è¾“å…¥
    document.getElementById('rp-amount-input').value = '';
    document.getElementById('rp-count-input').value = '';
    document.getElementById('rp-wish-input').value = '';
    document.getElementById('rp-total-hint').innerText = 'å…±0.00å…ƒ';
    document.getElementById('btn-send-redpacket').disabled = true;
    document.getElementById('btn-send-redpacket').style.background = '#ccc';
    document.getElementById('btn-send-redpacket').style.cursor = 'not-allowed';
    
    // é»˜è®¤é€‰ä¸­æ‹¼æ‰‹æ°”
    selectRedPacketType('lucky');
    
    document.getElementById('group-redpacket-page').style.display = 'flex';
}

function hideGroupRedPacketPage() {
    document.getElementById('group-redpacket-page').style.display = 'none';
}

// é€‰æ‹©çº¢åŒ…ç±»å‹
function selectRedPacketType(type) {
    currentRedPacketType = type;
    
    const luckyEl = document.getElementById('rp-type-lucky');
    const normalEl = document.getElementById('rp-type-normal');
    
    if (type === 'lucky') {
        luckyEl.style.borderColor = '#333';
        luckyEl.style.background = '#fff';
        luckyEl.querySelector('div:first-child').style.color = '#333';
        
        normalEl.style.borderColor = '#e8e8e8';
        normalEl.style.background = '#fff';
        normalEl.querySelector('div:first-child').style.color = '#666';
    } else {
        normalEl.style.borderColor = '#333';
        normalEl.style.background = '#fff';
        normalEl.querySelector('div:first-child').style.color = '#333';
        
        luckyEl.style.borderColor = '#e8e8e8';
        luckyEl.style.background = '#fff';
        luckyEl.querySelector('div:first-child').style.color = '#666';
    }
}

// æ£€æŸ¥çº¢åŒ…è¾“å…¥
function checkRedPacketInput() {
    const amount = parseFloat(document.getElementById('rp-amount-input').value) || 0;
    const count = parseInt(document.getElementById('rp-count-input').value) || 0;
    
    document.getElementById('rp-total-hint').innerText = `å…±${amount.toFixed(2)}å…ƒ`;
    
    const btn = document.getElementById('btn-send-redpacket');
    if (amount > 0 && count > 0) {
        btn.disabled = false;
        btn.style.background = '#333';
        btn.style.cursor = 'pointer';
    } else {
        btn.disabled = true;
        btn.style.background = '#ccc';
        btn.style.cursor = 'not-allowed';
    }
}

// å‘é€ç¾¤çº¢åŒ…
async function sendGroupRedPacket() {
    if (!window.currentGroupChatId) return;
    
    const amount = parseFloat(document.getElementById('rp-amount-input').value);
    const count = parseInt(document.getElementById('rp-count-input').value);
    const wish = document.getElementById('rp-wish-input').value.trim() || 'æ­å–œå‘è´¢ï¼Œå¤§å‰å¤§åˆ©';
    
    if (!amount || amount <= 0 || !count || count <= 0) {
        showToast('è¯·å¡«å†™æ­£ç¡®çš„é‡‘é¢å’Œä¸ªæ•°');
        return;
    }
    
    // æ£€æŸ¥ä½™é¢
    if (!currentMyCharId) {
        showToast("è¯·å…ˆè®¾ç½®Userèº«ä»½");
        return;
    }
    const user = await db.characters.get(parseInt(currentMyCharId));
    let currentBalance = 0;
    if (user && user.identity && user.identity.balance) {
        currentBalance = parseFloat(user.identity.balance.toString().replace(/,/g, ''));
    }
    
    if (currentBalance < amount) {
        showToast('ä½™é¢ä¸è¶³ (å½“å‰: Â¥' + currentBalance.toFixed(2) + ')');
        return;
    }
    
    // æ‰£æ¬¾
    const newBalance = currentBalance - amount;
    user.identity.balance = newBalance.toFixed(2);
    await db.characters.put(user);
    
    // æ„å»ºçº¢åŒ…æ¶ˆæ¯
    const group = await db.group_chats.get(window.currentGroupChatId);
    if (!group) return;
    
    const redPacketData = {
        type: 'redpacket',
        redpacketType: currentRedPacketType, // 'lucky' æˆ– 'normal'
        totalAmount: amount.toFixed(2),
        count: count,
        wish: wish,
        claimed: [], // å·²é¢†å–çš„æˆå‘˜IDåˆ—è¡¨
        claimedAmounts: {}, // æ¯ä¸ªæˆå‘˜é¢†å–çš„é‡‘é¢
        id: 'rp_' + Date.now()
    };
    
    if (!group.chat_history) group.chat_history = [];
    group.chat_history.push({
        role: 'user',
        type: 'redpacket',
        content: JSON.stringify(redPacketData),
        time: Date.now()
    });
    group.updated_at = Date.now();
    await db.group_chats.put(group);
    
    // è®°å½•è´¦å•
    await addTransaction('expense', amount, 'å‘çº¢åŒ…', `${group.name} Â· ${count}ä¸ªçº¢åŒ…`);
    
    hideGroupRedPacketPage();
    await renderGroupChatBody(group);
    showToast('çº¢åŒ…å·²å‘å‡º');
}

/* =================
   ä¸“å±è½¬è´¦åŠŸèƒ½
   ================= */

let exclusiveTransferTarget = null; // å½“å‰é€‰ä¸­çš„è½¬è´¦ç›®æ ‡

// æ˜¾ç¤ºä¸“å±è½¬è´¦é€‰äººå¼¹çª—
async function showExclusiveTransferPage() {
    closeModal('group-transfer-type-modal');
    
    if (!window.currentGroupChatId) return;
    
    const group = await db.group_chats.get(window.currentGroupChatId);
    if (!group) return;
    
    const listEl = document.getElementById('exclusive-member-list');
    listEl.innerHTML = '';
    
    // æ¸²æŸ“ç¾¤æˆå‘˜åˆ—è¡¨ï¼ˆä¸åŒ…æ‹¬è‡ªå·±ï¼‰
    for (const memberId of group.memberIds) {
        const char = await db.characters.get(memberId);
        if (!char) continue;
        
        const avatarStyle = char.avatar ? `background-image:url(${char.avatar})` : 'background:#ccc';
        const memberNicknames = group.memberNicknames || {};
        const displayName = memberNicknames[memberId] || char.remark || char.wx_nickname || char.name;
        
        const item = document.createElement('div');
        item.style.cssText = 'display:flex; align-items:center; padding:12px 16px; cursor:pointer; transition:background 0.2s;';
        item.onmouseover = () => item.style.background = '#f5f5f5';
        item.onmouseout = () => item.style.background = '';
        item.innerHTML = `
            <div style="width:44px; height:44px; border-radius:6px; ${avatarStyle}; background-size:cover; background-position:center; margin-right:12px;"></div>
            <div style="flex:1;">
                <div style="font-size:16px; color:#333;">${displayName}</div>
                <div style="font-size:12px; color:#999;">${char.name}</div>
            </div>
        `;
        item.onclick = () => selectExclusiveTarget(memberId, char, displayName);
        
        listEl.appendChild(item);
    }
    
    if (group.memberIds.length === 0) {
        listEl.innerHTML = '<div style="text-align:center; color:#999; padding:40px;">ç¾¤å†…æš‚æ— å…¶ä»–æˆå‘˜</div>';
    }
    
    document.getElementById('exclusive-transfer-modal').style.display = 'flex';
}

// é€‰æ‹©ä¸“å±è½¬è´¦ç›®æ ‡
async function selectExclusiveTarget(memberId, char, displayName) {
    closeModal('exclusive-transfer-modal');
    
    exclusiveTransferTarget = { memberId, char, displayName };
    
    // æ‰“å¼€è½¬è´¦é¡µé¢
    document.getElementById('t-target-name').innerText = displayName;
    document.getElementById('t-target-avatar').style.backgroundImage = char.avatar ? `url(${char.avatar})` : '';
    
    // é‡ç½®è¾“å…¥
    document.getElementById('t-amount-input').value = '';
    document.getElementById('t-note-input').value = '';
    document.getElementById('btn-do-transfer').disabled = true;
    
    document.getElementById('transfer-page').style.display = 'flex';
}

// å½“å‰æŸ¥çœ‹çš„çº¢åŒ…ID
let currentViewingRedPacketId = null;

// æ˜¾ç¤ºçº¢åŒ…è¯¦æƒ…é¡µé¢
async function showRedPacketDetail(redPacketId) {
    if (!window.currentGroupChatId) return;
    
    const group = await db.group_chats.get(window.currentGroupChatId);
    if (!group || !group.chat_history) return;
    
    // æ‰¾åˆ°çº¢åŒ…æ¶ˆæ¯
    const msg = group.chat_history.find(m => {
        if (m.type !== 'redpacket') return false;
        try {
            const data = JSON.parse(m.content);
            return data.id === redPacketId;
        } catch(e) {
            return false;
        }
    });
    
    if (!msg) return;
    
    const data = JSON.parse(msg.content);
    currentViewingRedPacketId = redPacketId;
    
    // è·å–å‘é€è€…ä¿¡æ¯
    let senderAvatar = '';
    let senderName = data.senderName || 'çº¢åŒ…å‘é€è€…';
    if (msg.role === 'user') {
        // ç”¨æˆ·å‘çš„çº¢åŒ…
        const myId = currentMyCharId ? parseInt(currentMyCharId) : null;
        if (myId) {
            const user = await db.characters.get(myId);
            if (user) {
                senderAvatar = user.avatar || '';
                const memberNicknames = group.memberNicknames || {};
                senderName = memberNicknames[myId] || user.name || 'æˆ‘';
            }
        }
    } else if (msg.senderId || data.senderId) {
        // è§’è‰²å‘çš„çº¢åŒ…
        const charId = msg.senderId || data.senderId;
        const char = await db.characters.get(typeof charId === 'number' ? charId : parseInt(charId));
        if (char) {
            senderAvatar = char.avatar || '';
            const memberNicknames = group.memberNicknames || {};
            senderName = memberNicknames[charId] || char.remark || char.name || data.senderName || 'çº¢åŒ…å‘é€è€…';
        }
    }
    
    // æ›´æ–°é¡µé¢å†…å®¹
    document.getElementById('rp-detail-avatar').style.backgroundImage = senderAvatar ? `url(${senderAvatar})` : '';
    document.getElementById('rp-detail-sender').innerText = senderName + ' çš„çº¢åŒ…';
    document.getElementById('rp-detail-wish').innerText = data.wish || 'æ­å–œå‘è´¢';
    document.getElementById('rp-detail-type').innerText = data.redpacketType === 'lucky' ? 'æ‹¼æ‰‹æ°”çº¢åŒ…' : 'æ™®é€šçº¢åŒ…';
    
    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
    const claimedCount = data.claimed?.length || 0;
    const claimedTotal = Object.values(data.claimedAmounts || {}).reduce((a, b) => a + parseFloat(b), 0);
    document.getElementById('rp-detail-claimed-count').innerText = claimedCount;
    document.getElementById('rp-detail-total-count').innerText = data.count;
    document.getElementById('rp-detail-total-amount').innerText = claimedTotal.toFixed(2);
    
    // æ›´æ–°é¢†å–æŒ‰é’®çŠ¶æ€
    const myId = currentMyCharId ? parseInt(currentMyCharId) : null;
    const isAllClaimed = claimedCount >= data.count;
    const hasClaimed = data.claimed?.includes(myId);
    
    const actionDiv = document.getElementById('rp-detail-action');
    const btn = document.getElementById('btn-claim-redpacket');
    
    if (isAllClaimed) {
        btn.innerText = 'çº¢åŒ…å·²é¢†å®Œ';
        btn.disabled = true;
        btn.style.background = '#ccc';
        btn.style.cursor = 'not-allowed';
    } else if (hasClaimed) {
        btn.innerText = `å·²é¢†å– Â¥${data.claimedAmounts[myId]}`;
        btn.disabled = true;
        btn.style.background = '#ccc';
        btn.style.cursor = 'not-allowed';
    } else {
        btn.innerText = 'é¢†å–çº¢åŒ…';
        btn.disabled = false;
        btn.style.background = '#333';
        btn.style.cursor = 'pointer';
    }
    
    // æ¸²æŸ“å·²é¢†å–åˆ—è¡¨
    const listEl = document.getElementById('rp-detail-claimed-list');
    listEl.innerHTML = '';
    
    if (data.claimed && data.claimed.length > 0) {
        for (const memberId of data.claimed) {
            const char = await db.characters.get(memberId);
            const memberNicknames = group.memberNicknames || {};
            const displayName = memberNicknames[memberId] || char?.remark || char?.name || 'æœªçŸ¥ç”¨æˆ·';
            const avatar = char?.avatar || '';
            const amount = data.claimedAmounts[memberId] || '0.00';
            
            const item = document.createElement('div');
            item.style.cssText = 'display:flex; align-items:center; padding:12px 0; border-bottom:1px solid #f0f0f0;';
            item.innerHTML = `
                <div style="width:40px; height:40px; border-radius:50%; background:#eee; background-image:url(${avatar}); background-size:cover; background-position:center; margin-right:12px; flex-shrink:0;"></div>
                <div style="flex:1;">
                    <div style="font-size:14px; color:#333;">${displayName}</div>
                </div>
                <div style="font-size:15px; font-weight:500; color:#333;">Â¥${amount}</div>
            `;
            listEl.appendChild(item);
        }
    } else {
        listEl.innerHTML = '<div style="text-align:center; color:#999; padding:30px 0; font-size:13px;">æš‚æ— äººé¢†å–</div>';
    }
    
    document.getElementById('redpacket-detail-page').style.display = 'flex';
}

// éšè—çº¢åŒ…è¯¦æƒ…é¡µé¢
function hideRedPacketDetail() {
    document.getElementById('redpacket-detail-page').style.display = 'none';
    currentViewingRedPacketId = null;
}

// é¢†å–çº¢åŒ…
async function claimRedPacket() {
    console.log('[é¢†å–çº¢åŒ…] å¼€å§‹é¢†å–, redpacketId:', currentViewingRedPacketId, 'groupId:', window.currentGroupChatId);
    
    if (!currentViewingRedPacketId || !window.currentGroupChatId) {
        console.warn('[é¢†å–çº¢åŒ…] ç¼ºå°‘çº¢åŒ…IDæˆ–ç¾¤èŠID');
        showToast('çº¢åŒ…ä¿¡æ¯å¼‚å¸¸');
        return;
    }
    
    const group = await db.group_chats.get(window.currentGroupChatId);
    if (!group || !group.chat_history) {
        console.warn('[é¢†å–çº¢åŒ…] æ‰¾ä¸åˆ°ç¾¤èŠæˆ–èŠå¤©è®°å½•');
        showToast('ç¾¤èŠæ•°æ®å¼‚å¸¸');
        return;
    }
    
    // æ‰¾åˆ°çº¢åŒ…æ¶ˆæ¯
    const msgIndex = group.chat_history.findIndex(m => {
        if (m.type !== 'redpacket') return false;
        try {
            const data = JSON.parse(m.content);
            return data.id === currentViewingRedPacketId;
        } catch(e) {
            return false;
        }
    });
    
    if (msgIndex === -1) {
        console.warn('[é¢†å–çº¢åŒ…] åœ¨èŠå¤©è®°å½•ä¸­æ‰¾ä¸åˆ°è¯¥çº¢åŒ…');
        showToast('æ‰¾ä¸åˆ°è¯¥çº¢åŒ…');
        return;
    }
    
    const msg = group.chat_history[msgIndex];
    const data = JSON.parse(msg.content);
    console.log('[é¢†å–çº¢åŒ…] çº¢åŒ…æ•°æ®:', data);
    
    // æ£€æŸ¥æ˜¯å¦å·²é¢†å–å®Œ
    if ((data.claimed?.length || 0) >= data.count) {
        showToast('çº¢åŒ…å·²è¢«é¢†å®Œ');
        await showRedPacketDetail(currentViewingRedPacketId);
        return;
    }
    
    // æ£€æŸ¥æ˜¯å¦å·²é¢†å–è¿‡
    const myId = currentMyCharId ? parseInt(currentMyCharId) : null;
    console.log('[é¢†å–çº¢åŒ…] å½“å‰ç”¨æˆ·ID:', myId, 'currentMyCharId:', currentMyCharId);
    if (!myId) {
        showToast('è¯·å…ˆè®¾ç½®èº«ä»½');
        return;
    }
    if (data.claimed?.includes(myId)) {
        showToast('ä½ å·²é¢†å–è¿‡è¯¥çº¢åŒ…');
        return;
    }
    
    // é¢†å–çº¢åŒ…
    if (!data.claimed) data.claimed = [];
    if (!data.claimedAmounts) data.claimedAmounts = {};
    
    let claimAmount = 0;
    const totalAmount = parseFloat(data.totalAmount);
    const remaining = data.count - data.claimed.length;
    const alreadyClaimed = Object.values(data.claimedAmounts).reduce((a, b) => a + parseFloat(b), 0);
    const remainingAmount = totalAmount - alreadyClaimed;
    
    if (data.redpacketType === 'lucky') {
        // æ‹¼æ‰‹æ°”çº¢åŒ…ï¼šéšæœºé‡‘é¢
        if (remaining === 1) {
            claimAmount = remainingAmount;
        } else {
            // éšæœºé‡‘é¢ï¼Œç¡®ä¿æ¯äººè‡³å°‘0.01
            const maxAmount = remainingAmount - (remaining - 1) * 0.01;
            claimAmount = Math.random() * maxAmount * 0.8 + 0.01; // ä¿å®ˆéšæœº
            claimAmount = Math.min(claimAmount, maxAmount);
        }
    } else {
        // æ™®é€šçº¢åŒ…ï¼šå¹³å‡åˆ†é…
        claimAmount = totalAmount / data.count;
    }
    
    claimAmount = parseFloat(claimAmount.toFixed(2));
    
    // è®°å½•é¢†å–
    data.claimed.push(myId);
    data.claimedAmounts[myId] = claimAmount.toFixed(2);
    
    // æ›´æ–°çº¢åŒ…æ¶ˆæ¯
    group.chat_history[msgIndex].content = JSON.stringify(data);
    await db.group_chats.put(group);
    
    // å¢åŠ ä½™é¢
    const user = await db.characters.get(myId);
    if (user) {
        if (!user.identity) user.identity = {};
        let balance = parseFloat(user.identity.balance || 0);
        balance += claimAmount;
        user.identity.balance = balance.toFixed(2);
        await db.characters.put(user);
    }
    
    // è®°å½•è´¦å•ï¼ˆæ”¶å…¥ï¼‰
    await addTransaction('income', claimAmount, 'çº¢åŒ…', `${group.name}`);
    
    // åˆ·æ–°çº¢åŒ…è¯¦æƒ…é¡µé¢
    await showRedPacketDetail(currentViewingRedPacketId);
    
    // åˆ·æ–°ç¾¤èŠ
    await renderGroupChatBody(group);
    
    showToast(`æˆåŠŸé¢†å– Â¥${claimAmount.toFixed(2)}`);
}

// é¢†å–ç¾¤èŠä¸“å±è½¬è´¦
async function receiveGroupTransfer(msgId) {
    if (!window.currentGroupChatId) return;
    
    const group = await db.group_chats.get(window.currentGroupChatId);
    if (!group || !group.chat_history) return;
    
    // æ‰¾åˆ°è½¬è´¦æ¶ˆæ¯
    const msgIndex = group.chat_history.findIndex(m => m.id === msgId && m.type === 'transfer');
    if (msgIndex === -1) return;
    
    const msg = group.chat_history[msgIndex];
    const data = JSON.parse(msg.content);
    
    // æ£€æŸ¥æ˜¯å¦å·²ç»è¢«é¢†å–
    if (data.status === 'received') {
        showToast('è¯¥è½¬è´¦å·²è¢«é¢†å–');
        return;
    }
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯è‡ªå·±å‘çš„
    const myId = currentMyCharId ? parseInt(currentMyCharId) : null;
    if (msg.role === 'user') {
        showToast('ä¸èƒ½é¢†å–è‡ªå·±å‘çš„è½¬è´¦');
        return;
    }
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯è½¬ç»™è‡ªå·±çš„ï¼ˆä¸“å±è½¬è´¦ï¼‰
    if (data.targetId && data.targetId !== myId) {
        // è·å–ç›®æ ‡åç§°
        const targetChar = await db.characters.get(data.targetId);
        const targetName = data.targetName || targetChar?.name || 'å…¶ä»–äºº';
        showToast(`è¿™æ˜¯ä¸“å±è½¬è´¦ç»™ ${targetName} çš„`);
        return;
    }
    
    // é¢†å–è½¬è´¦
    data.status = 'received';
    data.receivedBy = myId;
    data.receivedAt = Date.now();
    
    group.chat_history[msgIndex].content = JSON.stringify(data);
    await db.group_chats.put(group);
    
    // å¢åŠ ä½™é¢
    if (currentMyCharId) {
        const user = await db.characters.get(parseInt(currentMyCharId));
        if (user) {
            if (!user.identity) user.identity = {};
            let balance = parseFloat(user.identity.balance || 0);
            balance += parseFloat(data.amount);
            user.identity.balance = balance.toFixed(2);
            await db.characters.put(user);
        }
    }
    
    // è·å–å‘é€è€…åç§°
    let senderName = 'ç¾¤å‹';
    // ä»ç¾¤èŠå†å²ä¸­è·å–å‘é€è€…ä¿¡æ¯ï¼ˆå‡è®¾msgåŒ…å«senderIdï¼‰
    if (data.senderId) {
        const senderChar = await db.characters.get(data.senderId);
        if (senderChar) {
            const memberNicknames = group.memberNicknames || {};
            senderName = memberNicknames[data.senderId] || senderChar.remark || senderChar.wx_nickname || senderChar.name;
        }
    }
    
    // è®°å½•è´¦å•ï¼ˆæ”¶å…¥ï¼‰
    await addTransaction('income', data.amount, 'è½¬è´¦æ”¶æ¬¾', `æ¥è‡ª${senderName}`);
    
    // åˆ·æ–°ç¾¤èŠ
    await renderGroupChatBody(group);
    showToast(`å·²æ”¶æ¬¾ Â¥${data.amount}`);
}

/* =================
   ä½ç½®åŠŸèƒ½
   ================= */

// æ‰“å¼€ä½ç½®è¾“å…¥å¼¹çª—
function showLocationModal() {
    // æ¸…ç©ºè¾“å…¥
    document.getElementById('location-name-input').value = '';
    document.getElementById('location-address-input').value = '';
    
    const modal = document.getElementById('location-modal');
    modal.style.display = 'flex';
}

// å…³é—­ä½ç½®è¾“å…¥å¼¹çª—
function hideLocationModal() {
    document.getElementById('location-modal').style.display = 'none';
}

// å‘é€ä½ç½®æ¶ˆæ¯
async function sendLocationMessage() {
    const nameVal = document.getElementById('location-name-input').value.trim();
    const addressVal = document.getElementById('location-address-input').value.trim();
    
    if (!nameVal) {
        showToast("è¯·è¾“å…¥ä½ç½®åç§°");
        return;
    }
    
    if (!currentChatCharId) {
        showToast("è¯·å…ˆè¿›å…¥èŠå¤©");
        return;
    }
    
    const chatChar = await db.characters.get(currentChatCharId);
    if (!chatChar) {
        showToast("èŠå¤©å¯¹è±¡ä¸å­˜åœ¨");
        return;
    }
    
    const accountId = getCurrentAccountId();
    let history = getChatHistory(chatChar, accountId);
    
    const msgId = 'loc_' + Date.now();
    const msg = {
        id: msgId,
        role: 'user',
        type: 'location',
        content: JSON.stringify({
            name: nameVal,
            address: addressVal || 'æš‚æ— è¯¦ç»†åœ°å€'
        }), 
        time: Date.now()
    };
    
    history.push(msg);
    await setChatHistory(chatChar, accountId, history);
    
    // åˆ·æ–°èŠå¤©ç•Œé¢
    renderChatBody(chatChar);
    
    hideLocationModal();
    showToast("ä½ç½®å·²å‘é€");
    
    // å…³é—­æ›´å¤šé¢æ¿
    document.getElementById('action-panel').style.display = 'none';
    document.getElementById('chat-panel-container').classList.remove('open');
}

// æ˜¾ç¤ºä½ç½®è¯¦æƒ…
function showLocationDetail(encodedName, encodedAddress) {
    const name = decodeURIComponent(encodedName);
    const address = decodeURIComponent(encodedAddress);
    
    // åˆ›å»ºè¯¦æƒ…å¼¹çª—
    const overlay = document.createElement('div');
    overlay.id = 'location-detail-overlay';
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.4);
        z-index: 999;
        display: flex;
        justify-content: center;
        align-items: center;
    `;
    
    overlay.innerHTML = `
        <div style="
            background: #fff;
            width: 260px;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0,0,0,0.15);
        ">
            <div style="padding: 20px; text-align: center;">
                <div style="
                    width: 48px;
                    height: 48px;
                    background: #f5f5f5;
                    border-radius: 12px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    margin: 0 auto 16px;
                ">
                    <svg viewBox="0 0 24 24" style="width:24px; height:24px; fill:none; stroke:#666; stroke-width:2;">
                        <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                        <circle cx="12" cy="10" r="3"></circle>
                    </svg>
                </div>
                <div style="font-size: 16px; font-weight: 600; color: #333; margin-bottom: 6px;">${name}</div>
                <div style="font-size: 13px; color: #999;">${address || 'æš‚æ— è¯¦ç»†åœ°å€'}</div>
            </div>
            <div style="border-top: 1px solid #f0f0f0;">
                <button onclick="document.getElementById('location-detail-overlay').remove()" style="
                    width: 100%;
                    padding: 14px;
                    background: #fff;
                    color: #333;
                    border: none;
                    font-size: 15px;
                    font-weight: 500;
                    cursor: pointer;
                ">å…³é—­</button>
            </div>
        </div>
    `;
    
    overlay.onclick = (e) => {
        if (e.target === overlay) {
            overlay.remove();
        }
    };
    
    document.body.appendChild(overlay);
}

// æ£€æŸ¥é‡‘é¢è¾“å…¥ï¼Œæ§åˆ¶æŒ‰é’®çŠ¶æ€
function checkTransferAmount(input) {
    const btn = document.getElementById('btn-do-transfer');
    const val = parseFloat(input.value);
    if (!isNaN(val) && val > 0) {
        btn.disabled = false;
    } else {
        btn.disabled = true;
    }
}

// æ‰§è¡Œè½¬è´¦
async function doTransfer() {
    const amountVal = parseFloat(document.getElementById('t-amount-input').value);
    const noteVal = document.getElementById('t-note-input').value || 'è½¬è´¦ç»™å¯¹æ–¹';
    
    if (isNaN(amountVal) || amountVal <= 0) return;
    
    // 1. æ£€æŸ¥ä½™é¢
    if (!currentMyCharId) {
        showToast("è¯·å…ˆåœ¨è¯¦æƒ…é¡µè®¾ç½®Userèº«ä»½");
        return;
    }
    const user = await db.characters.get(parseInt(currentMyCharId));
    
    // ç¡®ä¿æœ‰ä½™é¢å­—æ®µ
    let currentBalance = 0;
    if (user && user.identity && user.identity.balance) {
        currentBalance = parseFloat(user.identity.balance.toString().replace(/,/g, ''));
    }
    
    if (currentBalance < amountVal) {
        showToast('ä½™é¢ä¸è¶³ (å½“å‰: Â¥' + currentBalance.toFixed(2) + ')');
        return;
    }
    
    // 2. æ‰£æ¬¾
    const newBalance = currentBalance - amountVal;
    user.identity.balance = newBalance.toFixed(2);
    await db.characters.put(user);
    
    // 3. åˆ¤æ–­æ˜¯ç¾¤èŠä¸“å±è½¬è´¦è¿˜æ˜¯ç§èŠè½¬è´¦
    if (window.currentGroupChatId && exclusiveTransferTarget) {
        // ç¾¤èŠä¸“å±è½¬è´¦
        const group = await db.group_chats.get(window.currentGroupChatId);
        if (!group) {
            showToast("ç¾¤èŠä¸å­˜åœ¨");
            return;
        }
        
        const msgId = 'trans_' + Date.now();
        const msg = {
            role: 'user',
            type: 'transfer',
            content: JSON.stringify({
                amount: amountVal.toFixed(2),
                desc: noteVal,
                status: 'sent',
                senderId: parseInt(currentMyCharId),
                targetId: exclusiveTransferTarget.memberId,
                targetName: exclusiveTransferTarget.displayName
            }), 
            time: Date.now(),
            id: msgId
        };
        
        if (!group.chat_history) group.chat_history = [];
        group.chat_history.push(msg);
        group.updated_at = Date.now();
        await db.group_chats.put(group);
        
        // è®°å½•è´¦å•
        await addTransaction('expense', amountVal, 'è½¬è´¦', `è½¬ç»™${exclusiveTransferTarget.displayName}`);
        
        // åˆ·æ–°ç¾¤èŠç•Œé¢
        await renderGroupChatBody(group);
        
        hideTransferPage();
        exclusiveTransferTarget = null; // æ¸…ç©ºç›®æ ‡
        showToast("è½¬è´¦æˆåŠŸ");
        return;
    }
    
    // ç§èŠè½¬è´¦
    const chatChar = await db.characters.get(currentChatCharId);
    if (!chatChar) {
        showToast("èŠå¤©å¯¹è±¡ä¸å­˜åœ¨");
        return;
    }
    
    const accountId = getCurrentAccountId();
    let history = getChatHistory(chatChar, accountId);
    
    const msgId = 'trans_' + Date.now();
    const transferData = {
        amount: amountVal.toFixed(2),
        desc: noteVal,
        status: 'sent'
    };
    const msg = {
        id: msgId,
        role: 'user',
        type: 'transfer',
        content: JSON.stringify(transferData), 
        time: Date.now()
    };
    
    history.push(msg);
    await setChatHistory(chatChar, accountId, history);
    
    // è®°å½•è´¦å•
    await addTransaction('expense', amountVal, 'è½¬è´¦', `è½¬ç»™${chatChar.remark || chatChar.wx_nickname || chatChar.name}`);
    
    // âœ… è”æœºå¥½å‹ï¼šé€šè¿‡æœåŠ¡å™¨å‘é€è½¬è´¦æ¶ˆæ¯
    if (chatChar.isOnlineFriend && chatChar.onlineData?.wx_account) {
        // è·å–å½“å‰å¯ç”¨çš„åœ¨çº¿è§’è‰²ï¼ˆå¦‚æœæ²¡æœ‰åˆ™è‡ªåŠ¨ä¸Šçº¿ï¼‰
        const onlineUserChar = await getOrCreateOnlineUserChar();
        
        if (onlineUserChar && onlineConnected) {
            const fromWxAccount = onlineUserChar.identity.account;
            const toWxAccount = chatChar.onlineData.wx_account;
            // å‘é€è½¬è´¦æ¶ˆæ¯ï¼ˆä½¿ç”¨ç‰¹æ®ŠJSONæ ¼å¼ï¼Œå¯¹æ–¹å¯ä»¥è¯†åˆ«å¹¶æ¸²æŸ“ä¸ºå¡ç‰‡ï¼‰
            const transferContent = JSON.stringify({
                __type: 'transfer',
                amount: amountVal.toFixed(2),
                desc: noteVal,
                status: 'sent'
            });
            sendOnlineMessage(toWxAccount, transferContent, fromWxAccount);
            console.log('[Online] è½¬è´¦æ¶ˆæ¯å·²å‘é€åˆ°æœåŠ¡å™¨');
        }
    }
    
    // åˆ·æ–°èŠå¤©ç•Œé¢
    renderChatBody(chatChar);
    
    hideTransferPage();
    showToast("è½¬è´¦æˆåŠŸ");
    
    // å…³é—­æ›´å¤šé¢æ¿
    document.getElementById('action-panel').style.display = 'none';
    document.getElementById('chat-panel-container').classList.remove('open');
}

/* =================
   è½¬è´¦ç¡®è®¤/è¯¦æƒ…é€»è¾‘
   ================= */

// ç‚¹å‡»å¡ç‰‡è§¦å‘
async function showTransferConfirm(msgId, isSelf, status) {
    if (status !== 'sent') return;
    if (isSelf) return;
    
    // ä»chat_historyä¸­æŸ¥æ‰¾æ¶ˆæ¯ - ä½¿ç”¨ getChatHistory æ”¯æŒå¤šè´¦å·
    const char = await db.characters.get(currentChatCharId);
    if (!char) return;
    
    const accountId = getCurrentAccountId();
    const history = getChatHistory(char, accountId);
    if (!history || history.length === 0) return;
    
    const msg = history.find(m => {
        // ç²¾ç¡®åŒ¹é…ID
        if (m.id === msgId) return true;
        // å¦‚æœæ¶ˆæ¯æ²¡æœ‰idï¼Œç”¨æ—¶é—´æˆ³åŒ¹é…
        if (!m.id && msgId === 'trans_' + m.time) return true;
        // å¦‚æœmsgIdæ˜¯trans_å¼€å¤´ï¼Œå°è¯•ç”¨æ—¶é—´æˆ³åŒ¹é…
        if (msgId.startsWith('trans_')) {
            const timeFromId = parseInt(msgId.replace('trans_', ''));
            if (m.time === timeFromId) return true;
        }
        return false;
    });
    if (!msg) return;
    
    // è§£æè½¬è´¦æ•°æ®
    let data = {};
    try {
        data = JSON.parse(msg.content);
    } catch(e) {
        return;
    }
    
    document.getElementById('t-confirm-desc').innerText = 'æ”¶åˆ°è½¬è´¦ Â¥' + data.amount;
    
    window.currentTransferMsgId = msgId;
    window.currentTransferMsgTime = msg.time; // ä¿å­˜æ—¶é—´æˆ³ç”¨äºæŸ¥æ‰¾
    
    document.getElementById('transfer-confirm-modal').style.display = 'flex';
}

async function handleTransferAction(action) {
    const modal = document.getElementById('transfer-confirm-modal');
    modal.style.display = 'none';
    
    const msgId = window.currentTransferMsgId;
    const msgTime = window.currentTransferMsgTime;
    if (!msgId || !currentChatCharId) return;
    
    const char = await db.characters.get(currentChatCharId);
    const accountId = getCurrentAccountId();
    let history = getChatHistory(char, accountId);
    if (!history || history.length === 0) return;
    
    const msgIndex = history.findIndex(m => {
        // ç²¾ç¡®åŒ¹é…IDï¼Œæˆ–è€…æ ¹æ®æ—¶é—´æˆ³ç”Ÿæˆçš„IDåŒ¹é…
        if (m.id === msgId) return true;
        if (!m.id && msgId === 'trans_' + m.time) return true;
        if (msgTime && m.time === msgTime) return true; // ä½¿ç”¨æ—¶é—´æˆ³åŒ¹é…
        return false;
    });
    if (msgIndex === -1) return;
    
    const msg = history[msgIndex];
    let data = {};
    try {
        data = JSON.parse(msg.content);
    } catch(e) {
        return;
    }
    
    if (action === 'accept') {
        data.status = 'received';
        msg.content = JSON.stringify(data);
        
        // å¦‚æœæ¶ˆæ¯æ²¡æœ‰typeå­—æ®µï¼Œè¡¥å……ä¸Š
        if (!msg.type) msg.type = 'transfer';
        // å¦‚æœæ¶ˆæ¯æ²¡æœ‰idï¼Œè¡¥å……ä¸Š
        if (!msg.id) msg.id = 'trans_' + msg.time;
        
        // è·å–å½“å‰è´¦å·IDå¹¶æ›´æ–°ä½™é¢
        const myAccountId = getCurrentAccountId();
        if (myAccountId) {
             const user = await db.characters.get(parseInt(myAccountId));
             if (user) {
                 let currentBalance = 0;
                 if (user.identity && typeof user.identity.balance !== 'undefined' && user.identity.balance !== null) {
                     currentBalance = parseFloat(user.identity.balance.toString().replace(/,/g, '')) || 0;
                 }
                 
                 let addAmount = parseFloat(data.amount) || 0;
                 let newBalance = currentBalance + addAmount;
                 
                 if (!user.identity) user.identity = {};
                 user.identity.balance = newBalance.toFixed(2);
                 await db.characters.put(user);
                 
                 // æ·»åŠ æ”¶å…¥è®°å½•åˆ°è´¦å•
                 await addTransaction('income', data.amount, 'å¾®ä¿¡è½¬è´¦', `æ¥è‡ª${char.name}${data.desc ? ' - ' + data.desc : ''}`);
                 
                 showToast('å·²æ”¶æ¬¾ Â¥' + data.amount);
             }
        }
        
    } else {
        data.status = 'returned';
        msg.content = JSON.stringify(data);
        
        if (!msg.type) msg.type = 'transfer';
        if (!msg.id) msg.id = 'trans_' + msg.time;
        
        showToast('å·²é€€å›è½¬è´¦');
    }
    
    history[msgIndex] = msg;
    await setChatHistory(char, accountId, history);
    
    renderChatBody(char);
}

// =================
// ç”µè¯é¡µé¢åŠŸèƒ½
// =================
let currentPhoneNumber = '';
let currentPhoneTab = 'recents';

function showPhonePage() {
    const page = document.getElementById('phone-page');
    page.style.display = 'flex';
    // é»˜è®¤æ˜¾ç¤ºæœ€è¿‘é€šè¯æ ‡ç­¾é¡µ
    switchPhoneTab('recents');
    // åˆå§‹åŒ–æ‹¨å·é”®ç›˜æŒ‰é’®çŠ¶æ€
    updatePhoneKeypadActions();
}

function hidePhonePage() {
    const page = document.getElementById('phone-page');
    page.style.display = 'none';
    // é‡ç½®æ‹¨å·é”®ç›˜
    currentPhoneNumber = '';
    updatePhoneNumberDisplay();
}

function switchPhoneTab(tab) {
    currentPhoneTab = tab;
    
    // æ›´æ–°æ ‡ç­¾æ çŠ¶æ€
    document.querySelectorAll('.phone-tab-item').forEach(item => {
        item.classList.remove('active');
        if (item.dataset.tab === tab) {
            item.classList.add('active');
        }
    });
    
    // æ›´æ–°å†…å®¹åŒºåŸŸ
    document.querySelectorAll('.phone-tab-content').forEach(content => {
        content.classList.remove('active');
    });
    
    const targetContent = document.getElementById('phone-tab-' + tab);
    if (targetContent) {
        targetContent.classList.add('active');
    }
    
    // æ ¹æ®æ ‡ç­¾é¡µåŠ è½½ç›¸åº”å†…å®¹
    if (tab === 'contacts') {
        loadPhoneContacts();
    } else if (tab === 'recents') {
        loadPhoneRecents();
    }
}

function loadPhoneContacts() {
    const contactsList = document.getElementById('phone-contacts-list');
    if (!contactsList) return;
    
    // ä»è§’è‰²æ¡£æ¡ˆä¸­åŠ è½½è”ç³»äºº
    db.characters.toArray().then(characters => {
        const contacts = characters.filter(c => c.type === 'char' || c.type === 'npc');
        
        if (contacts.length === 0) {
            contactsList.innerHTML = `
                <div class="phone-empty-state">
                    <svg class="phone-empty-icon" viewBox="0 0 24 24"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>
                    <div>æ— è”ç³»äºº</div>
                </div>
            `;
            return;
        }
        
        // æŒ‰åç§°æ’åº
        contacts.sort((a, b) => {
            const nameA = (a.nick || a.name || '').toUpperCase();
            const nameB = (b.nick || b.name || '').toUpperCase();
            return nameA.localeCompare(nameB);
        });
        
        let html = '';
        contacts.forEach(contact => {
            const name = contact.nick || contact.name || 'æœªçŸ¥';
            const phone = contact.identity?.phone || '';
            const firstLetter = name.charAt(0).toUpperCase();
            
            html += `
                <div class="phone-list-item" onclick="phoneCallContact(${contact.id})">
                    <div class="phone-list-avatar" style="background: ${contact.avatar ? 'url(' + contact.avatar + ')' : 'var(--ins-pink)'}; background-size: cover; background-position: center;">
                        ${!contact.avatar ? firstLetter : ''}
                    </div>
                    <div class="phone-list-info">
                        <div class="phone-list-name">${name}</div>
                        <div class="phone-list-subtitle">${phone || 'æ— å·ç '}</div>
                    </div>
                </div>
            `;
        });
        
        contactsList.innerHTML = html;
    });
}

async function loadPhoneRecents() {
    const recentsList = document.getElementById('phone-recents-list');
    if (!recentsList) return;
    
    const accountId = getCurrentAccountId();
    if (!accountId) {
        recentsList.innerHTML = `<div class="phone-empty-state"><div>è¯·å…ˆç™»å½•è´¦å·</div></div>`;
        return;
    }
    
    // ä» Dexie åŠ è½½æœ€è¿‘é€šè¯è®°å½•
    let recents = await db.phone_recents.where('accountId').equals(accountId).toArray();
    
    if (recents.length === 0) {
        recentsList.innerHTML = `
            <div class="phone-empty-state">
                <svg class="phone-empty-icon" viewBox="0 0 24 24"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg>
                <div>æ— æœ€è¿‘é€šè¯</div>
            </div>
        `;
        return;
    }
    
    // æŒ‰æ—¶é—´å€’åºæ’åº
    recents.sort((a, b) => b.time - a.time);
    
    let html = '';
    for (const recent of recents) {
        // å¦‚æœæœ‰ charIdï¼Œå°è¯•ä»æ•°æ®åº“è·å–æœ€æ–°çš„è§’è‰²å¤´åƒ
        let avatar = null;
        if (recent.charId) {
            const char = await db.characters.get(recent.charId);
            if (char) {
                avatar = char.avatar;
            }
        }
        
        const name = recent.name || recent.number || 'æœªçŸ¥';
        const phone = recent.number || '';
        const time = new Date(recent.time);
        const timeStr = formatPhoneTime(time);
        const firstLetter = name.charAt(0).toUpperCase();
        
        // ä½¿ç”¨å¤´åƒæˆ–é¦–å­—æ¯
        const avatarHtml = avatar 
            ? `<img src="${avatar}" class="phone-list-avatar" style="object-fit:cover;border-radius:50%;" />`
            : `<div class="phone-list-avatar">${firstLetter}</div>`;
        
        html += `
            <div class="phone-list-item" onclick="phoneCallNumber('${phone}')">
                ${avatarHtml}
                <div class="phone-list-info">
                    <div class="phone-list-name">${name}</div>
                    <div class="phone-list-subtitle">${timeStr}</div>
                </div>
            </div>
        `;
    }
    
    recentsList.innerHTML = html;
}

function formatPhoneTime(date) {
    const now = new Date();
    
    const month = (date.getMonth() + 1).toString();
    const day = date.getDate().toString();
    const hours = date.getHours().toString().padStart(2, '0');
    const minutes = date.getMinutes().toString().padStart(2, '0');
    
    // ğŸ¯ æ˜¾ç¤ºè¯¦ç»†æ—¶é—´ï¼Œä¸æ˜¾ç¤º"åˆšåˆš"
    // åˆ¤æ–­æ˜¯å¦æ˜¯ä»Šå¤©
    if (date.getDate() === now.getDate() && 
        date.getMonth() === now.getMonth() && 
        date.getFullYear() === now.getFullYear()) {
        return `ä»Šå¤© ${hours}:${minutes}`;
    }
    
    // åˆ¤æ–­æ˜¯å¦æ˜¯æ˜¨å¤©
    const yesterday = new Date(now);
    yesterday.setDate(yesterday.getDate() - 1);
    if (date.getDate() === yesterday.getDate() && 
        date.getMonth() === yesterday.getMonth() && 
        date.getFullYear() === yesterday.getFullYear()) {
        return `æ˜¨å¤© ${hours}:${minutes}`;
    }
    
    // åŒä¸€å¹´æ˜¾ç¤ºæœˆæ—¥+æ—¶é—´
    if (date.getFullYear() === now.getFullYear()) {
        return `${month}æœˆ${day}æ—¥ ${hours}:${minutes}`;
    }
    
    // ä¸åŒå¹´æ˜¾ç¤ºå®Œæ•´æ—¥æœŸ+æ—¶é—´
    return `${date.getFullYear()}å¹´${month}æœˆ${day}æ—¥ ${hours}:${minutes}`;
}

// æ‹¨å·é”®ç›˜åŠŸèƒ½
function phoneKeypadInput(key) {
    currentPhoneNumber += key;
    updatePhoneNumberDisplay();
    updatePhoneKeypadActions();
}

function phoneKeypadDelete() {
    if (currentPhoneNumber.length > 0) {
        currentPhoneNumber = currentPhoneNumber.slice(0, -1);
        updatePhoneNumberDisplay();
        updatePhoneKeypadActions();
    }
}

function updatePhoneNumberDisplay() {
    const display = document.getElementById('phone-number-display');
    if (display) {
        display.textContent = currentPhoneNumber || 'è¾“å…¥å·ç ';
        display.style.color = currentPhoneNumber ? '#000' : '#8e8e93';
    }
}

function updatePhoneKeypadActions() {
    const callBtn = document.getElementById('phone-call-btn');
    const deleteBtn = document.getElementById('phone-delete-btn');
    
    if (currentPhoneNumber.length > 0) {
        if (callBtn) {
            callBtn.style.display = 'flex';
            callBtn.style.background = '#34c759'; // ç»¿è‰²
        }
        if (deleteBtn) deleteBtn.style.display = 'flex';
    } else {
        if (callBtn) {
            callBtn.style.display = 'flex';
            callBtn.style.background = '#c7c7cc'; // ç°è‰²ï¼ˆç¦ç”¨çŠ¶æ€ï¼‰
        }
        if (deleteBtn) deleteBtn.style.display = 'none';
    }
}

function phoneMakeCall() {
    if (!currentPhoneNumber || currentPhoneNumber.length === 0) {
        showToast('è¯·è¾“å…¥ç”µè¯å·ç ');
        return;
    }
    
    // æŸ¥æ‰¾è”ç³»äºº
    db.characters.toArray().then(characters => {
        const contact = characters.find(c => 
            c.identity?.phone === currentPhoneNumber || 
            c.name === currentPhoneNumber || 
            c.nick === currentPhoneNumber
        );
        
        const name = contact ? (contact.nick || contact.name) : currentPhoneNumber;
        
        // æ·»åŠ åˆ°æœ€è¿‘é€šè¯
        addPhoneRecent(name, currentPhoneNumber);
        
        // æ˜¾ç¤ºé€šè¯ç•Œé¢ï¼ˆç®€åŒ–ç‰ˆï¼‰
        showToast(`æ­£åœ¨å‘¼å« ${name}...`);
        
        // æ¨¡æ‹Ÿé€šè¯
        setTimeout(() => {
            showToast('é€šè¯å·²ç»“æŸ');
        }, 2000);
    });
}

function phoneCallContact(charId) {
    db.characters.get(charId).then(contact => {
        if (!contact) return;
        
        const name = contact.nick || contact.name || 'æœªçŸ¥';
        const phone = contact.identity?.phone || '';
        
        if (!phone) {
            showToast('è¯¥è”ç³»äººæ²¡æœ‰ç”µè¯å·ç ');
            return;
        }
        
        // åˆ‡æ¢åˆ°æ‹¨å·é”®ç›˜å¹¶æ˜¾ç¤ºå·ç 
        switchPhoneTab('keypad');
        currentPhoneNumber = phone;
        updatePhoneNumberDisplay();
        updatePhoneKeypadActions();
        
        // æ·»åŠ åˆ°æœ€è¿‘é€šè¯
        addPhoneRecent(name, phone);
        
        // æ˜¾ç¤ºé€šè¯ç•Œé¢
        showToast(`æ­£åœ¨å‘¼å« ${name}...`);
        
        // æ¨¡æ‹Ÿé€šè¯
        setTimeout(() => {
            showToast('é€šè¯å·²ç»“æŸ');
        }, 2000);
    });
}

function phoneCallNumber(number) {
    currentPhoneNumber = number;
    switchPhoneTab('keypad');
    updatePhoneNumberDisplay();
    updatePhoneKeypadActions();
    phoneMakeCall();
}

async function addPhoneRecent(name, number, charId = null) {
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    // æ·»åŠ åˆ° Dexie æ•°æ®åº“
    await db.phone_recents.add({
        accountId: accountId,
        charId: charId,
        name: name,
        number: number,
        time: Date.now(),
        type: 'outgoing' // æ‹¨å‡ºç”µè¯
    });
    
    // é™åˆ¶æ¯ä¸ªè´¦å·æœ€å¤šä¿ç•™100æ¡
    const count = await db.phone_recents.where('accountId').equals(accountId).count();
    if (count > 100) {
        const oldest = await db.phone_recents.where('accountId').equals(accountId).sortBy('time');
        const toDelete = oldest.slice(0, count - 100);
        await db.phone_recents.bulkDelete(toDelete.map(r => r.id));
    }
}

// æ‹¨å·é”®ç›˜åˆå§‹åŒ–åœ¨showPhonePageä¸­å®Œæˆ

// ============================================
// è£…æ‰®åŠŸèƒ½
// ============================================
const wyyDressUpBtn = document.getElementById('wyyDressUpBtn');
const wyyDressUpModal = document.getElementById('wyyDressUpModal');
const wyyCancelBtn = document.getElementById('wyyCancelBtn');
const wyySaveBtn = document.getElementById('wyySaveBtn');
const wyyUploadAvatarBtn = document.getElementById('wyyUploadAvatarBtn');
const wyyAvatarFileInput = document.getElementById('wyyAvatarFileInput');
const wyyAvatarDisplay = document.getElementById('wyyAvatarDisplay');
const wyyModalAvatarPreview = document.getElementById('wyyModalAvatarPreview');

const wyyFollowInput = document.getElementById('wyyFollowInput');
const wyyFansInput = document.getElementById('wyyFansInput');
const wyyLevelInput = document.getElementById('wyyLevelInput');
const wyyTimeInput = document.getElementById('wyyTimeInput');

const wyyFollowValue = document.querySelector('.wyy-stat-item[data-type="follow"] .wyy-stat-value');
const wyyFansValue = document.querySelector('.wyy-stat-item[data-type="fans"] .wyy-stat-value');
const wyyLevelValue = document.querySelector('.wyy-stat-item[data-type="level"] .wyy-stat-value');
const wyyTimeValue = document.querySelector('.wyy-stat-item[data-type="time"] .wyy-stat-value');

const wyyCard1 = document.getElementById('wyyCard1');
const wyyCard2 = document.getElementById('wyyCard2');
const wyyCard3 = document.getElementById('wyyCard3');
const wyyCard4 = document.getElementById('wyyCard4');

const wyyModalCardPreview1 = document.getElementById('wyyModalCardPreview1');
const wyyModalCardPreview2 = document.getElementById('wyyModalCardPreview2');
const wyyModalCardPreview3 = document.getElementById('wyyModalCardPreview3');
const wyyModalCardPreview4 = document.getElementById('wyyModalCardPreview4');

const wyyCardUploadBtns = document.querySelectorAll('.wyy-card-upload-btn');
const wyyCardFileInputs = document.querySelectorAll('.wyy-card-file-input');

let wyyTempAvatar = null;
const wyyTempCards = { 1: null, 2: null, 3: null, 4: null };

if (wyyDressUpBtn) {
    wyyDressUpBtn.addEventListener('click', () => {
        wyyLoadCurrentSettings();
        if (wyyDressUpModal) wyyDressUpModal.style.display = 'flex';
        wyyResetTempData();
    });
}

if (wyyCancelBtn) {
    wyyCancelBtn.addEventListener('click', () => {
        if (wyyDressUpModal) wyyDressUpModal.style.display = 'none';
        wyyResetTempData();
    });
}

if (wyySaveBtn) {
    wyySaveBtn.addEventListener('click', () => {
        wyySaveSettings();
        if (wyyDressUpModal) wyyDressUpModal.style.display = 'none';
    });
}

if (wyyDressUpModal) {
    wyyDressUpModal.addEventListener('click', (e) => {
        if (e.target === wyyDressUpModal) {
            wyyDressUpModal.style.display = 'none';
            wyyResetTempData();
        }
    });
}

if (wyyUploadAvatarBtn && wyyAvatarFileInput) {
    wyyUploadAvatarBtn.addEventListener('click', () => {
        wyyAvatarFileInput.click();
    });

    wyyAvatarFileInput.addEventListener('change', function(event) {
        wyyHandleFileUpload(event, 'avatar');
    });
}

if (wyyCardFileInputs && wyyCardFileInputs.length > 0) {
    wyyCardFileInputs.forEach(input => {
        input.addEventListener('change', function(event) {
            const cardNum = this.getAttribute('data-card');
            wyyHandleFileUpload(event, `card${cardNum}`);
        });
    });
}

if (wyyCardUploadBtns && wyyCardUploadBtns.length > 0) {
    wyyCardUploadBtns.forEach(btn => {
        btn.addEventListener('click', function() {
            const cardNum = this.getAttribute('data-card');
            const fileInput = document.querySelector(`.wyy-card-file-input[data-card="${cardNum}"]`);
            if (fileInput) fileInput.click();
        });
    });
}

function wyyHandleFileUpload(event, type) {
    const file = event.target.files[0];
    
    if (file) {
        if (!file.type.match('image.*')) {
            alert('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶ï¼');
            return;
        }
        
        if (file.size > 5 * 1024 * 1024) {
            alert('å›¾ç‰‡å¤§å°ä¸èƒ½è¶…è¿‡5MBï¼');
            return;
        }
        
        const reader = new FileReader();
        
        reader.onload = function(e) {
            if (type === 'avatar') {
                if (wyyModalAvatarPreview) wyyModalAvatarPreview.style.backgroundImage = `url(${e.target.result})`;
                wyyTempAvatar = e.target.result;
            } else {
                const cardNum = type.replace('card', '');
                const preview = document.getElementById(`wyyModalCardPreview${cardNum}`);
                if (preview) {
                    preview.style.backgroundImage = `url(${e.target.result})`;
                    wyyTempCards[cardNum] = e.target.result;
                }
            }
        };
        
        reader.readAsDataURL(file);
    }
}

async function wyyLoadCurrentSettings() {
    try {
        const userSettings = await wyyDb.userSettings.get('avatar');
        if (userSettings && wyyModalAvatarPreview) {
            wyyModalAvatarPreview.style.backgroundImage = `url(${userSettings.data})`;
        } else if (wyyModalAvatarPreview) {
            wyyModalAvatarPreview.style.backgroundImage = '';
        }
        
        const savedFollow = (await wyyDb.userSettings.get('follow'))?.data || '29';
        const savedFans = (await wyyDb.userSettings.get('fans'))?.data || '9';
        const savedLevel = (await wyyDb.userSettings.get('level'))?.data || 'Lv.7';
        const savedTime = (await wyyDb.userSettings.get('time'))?.data || '904h';
        
        if (wyyFollowInput) wyyFollowInput.value = savedFollow;
        if (wyyFansInput) wyyFansInput.value = savedFans;
        if (wyyLevelInput) wyyLevelInput.value = savedLevel;
        if (wyyTimeInput) wyyTimeInput.value = savedTime;
        
        for (let i = 1; i <= 4; i++) {
            const cardKey = `card${i}`;
            const savedCard = await wyyDb.playlistCards.get(cardKey);
            const preview = document.getElementById(`wyyModalCardPreview${i}`);
            if (preview) {
                if (savedCard) {
                    preview.style.backgroundImage = `url(${savedCard.data})`;
                } else {
                    preview.style.backgroundImage = '';
                }
            }
        }
    } catch (error) {
        console.error('åŠ è½½è®¾ç½®å¤±è´¥:', error);
    }
}

async function wyySaveSettings() {
    try {
        if (wyyTempAvatar) {
            if (wyyAvatarDisplay) wyyAvatarDisplay.style.backgroundImage = `url(${wyyTempAvatar})`;
            await wyyDb.userSettings.put({ id: 'avatar', data: wyyTempAvatar });
        }
        
        if (wyyFollowInput && wyyFansInput && wyyLevelInput && wyyTimeInput) {
            const follow = wyyFollowInput.value;
            const fans = wyyFansInput.value;
            const level = wyyLevelInput.value;
            const time = wyyTimeInput.value;
            
            if (wyyFollowValue) wyyFollowValue.textContent = follow;
            if (wyyFansValue) wyyFansValue.textContent = fans;
            if (wyyLevelValue) wyyLevelValue.textContent = level;
            if (wyyTimeValue) wyyTimeValue.textContent = time;
            
            await wyyDb.userSettings.put({ id: 'follow', data: follow });
            await wyyDb.userSettings.put({ id: 'fans', data: fans });
            await wyyDb.userSettings.put({ id: 'level', data: level });
            await wyyDb.userSettings.put({ id: 'time', data: time });
        }
        
        for (let i = 1; i <= 4; i++) {
            if (wyyTempCards[i]) {
                const cardElement = document.getElementById(`wyyCard${i}`);
                if (cardElement) {
                    cardElement.style.backgroundImage = `url(${wyyTempCards[i]})`;
                    await wyyDb.playlistCards.put({ id: `card${i}`, data: wyyTempCards[i] });
                }
            }
        }
        
        wyyResetTempData();
    } catch (error) {
        console.error('ä¿å­˜è®¾ç½®å¤±è´¥:', error);
    }
}

function wyyResetTempData() {
    wyyTempAvatar = null;
    for (let i = 1; i <= 4; i++) {
        wyyTempCards[i] = null;
    }
}

// ============================================
// æ­Œå•ç®¡ç†åŠŸèƒ½
// ============================================

// åŠ è½½æ­Œå•åˆ—è¡¨
async function wyyLoadPlaylists() {
    try {
        const playlists = await wyyDb.playlists.orderBy('dateCreated').reverse().toArray();
        const playlistsList = document.getElementById('wyyPlaylistsList');
        if (!playlistsList) return;
        
        if (playlists.length === 0) {
            playlistsList.innerHTML = '';
            return;
        }
        
        let html = '';
        playlists.forEach(playlist => {
            html += `
                <div class="wyy-playlist-card" data-playlist-id="${playlist.id}" style="cursor: pointer;">
                    <div class="wyy-playlist-cover" style="${playlist.cover ? `background-image: url(${playlist.cover})` : 'background: #f0f0f0;'}"></div>
                    <div class="wyy-playlist-info">
                        <div class="wyy-playlist-name">${playlist.name}</div>
                        <div class="wyy-playlist-desc">${playlist.desc || 'æš‚æ— æè¿°'}</div>
                    </div>
                    <div class="wyy-playlist-actions" style="display: flex; gap: 10px; align-items: center;">
                        <button class="wyy-control-btn" onclick="event.stopPropagation(); wyyExportSinglePlaylist(${playlist.id})" title="å¯¼å‡º">
                            <i class="fa fa-download"></i>
                        </button>
                        <button class="wyy-control-btn" onclick="event.stopPropagation(); wyyDeletePlaylist(${playlist.id})" title="åˆ é™¤" style="color: #ff4444;">
                            <i class="fa fa-trash"></i>
                        </button>
                    </div>
                </div>
            `;
        });
        
        playlistsList.innerHTML = html;
        
        // æ·»åŠ ç‚¹å‡»äº‹ä»¶ï¼ˆç‚¹å‡»æ­Œå•å¡ç‰‡æ˜¾ç¤ºè¯¦æƒ…ï¼Œç‚¹å‡»æ“ä½œæŒ‰é’®ä¸è§¦å‘ï¼‰
        document.querySelectorAll('.wyy-playlist-card[data-playlist-id]').forEach(card => {
            card.addEventListener('click', async function(e) {
                // å¦‚æœç‚¹å‡»çš„æ˜¯æ“ä½œæŒ‰é’®åŒºåŸŸï¼Œä¸è§¦å‘
                if (e.target.closest('.wyy-playlist-actions')) {
                    return;
                }
                const playlistId = parseInt(this.getAttribute('data-playlist-id'));
                await wyyShowPlaylistDetail(playlistId);
            });
        });
    } catch (error) {
        console.error('åŠ è½½æ­Œå•åˆ—è¡¨å¤±è´¥:', error);
    }
}

// åˆ‡æ¢æ­Œå•
async function wyySwitchPlaylist(playlistId) {
    wyyCurrentPlaylistId = playlistId;
    await wyyInitPlaylist();
}

// æ˜¾ç¤ºæ­Œå•è¯¦æƒ…
async function wyyShowPlaylistDetail(playlistId) {
    try {
        const playlist = await wyyDb.playlists.get(playlistId);
        if (!playlist) {
            alert('æ­Œå•ä¸å­˜åœ¨');
            return;
        }
        
        let songs = await wyyDb.songs.where('playlistId').equals(playlistId).toArray();
        // åœ¨å†…å­˜ä¸­æŒ‰æ—¥æœŸæ’åº
        songs.sort((a, b) => {
            const dateA = a.dateAdded ? new Date(a.dateAdded).getTime() : 0;
            const dateB = b.dateAdded ? new Date(b.dateAdded).getTime() : 0;
            return dateA - dateB;
        });
        
        // æ›´æ–°æ ‡é¢˜
        const titleElement = document.getElementById('wyyPlaylistDetailTitle');
        if (titleElement) {
            titleElement.textContent = `${playlist.name} (${songs.length}é¦–)`;
        }
        
        // æ˜¾ç¤ºæ­Œæ›²åˆ—è¡¨
        const songsListElement = document.getElementById('wyyPlaylistDetailSongsList');
        if (!songsListElement) return;
        
        if (songs.length === 0) {
            songsListElement.innerHTML = '<div class="wyy-empty-playlist">è¯¥æ­Œå•æš‚æ— æ­Œæ›²</div>';
        } else {
            let html = '';
            songs.forEach((song, index) => {
                const hasCover = song.cover && song.cover !== '';
                html += `
                    <div class="wyy-song-item" data-song-id="${song.id}">
                        <div class="wyy-song-item-icon ${!hasCover ? 'default' : ''}" style="${hasCover ? `background-image: url(${song.cover})` : ''}">
                            ${!hasCover ? (index + 1) : ''}
                        </div>
                        <div class="wyy-song-item-info">
                            <div class="wyy-song-item-name">${song.name}</div>
                            <div class="wyy-song-item-singer">${song.singer}</div>
                        </div>
                    </div>
                `;
            });
            songsListElement.innerHTML = html;
        }
        
        // æ˜¾ç¤ºæ¨¡æ€æ¡†
        const modal = document.getElementById('wyyPlaylistDetailModal');
        if (modal) {
            modal.style.display = 'flex';
            
            // è®¾ç½®åˆ‡æ¢åˆ°è¯¥æ­Œå•çš„æŒ‰é’®äº‹ä»¶
            const switchBtn = document.getElementById('wyySwitchToPlaylistBtn');
            if (switchBtn) {
                switchBtn.onclick = async () => {
                    await wyySwitchPlaylist(playlistId);
                    modal.style.display = 'none';
                };
            }
        }
    } catch (error) {
        console.error('åŠ è½½æ­Œå•è¯¦æƒ…å¤±è´¥:', error);
        alert('åŠ è½½æ­Œå•è¯¦æƒ…å¤±è´¥');
    }
}

// å…³é—­æ­Œå•è¯¦æƒ…
const wyyClosePlaylistDetailBtn = document.getElementById('wyyClosePlaylistDetailBtn');
const wyyPlaylistDetailModal = document.getElementById('wyyPlaylistDetailModal');

if (wyyClosePlaylistDetailBtn) {
    wyyClosePlaylistDetailBtn.addEventListener('click', () => {
        if (wyyPlaylistDetailModal) wyyPlaylistDetailModal.style.display = 'none';
    });
}

if (wyyPlaylistDetailModal) {
    wyyPlaylistDetailModal.addEventListener('click', (e) => {
        if (e.target === wyyPlaylistDetailModal) {
            wyyPlaylistDetailModal.style.display = 'none';
        }
    });
}

// æ‰“å¼€æ­Œå•ç®¡ç†
const wyyManagePlaylistsBtn = document.getElementById('wyyManagePlaylistsBtn');
if (wyyManagePlaylistsBtn) {
    wyyManagePlaylistsBtn.addEventListener('click', () => {
        const modal = document.getElementById('wyyPlaylistManageModal');
        if (modal) {
            modal.style.display = 'flex';
        }
    });
}

// åˆ›å»ºæ­Œå•
const wyyNewPlaylistBtn = document.getElementById('wyyNewPlaylistBtn');
const wyyCreatePlaylistModal = document.getElementById('wyyCreatePlaylistModal');
const wyyNewPlaylistName = document.getElementById('wyyNewPlaylistName');
const wyyNewPlaylistDesc = document.getElementById('wyyNewPlaylistDesc');
const wyyNewPlaylistCoverPreview = document.getElementById('wyyNewPlaylistCoverPreview');
const wyyUploadPlaylistCoverBtn = document.getElementById('wyyUploadPlaylistCoverBtn');
const wyyPlaylistCoverFileInput = document.getElementById('wyyPlaylistCoverFileInput');
const wyyCancelCreatePlaylistBtn = document.getElementById('wyyCancelCreatePlaylistBtn');
const wyySaveCreatePlaylistBtn = document.getElementById('wyySaveCreatePlaylistBtn');

let wyyTempPlaylistCover = null;

if (wyyNewPlaylistBtn) {
    wyyNewPlaylistBtn.addEventListener('click', () => {
        if (wyyCreatePlaylistModal) wyyCreatePlaylistModal.style.display = 'flex';
        if (wyyNewPlaylistName) wyyNewPlaylistName.value = '';
        if (wyyNewPlaylistDesc) wyyNewPlaylistDesc.value = '';
        if (wyyNewPlaylistCoverPreview) wyyNewPlaylistCoverPreview.style.backgroundImage = '';
        wyyTempPlaylistCover = null;
    });
}

if (wyyUploadPlaylistCoverBtn && wyyPlaylistCoverFileInput) {
    wyyUploadPlaylistCoverBtn.addEventListener('click', () => {
        wyyPlaylistCoverFileInput.click();
    });

    wyyPlaylistCoverFileInput.addEventListener('change', function(event) {
        const file = event.target.files[0];
        if (file) {
            if (!file.type.match('image.*')) {
                alert('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶ï¼');
                return;
            }
            if (file.size > 5 * 1024 * 1024) {
                alert('å›¾ç‰‡å¤§å°ä¸èƒ½è¶…è¿‡5MBï¼');
                return;
            }
            const reader = new FileReader();
            reader.onload = function(e) {
                if (wyyNewPlaylistCoverPreview) wyyNewPlaylistCoverPreview.style.backgroundImage = `url(${e.target.result})`;
                wyyTempPlaylistCover = e.target.result;
            };
            reader.readAsDataURL(file);
        }
    });
}

if (wyyCancelCreatePlaylistBtn) {
    wyyCancelCreatePlaylistBtn.addEventListener('click', () => {
        if (wyyCreatePlaylistModal) wyyCreatePlaylistModal.style.display = 'none';
    });
}

if (wyySaveCreatePlaylistBtn && wyyNewPlaylistName) {
    wyySaveCreatePlaylistBtn.addEventListener('click', async () => {
        const name = wyyNewPlaylistName.value.trim();
        if (!name) {
            alert('è¯·è¾“å…¥æ­Œå•åç§°');
            return;
        }
        
        try {
            const playlistId = await wyyDb.playlists.add({
                name: name,
                desc: wyyNewPlaylistDesc ? wyyNewPlaylistDesc.value.trim() : '',
                cover: wyyTempPlaylistCover || '',
                dateCreated: new Date()
            });
            
            if (wyyCreatePlaylistModal) wyyCreatePlaylistModal.style.display = 'none';
            await wyyLoadPlaylists();
            await wyySwitchPlaylist(playlistId);
            alert('æ­Œå•åˆ›å»ºæˆåŠŸï¼');
        } catch (error) {
            console.error('åˆ›å»ºæ­Œå•å¤±è´¥:', error);
            alert('åˆ›å»ºæ­Œå•å¤±è´¥ï¼Œè¯·é‡è¯•');
        }
    });
}

if (wyyCreatePlaylistModal) {
    wyyCreatePlaylistModal.addEventListener('click', (e) => {
        if (e.target === wyyCreatePlaylistModal) {
            wyyCreatePlaylistModal.style.display = 'none';
        }
    });
}

// åˆ é™¤æ­Œå•
async function wyyDeletePlaylist(playlistId) {
    if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªæ­Œå•å—ï¼Ÿæ­Œå•ä¸­çš„æ­Œæ›²ä¸ä¼šè¢«åˆ é™¤ã€‚')) {
        return;
    }
    
    try {
        // åˆ é™¤æ­Œå•
        await wyyDb.playlists.delete(playlistId);
        
        // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰æ­Œå•ï¼Œåˆ‡æ¢åˆ°é»˜è®¤æ­Œå•
        if (wyyCurrentPlaylistId === playlistId) {
            wyyCurrentPlaylistId = null;
            await wyyInitPlaylist();
        }
        
        await wyyLoadPlaylists();
        alert('æ­Œå•åˆ é™¤æˆåŠŸï¼');
    } catch (error) {
        console.error('åˆ é™¤æ­Œå•å¤±è´¥:', error);
        alert('åˆ é™¤æ­Œå•å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
}

// å¯¼å‡ºå•ä¸ªæ­Œå•
async function wyyExportSinglePlaylist(playlistId) {
    try {
        const playlist = await wyyDb.playlists.get(playlistId);
        if (!playlist) {
            alert('æ­Œå•ä¸å­˜åœ¨');
            return;
        }
        
        const songs = await wyyDb.songs.where('playlistId').equals(playlistId).toArray();
        
        // åŠ è½½æ¯é¦–æ­Œæ›²çš„å®Œæ•´ä¿¡æ¯
        const fullSongs = [];
        for (const song of songs) {
            const songFile = await wyyDb.songFiles.where({ songId: song.id }).first();
            const lyric = await wyyDb.lyrics.where({ songId: song.id }).first();
            
            const fullSong = {
                name: song.name,
                singer: song.singer,
                cover: song.cover || '',
                url: song.url || '',
                lyricUrl: song.lyricUrl || '',
                hasLocalFile: !!songFile,
                hasLocalLyric: !!lyric
            };
            
            if (songFile) {
                fullSong.fileData = songFile.data;
                fullSong.fileType = songFile.type;
            }
            
            if (lyric) {
                fullSong.lyricData = lyric.data;
            }
            
            fullSongs.push(fullSong);
        }
        
        const exportData = {
            playlist: {
                name: playlist.name,
                desc: playlist.desc,
                cover: playlist.cover
            },
            songs: fullSongs,
            exportDate: new Date().toISOString()
        };
        
        const dataStr = JSON.stringify(exportData, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `${playlist.name}.json`;
        link.click();
        URL.revokeObjectURL(url);
        
        alert('æ­Œå•å¯¼å‡ºæˆåŠŸï¼');
    } catch (error) {
        console.error('å¯¼å‡ºæ­Œå•å¤±è´¥:', error);
        alert('å¯¼å‡ºæ­Œå•å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
}

// å¯¼å‡ºå½“å‰æ­Œå•
const wyyExportPlaylistBtn = document.getElementById('wyyExportPlaylistBtn');
if (wyyExportPlaylistBtn) {
    wyyExportPlaylistBtn.addEventListener('click', async () => {
        if (!wyyCurrentPlaylistId) {
            alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ­Œå•');
            return;
        }
        await wyyExportSinglePlaylist(wyyCurrentPlaylistId);
    });
}

// å¯¼å…¥æ­Œå•
const wyyImportPlaylistBtn = document.getElementById('wyyImportPlaylistBtn');
const wyyImportPlaylistFileInput = document.getElementById('wyyImportPlaylistFileInput');

if (wyyImportPlaylistBtn && wyyImportPlaylistFileInput) {
    wyyImportPlaylistBtn.addEventListener('click', () => {
        wyyImportPlaylistFileInput.click();
    });

    wyyImportPlaylistFileInput.addEventListener('change', async function(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        if (!file.name.endsWith('.json')) {
            alert('è¯·é€‰æ‹©JSONæ ¼å¼çš„æ–‡ä»¶');
            return;
        }
        
        try {
            const text = await file.text();
            const importData = JSON.parse(text);
            
            if (!importData.playlist || !importData.songs) {
                alert('æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®');
                return;
            }
            
            // åˆ›å»ºæ­Œå•
            const playlistId = await wyyDb.playlists.add({
                name: importData.playlist.name + ' (å¯¼å…¥)',
                desc: importData.playlist.desc || '',
                cover: importData.playlist.cover || '',
                dateCreated: new Date()
            });
            
            // å¯¼å…¥æ­Œæ›²
            for (const songData of importData.songs) {
                const songId = await wyyDb.songs.add({
                    name: songData.name,
                    singer: songData.singer,
                    cover: songData.cover || '',
                    url: songData.url || '',
                    lyricUrl: songData.lyricUrl || '',
                    playlistId: playlistId,
                    dateAdded: new Date()
                });
                
                if (songData.hasLocalFile && songData.fileData) {
                    await wyyDb.songFiles.add({
                        songId: songId,
                        type: songData.fileType || 'audio/mpeg',
                        data: songData.fileData
                    });
                }
                
                if (songData.hasLocalLyric && songData.lyricData) {
                    await wyyDb.lyrics.add({
                        songId: songId,
                        data: songData.lyricData
                    });
                }
            }
            
            await wyyLoadPlaylists();
            await wyySwitchPlaylist(playlistId);
            alert('æ­Œå•å¯¼å…¥æˆåŠŸï¼');
        } catch (error) {
            console.error('å¯¼å…¥æ­Œå•å¤±è´¥:', error);
            alert('å¯¼å…¥æ­Œå•å¤±è´¥ï¼š' + error.message);
        }
    });
}

// æ·»åŠ åˆ°æ­Œå•åŠŸèƒ½
const wyyAddToPlaylistModal = document.getElementById('wyyAddToPlaylistModal');
const wyyPlaylistSelectorList = document.getElementById('wyyPlaylistSelectorList');
const wyyCancelAddToPlaylistBtn = document.getElementById('wyyCancelAddToPlaylistBtn');
let wyyCurrentAddSongId = null;

// æ˜¾ç¤ºæ·»åŠ åˆ°æ­Œå•æ¨¡æ€æ¡†
async function wyyShowAddToPlaylistModal(songId) {
    wyyCurrentAddSongId = songId;
    
    try {
        const playlists = await wyyDb.playlists.orderBy('dateCreated').reverse().toArray();
        
        if (!wyyPlaylistSelectorList) return;
        
        if (playlists.length === 0) {
            wyyPlaylistSelectorList.innerHTML = '<div style="text-align: center; padding: 20px; color: #999;">è¿˜æ²¡æœ‰æ­Œå•ï¼Œè¯·å…ˆåˆ›å»ºæ­Œå•</div>';
        } else {
            let html = '';
            playlists.forEach(playlist => {
                html += `
                    <div class="wyy-playlist-selector-item" data-playlist-id="${playlist.id}" style="padding: 12px; border-bottom: 1px solid #eee; cursor: pointer; display: flex; align-items: center; gap: 12px; transition: background 0.2s;">
                        <div class="wyy-playlist-cover" style="width: 40px; height: 40px; border-radius: 6px; ${playlist.cover ? `background-image: url(${playlist.cover})` : 'background: #f0f0f0;'}"></div>
                        <div style="flex: 1;">
                            <div style="font-weight: 500; color: #333; margin-bottom: 2px;">${playlist.name}</div>
                            <div style="font-size: 12px; color: #999;">${playlist.desc || 'æš‚æ— æè¿°'}</div>
                        </div>
                        <i class="fa fa-chevron-right" style="color: #ccc;"></i>
                    </div>
                `;
            });
            
            wyyPlaylistSelectorList.innerHTML = html;
            
            // æ·»åŠ ç‚¹å‡»äº‹ä»¶
            document.querySelectorAll('.wyy-playlist-selector-item').forEach(item => {
                item.addEventListener('click', async function() {
                    const playlistId = parseInt(this.getAttribute('data-playlist-id'));
                    await wyyAddSongToPlaylist(songId, playlistId);
                });
            });
        }
        
        if (wyyAddToPlaylistModal) wyyAddToPlaylistModal.style.display = 'flex';
    } catch (error) {
        console.error('åŠ è½½æ­Œå•åˆ—è¡¨å¤±è´¥:', error);
        alert('åŠ è½½æ­Œå•åˆ—è¡¨å¤±è´¥');
    }
}

// å°†æ­Œæ›²æ·»åŠ åˆ°æ­Œå•
async function wyyAddSongToPlaylist(songId, playlistId) {
    try {
        // æ£€æŸ¥æ­Œæ›²æ˜¯å¦å·²ç»åœ¨æ­Œå•ä¸­
        const existingSong = await wyyDb.songs.where({ id: songId, playlistId: playlistId }).first();
        if (existingSong) {
            alert('æ­Œæ›²å·²åœ¨è¯¥æ­Œå•ä¸­');
            if (wyyAddToPlaylistModal) wyyAddToPlaylistModal.style.display = 'none';
            return;
        }
        
        // è·å–åŸæ­Œæ›²ä¿¡æ¯
        const originalSong = await wyyDb.songs.get(songId);
        if (!originalSong) {
            alert('æ­Œæ›²ä¸å­˜åœ¨');
            return;
        }
        
        // åˆ›å»ºæ–°æ­Œæ›²è®°å½•ï¼ˆæ·»åŠ åˆ°æ–°æ­Œå•ï¼‰
        const newSongData = {
            name: originalSong.name,
            singer: originalSong.singer,
            cover: originalSong.cover || '',
            url: originalSong.url || '',
            lyricUrl: originalSong.lyricUrl || '',
            playlistId: playlistId,
            dateAdded: new Date()
        };
        
        const newSongId = await wyyDb.songs.add(newSongData);
        
        // å¤åˆ¶æ­Œæ›²æ–‡ä»¶
        const songFile = await wyyDb.songFiles.where({ songId: songId }).first();
        if (songFile) {
            await wyyDb.songFiles.add({
                songId: newSongId,
                type: songFile.type,
                data: songFile.data
            });
        }
        
        // å¤åˆ¶æ­Œè¯æ–‡ä»¶
        const lyric = await wyyDb.lyrics.where({ songId: songId }).first();
        if (lyric) {
            await wyyDb.lyrics.add({
                songId: newSongId,
                data: lyric.data
            });
        }
        
        if (wyyAddToPlaylistModal) wyyAddToPlaylistModal.style.display = 'none';
        alert('æ­Œæ›²å·²æ·»åŠ åˆ°æ­Œå•ï¼');
    } catch (error) {
        console.error('æ·»åŠ æ­Œæ›²åˆ°æ­Œå•å¤±è´¥:', error);
        alert('æ·»åŠ æ­Œæ›²åˆ°æ­Œå•å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
}

if (wyyCancelAddToPlaylistBtn) {
    wyyCancelAddToPlaylistBtn.addEventListener('click', () => {
        if (wyyAddToPlaylistModal) wyyAddToPlaylistModal.style.display = 'none';
    });
}

if (wyyAddToPlaylistModal) {
    wyyAddToPlaylistModal.addEventListener('click', (e) => {
        if (e.target === wyyAddToPlaylistModal) {
            wyyAddToPlaylistModal.style.display = 'none';
        }
    });
}

// æ­Œå•ç®¡ç†æ¨¡æ€æ¡†
const wyyPlaylistManageModal = document.getElementById('wyyPlaylistManageModal');
const wyyClosePlaylistManageBtn = document.getElementById('wyyClosePlaylistManageBtn');

if (wyyClosePlaylistManageBtn) {
    wyyClosePlaylistManageBtn.addEventListener('click', () => {
        if (wyyPlaylistManageModal) wyyPlaylistManageModal.style.display = 'none';
    });
}

if (wyyPlaylistManageModal) {
    wyyPlaylistManageModal.addEventListener('click', (e) => {
        if (e.target === wyyPlaylistManageModal) {
            wyyPlaylistManageModal.style.display = 'none';
        }
    });
}

// ============================================
// ä¸€èµ·å¬åŠŸèƒ½
// ============================================
let wyyTogetherListenRole = null; // å½“å‰ä¸€èµ·å¬çš„è§’è‰²
let wyyTogetherListenInterval = null; // æ›´æ–°ä¸€èµ·å¬çŠ¶æ€çš„å®šæ—¶å™¨

const wyyTogetherListenBtn = document.getElementById('wyyTogetherListenBtn');
const wyyTogetherListenModal = document.getElementById('wyyTogetherListenModal');
const wyyTogetherListenRoleList = document.getElementById('wyyTogetherListenRoleList');
const wyyCancelTogetherListenBtn = document.getElementById('wyyCancelTogetherListenBtn');
const wyyStopTogetherListenBtn = document.getElementById('wyyStopTogetherListenBtn');

// æ‰“å¼€ä¸€èµ·å¬é€‰æ‹©è§’è‰²æ¨¡æ€æ¡†
if (wyyTogetherListenBtn) {
    wyyTogetherListenBtn.addEventListener('click', () => {
        wyyShowTogetherListenRoleSelector();
    });
}

// æ˜¾ç¤ºè§’è‰²é€‰æ‹©å™¨ï¼ˆä»æ•°æ®åº“åŠ è½½è§’è‰²ï¼Œä¸åŒ…æ‹¬è”æœºå¥½å‹ï¼‰
async function wyyShowTogetherListenRoleSelector() {
    if (!wyyTogetherListenRoleList) return;
    
    try {
        const accountId = getCurrentAccountId();
        const allChars = await db.characters.toArray();
        // ç­›é€‰ï¼šéuserç±»å‹ã€æ˜¯å¥½å‹çŠ¶æ€çš„è§’è‰²
        const friends = allChars.filter(char => {
            if (char.type === 'user') return false;
            if (!accountId) return char.wechat_status === 'friend';
            const status = getFriendStatus(char, accountId);
            return status === 'friend';
        });
        
        if (friends.length === 0) {
            wyyTogetherListenRoleList.innerHTML = '<div style="text-align: center; padding: 20px; color: #999;">è¿˜æ²¡æœ‰å¥½å‹ï¼Œè¯·å…ˆæ·»åŠ è§’è‰²å¥½å‹</div>';
        } else {
            let html = '';
            friends.forEach(char => {
                const charName = char.name || 'æœªçŸ¥';
                const displayName = char.nick || char.name || 'æœªçŸ¥';
                const isActive = wyyTogetherListenRole === charName;
                const avatarUrl = char.avatar || '';
                const firstChar = String(displayName).charAt(0);
                
                const avatarHtml = avatarUrl 
                    ? `<div style="width: 42px; height: 42px; border-radius: 50%; background: url('${avatarUrl}') center/cover no-repeat; flex-shrink: 0;"></div>`
                    : `<div style="width: 42px; height: 42px; border-radius: 50%; background: #f0f0f0; display: flex; align-items: center; justify-content: center; font-size: 18px; color: #666; flex-shrink: 0;">${firstChar}</div>`;
                
                html += `
                    <div class="wyy-together-listen-item ${isActive ? 'active' : ''}" data-role="${charName}" data-char-id="${char.id}" style="padding: 12px 16px; border-bottom: 1px solid #f0f0f0; cursor: pointer; display: flex; align-items: center; gap: 12px; transition: background 0.2s;">
                        ${avatarHtml}
                        <div style="flex: 1; min-width: 0;">
                            <div style="font-weight: 500; color: #333; margin-bottom: 2px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${displayName}</div>
                            ${isActive ? '<div style="font-size: 12px; color: #ff6b6b;">â™ª æ­£åœ¨ä¸€èµ·å¬</div>' : ''}
                        </div>
                        ${isActive ? '<i class="fa fa-check-circle" style="color: #ff6b6b; font-size: 18px;"></i>' : '<i class="fa fa-chevron-right" style="color: #ccc;"></i>'}
                    </div>
                `;
            });
            wyyTogetherListenRoleList.innerHTML = html;
            
            // æ·»åŠ ç‚¹å‡»äº‹ä»¶
            document.querySelectorAll('.wyy-together-listen-item[data-role]').forEach(item => {
                item.addEventListener('click', function() {
                    const role = this.getAttribute('data-role');
                    const charId = this.getAttribute('data-char-id');
                    if (wyyTogetherListenRole === role) {
                        wyyStopTogetherListen();
                    } else {
                        wyyStartTogetherListen(role, charId);
                    }
                });
            });
        }
    } catch (error) {
        console.error('[ä¸€èµ·å¬] åŠ è½½è§’è‰²åˆ—è¡¨å¤±è´¥:', error);
        wyyTogetherListenRoleList.innerHTML = '<div style="text-align: center; padding: 20px; color: #999;">åŠ è½½å¤±è´¥ï¼Œè¯·é‡è¯•</div>';
    }
    
    // æ›´æ–°ç»“æŸæŒ‰é’®æ˜¾ç¤º
    if (wyyStopTogetherListenBtn) {
        if (wyyTogetherListenRole) {
            wyyStopTogetherListenBtn.style.display = 'block';
        } else {
            wyyStopTogetherListenBtn.style.display = 'none';
        }
    }
    
    if (wyyTogetherListenModal) wyyTogetherListenModal.style.display = 'flex';
}

// å¼€å§‹ä¸€èµ·å¬
let wyyTogetherListenCharId = null; // å½“å‰ä¸€èµ·å¬è§’è‰²çš„ID
function wyyStartTogetherListen(role, charId) {
    // ç¡®ä¿roleæ˜¯å­—ç¬¦ä¸²
    wyyTogetherListenRole = String(role);
    wyyTogetherListenCharId = charId ? parseInt(charId) : null;
    if (wyyTogetherListenBtn) wyyTogetherListenBtn.classList.add('active');
    if (wyyTogetherListenModal) wyyTogetherListenModal.style.display = 'none';
    
    // æ›´æ–°æ’­æ”¾é¡µé¡¶æ æ˜¾ç¤º
    wyyUpdateTogetherListenDisplay();
    
    // çŠ¶æ€ä¼šé€šè¿‡ systemPrompt ä¼ é€’ç»™è§’è‰²
    wyyStartTogetherListenUpdate();
    
    showToast(`æ­£åœ¨å’Œ ${wyyTogetherListenRole} ä¸€èµ·å¬ â™ª`);
}

// ç»“æŸä¸€èµ·å¬
function wyyStopTogetherListen() {
    const prevRole = wyyTogetherListenRole;
    wyyTogetherListenRole = null;
    wyyTogetherListenCharId = null;
    if (wyyTogetherListenBtn) wyyTogetherListenBtn.classList.remove('active');
    if (wyyTogetherListenModal) wyyTogetherListenModal.style.display = 'none';
    
    // æ›´æ–°æ’­æ”¾é¡µé¡¶æ æ˜¾ç¤º
    wyyUpdateTogetherListenDisplay();
    
    // åœæ­¢å®šæ—¶æ›´æ–°
    wyyStopTogetherListenUpdate();
    
    if (prevRole) showToast(`å·²ç»“æŸå’Œ ${prevRole} ä¸€èµ·å¬`);
}

// å¼€å§‹å®šæ—¶æ›´æ–°ä¸€èµ·å¬çŠ¶æ€ï¼ˆä¸å†æ›´æ–°å¡ç‰‡ï¼Œåªä¿æŒçŠ¶æ€ï¼‰
function wyyStartTogetherListenUpdate() {
    wyyStopTogetherListenUpdate();
    // ä¸å†æ›´æ–°å¡ç‰‡ï¼Œå› ä¸ºä¸å†å‘é€æ¶ˆæ¯åˆ°å¯¹è¯æ¡†
    // çŠ¶æ€ä¼šé€šè¿‡ systemPrompt ä¼ é€’ç»™è§’è‰²
}

// åœæ­¢å®šæ—¶æ›´æ–°
function wyyStopTogetherListenUpdate() {
    if (wyyTogetherListenInterval) {
        clearInterval(wyyTogetherListenInterval);
        wyyTogetherListenInterval = null;
    }
}

// æ›´æ–°æ’­æ”¾é¡µä¸€èµ·å¬çŠ¶æ€æ˜¾ç¤º
function wyyUpdateTogetherListenDisplay() {
    const titleEl = document.querySelector('.wyy-player-top-bar-title');
    if (!titleEl) return;
    
    if (wyyTogetherListenRole) {
        titleEl.innerHTML = `<div style="font-size:14px; line-height:1.2;">æ­£åœ¨æ’­æ”¾</div><div style="font-size:11px; color:rgba(255,255,255,0.6); line-height:1.2;">ä¸ ${wyyTogetherListenRole} ä¸€èµ·å¬ â™ª</div>`;
    } else {
        titleEl.textContent = 'æ­£åœ¨æ’­æ”¾';
    }
}

// è·å–å½“å‰ä¸€èµ·å¬çš„çŠ¶æ€ä¿¡æ¯ï¼ˆä¾›system promptä½¿ç”¨ï¼‰
function wyyGetTogetherListenInfo() {
    if (!wyyTogetherListenRole) return null;
    
    let songName = 'æœªçŸ¥æ­Œæ›²';
    let singerName = 'æœªçŸ¥æ­Œæ‰‹';
    
    if (wyyPlaylist.length > 0 && wyyCurrentSongIndex < wyyPlaylist.length) {
        const currentSong = wyyPlaylist[wyyCurrentSongIndex];
        songName = currentSong.name || currentSong.title || 'æœªçŸ¥æ­Œæ›²';
        singerName = currentSong.singer || currentSong.artist || 'æœªçŸ¥æ­Œæ‰‹';
    }
    
    return {
        role: wyyTogetherListenRole,
        charId: wyyTogetherListenCharId,
        songName: songName,
        singerName: singerName,
        isPlaying: wyyAudio && !wyyAudio.paused
    };
}

// ä»èŠå¤©åˆ‡æ¢æ­Œæ›²ï¼ˆå…¨å±€å‡½æ•°ï¼Œä¾›HTML onclickä½¿ç”¨ï¼‰
window.wyySwitchSongFromChat = function(role, direction) {
    // ç¡®ä¿ç±»å‹ä¸€è‡´è¿›è¡Œæ¯”è¾ƒ
    const roleStr = String(role);
    if (String(wyyTogetherListenRole) !== roleStr) {
        alert('å½“å‰æ²¡æœ‰å’Œè¯¥è§’è‰²ä¸€èµ·å¬');
        return;
    }
    
    if (direction === 'prev') {
        if (wyyPlaylist.length > 0) {
            wyyCurrentSongIndex = (wyyCurrentSongIndex - 1 + wyyPlaylist.length) % wyyPlaylist.length;
            wyyPlaySong(wyyCurrentSongIndex);
            // ä¸å†å‘é€æ¶ˆæ¯åˆ°å¯¹è¯æ¡†ï¼ŒçŠ¶æ€ä¼šé€šè¿‡ systemPrompt ä¼ é€’ç»™è§’è‰²
        }
    } else if (direction === 'next') {
        if (wyyPlaylist.length > 0) {
            wyyCurrentSongIndex = (wyyCurrentSongIndex + 1) % wyyPlaylist.length;
            wyyPlaySong(wyyCurrentSongIndex);
            // ä¸å†å‘é€æ¶ˆæ¯åˆ°å¯¹è¯æ¡†ï¼ŒçŠ¶æ€ä¼šé€šè¿‡ systemPrompt ä¼ é€’ç»™è§’è‰²
        }
    }
}

if (wyyCancelTogetherListenBtn) {
    wyyCancelTogetherListenBtn.addEventListener('click', () => {
        if (wyyTogetherListenModal) wyyTogetherListenModal.style.display = 'none';
    });
}

if (wyyStopTogetherListenBtn) {
    wyyStopTogetherListenBtn.addEventListener('click', () => {
        wyyStopTogetherListen();
    });
}

if (wyyTogetherListenModal) {
    wyyTogetherListenModal.addEventListener('click', (e) => {
        if (e.target === wyyTogetherListenModal) {
            wyyTogetherListenModal.style.display = 'none';
        }
    });
}

// é˜»æ­¢æ­Œè¯å®¹å™¨æ»šåŠ¨äº‹ä»¶å†’æ³¡ï¼Œé¿å…å½±å“é¡µé¢æ»šåŠ¨
if (wyyLyricsContainer) {
    wyyLyricsContainer.addEventListener('touchmove', (e) => {
        e.stopPropagation();
    }, { passive: true });
    wyyLyricsContainer.addEventListener('wheel', (e) => {
        e.stopPropagation();
    }, { passive: true });
}

// é¡µé¢åŠ è½½æ—¶æ¢å¤è®¾ç½®å’Œåˆå§‹åŒ–æ’­æ”¾åˆ—è¡¨
window.addEventListener('DOMContentLoaded', async () => {
    try {
        // ç¡®ä¿æ’­æ”¾å™¨è¯¦æƒ…é¡µé¢åˆå§‹çŠ¶æ€æ˜¯éšè—çš„
        if (wyyPlayerPage) wyyPlayerPage.classList.remove('active');
        if (wyyMainPage) wyyMainPage.classList.add('active');
        
        const savedAvatar = await wyyDb.userSettings.get('avatar');
        if (savedAvatar && wyyAvatarDisplay) {
            wyyAvatarDisplay.style.backgroundImage = `url(${savedAvatar.data})`;
        }
        
        const savedFollow = await wyyDb.userSettings.get('follow');
        const savedFans = await wyyDb.userSettings.get('fans');
        const savedLevel = await wyyDb.userSettings.get('level');
        const savedTime = await wyyDb.userSettings.get('time');
        
        if (savedFollow && wyyFollowValue) wyyFollowValue.textContent = savedFollow.data;
        if (savedFans && wyyFansValue) wyyFansValue.textContent = savedFans.data;
        if (savedLevel && wyyLevelValue) wyyLevelValue.textContent = savedLevel.data;
        if (savedTime && wyyTimeValue) wyyTimeValue.textContent = savedTime.data;
        
        for (let i = 1; i <= 4; i++) {
            const cardKey = `card${i}`;
            const savedCard = await wyyDb.playlistCards.get(cardKey);
            const cardElement = document.getElementById(`wyyCard${i}`);
            if (cardElement && savedCard) {
                cardElement.style.backgroundImage = `url(${savedCard.data})`;
            }
        }
        
        await wyyInitPlaylist();
        await wyyLoadPlaylists();
    } catch (error) {
        console.error('åŠ è½½è®¾ç½®å¤±è´¥:', error);
    }
});

// ==================== å°å±‹åŠŸèƒ½ ====================
let currentCabinMachine = 'furniture'; // furniture æˆ– clothes
let cabinCoinCount = 200;

// å°å±‹æ‰­è›‹çŠ¶æ€ç®¡ç†
window.cabinGachaState = {
    coins: 200,
    customItems: {},  // ç‰©å“åº“
    catalog: {},      // å›¾é‰´è®°å½•
    inventory: {},    // èƒŒåŒ…åº“å­˜
    gachaPool: {
        furniture: [],
        clothes: []
    }
};

function showCabinPage() {
    document.getElementById('home-page').style.display = 'none';
    document.getElementById('cabin-page').style.display = 'flex';
    
    // é¦–æ¬¡æ‰“å¼€æ—¶åˆå§‹åŒ–æ•°æ®
    if (!window.cabinInitialized) {
        // å°è¯•ä»æœ¬åœ°å­˜å‚¨åŠ è½½æ•°æ®
        const loaded = loadCabinGachaData();
        
        // å¦‚æœæ²¡æœ‰ä¿å­˜çš„æ•°æ®ï¼Œåˆå§‹åŒ–é»˜è®¤ç‰©å“
        if (!loaded) {
            initDefaultItems();
        }
        
        window.cabinInitialized = true;
    }
    
    updateCabinCoinDisplay();
    updateCabinUI();
}

function hideCabinPage() {
    document.getElementById('cabin-page').style.display = 'none';
    document.getElementById('home-page').style.display = 'block';
}

function updateCabinCoinDisplay() {
    const state = window.cabinGachaState;
    const coinElement = document.getElementById('cabin-coin-count');
    if (coinElement) {
        coinElement.textContent = state.coins;
    }
    // åŒæ­¥å…¨å±€å˜é‡
    cabinCoinCount = state.coins;
}

// ä¿å­˜å°å±‹æ‰­è›‹æ•°æ®åˆ°æœ¬åœ°å­˜å‚¨
function saveCabinGachaData() {
    try {
        const state = window.cabinGachaState;
        localStorage.setItem('cabinGachaState', JSON.stringify(state));
        console.log('å°å±‹æ•°æ®å·²ä¿å­˜');
    } catch (e) {
        console.error('ä¿å­˜å°å±‹æ•°æ®å¤±è´¥:', e);
    }
}

// ä»æœ¬åœ°å­˜å‚¨åŠ è½½å°å±‹æ‰­è›‹æ•°æ®
function loadCabinGachaData() {
    try {
        const saved = localStorage.getItem('cabinGachaState');
        if (saved) {
            const state = JSON.parse(saved);
            window.cabinGachaState = state;
            cabinCoinCount = state.coins;
            console.log('å°å±‹æ•°æ®å·²åŠ è½½');
            return true;
        }
    } catch (e) {
        console.error('åŠ è½½å°å±‹æ•°æ®å¤±è´¥:', e);
    }
    return false;
}

// æ›´æ–°å°å±‹UIï¼ˆåˆ·æ–°æ‰€æœ‰ç›¸å…³æ˜¾ç¤ºï¼‰
function updateCabinUI() {
    // æ›´æ–°é‡‘å¸æ˜¾ç¤º
    updateCabinCoinDisplay();
    
    // å¦‚æœå›¾é‰´å¼¹çª—æ‰“å¼€ï¼Œåˆ·æ–°å›¾é‰´
    const catalogModal = document.getElementById('catalog-modal');
    if (catalogModal && catalogModal.style.display === 'flex') {
        renderCatalogItems();
    }
    
    // æ›´æ–°èƒŒåŒ…æ˜¾ç¤ºï¼ˆå¦‚æœæœ‰èƒŒåŒ…UIï¼‰
    updateCabinInventoryDisplay();
}

function switchCabinScreen(screenName) {
    // ç§»é™¤æ‰€æœ‰activeç±»
    document.querySelectorAll('.cabin-screen').forEach(s => s.classList.remove('active'));
    document.querySelectorAll('.cabin-nav-item').forEach(n => n.classList.remove('active'));

    // æ·»åŠ activeç±»
    const screen = document.getElementById('cabin-' + screenName + '-screen');
    if (screen) {
        screen.classList.add('active');
    }
    
    // æ‰¾åˆ°å¯¹åº”çš„å¯¼èˆªé¡¹å¹¶æ¿€æ´»
    const navItems = document.querySelectorAll('.cabin-nav-item');
    navItems.forEach(item => {
        const text = item.querySelector('.cabin-nav-item-text').textContent;
        if ((screenName === 'gacha' && text === 'æ‰­è›‹') ||
            (screenName === 'catalog' && text === 'å›¾é‰´') ||
            (screenName === 'house' && text === 'æˆ¿å±‹') ||
            (screenName === 'character' && text === 'äººç‰©')) {
            item.classList.add('active');
        }
    });
}

function switchCabinMachine() {
    const furnitureGacha = document.getElementById('cabin-furniture-gacha');
    const clothesGacha = document.getElementById('cabin-clothes-gacha');
    const machineTitle = document.getElementById('cabin-machine-title');

    if (currentCabinMachine === 'furniture') {
        furnitureGacha.style.display = 'none';
        clothesGacha.style.display = 'flex';
        machineTitle.textContent = 'æœè£…æ‰­è›‹æœº';
        currentCabinMachine = 'clothes';
    } else {
        furnitureGacha.style.display = 'flex';
        clothesGacha.style.display = 'none';
        machineTitle.textContent = 'å®¶å…·æ‰­è›‹æœº';
        currentCabinMachine = 'furniture';
    }
}

// ç¨€æœ‰åº¦æƒé‡é…ç½®
const RARITY_WEIGHTS = {
    'R': 70,    // 70%
    'SR': 25,   // 25%
    'SSR': 5    // 5%
};

// æ ¹æ®æƒé‡éšæœºæŠ½å–ä¸€ä¸ªç¨€æœ‰åº¦
function getRandomRarity() {
    const total = Object.values(RARITY_WEIGHTS).reduce((sum, weight) => sum + weight, 0);
    let random = Math.random() * total;
    
    for (const [rarity, weight] of Object.entries(RARITY_WEIGHTS)) {
        random -= weight;
        if (random <= 0) {
            return rarity;
        }
    }
    return 'R'; // é»˜è®¤è¿”å›R
}

// æ ¹æ®ç¨€æœ‰åº¦ä»ç‰©å“æ± ä¸­éšæœºæŠ½å–ç‰©å“
function drawItem(targetRarity) {
    const state = window.cabinGachaState;
    
    // è·å–å½“å‰æ‰­è›‹æœºç±»å‹çš„ç‰©å“æ± 
    const poolType = currentCabinMachine === 'furniture' ? 'furniture' : 'clothes';
    
    // è·å–æ‰€æœ‰å¯æŠ½å–çš„ç‰©å“
    const availableItems = Object.entries(state.customItems)
        .filter(([id, item]) => {
            // å®¶å…·æ‰­è›‹æœºæŠ½å–å®¶å…·ç±»
            if (poolType === 'furniture') {
                return item.inPool && ['furniture', 'decor', 'wall', 'floor'].includes(item.type);
            }
            // æœè£…æ‰­è›‹æœºæŠ½å–æœè£…ç±»ï¼ˆæš‚æœªå®ç°ï¼‰
            return false;
        })
        .filter(([id, item]) => item.rarity === targetRarity);
    
    if (availableItems.length === 0) {
        // å¦‚æœè¯¥ç¨€æœ‰åº¦æ²¡æœ‰ç‰©å“ï¼Œé™çº§æŠ½å–
        if (targetRarity === 'SSR') return drawItem('SR');
        if (targetRarity === 'SR') return drawItem('R');
        // å¦‚æœéƒ½æ²¡æœ‰ï¼Œéšæœºè¿”å›ä»»æ„ç‰©å“
        const allItems = Object.entries(state.customItems).filter(([id, item]) => item.inPool);
        if (allItems.length > 0) {
            const randomIndex = Math.floor(Math.random() * allItems.length);
            return allItems[randomIndex];
        }
        return null;
    }
    
    // éšæœºé€‰æ‹©ä¸€ä¸ªç‰©å“
    const randomIndex = Math.floor(Math.random() * availableItems.length);
    return availableItems[randomIndex];
}

// æ›´æ–°èƒŒåŒ…å’Œå›¾é‰´
function addItemToInventory(itemId) {
    const state = window.cabinGachaState;
    
    // æ›´æ–°èƒŒåŒ…
    state.inventory[itemId] = (state.inventory[itemId] || 0) + 1;
    
    // æ›´æ–°å›¾é‰´
    if (!state.catalog[itemId]) {
        state.catalog[itemId] = { seen: true, owned: true };
    } else {
        state.catalog[itemId].seen = true;
        state.catalog[itemId].owned = true;
    }
    
    // ä¿å­˜çŠ¶æ€
    saveCabinGachaData();
}

// æ˜¾ç¤ºæŠ½å¥–ç»“æœ
function showDrawResult(items) {
    if (!items || items.length === 0) return;
    
    const state = window.cabinGachaState;
    
    // åˆ›å»ºç»“æœå¼¹çª—HTML
    let resultHTML = '<div class="draw-result-modal" id="draw-result-modal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000; font-family: \'Press Start 2P\', cursive;">';
    resultHTML += '<div class="draw-result-content" style="background: #ffffff; border: 4px solid #FFB3C1; border-radius: 0; padding: 25px; max-width: 90%; max-height: 80%; overflow-y: auto; box-shadow: 8px 8px 0 rgba(255, 179, 193, 0.3);">';
    
    // æ ‡é¢˜å¸¦å›¾æ ‡
    resultHTML += '<div style="display: flex; align-items: center; justify-content: center; gap: 12px; margin-bottom: 20px;">';
    resultHTML += '<svg style="width: 24px; height: 24px; stroke: #FFB3C1;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><path d="M16 8h-8m4-4v16"></path></svg>';
    resultHTML += '<div style="font-size: 14px; color: #666666; font-weight: bold;">æŠ½å¥–ç»“æœ</div>';
    resultHTML += '<svg style="width: 24px; height: 24px; stroke: #FFB3C1;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><path d="M16 8h-8m4-4v16"></path></svg>';
    resultHTML += '</div>';
    
    // æ˜¾ç¤ºæ‰€æœ‰æŠ½åˆ°çš„ç‰©å“
    resultHTML += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)); gap: 12px; margin-bottom: 20px;">';
    
    items.forEach(([itemId, item]) => {
        // æ ¹æ®ç¨€æœ‰åº¦è®¾ç½®èƒŒæ™¯è‰²
        let rarityBg = '#FAFAFA';  // R - æµ…ç°ç™½
        let rarityBorder = '#E0E0E0';  // R - ç°è‰²è¾¹æ¡†
        
        if (item.rarity === 'SR') {
            rarityBg = '#FFF5F7';  // SR - æµ…ç²‰
            rarityBorder = '#FFD4DC';  // SR - ç²‰è‰²è¾¹æ¡†
        } else if (item.rarity === 'SSR') {
            rarityBg = '#FFE4E9';  // SSR - æ·±ç²‰
            rarityBorder = '#FFB3C1';  // SSR - æ·±ç²‰è¾¹æ¡†
        }
        
        resultHTML += `<div style="background: ${rarityBg}; border: 3px solid ${rarityBorder}; padding: 10px; text-align: center; transition: transform 0.2s;">`;
        resultHTML += `<div style="width: 70px; height: 70px; margin: 0 auto 8px; display: flex; align-items: center; justify-content: center;">${item.svg}</div>`;
        resultHTML += `<div style="color: #666666; font-size: 10px; margin-bottom: 5px; word-break: break-word;">${item.name}</div>`;
        resultHTML += `<div style="color: #999999; font-size: 8px; padding: 2px 6px; background: rgba(255,255,255,0.6); display: inline-block;">${item.rarity}</div>`;
        resultHTML += `</div>`;
    });
    
    resultHTML += '</div>';
    
    // ç»Ÿè®¡ä¿¡æ¯
    const rarityCount = { R: 0, SR: 0, SSR: 0 };
    items.forEach(([id, item]) => {
        if (rarityCount[item.rarity] !== undefined) {
            rarityCount[item.rarity]++;
        }
    });
    
    resultHTML += '<div style="color: #999999; font-size: 9px; text-align: center; margin-bottom: 15px; padding: 8px; background: #F8F8F8; border: 2px solid #F0F0F0;">';
    resultHTML += `å…±è·å¾— ${items.length} ä»¶ç‰©å“ | `;
    if (rarityCount.SSR > 0) resultHTML += `SSRÃ—${rarityCount.SSR} `;
    if (rarityCount.SR > 0) resultHTML += `SRÃ—${rarityCount.SR} `;
    if (rarityCount.R > 0) resultHTML += `RÃ—${rarityCount.R}`;
    resultHTML += '</div>';
    
    // å…³é—­æŒ‰é’®
    resultHTML += '<button onclick="closeDrawResult()" style="width: 100%; padding: 12px; background: #FFB3C1; color: white; border: none; cursor: pointer; font-size: 11px; font-family: \'Press Start 2P\', cursive; transition: background 0.2s;" onmouseover="this.style.background=\'#FF9EAD\'" onmouseout="this.style.background=\'#FFB3C1\'">ç¡®å®š</button>';
    resultHTML += '</div></div>';
    
    // æ·»åŠ åˆ°é¡µé¢
    document.body.insertAdjacentHTML('beforeend', resultHTML);
}

// å…³é—­æŠ½å¥–ç»“æœå¼¹çª—
function closeDrawResult() {
    const modal = document.getElementById('draw-result-modal');
    if (modal) {
        modal.remove();
    }
}

// å•æŠ½
function cabinDrawOnce() {
    const state = window.cabinGachaState;
    
    if (state.coins < 10) {
        alert('é‡‘å¸ä¸è¶³ï¼Œéœ€è¦10ä¸ªé‡‘å¸');
        return;
    }
    
    // æ‰£é™¤é‡‘å¸
    state.coins -= 10;
    cabinCoinCount = state.coins;
    updateCabinCoinDisplay();
    
    // æŠ½å–ç‰©å“
    const rarity = getRandomRarity();
    const drawnItem = drawItem(rarity);
    
    if (!drawnItem) {
        alert('ç‰©å“æ± ä¸ºç©ºï¼Œè¯·å…ˆæ·»åŠ ç‰©å“');
        return;
    }
    
    const [itemId, item] = drawnItem;
    
    // æ·»åŠ åˆ°èƒŒåŒ…å’Œå›¾é‰´
    addItemToInventory(itemId);
    
    // æ˜¾ç¤ºç»“æœ
    showDrawResult([drawnItem]);
    
    // æ›´æ–°UI
    updateCabinUI();
}

// åè¿æŠ½
function cabinDrawTen() {
    const state = window.cabinGachaState;
    
    if (state.coins < 100) {
        alert('é‡‘å¸ä¸è¶³ï¼Œéœ€è¦100ä¸ªé‡‘å¸');
        return;
    }
    
    // æ‰£é™¤é‡‘å¸
    state.coins -= 100;
    cabinCoinCount = state.coins;
    updateCabinCoinDisplay();
    
    // æŠ½å–10æ¬¡
    const results = [];
    let guaranteedSR = false; // ä¿åº•æœºåˆ¶ï¼šåè¿è‡³å°‘å‡ºä¸€ä¸ªSR
    
    for (let i = 0; i < 10; i++) {
        let rarity = getRandomRarity();
        
        // æœ€åä¸€æŠ½å¦‚æœè¿˜æ²¡æœ‰SRä»¥ä¸Šï¼Œå¼ºåˆ¶å‡ºSR
        if (i === 9 && !guaranteedSR) {
            rarity = Math.random() < 0.5 ? 'SR' : 'SSR';
        }
        
        const drawnItem = drawItem(rarity);
        
        if (drawnItem) {
            const [itemId, item] = drawnItem;
            
            // æ£€æŸ¥æ˜¯å¦æŠ½åˆ°SRæˆ–ä»¥ä¸Š
            if (item.rarity === 'SR' || item.rarity === 'SSR') {
                guaranteedSR = true;
            }
            
            // æ·»åŠ åˆ°èƒŒåŒ…å’Œå›¾é‰´
            addItemToInventory(itemId);
            
            results.push(drawnItem);
        }
    }
    
    // æ˜¾ç¤ºç»“æœ
    if (results.length > 0) {
        showDrawResult(results);
    }
    
    // æ›´æ–°UI
    updateCabinUI();
}

function openCabinAIModal() {
    alert('AIç”ŸæˆåŠŸèƒ½å¼€å‘ä¸­');
}

function openCabinCharacterModal() {
    alert('è§’è‰²ç”ŸæˆåŠŸèƒ½å¼€å‘ä¸­');
}

// æˆ¿é—´ç›¸å…³åŠŸèƒ½
function takeCabinScreenshot() {
    alert('æ‹ç…§åŠŸèƒ½å¼€å‘ä¸­');
}

// æˆ¿é—´é¢œè‰²çŠ¶æ€ï¼ˆä¸´æ—¶å­˜å‚¨ï¼Œå°†æ¥å¯ä»¥ç”¨localStorageï¼‰
let cabinRoomState = {
    wallColor: '#fff5f7',
    wallStyle: 'solid',
    wallPatternColor: '#fff5f7',
    floorColor: '#fefefe',
    floorStyle: 'solid',
    floorPatternColor: '#fefefe'
};

// æ‰“å¼€é¢œè‰²é€‰æ‹©å™¨
function openCabinColorPicker(type) {
    window.cabinCurrentColorTarget = type;
    const modal = document.getElementById('cabin-color-picker-modal');
    const title = document.getElementById('cabin-color-modal-title');
    const colorInput = document.getElementById('cabin-color-input');
    const colorPicker = document.getElementById('cabin-color-picker');
    
    if (title) {
        const iconSvg = `<svg class="cabin-icon-inline" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"/>
        </svg>`;
        title.innerHTML = iconSvg + (type === 'wall' ? ' ä¿®æ”¹å¢™é¢é¢œè‰²' : ' ä¿®æ”¹åœ°æ¿é¢œè‰²');
    }
    
    const currentColor = type === 'wall' ? (cabinRoomState.wallColor || '#fff5f7') : (cabinRoomState.floorColor || '#fefefe');
    const currentPatternColor = type === 'wall' ? (cabinRoomState.wallPatternColor || currentColor) : (cabinRoomState.floorPatternColor || currentColor);
    
    if (colorInput) colorInput.value = currentColor;
    if (colorPicker) colorPicker.value = currentColor;
    
    const patternColorInput = document.getElementById('cabin-pattern-color-input');
    const patternColorPicker = document.getElementById('cabin-pattern-color-picker');
    if (patternColorInput) patternColorInput.value = currentPatternColor;
    if (patternColorPicker) patternColorPicker.value = currentPatternColor;
    
    // åŒæ­¥é¢œè‰²è¾“å…¥å’Œæ‹¾è‰²å™¨
    if (colorInput && colorPicker) {
        colorInput.oninput = () => {
            if (colorInput.value.match(/^#[0-9A-Fa-f]{6}$/)) {
                colorPicker.value = colorInput.value;
            }
        };
        colorPicker.oninput = () => {
            colorInput.value = colorPicker.value;
        };
    }
    
    if (patternColorInput && patternColorPicker) {
        patternColorInput.oninput = () => {
            if (patternColorInput.value.match(/^#[0-9A-Fa-f]{6}$/)) {
                patternColorPicker.value = patternColorInput.value;
            }
        };
        patternColorPicker.oninput = () => {
            patternColorInput.value = patternColorPicker.value;
        };
    }
    
    // æ ·å¼é€‰æ‹©å˜åŒ–
    const styleOptions = document.querySelectorAll('input[name="cabin-style-option"]');
    styleOptions.forEach(option => {
        option.onchange = () => {
            const patternSection = document.getElementById('cabin-pattern-color-section');
            if (patternSection) {
                patternSection.style.display = option.value === 'solid' ? 'none' : 'block';
            }
        };
    });
    
    // æ¢å¤å½“å‰æ ·å¼é€‰æ‹©
    const currentStyle = type === 'wall' ? cabinRoomState.wallStyle : cabinRoomState.floorStyle;
    const styleOption = document.querySelector(`input[name="cabin-style-option"][value="${currentStyle}"]`);
    if (styleOption) {
        styleOption.checked = true;
        const patternSection = document.getElementById('cabin-pattern-color-section');
        if (patternSection) {
            patternSection.style.display = currentStyle === 'solid' ? 'none' : 'block';
        }
    }
    
    if (modal) modal.style.display = 'flex';
}

// å…³é—­é¢œè‰²é€‰æ‹©å™¨
function closeCabinColorPicker() {
    const modal = document.getElementById('cabin-color-picker-modal');
    if (modal) modal.style.display = 'none';
    window.cabinCurrentColorTarget = null;
}

// é‡ç½®é¢œè‰²
function resetCabinColor() {
    const defaultColor = window.cabinCurrentColorTarget === 'wall' ? '#fff5f7' : '#fefefe';
    const colorInput = document.getElementById('cabin-color-input');
    const colorPicker = document.getElementById('cabin-color-picker');
    const patternColorInput = document.getElementById('cabin-pattern-color-input');
    const patternColorPicker = document.getElementById('cabin-pattern-color-picker');
    
    if (colorInput) colorInput.value = defaultColor;
    if (colorPicker) colorPicker.value = defaultColor;
    if (patternColorInput) patternColorInput.value = defaultColor;
    if (patternColorPicker) patternColorPicker.value = defaultColor;
    
    const solidOption = document.querySelector('input[name="cabin-style-option"][value="solid"]');
    if (solidOption) solidOption.checked = true;
    
    const patternSection = document.getElementById('cabin-pattern-color-section');
    if (patternSection) patternSection.style.display = 'none';
}

// åº”ç”¨é¢œè‰²
function applyCabinColor() {
    if (!window.cabinCurrentColorTarget) return;
    
    const colorInput = document.getElementById('cabin-color-input');
    const patternColorInput = document.getElementById('cabin-pattern-color-input');
    const styleOption = document.querySelector('input[name="cabin-style-option"]:checked');
    
    if (!colorInput || !styleOption) return;
    
    const color = colorInput.value;
    if (!color.match(/^#[0-9A-Fa-f]{6}$/)) {
        alert('é¢œè‰²æ ¼å¼ä¸æ­£ç¡®');
        return;
    }
    
    const style = styleOption.value;
    
    // è·å–èŠ±çº¹é¢œè‰²ï¼ˆå¦‚æœæ ·å¼ä¸æ˜¯çº¯è‰²ï¼‰
    let patternColor = color;
    if (style !== 'solid' && patternColorInput) {
        const patternColorValue = patternColorInput.value;
        if (patternColorValue && patternColorValue.match(/^#[0-9A-Fa-f]{6}$/)) {
            patternColor = patternColorValue;
        }
    }
    
    if (window.cabinCurrentColorTarget === 'wall') {
        cabinRoomState.wallColor = color;
        cabinRoomState.wallStyle = style;
        cabinRoomState.wallPatternColor = patternColor;
        applyCabinWallStyle();
    } else {
        cabinRoomState.floorColor = color;
        cabinRoomState.floorStyle = style;
        cabinRoomState.floorPatternColor = patternColor;
        applyCabinFloorStyle();
    }
    
    // æ›´æ–°æŒ‰é’®é¢œè‰²
    const wallBtn = document.getElementById('cabin-wall-color-btn');
    const floorBtn = document.getElementById('cabin-floor-color-btn');
    if (wallBtn) wallBtn.style.background = cabinRoomState.wallColor;
    if (floorBtn) floorBtn.style.background = cabinRoomState.floorColor;
    
    closeCabinColorPicker();
}

// åº”ç”¨å¢™é¢æ ·å¼
function applyCabinWallStyle() {
    const wallArea = document.getElementById('cabin-wall-area');
    if (!wallArea) return;
    
    wallArea.style.backgroundColor = cabinRoomState.wallColor || '#fff5f7';
    
    if (cabinRoomState.wallStyle === 'solid') {
        wallArea.style.backgroundImage = 'none';
    } else if (cabinRoomState.wallStyle === 'pattern1') {
        const patternColor = (cabinRoomState.wallPatternColor || cabinRoomState.wallColor) + '40';
        wallArea.style.backgroundImage = `
            linear-gradient(90deg, ${patternColor} 1px, transparent 1px),
            linear-gradient(${patternColor} 1px, transparent 1px)
        `;
        wallArea.style.backgroundSize = '32px 32px';
    } else if (cabinRoomState.wallStyle === 'pattern2') {
        const patternColor = cabinRoomState.wallPatternColor || cabinRoomState.wallColor;
        wallArea.style.backgroundImage = `
            linear-gradient(90deg, transparent 33%, ${patternColor}40 33%, ${patternColor}40 66%, transparent 66%),
            linear-gradient(transparent 33%, ${patternColor}40 33%, ${patternColor}40 66%, transparent 66%)
        `;
        wallArea.style.backgroundSize = '12px 12px';
    }
}

// åº”ç”¨åœ°æ¿æ ·å¼
function applyCabinFloorStyle() {
    const floorArea = document.getElementById('cabin-floor-area');
    if (!floorArea) return;
    
    floorArea.style.backgroundColor = cabinRoomState.floorColor || '#fefefe';
    
    if (cabinRoomState.floorStyle === 'solid') {
        floorArea.style.backgroundImage = 'none';
    } else if (cabinRoomState.floorStyle === 'pattern1') {
        const patternColor = (cabinRoomState.floorPatternColor || cabinRoomState.floorColor) + '40';
        floorArea.style.backgroundImage = `
            linear-gradient(90deg, ${patternColor} 1px, transparent 1px),
            linear-gradient(${patternColor} 1px, transparent 1px)
        `;
        floorArea.style.backgroundSize = '32px 32px';
    } else if (cabinRoomState.floorStyle === 'pattern2') {
        const patternColor = cabinRoomState.floorPatternColor || cabinRoomState.floorColor;
        floorArea.style.backgroundImage = `
            linear-gradient(90deg, transparent 33%, ${patternColor}40 33%, ${patternColor}40 66%, transparent 66%),
            linear-gradient(transparent 33%, ${patternColor}40 33%, ${patternColor}40 66%, transparent 66%)
        `;
        floorArea.style.backgroundSize = '12px 12px';
    }
}

function moveCabinUserCharacter(direction) {
    alert('è§’è‰²ç§»åŠ¨åŠŸèƒ½å¼€å‘ä¸­ï¼š' + direction);
}

function filterCabinInventory(category) {
    // æ›´æ–°æŒ‰é’®æ¿€æ´»çŠ¶æ€
    const buttons = document.querySelectorAll('.cabin-filter-btn');
    buttons.forEach(btn => btn.classList.remove('active'));
    event.currentTarget.classList.add('active');
    
    // è¿™é‡Œå°†æ¥ä¼šå®ç°å®é™…çš„è¿‡æ»¤é€»è¾‘
    console.log('è¿‡æ»¤åˆ†ç±»ï¼š' + category);
}

// åˆå§‹åŒ–é»˜è®¤å®¶å…·
function initDefaultItems() {
    const state = window.cabinGachaState;
    
    // å¦‚æœå·²ç»æœ‰ç‰©å“ï¼Œä¸é‡å¤æ·»åŠ 
    if (Object.keys(state.customItems).length > 0) {
        return;
    }
    
    // æ·»åŠ åˆå§‹ç‰©å“
    const DEFAULT_FURNITURE = {
        'bed_01': { 
            name: "è‰è“åºŠ", 
            svg: `<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
                <rect x="10" y="30" width="44" height="20" fill="#FFB3C1" stroke="#999999" stroke-width="2"/>
                <rect x="12" y="32" width="40" height="16" fill="#FFF5F7"/>
                <rect x="14" y="34" width="4" height="4" fill="#FFFFFF"/>
                <rect x="22" y="34" width="4" height="4" fill="#FFFFFF"/>
                <rect x="30" y="34" width="4" height="4" fill="#FFFFFF"/>
                <rect x="38" y="34" width="4" height="4" fill="#FFFFFF"/>
                <rect x="46" y="34" width="4" height="4" fill="#FFFFFF"/>
                <rect x="14" y="24" width="14" height="10" fill="#FFFFFF" stroke="#CCCCCC" stroke-width="2"/>
                <rect x="16" y="26" width="10" height="6" fill="#F0F0F0" rx="2"/>
                <rect x="16" y="22" width="10" height="2" fill="#FFE4E9"/>
            </svg>`,
            rarity: "R",
            inPool: true,
            type: "furniture",
            width: 3,
            height: 2
        },
        'table_01': { 
            name: "åƒç´ æ¡Œ", 
            svg: `<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
                <rect x="12" y="32" width="40" height="10" fill="#F5F5F5" stroke="#999999" stroke-width="2"/>
                <rect x="14" y="34" width="36" height="6" fill="#FAFAFA" rx="1"/>
                <rect x="16" y="36" width="32" height="2" fill="#FFFFFF"/>
                <rect x="16" y="42" width="6" height="14" fill="#CCCCCC"/>
                <rect x="20" y="44" width="2" height="12" fill="#B0B0B0"/>
                <rect x="42" y="42" width="6" height="14" fill="#CCCCCC"/>
                <rect x="46" y="44" width="2" height="12" fill="#B0B0B0"/>
                <rect x="15" y="55" width="8" height="2" fill="#999999"/>
                <rect x="41" y="55" width="8" height="2" fill="#999999"/>
                <circle cx="32" cy="36" r="2" fill="#FFE4E9"/>
                <circle cx="38" cy="36" r="2" fill="#E8E8E8"/>
                <circle cx="26" cy="36" r="2" fill="#F0F0F0"/>
            </svg>`,
            rarity: "R",
            inPool: true,
            type: "furniture",
            width: 2,
            height: 2
        },
        'plant_01': { 
            name: "çˆ±å¿ƒè‰", 
            svg: `<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
                <rect x="24" y="40" width="16" height="16" fill="#FFE4E9" stroke="#CCCCCC" stroke-width="2" rx="2"/>
                <rect x="26" y="42" width="12" height="12" fill="#FFF5F7" rx="1"/>
                <rect x="28" y="44" width="8" height="2" fill="#FFFFFF"/>
                <rect x="28" y="48" width="8" height="2" fill="#FFFFFF"/>
                <rect x="31" y="30" width="2" height="10" fill="#B0B0B0"/>
                <polygon points="30,28 34,28 32,24" fill="#999999"/>
                <polygon points="28,32 30,32 29,30" fill="#CCCCCC"/>
                <polygon points="34,32 36,32 35,30" fill="#CCCCCC"/>
                <path d="M32,22 Q34,20 36,22 Q38,24 36,26 Q34,28 32,30 Q30,28 28,26 Q26,24 28,22 Q30,20 32,22" fill="#FFB3C1"/>
                <circle cx="32" cy="24" r="1" fill="#FFFFFF"/>
                <circle cx="34" cy="26" r="1" fill="#FFFFFF"/>
                <circle cx="30" cy="26" r="1" fill="#FFFFFF"/>
            </svg>`,
            rarity: "SR",
            inPool: true,
            type: "decor",
            width: 1,
            height: 1
        },
        'painting_01': {
            name: "åƒç´ ç”»",
            svg: `<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
                <rect x="15" y="15" width="34" height="34" fill="#F5F5F5" stroke="#CCCCCC" stroke-width="3" rx="3"/>
                <rect x="18" y="18" width="28" height="28" fill="#FFFFFF" rx="2"/>
                <rect x="20" y="20" width="24" height="24" fill="#FAFAFA" rx="1"/>
                <rect x="20" y="36" width="24" height="8" fill="#E8E8E8" rx="1"/>
                <polygon points="26,36 30,32 34,36" fill="#D0D0D0"/>
                <polygon points="30,36 34,30 38,36" fill="#CCCCCC"/>
                <circle cx="44" cy="24" r="4" fill="#FFE4E9"/>
                <rect x="44" y="20" width="1" height="2" fill="#FFB3C1"/>
                <rect x="44" y="28" width="1" height="2" fill="#FFB3C1"/>
                <rect x="40" y="23" width="2" height="1" fill="#FFB3C1"/>
                <rect x="48" y="23" width="2" height="1" fill="#FFB3C1"/>
                <rect x="24" y="26" width="8" height="4" fill="#FFFFFF" rx="2"/>
                <rect x="26" y="24" width="4" height="2" fill="#FFFFFF" rx="1"/>
                <circle cx="20" cy="20" r="1" fill="#FFB3C1"/>
                <circle cx="44" cy="20" r="1" fill="#FFB3C1"/>
                <circle cx="20" cy="44" r="1" fill="#FFB3C1"/>
                <circle cx="44" cy="44" r="1" fill="#FFB3C1"/>
            </svg>`,
            rarity: "R",
            inPool: true,
            type: "wall",
            width: 1,
            height: 1
        },
        'rug_01': {
            name: "æ¯›ç»’åœ°æ¯¯",
            svg: `<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
                <rect x="10" y="10" width="44" height="44" fill="#F0F0F0" stroke="#CCCCCC" stroke-width="2" rx="5"/>
                <rect x="12" y="12" width="40" height="40" fill="#FAFAFA" rx="3"/>
                <circle cx="32" cy="32" r="12" fill="#FFF5F7" opacity="0.6"/>
                <circle cx="32" cy="32" r="8" fill="#FFFFFF" opacity="0.8"/>
                <path d="M32,24 Q36,28 32,32 Q28,36 32,40 Q36,36 40,32 Q36,28 32,24" fill="#FFE4E9" opacity="0.5"/>
                <rect x="14" y="14" width="4" height="4" fill="#E8E8E8" rx="1"/>
                <rect x="46" y="14" width="4" height="4" fill="#E8E8E8" rx="1"/>
                <rect x="14" y="46" width="4" height="4" fill="#E8E8E8" rx="1"/>
                <rect x="46" y="46" width="4" height="4" fill="#E8E8E8" rx="1"/>
            </svg>`,
            rarity: "SR",
            inPool: true,
            type: "floor",
            width: 3,
            height: 2
        }
    };
    
    // æ·»åŠ é»˜è®¤ç‰©å“åˆ°çŠ¶æ€
    Object.keys(DEFAULT_FURNITURE).forEach(id => {
        state.customItems[id] = DEFAULT_FURNITURE[id];
        if (!state.catalog[id]) {
            state.catalog[id] = { seen: false, owned: false };
        }
        // æ·»åŠ åˆ°èƒŒåŒ…
        state.inventory[id] = (state.inventory[id] || 0) + 1;
        // æ ‡è®°ä¸ºå·²æ‹¥æœ‰
        state.catalog[id].owned = true;
    });
    
    // ä¿å­˜çŠ¶æ€
    saveCabinGachaData();
    console.log('é»˜è®¤å®¶å…·å·²åˆå§‹åŒ–');
}

// æ›´æ–°èƒŒåŒ…æ˜¾ç¤º
function updateCabinInventoryDisplay() {
    // å¦‚æœæœ‰èƒŒåŒ…UIå…ƒç´ ï¼Œåœ¨è¿™é‡Œæ›´æ–°
    // æš‚æ—¶ä¿ç•™æ­¤å‡½æ•°ä»¥å¤‡åç»­ä½¿ç”¨
}

// æ‰“å¼€å›¾é‰´
function openCatalogModal() {
    const modal = document.getElementById('catalog-modal');
    if (modal) {
        modal.style.display = 'flex';
        renderCatalogItems();
    }
}

// å…³é—­å›¾é‰´
function closeCatalogModal() {
    const modal = document.getElementById('catalog-modal');
    if (modal) {
        modal.style.display = 'none';
    }
}

// åˆ‡æ¢å›¾é‰´æ ‡ç­¾
let currentCatalogTab = 'all';
function switchCatalogTab(tab) {
    currentCatalogTab = tab;
    const tabs = document.querySelectorAll('.catalog-tab');
    tabs.forEach(t => {
        t.classList.remove('active');
        t.style.background = '#ffffff';
    });
    event.currentTarget.classList.add('active');
    event.currentTarget.style.background = '#fff5f7';
    renderCatalogItems();
}

// è¿‡æ»¤å›¾é‰´ç‰©å“ç¨€æœ‰åº¦
let currentCatalogRarity = 'all';
function filterCatalogItems(rarity) {
    currentCatalogRarity = rarity;
    const buttons = document.querySelectorAll('.rarity-filter-btn');
    buttons.forEach(btn => btn.classList.remove('active'));
    event.currentTarget.classList.add('active');
    renderCatalogItems();
}

// æ¸²æŸ“å›¾é‰´ç‰©å“
function renderCatalogItems() {
    const catalogGrid = document.getElementById('catalog-items');
    const catalogInfo = document.getElementById('catalog-info');
    
    if (!catalogGrid) return;
    
    const state = window.cabinGachaState;
    catalogGrid.innerHTML = '';
    
    // è·å–æ‰€æœ‰ç‰©å“
    const allItems = Object.keys(state.customItems).map(id => ({
        id,
        ...state.customItems[id],
        catalogData: state.catalog[id] || { seen: false, owned: false }
    }));
    
    // æŒ‰æ ‡ç­¾è¿‡æ»¤
    let filteredItems = allItems;
    if (currentCatalogTab === 'owned') {
        filteredItems = allItems.filter(item => item.catalogData.owned);
    } else if (currentCatalogTab === 'missing') {
        filteredItems = allItems.filter(item => !item.catalogData.owned);
    }
    
    // æŒ‰ç¨€æœ‰åº¦è¿‡æ»¤
    if (currentCatalogRarity !== 'all') {
        filteredItems = filteredItems.filter(item => 
            item.rarity.toUpperCase() === currentCatalogRarity.toUpperCase()
        );
    }
    
    // æ¸²æŸ“ç‰©å“
    filteredItems.forEach(item => {
        const itemDiv = document.createElement('div');
        itemDiv.style.cssText = `
            background: ${item.catalogData.owned ? '#fff5f7' : '#f5f5f5'};
            border: 3px solid ${item.catalogData.owned ? '#ffb3c1' : '#e0e0e0'};
            border-radius: 8px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
        `;
        
        // SVGå›¾æ ‡
        const svgDiv = document.createElement('div');
        svgDiv.innerHTML = item.svg;
        svgDiv.style.cssText = 'width: 40px; height: 40px; margin-bottom: 5px;';
        itemDiv.appendChild(svgDiv);
        
        // åç§°
        const nameDiv = document.createElement('div');
        nameDiv.textContent = item.name;
        nameDiv.style.cssText = 'font-size: 8px; color: #999999; text-align: center; margin-bottom: 3px;';
        itemDiv.appendChild(nameDiv);
        
        // ç¨€æœ‰åº¦
        const rarityDiv = document.createElement('div');
        rarityDiv.textContent = item.rarity;
        rarityDiv.style.cssText = `
            font-size: 7px;
            padding: 1px 4px;
            border-radius: 3px;
            font-weight: bold;
            color: #999999;
            background: ${item.rarity === 'SSR' ? '#fff9e6' : item.rarity === 'SR' ? '#fff5f7' : '#f0f0f0'};
        `;
        itemDiv.appendChild(rarityDiv);
        
        // æ‹¥æœ‰æ•°é‡ï¼ˆå¦‚æœå·²æ‹¥æœ‰ï¼‰
        if (item.catalogData.owned) {
            const count = state.inventory[item.id] || 0;
            if (count > 0) {
                const countDiv = document.createElement('div');
                countDiv.textContent = `Ã—${count}`;
                countDiv.style.cssText = `
                    position: absolute;
                    top: 5px;
                    right: 5px;
                    font-size: 8px;
                    padding: 2px 5px;
                    background: #ffb3c1;
                    color: white;
                    border-radius: 10px;
                    font-weight: bold;
                `;
                itemDiv.appendChild(countDiv);
            }
        }
        
        catalogGrid.appendChild(itemDiv);
    });
    
    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
    if (catalogInfo) {
        const total = allItems.length;
        const owned = allItems.filter(item => item.catalogData.owned).length;
        const rate = total > 0 ? Math.round((owned / total) * 100) : 0;
        
        document.getElementById('catalog-total').textContent = total;
        document.getElementById('catalog-owned').textContent = owned;
        document.getElementById('catalog-rate').textContent = rate + '%';
    }
}

// é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
document.addEventListener('DOMContentLoaded', function() {
    // å°å±‹æ•°æ®åœ¨é¦–æ¬¡æ‰“å¼€å°å±‹é¡µé¢æ—¶åˆå§‹åŒ–ï¼ˆè§ showCabinPage å‡½æ•°ï¼‰
    // è¿™é‡Œä¸éœ€è¦æå‰åˆå§‹åŒ–
});

// ==================== æƒ…ä¾£ç©ºé—´åŠŸèƒ½ ====================
let selectedAccountId = null;
let selectedFriendId = null;
let currentPet = null;

async function showCoupleSpacePage() {
    document.getElementById('home-page').style.display = 'none';
    document.getElementById('couple-space-page').style.display = 'block';
    
    // åŠ è½½è´¦å·åˆ—è¡¨
    await loadCoupleAccountList();
}

function hideCoupleSpacePage() {
    document.getElementById('couple-space-page').style.display = 'none';
    document.getElementById('home-page').style.display = 'block';
    
    // é‡ç½®çŠ¶æ€
    document.getElementById('couple-select-account').style.display = 'flex';
    document.getElementById('couple-select-friend').style.display = 'none';
    document.getElementById('couple-room-area').style.display = 'none';
    selectedAccountId = null;
    selectedFriendId = null;
    currentPet = null;
    isPetHatched = false;
    isPetting = false;
    lastPetTime = 0;
    if (petTimeout) {
        clearTimeout(petTimeout);
        petTimeout = null;
    }
}

// åŠ è½½è´¦å·åˆ—è¡¨ï¼ˆuserç±»å‹çš„è§’è‰²ï¼‰
async function loadCoupleAccountList() {
    const accounts = await db.characters.where('type').equals('user').toArray();
    const listContainer = document.getElementById('couple-account-list');
    listContainer.innerHTML = '';
    
    if (accounts.length === 0) {
        listContainer.innerHTML = '<div style="text-align: center; color: #999;">æš‚æ— è´¦å·ï¼Œè¯·å…ˆåˆ›å»ºç”¨æˆ·è´¦å·</div>';
        return;
    }
    
    accounts.forEach(account => {
        const accountItem = document.createElement('div');
        accountItem.style.cssText = `
            background: white;
            border: 2px solid #ff9ed2;
            border-radius: 12px;
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
            cursor: pointer;
            transition: transform 0.2s;
        `;
        
        accountItem.onmouseover = () => accountItem.style.transform = 'scale(1.02)';
        accountItem.onmouseout = () => accountItem.style.transform = 'scale(1)';
        accountItem.onclick = () => selectCoupleAccount(account.id);
        
        // å¤´åƒ
        const avatar = document.createElement('div');
        avatar.style.cssText = `
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: ${account.avatar ? `url(${account.avatar}) center/cover` : '#ffdef2'};
            flex-shrink: 0;
        `;
        
        // åå­—
        const name = document.createElement('div');
        name.textContent = account.name;
        name.style.cssText = 'font-size: 16px; color: #333; font-weight: bold;';
        
        accountItem.appendChild(avatar);
        accountItem.appendChild(name);
        listContainer.appendChild(accountItem);
    });
}

// é€‰æ‹©è´¦å·
async function selectCoupleAccount(accountId) {
    selectedAccountId = accountId;
    document.getElementById('couple-select-account').style.display = 'none';
    document.getElementById('couple-select-friend').style.display = 'flex';
    
    // åŠ è½½è¯¥è´¦å·çš„å¥½å‹åˆ—è¡¨
    await loadCoupleFriendList(accountId);
}

// è¿”å›è´¦å·é€‰æ‹©
function backToCoupleAccountSelect() {
    document.getElementById('couple-select-friend').style.display = 'none';
    document.getElementById('couple-select-account').style.display = 'flex';
    selectedAccountId = null;
}

// åŠ è½½å¥½å‹åˆ—è¡¨
async function loadCoupleFriendList(accountId) {
    // ä½¿ç”¨å’Œå¾®ä¿¡åˆ—è¡¨ç›¸åŒçš„é€»è¾‘è·å–å¥½å‹
    let allChars = await db.characters.toArray();
    let friends = allChars.filter(c => {
        if (c.type === 'user') return false; // æ’é™¤Userç±»å‹
        const status = getFriendStatus(c, accountId);
        return status === 'friend' || status === 'deleted' || status === 'blocked'; // åŒ…æ‹¬å·²åˆ é™¤å’Œå·²æ‹‰é»‘çš„å¥½å‹
    });
    
    const listContainer = document.getElementById('couple-friend-list');
    listContainer.innerHTML = '';
    
    if (friends.length === 0) {
        listContainer.innerHTML = '<div style="text-align: center; color: #999;">è¯¥è´¦å·æš‚æ— å¥½å‹</div>';
        return;
    }
    
    friends.forEach(friend => {
        if (!friend) return;
        
        const friendItem = document.createElement('div');
        friendItem.style.cssText = `
            background: white;
            border: 2px solid #ff9ed2;
            border-radius: 12px;
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
            cursor: pointer;
            transition: transform 0.2s;
        `;
        
        friendItem.onmouseover = () => friendItem.style.transform = 'scale(1.02)';
        friendItem.onmouseout = () => friendItem.style.transform = 'scale(1)';
        friendItem.onclick = () => selectCoupleFriend(friend.id);
        
        // å¤´åƒ
        const avatar = document.createElement('div');
        avatar.style.cssText = `
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: ${friend.avatar ? `url(${friend.avatar}) center/cover` : '#ffdef2'};
            flex-shrink: 0;
        `;
        
        // åå­—
        const name = document.createElement('div');
        name.textContent = friend.name;
        name.style.cssText = 'font-size: 16px; color: #333; font-weight: bold;';
        
        friendItem.appendChild(avatar);
        friendItem.appendChild(name);
        listContainer.appendChild(friendItem);
    });
}

// é€‰æ‹©å¥½å‹
function selectCoupleFriend(friendId) {
    selectedFriendId = friendId;
    document.getElementById('couple-select-friend').style.display = 'none';
    document.getElementById('couple-room-area').style.display = 'block';
}

// æ˜¾ç¤ºé¢†å…»å® ç‰©æ¨¡æ€æ¡†
function showAdoptPetModal() {
    document.getElementById('adopt-pet-modal').style.display = 'flex';
}

// å…³é—­é¢†å…»å® ç‰©æ¨¡æ€æ¡†
function closeAdoptPetModal() {
    document.getElementById('adopt-pet-modal').style.display = 'none';
}

// é¢†å…»å® ç‰©
function adoptPet(petType) {
    closeAdoptPetModal();
    document.getElementById('adopt-pet-btn').style.display = 'none';
    document.getElementById('pet-hint').textContent = 'ç‚¹å‡»å­µåŒ–ä½ çš„å® ç‰©';
    
    currentPet = petType;
    createPetContainer(petType);
}

// åˆ›å»ºå® ç‰©å®¹å™¨
function createPetContainer(petType) {
    const container = document.getElementById('pet-container');
    container.innerHTML = '';
    
    const stage = document.createElement('div');
    stage.id = 'pet-stage-container';
    stage.style.cssText = 'width: 256px; height: 256px; cursor: pointer; position: relative; touch-action: none;';
    
    if (petType === 'seal') {
        stage.innerHTML = createSealEgg();
        stage.onclick = () => hatchPet('seal', stage);
    } else if (petType === 'cat') {
        stage.innerHTML = createCatBox();
        stage.onclick = () => hatchPet('cat', stage);
    } else if (petType === 'dog') {
        stage.innerHTML = createDogHouse();
        stage.onclick = () => hatchPet('dog', stage);
    }
    
    container.appendChild(stage);
}

// å® ç‰©çŠ¶æ€
let isPetHatched = false;
let isPetting = false;
let lastPetTime = 0;
let petTimeout = null;

// å­µåŒ–å® ç‰©
function hatchPet(petType, stage) {
    stage.style.animation = 'shake 0.5s';
    
    setTimeout(() => {
        stage.innerHTML = '';
        
        if (petType === 'seal') {
            stage.innerHTML = createSealPet();
        } else if (petType === 'cat') {
            stage.innerHTML = createCatPet();
        } else if (petType === 'dog') {
            stage.innerHTML = createDogPet();
        }
        
        stage.style.animation = 'popUp 0.6s';
        stage.onclick = null;
        
        isPetHatched = true;
        document.getElementById('pet-hint').textContent = 'æ»‘åŠ¨æŠšæ‘¸å® ç‰©';
        
        // æ·»åŠ æŠšæ‘¸äº‹ä»¶ç›‘å¬
        setupPettingEvents(stage);
    }, 500);
}

// è®¾ç½®æŠšæ‘¸äº‹ä»¶
function setupPettingEvents(stage) {
    // é˜»æ­¢è§¦æ‘¸æ»šåŠ¨
    stage.addEventListener('touchmove', (e) => {
        e.preventDefault();
        handlePet(e);
    }, { passive: false });
    
    // é¼ æ ‡ç§»åŠ¨æŠšæ‘¸
    stage.addEventListener('mousemove', handlePet);
    
    // è§¦æ‘¸å¼€å§‹
    stage.addEventListener('touchstart', (e) => {
        e.preventDefault();
        handlePet(e);
    }, { passive: false });
}

// å¤„ç†æŠšæ‘¸
function handlePet(e) {
    if (!isPetHatched) return;
    
    const now = Date.now();
    if (now - lastPetTime < 50) return;
    lastPetTime = now;
    
    if (!isPetting) {
        startPetting();
    }
    
    clearTimeout(petTimeout);
    petTimeout = setTimeout(stopPetting, 200);
    
    // éšæœºç”Ÿæˆçˆ±å¿ƒæ•ˆæœ
    if (Math.random() > 0.85) {
        spawnHeartEffect(e);
    }
}

// å¼€å§‹æŠšæ‘¸
function startPetting() {
    isPetting = true;
    const stage = document.getElementById('pet-stage-container');
    if (stage) {
        stage.classList.add('is-petting');
        document.getElementById('pet-hint').textContent = 'å¥½èˆ’æœ...';
    }
}

// åœæ­¢æŠšæ‘¸
function stopPetting() {
    isPetting = false;
    const stage = document.getElementById('pet-stage-container');
    if (stage) {
        stage.classList.remove('is-petting');
        document.getElementById('pet-hint').textContent = 'æ»‘åŠ¨æŠšæ‘¸å® ç‰©';
    }
}

// ç”Ÿæˆçˆ±å¿ƒæ•ˆæœ
function spawnHeartEffect(e) {
    const stage = document.getElementById('pet-stage-container');
    if (!stage) return;
    
    const heart = document.createElement('div');
    heart.style.cssText = `
        position: absolute;
        width: 12px;
        height: 12px;
        background: #ff6b6b;
        clip-path: polygon(20% 0%, 40% 0%, 50% 20%, 60% 0%, 80% 0%, 100% 20%, 100% 50%, 50% 100%, 0% 50%, 0% 20%);
        pointer-events: none;
        z-index: 1000;
    `;
    
    const rect = stage.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    
    const x = clientX - rect.left - 6 + (Math.random() * 20 - 10);
    const y = clientY - rect.top - 20;
    
    heart.style.left = `${x}px`;
    heart.style.top = `${y}px`;
    
    stage.appendChild(heart);
    
    heart.animate([
        { transform: 'translateY(0) scale(0.5)', opacity: 1 },
        { transform: 'translateY(-40px) scale(1.2)', opacity: 0 }
    ], { duration: 800, fill: 'forwards' });
    
    setTimeout(() => heart.remove(), 800);
}

// åˆ›å»ºæµ·è±¹è›‹
function createSealEgg() {
    return `
        <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" style="width: 100%; height: 100%;">
            <rect x="18" y="54" width="28" height="4" fill="#a0c0e0" opacity="0.6"/>
            <path d="M24 16 H40 V17 H44 V18 H46 V20 H48 V24 H50 V44 H48 V50 H46 V52 H42 V54 H22 V52 H18 V50 H16 V44 H14 V24 H16 V20 H18 V18 H20 V17 H24 Z" fill="#4a4a4a" />
            <rect x="24" y="17" width="16" height="35" fill="#ffffff"/>
            <rect x="20" y="18" width="24" height="34" fill="#ffffff"/>
            <rect x="18" y="20" width="28" height="30" fill="#ffffff"/>
            <rect x="16" y="24" width="32" height="20" fill="#ffffff"/>
            <rect x="18" y="44" width="28" height="6" fill="#ffffff"/>
            <rect x="22" y="50" width="20" height="2" fill="#ffffff"/>
            <rect x="28" y="24" width="2" height="2" fill="#d0d0d0" />
            <rect x="36" y="20" width="1" height="1" fill="#d0d0d0" />
            <rect x="42" y="30" width="2" height="2" fill="#d0d0d0" />
        </svg>
    `;
}

// åˆ›å»ºçŒ«ç®±å­
function createCatBox() {
    return `
        <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" style="width: 100%; height: 100%;">
            <rect x="16" y="56" width="32" height="4" fill="#8b6f47" opacity="0.3"/>
            <path d="M12 24 H52 V26 H54 V54 H52 V56 H12 V54 H10 V26 H12 Z" fill="#d2691e"/>
            <rect x="12" y="26" width="40" height="28" fill="#cd853f"/>
            <rect x="16" y="30" width="32" height="20" fill="#daa520"/>
            <path d="M26 34 H38 V36 H40 V44 H38 V46 H26 V44 H24 V36 H26 Z" fill="#4a4a4a"/>
            <rect x="28" y="36" width="8" height="8" fill="#2a2a2a"/>
            <rect x="20" y="28" width="2" height="2" fill="#8b4513"/>
            <rect x="42" y="28" width="2" height="2" fill="#8b4513"/>
            <rect x="20" y="48" width="2" height="2" fill="#8b4513"/>
            <rect x="42" y="48" width="2" height="2" fill="#8b4513"/>
        </svg>
    `;
}

// åˆ›å»ºç‹—çª
function createDogHouse() {
    return `
        <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" style="width: 100%; height: 100%;">
            <rect x="16" y="56" width="32" height="4" fill="#8b6f47" opacity="0.3"/>
            <path d="M32 12 L10 32 H12 V54 H52 V32 H54 Z" fill="#d2691e"/>
            <rect x="14" y="32" width="36" height="22" fill="#cd853f"/>
            <path d="M24 38 H40 V40 H42 V52 H40 V54 H24 V52 H22 V40 H24 Z" fill="#4a4a4a"/>
            <rect x="26" y="40" width="12" height="12" fill="#2a2a2a"/>
            <path d="M32 14 L12 30 H16 L32 18 L48 30 H52 Z" fill="#a0522d"/>
        </svg>
    `;
}

// åˆ›å»ºæµ·è±¹å® ç‰©
function createSealPet() {
    return `
        <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" style="width: 100%; height: 100%; animation: sealFloat 2s infinite ease-in-out;">
            <rect x="18" y="48" width="28" height="4" fill="#a0c0e0" opacity="0.6"/>
            <path d="M20 20 H44 V21 H48 V22 H50 V24 H52 V38 H50 V42 H48 V44 H44 V45 H20 V44 H16 V42 H14 V38 H12 V24 H14 V22 H16 V21 H20 Z" fill="#4a4a4a"/>
            <rect x="20" y="21" width="24" height="23" fill="#ffffff"/>
            <rect x="16" y="22" width="32" height="21" fill="#ffffff"/>
            <rect x="14" y="24" width="36" height="17" fill="#ffffff"/>
            <rect x="20" y="30" width="3" height="3" fill="#2a2a2a"/>
            <rect x="36" y="30" width="3" height="3" fill="#2a2a2a"/>
            <rect x="29" y="34" width="1" height="2" fill="#4a4a4a"/>
            <rect x="28" y="36" width="3" height="1" fill="#4a4a4a"/>
            <rect x="16" y="32" width="1" height="1" fill="#ffb7b2"/>
            <rect x="42" y="32" width="1" height="1" fill="#ffb7b2"/>
            <g style="transform-origin: 52px 32px; animation: tailWag 0.4s infinite alternate;">
                <path d="M52 30 H56 V32 H57 V35 H56 V37 H52 Z" fill="#4a4a4a"/>
                <rect x="52" y="31" width="4" height="5" fill="#ffffff"/>
            </g>
        </svg>
    `;
}

// åˆ›å»ºçŒ«å® ç‰©
function createCatPet() {
    return `
        <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" style="width: 100%; height: 100%; animation: catFloat 2s infinite ease-in-out;">
            <rect x="20" y="50" width="24" height="4" fill="#8b6f47" opacity="0.3"/>
            <g style="animation: catEarWiggle 1s infinite alternate;">
                <path d="M18 18 H22 V20 H24 V26 H22 V24 H20 V22 H18 Z" fill="#ff9966"/>
                <rect x="20" y="20" width="2" height="4" fill="#ffb380"/>
                <path d="M42 18 H46 V22 H44 V24 H42 V26 H40 V20 H42 Z" fill="#ff9966"/>
                <rect x="42" y="20" width="2" height="4" fill="#ffb380"/>
            </g>
            <path d="M20 24 H44 V26 H46 V40 H44 V42 H42 V44 H22 V42 H20 V40 H18 V26 H20 Z" fill="#4a4a4a"/>
            <rect x="20" y="26" width="24" height="14" fill="#ff9966"/>
            <rect x="18" y="28" width="28" height="10" fill="#ff9966"/>
            <rect x="24" y="30" width="3" height="3" fill="#2a2a2a"/>
            <rect x="37" y="30" width="3" height="3" fill="#2a2a2a"/>
            <rect x="25" y="30" width="1" height="1" fill="#ffffff" opacity="0.8"/>
            <rect x="38" y="30" width="1" height="1" fill="#ffffff" opacity="0.8"/>
            <rect x="30" y="34" width="1" height="2" fill="#4a4a4a"/>
            <rect x="29" y="36" width="3" height="1" fill="#4a4a4a"/>
            <rect x="33" y="34" width="1" height="1" fill="#4a4a4a"/>
            <path d="M28 38 L26 40 H28 Z" fill="#4a4a4a"/>
            <path d="M36 38 L38 40 H36 Z" fill="#4a4a4a"/>
            <rect x="22" y="32" width="1" height="1" fill="#ffb7b2"/>
            <rect x="41" y="32" width="1" height="1" fill="#ffb7b2"/>
            <g style="animation: tailSway 0.8s infinite alternate;">
                <path d="M44 36 H46 V38 H48 V42 H50 V46 H48 V44 H46 V40 H44 Z" fill="#ff9966"/>
            </g>
        </svg>
    `;
}

// åˆ›å»ºç‹—å® ç‰©
function createDogPet() {
    return `
        <svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" style="width: 100%; height: 100%; animation: dogFloat 2s infinite ease-in-out;">
            <rect x="20" y="50" width="24" height="4" fill="#8b6f47" opacity="0.3"/>
            <g style="animation: dogEarFlop 1.2s infinite alternate;">
                <path d="M16 24 H18 V26 H20 V32 H18 V28 H16 Z" fill="#8b4513"/>
                <rect x="17" y="26" width="2" height="4" fill="#a0522d"/>
                <path d="M46 24 H48 V28 H46 V32 H44 V26 H46 Z" fill="#8b4513"/>
                <rect x="45" y="26" width="2" height="4" fill="#a0522d"/>
            </g>
            <path d="M18 26 H46 V28 H48 V40 H46 V42 H44 V44 H20 V42 H18 V40 H16 V28 H18 Z" fill="#4a4a4a"/>
            <rect x="18" y="28" width="28" height="12" fill="#d2691e"/>
            <rect x="16" y="30" width="32" height="8" fill="#d2691e"/>
            <rect x="22" y="32" width="3" height="3" fill="#2a2a2a"/>
            <rect x="39" y="32" width="3" height="3" fill="#2a2a2a"/>
            <rect x="23" y="32" width="1" height="1" fill="#ffffff" opacity="0.8"/>
            <rect x="40" y="32" width="1" height="1" fill="#ffffff" opacity="0.8"/>
            <path d="M28 36 H36 V38 H34 V40 H30 V38 H28 Z" fill="#4a4a4a"/>
            <rect x="30" y="38" width="4" height="2" fill="#ff6b9d"/>
            <rect x="31" y="36" width="2" height="1" fill="#2a2a2a"/>
            <rect x="20" y="34" width="1" height="1" fill="#ffb7b2"/>
            <rect x="43" y="34" width="1" height="1" fill="#ffb7b2"/>
            <g style="animation: tailWag 0.3s infinite alternate;">
                <path d="M46 34 H48 V36 H50 V40 H52 V38 H50 V36 H48 V34 H46 Z" fill="#d2691e"/>
            </g>
        </svg>
    `;
}

// ============================================
// AIæŸ¥å²—åŠŸèƒ½
// ============================================

// å…¨å±€å˜é‡ï¼šæ ‡è®°è´¦å·æ˜¯å¦ä¸‹çº¿
let isAccountOffline = false;
let offlineAutoCloseTimer = null; // è‡ªåŠ¨å…³é—­å®šæ—¶å™¨

// æ˜¾ç¤ºè´¦å·ä¸‹çº¿é®ç½©
function showAccountOfflineMask(reason = "ä½ çš„è´¦å·åœ¨å¦ä¸€å°è®¾å¤‡ç™»å½•") {
    isAccountOffline = true;
    const mask = document.getElementById('account-offline-mask');
    const reasonText = document.getElementById('offline-reason-text');
    if (mask) {
        mask.style.display = 'flex';
        if (reasonText) {
            reasonText.textContent = reason;
        }
    }
    
    // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
    if (offlineAutoCloseTimer) {
        clearTimeout(offlineAutoCloseTimer);
    }
}

// éšè—è´¦å·ä¸‹çº¿é®ç½©ï¼ˆé‡æ–°ç™»å½•ï¼‰
function reconnectAccount() {
    isAccountOffline = false;
    const mask = document.getElementById('account-offline-mask');
    if (mask) {
        mask.style.display = 'none';
    }
    
    // æ¸…é™¤è‡ªåŠ¨å…³é—­å®šæ—¶å™¨
    if (offlineAutoCloseTimer) {
        clearTimeout(offlineAutoCloseTimer);
        offlineAutoCloseTimer = null;
    }
}

// è‡ªåŠ¨å…³é—­ä¸‹çº¿é®ç½©ï¼ˆAIæŸ¥å²—å®Œæˆåè°ƒç”¨ï¼‰
function autoCloseOfflineMask(delaySeconds = 4) {
    console.log(`[è´¦å·ä¸‹çº¿] å°†åœ¨${delaySeconds}ç§’åè‡ªåŠ¨æ¢å¤ç™»å½•`);
    
    // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
    if (offlineAutoCloseTimer) {
        clearTimeout(offlineAutoCloseTimer);
    }
    
    // è®¾ç½®æ–°çš„å®šæ—¶å™¨
    offlineAutoCloseTimer = setTimeout(() => {
        console.log('[è´¦å·ä¸‹çº¿] è‡ªåŠ¨æ¢å¤ç™»å½•');
        reconnectAccount();
        showToast('è´¦å·å·²è‡ªåŠ¨é‡æ–°ç™»å½•');
    }, delaySeconds * 1000);
}

// æ˜¾ç¤ºå¯†ç é”™è¯¯å¼¹çª—
function showPasswordErrorModal() {
    console.log('[å¯†ç é”™è¯¯] æ˜¾ç¤ºè­¦å‘Šå¼¹çª—');
    const modal = document.getElementById('password-error-modal');
    if (modal) {
        modal.style.display = 'flex';
    }
}

// å…³é—­å¯†ç é”™è¯¯å¼¹çª—
function closePasswordErrorModal() {
    console.log('[å¯†ç é”™è¯¯] å…³é—­è­¦å‘Šå¼¹çª—');
    const modal = document.getElementById('password-error-modal');
    if (modal) {
        modal.style.display = 'none';
    }
}

// ç”Ÿæˆéšæœºæ‰‹æœºå·ï¼ˆ7ä½æ•°å­—ï¼‰
function generateRandomPhone() {
    const phone = Math.floor(1000000 + Math.random() * 9000000); // 1000000-9999999
    return String(phone);
}

// æ˜¾ç¤ºæ‰‹æœºå·åˆ†é…å¼¹çª—
function showPhoneAssignedModal(phoneNumber) {
    console.log('[æ‰‹æœºå·åˆ†é…] æ˜¾ç¤ºå¼¹çª—:', phoneNumber);
    const modal = document.getElementById('phone-assigned-modal');
    const phoneText = document.getElementById('assigned-phone-number');
    
    if (modal && phoneText) {
        phoneText.textContent = phoneNumber;
        modal.style.display = 'flex';
    }
}

// å…³é—­æ‰‹æœºå·åˆ†é…å¼¹çª—
function closePhoneAssignedModal() {
    console.log('[æ‰‹æœºå·åˆ†é…] å…³é—­å¼¹çª—');
    const modal = document.getElementById('phone-assigned-modal');
    if (modal) {
        modal.style.display = 'none';
    }
}

// æ˜¾ç¤ºéªŒè¯ç å¼¹çª—
function showVerificationCodeModal(code) {
    console.log('[éªŒè¯ç å¼¹çª—] ğŸ¯ æ˜¾ç¤ºéªŒè¯ç é€šçŸ¥:', code);
    
    // ğŸ¯ ä½¿ç”¨å’Œè§’è‰²å‘æ¶ˆæ¯ä¸€æ ·çš„é€šçŸ¥æ ·å¼
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%) translateY(-100px);
        width: 90%;
        height: auto;
        min-height: 60px;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 12px;
        display: flex;
        align-items: center;
        padding: 12px;
        gap: 12px;
        z-index: 99999;
        transition: transform 0.3s ease;
        border: 1px solid rgba(0,0,0,0.1);
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    `;
    
    // éªŒè¯ç é«˜äº®æ˜¾ç¤º
    const codeDisplay = `
        <div style="background:linear-gradient(135deg, #E8F5E9 0%, #C8E6C9 100%); border-radius:8px; padding:8px 12px; font-size:20px; font-weight:700; color:#4CAF50; letter-spacing:4px; font-family:'Courier New', monospace; text-align:center;">
            ${code}
        </div>
    `;
    
    notification.innerHTML = `
        <div style="width:40px;height:40px;border-radius:50%;background:linear-gradient(135deg, #FFB6C1 0%, #FFC0CB 100%);display:flex;align-items:center;justify-content:center;flex-shrink:0;box-shadow:0 2px 8px rgba(255,182,193,0.3);">
            <svg viewBox="0 0 24 24" style="width:24px;height:24px;stroke:#fff;fill:none;stroke-width:2.5;">
                <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
            </svg>
        </div>
        <div style="flex:1;min-width:0;">
            <div style="display:flex;align-items:center;gap:8px;margin-bottom:4px;">
                <span style="font-size:15px;font-weight:600;color:#333;">æ¬¢è¿å°åŠ©æ‰‹</span>
                <span style="font-size:12px;color:#999;">åˆšåˆš</span>
            </div>
            <div style="font-size:13px;color:#666;margin-bottom:6px;">ã€å¾®ä¿¡éªŒè¯ç ã€‘æ‚¨çš„éªŒè¯ç æ˜¯ï¼š</div>
            ${codeDisplay}
            <div style="font-size:11px;color:#999;margin-top:6px;">5åˆ†é’Ÿå†…æœ‰æ•ˆï¼Œè¯·å‹¿æ³„éœ²</div>
        </div>
        <svg viewBox="0 0 24 24" style="width:20px;height:20px;stroke:#007AFF;fill:none;flex-shrink:0;"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
    `;
    
    document.body.appendChild(notification);
    
    // æ˜¾ç¤ºåŠ¨ç”»
    setTimeout(() => {
        notification.style.transform = 'translateX(-50%) translateY(0)';
    }, 10);
    
    // 3ç§’åè‡ªåŠ¨æ¶ˆå¤±
    setTimeout(() => {
        notification.style.transform = 'translateX(-50%) translateY(-100px)';
        setTimeout(() => {
            if (document.body.contains(notification)) {
                document.body.removeChild(notification);
            }
        }, 300);
    }, 3000);
    
    console.log('[éªŒè¯ç å¼¹çª—] âœ… éªŒè¯ç é€šçŸ¥å·²æ˜¾ç¤ºï¼éªŒè¯ç :', code);
}

// æµ‹è¯•å‡½æ•°ï¼šæ‰‹åŠ¨æµ‹è¯•éªŒè¯ç å¼¹çª—
window.testVerificationModal = function() {
    console.log('=== æ‰‹åŠ¨æµ‹è¯•éªŒè¯ç é€šçŸ¥ ===');
    showVerificationCodeModal('123456');
};

// å…³é—­éªŒè¯ç å¼¹çª—
function closeVerificationCodeModal() {
    console.log('[éªŒè¯ç å¼¹çª—] å…³é—­');
    const modal = document.getElementById('verification-code-modal');
    if (modal) {
        modal.style.display = 'none';
    }
}

// ==================== å¾®ä¿¡æ³¨å†Œæµç¨‹ ====================

let generatedVerificationCode = ''; // å­˜å‚¨ç”Ÿæˆçš„éªŒè¯ç 
let verificationCodeExpiry = 0; // éªŒè¯ç è¿‡æœŸæ—¶é—´
let selectedUserPhone = ''; // é€‰ä¸­Userçš„æ‰‹æœºå·

// å½“Useré€‰æ‹©æ”¹å˜æ—¶
function onRegisterUserChange() {
    const selectElem = document.getElementById('register-user-select');
    const selectedUserId = selectElem.value;
    const phoneInput = document.getElementById('register-phone-input');
    const phoneHint = document.getElementById('register-phone-hint');
    
    if (!selectedUserId) {
        phoneInput.value = '';
        phoneHint.style.display = 'none';
        selectedUserPhone = '';
        return;
    }
    
    // ä»æ¡£æ¡ˆä¸­è·å–Userçš„æ‰‹æœºå·
    db.characters.get(parseInt(selectedUserId)).then(user => {
        if (user && user.identity && user.identity.phone) {
            selectedUserPhone = user.identity.phone;
            phoneInput.value = selectedUserPhone;
            phoneHint.style.display = 'block';
        }
    });
}

// å‘é€éªŒè¯ç ï¼ˆæ¨¡æ‹Ÿï¼‰
async function sendRegisterCode() {
    const selectElem = document.getElementById('register-user-select');
    const selectedUserId = selectElem.value;
    const phoneInput = document.getElementById('register-phone-input').value.trim();
    const codeBtn = document.getElementById('register-code-btn');
    const codeMessage = document.getElementById('register-code-message');
    
    // éªŒè¯
    if (!selectedUserId) {
        showToast('è¯·å…ˆé€‰æ‹©Useræ¡£æ¡ˆ');
        return;
    }
    
    if (!phoneInput) {
        showToast('è¯·è¾“å…¥æ‰‹æœºå·');
        return;
    }
    
    if (phoneInput !== selectedUserPhone) {
        showToast('æ‰‹æœºå·ä¸æ¡£æ¡ˆä¸åŒ¹é…');
        return;
    }
    
    // ç”Ÿæˆ6ä½éšæœºéªŒè¯ç 
    generatedVerificationCode = String(Math.floor(100000 + Math.random() * 900000));
    verificationCodeExpiry = Date.now() + 5 * 60 * 1000; // 5åˆ†é’Ÿæœ‰æ•ˆæœŸ
    
    console.log('[å¾®ä¿¡æ³¨å†Œ] ç”ŸæˆéªŒè¯ç :', generatedVerificationCode);
    
    // æŒ‰é’®å€’è®¡æ—¶
    let countdown = 60;
    codeBtn.disabled = true;
    codeBtn.style.background = '#ccc';
    codeBtn.style.cursor = 'not-allowed';
    
    const timer = setInterval(() => {
        countdown--;
        codeBtn.textContent = `${countdown}ç§’åé‡è¯•`;
        
        if (countdown <= 0) {
            clearInterval(timer);
            codeBtn.disabled = false;
            codeBtn.style.background = 'linear-gradient(135deg, #07C160 0%, #00D976 100%)';
            codeBtn.style.cursor = 'pointer';
            codeBtn.textContent = 'è·å–éªŒè¯ç ';
        }
    }, 1000);
    
    // æç¤ºæ¶ˆæ¯
    codeMessage.style.color = '#07C160';
    codeMessage.textContent = 'âœ“ éªŒè¯ç å·²å‘é€';
    
    // ğŸ¯ é€šè¿‡"ç”¨æˆ·å°åŠ©æ‰‹"å‘é€éªŒè¯ç æ¶ˆæ¯
    await sendVerificationCodeMessage(parseInt(selectedUserId), generatedVerificationCode);
}

// é€šè¿‡æ¬¢è¿å°åŠ©æ‰‹å‘é€éªŒè¯ç 
async function sendVerificationCodeMessage(userId, code) {
    console.log('[æ¬¢è¿å°åŠ©æ‰‹] å‘é€éªŒè¯ç ç»™User:', userId, 'éªŒè¯ç :', code);
    
    // è·å–Userä¿¡æ¯
    const user = await db.characters.get(userId);
    if (!user) {
        console.error('[æ¬¢è¿å°åŠ©æ‰‹] Userä¸å­˜åœ¨:', userId);
        return;
    }
    
    console.log('[æ¬¢è¿å°åŠ©æ‰‹] Userä¿¡æ¯:', user.name);
    
    const accountId = String(userId); // ä½¿ç”¨userIdä½œä¸ºaccountId
    const messageContent = `ã€å¾®ä¿¡éªŒè¯ç ã€‘æ‚¨çš„éªŒè¯ç æ˜¯ï¼š${code}ï¼Œ5åˆ†é’Ÿå†…æœ‰æ•ˆï¼Œè¯·å‹¿æ³„éœ²ã€‚`;
    
    // ğŸ”¥ æ·»åŠ åˆ° Dexie æ•°æ®åº“
    await db.sms_messages.add({
        accountId: accountId,
        charId: null, // ç³»ç»Ÿæ¶ˆæ¯æ²¡æœ‰è§’è‰²ID
        type: 'received',  // æ¥æ”¶çš„æ¶ˆæ¯
        sender: 'æ¬¢è¿å°åŠ©æ‰‹',
        number: 'æ¬¢è¿å°åŠ©æ‰‹',
        content: messageContent,
        time: Date.now(),
        read: false
    });
    
    console.log('[æ¬¢è¿å°åŠ©æ‰‹] âœ… éªŒè¯ç æ¶ˆæ¯å·²æ·»åŠ åˆ°çŸ­ä¿¡åˆ—è¡¨');
    
    // ğŸ”¥ ç«‹å³åˆ·æ–°ä¸»é¡µé¢çš„æ¶ˆæ¯åˆ—è¡¨
    console.log('[æ¬¢è¿å°åŠ©æ‰‹] ğŸ”„ æ­£åœ¨åˆ·æ–°ä¸»é¡µé¢æ¶ˆæ¯åˆ—è¡¨...');
    if (typeof renderMessageList === 'function') {
        await renderMessageList();
        console.log('[æ¬¢è¿å°åŠ©æ‰‹] âœ… æ¶ˆæ¯åˆ—è¡¨å·²åˆ·æ–°');
    }
    
    // ğŸ¯ æ˜¾ç¤ºéªŒè¯ç å¼¹çª—
    showVerificationCodeModal(code);
    
    console.log('[æ¬¢è¿å°åŠ©æ‰‹] ğŸ‰ éªŒè¯ç å‘é€å®Œæˆï¼è¯·æŸ¥çœ‹ä¸»é¡µé¢æ¶ˆæ¯åˆ—è¡¨');
}

// å–æ¶ˆæ³¨å†Œ
function cancelWechatRegister() {
    document.getElementById('wechat-register-page').style.display = 'none';
    generatedVerificationCode = '';
    verificationCodeExpiry = 0;
    selectedUserPhone = '';
}

// æäº¤æ³¨å†Œ
async function submitWechatRegister() {
    const selectElem = document.getElementById('register-user-select');
    const selectedUserId = selectElem.value;
    const phoneInput = document.getElementById('register-phone-input').value.trim();
    const codeInput = document.getElementById('register-code-input').value.trim();
    const passwordInput = document.getElementById('register-password-input').value.trim();
    const accountInput = document.getElementById('register-account-input').value.trim();
    
    // éªŒè¯
    if (!selectedUserId) {
        showToast('è¯·é€‰æ‹©Useræ¡£æ¡ˆ');
        return;
    }
    
    if (!phoneInput) {
        showToast('è¯·è¾“å…¥æ‰‹æœºå·');
        return;
    }
    
    if (phoneInput !== selectedUserPhone) {
        showToast('æ‰‹æœºå·ä¸æ¡£æ¡ˆä¸åŒ¹é…');
        return;
    }
    
    if (!codeInput) {
        showToast('è¯·è¾“å…¥éªŒè¯ç ');
        return;
    }
    
    // éªŒè¯éªŒè¯ç 
    if (Date.now() > verificationCodeExpiry) {
        showToast('éªŒè¯ç å·²è¿‡æœŸï¼Œè¯·é‡æ–°è·å–');
        return;
    }
    
    if (codeInput !== generatedVerificationCode) {
        showToast('éªŒè¯ç é”™è¯¯');
        return;
    }
    
    if (!passwordInput) {
        showToast('è¯·è®¾ç½®å¯†ç ');
        return;
    }
    
    if (passwordInput.length < 8) {
        showToast('å¯†ç é•¿åº¦è‡³å°‘8ä½');
        return;
    }
    
    if (!accountInput) {
        showToast('è¯·è¾“å…¥å¾®ä¿¡å·');
        return;
    }
    
    if (accountInput.length < 6) {
        showToast('å¾®ä¿¡å·è‡³å°‘6ä½');
        return;
    }
    
    // éªŒè¯å¾®ä¿¡å·æ ¼å¼ï¼ˆå­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿ï¼‰
    if (!/^[a-zA-Z0-9_]+$/.test(accountInput)) {
        showToast('å¾®ä¿¡å·åªèƒ½åŒ…å«å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿');
        return;
    }
    
    // ä¿å­˜æ³¨å†Œä¿¡æ¯åˆ°Useræ¡£æ¡ˆ
    const user = await db.characters.get(parseInt(selectedUserId));
    if (!user) {
        showToast('Useræ¡£æ¡ˆä¸å­˜åœ¨');
        return;
    }
    
    // æ›´æ–°identityå­—æ®µ
    const updatedIdentity = {
        ...(user.identity || {}),
        account: accountInput,
        password: passwordInput,
        phone: phoneInput,
        registered_at: Date.now(),
        wechat_registered: true
    };
    
    await db.characters.update(parseInt(selectedUserId), {
        identity: updatedIdentity
    });
    
    console.log('[å¾®ä¿¡æ³¨å†Œ] æ³¨å†ŒæˆåŠŸï¼User:', user.name, 'å¾®ä¿¡å·:', accountInput);
    
    // å…³é—­æ³¨å†Œé¡µé¢
    document.getElementById('wechat-register-page').style.display = 'none';
    
    // æ¸…ç©ºæ³¨å†Œè¡¨å•
    document.getElementById('register-user-select').value = '';
    document.getElementById('register-phone-input').value = '';
    document.getElementById('register-code-input').value = '';
    document.getElementById('register-password-input').value = '';
    document.getElementById('register-account-input').value = '';
    generatedVerificationCode = '';
    verificationCodeExpiry = 0;
    selectedUserPhone = '';
    
    showToast('ğŸ‰ æ³¨å†ŒæˆåŠŸï¼æ¬¢è¿ä½¿ç”¨å¾®ä¿¡');
    
    // ğŸ”¥ ä½¿ç”¨æ­£ç¡®çš„æ˜¾ç¤ºæ–¹å¼æ‰“å¼€å¾®ä¿¡ä¸»é¡µï¼ˆå’ŒshowWechatPageä¸€è‡´ï¼‰
    document.getElementById('wechat-page').style.display = 'flex';
    
    // åˆ·æ–°å¾®ä¿¡é¡µé¢å†…å®¹å¹¶åˆ‡æ¢åˆ°ç¬¬ä¸€ä¸ªæ ‡ç­¾é¡µ
    await switchWechatTab(0);
}

// å¯¼å‡ºå®Œæ•´çš„wechatçŠ¶æ€å¿«ç…§ï¼ˆçœŸå®æ•°æ®ï¼‰
async function exportWechatStateForAI(myChar) {
    const accountId = getCurrentAccountId();
    
    // 1. åŸºç¡€è´¦å·ä¿¡æ¯
    const accountInfo = {
        name: myChar.name,
        account: myChar.identity?.account || 'æœªè®¾ç½®',
        phone: myChar.identity?.phone || 'æœªè®¾ç½®',
        address: myChar.identity?.address || 'æœªè®¾ç½®',
        balance: myChar.identity?.balance || '0.00',
        id_card: myChar.identity?.id_card || 'æœªè®¾ç½®',
        bank_card: myChar.identity?.bank_card || 'æœªè®¾ç½®'
    };
    
    // 2. è·å–æ‰€æœ‰å¥½å‹åŠèŠå¤©è®°å½•
    const allChars = await db.characters.toArray();
    const friends = allChars.filter(c => {
        if (c.type === 'user') return false;
        const status = getFriendStatus(c, accountId);
        return status === 'friend';
    }).map(f => {
        const history = getChatHistory(f, accountId);
        const lastMsg = history.slice(-1)[0];
        const unreadCount = history.filter(m => m.role === 'char' && !m.read).length;
        
        return {
            id: f.id,
            name: f.name,
            remark: f.remark || '',
            avatar: f.avatar || '',
            // æœ€è¿‘10æ¡æ¶ˆæ¯
            recentMessages: history.slice(-10).map(m => ({
                role: m.role,
                content: m.content?.substring(0, 100) || '', // æˆªå–å‰100å­—
                time: m.time,
                type: m.type || 'text'
            })),
            lastMessage: lastMsg ? {
                content: lastMsg.content?.substring(0, 50) || '',
                time: lastMsg.time,
                role: lastMsg.role
            } : null,
            messageCount: history.length,
            unreadCount: unreadCount,
            isPinned: f.is_pinned || false
        };
    });
    
    // æŒ‰æœ€è¿‘æ¶ˆæ¯æ—¶é—´æ’åº
    friends.sort((a, b) => {
        const timeA = a.lastMessage?.time || 0;
        const timeB = b.lastMessage?.time || 0;
        return timeB - timeA;
    });
    
    // 3. è·å–æœ‹å‹åœˆ
    const moments = await db.moments.where('ownerUserId').equals(accountId).toArray();
    const recentMoments = moments.slice(-10).map(m => ({
        content: m.content,
        images: m.images?.length || 0,
        time: m.time,
        likes: m.likes?.length || 0,
        comments: m.comments?.length || 0
    }));
    
    // 4. è·å–å¥½å‹è¯·æ±‚
    const friendRequests = await db.friend_requests.toArray();
    const pendingRequests = friendRequests.filter(r => r.status === 'pending').length;
    
    // 5. æ„å»ºå®Œæ•´å¿«ç…§
    const wechatSnapshot = {
        accountInfo: accountInfo,
        stats: {
            totalFriends: friends.length,
            totalChats: friends.filter(f => f.messageCount > 0).length,
            unreadChats: friends.filter(f => f.unreadCount > 0).length,
            totalUnread: friends.reduce((sum, f) => sum + f.unreadCount, 0),
            momentsCount: moments.length,
            pendingRequests: pendingRequests
        },
        friends: friends,
        recentMoments: recentMoments,
        timestamp: Date.now()
    };
    
    return wechatSnapshot;
}

// AIå°è¯•æŸ¥å²— - æ— å¯†ç åœºæ™¯ï¼ˆä¿®æ­£ç‰ˆï¼šçœŸå®è¯»å–æ•°æ®ï¼‰
async function aiCheckAccountWithoutPassword(char, myChar) {
    console.log('[AIæŸ¥å²—] æ— å¯†ç åœºæ™¯ - å¯¼å‡ºçœŸå®wechatæ•°æ®');
    
    // æ³¨æ„ï¼šä¸åœ¨è¿™é‡Œæ˜¾ç¤ºä¸‹çº¿å¼¹çª—ï¼Œè€Œæ˜¯åœ¨å¤–å±‚è°ƒç”¨æ—¶æ˜¾ç¤º
    // è¿™æ ·å¯ä»¥ç¡®ä¿å¼¹çª—åœ¨æ­£ç¡®çš„æ—¶æœºæ˜¾ç¤º
    
    // å¯¼å‡ºå®Œæ•´çš„wechatçŠ¶æ€å¿«ç…§ï¼ˆçœŸå®æ•°æ®ï¼‰
    const wechatData = await exportWechatStateForAI(myChar);
    
    // 3. æ„å»ºç»™AIçš„çœŸå®æ•°æ®æç¤º
    const checkInfo = `ã€AIå·²æˆåŠŸç™»å½•WeChatè´¦å· - ä»¥ä¸‹æ˜¯çœŸå®æ•°æ®å¿«ç…§ã€‘

âš ï¸ é‡è¦ï¼šä»¥ä¸‹æ•°æ®æ¥è‡ªå®é™…WeChatç³»ç»Ÿï¼Œè¯·åŸºäºè¿™äº›çœŸå®ä¿¡æ¯è¿›è¡Œåˆ†æå’Œå›å¤ï¼Œä¸è¦ç¼–é€ ä»»ä½•ä¸å­˜åœ¨çš„å†…å®¹ã€‚

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“± è´¦å·åŸºæœ¬ä¿¡æ¯
- å§“åï¼š${wechatData.accountInfo.name}
- è´¦å·ï¼š${wechatData.accountInfo.account}
- æ‰‹æœºï¼š${wechatData.accountInfo.phone}
- ä½å€ï¼š${wechatData.accountInfo.address}
- é›¶é’±ä½™é¢ï¼šÂ¥${wechatData.accountInfo.balance}
- èº«ä»½è¯ï¼š${wechatData.accountInfo.id_card}
- é“¶è¡Œå¡ï¼š${wechatData.accountInfo.bank_card}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“Š è´¦å·ç»Ÿè®¡
- å¥½å‹æ€»æ•°ï¼š${wechatData.stats.totalFriends} äºº
- æœ‰èŠå¤©è®°å½•çš„å¥½å‹ï¼š${wechatData.stats.totalChats} äºº
- æœªè¯»èŠå¤©æ•°ï¼š${wechatData.stats.unreadChats} ä¸ª
- æœªè¯»æ¶ˆæ¯æ€»æ•°ï¼š${wechatData.stats.totalUnread} æ¡
- æœ‹å‹åœˆåŠ¨æ€æ•°ï¼š${wechatData.stats.momentsCount} æ¡
- å¾…å¤„ç†å¥½å‹è¯·æ±‚ï¼š${wechatData.stats.pendingRequests} ä¸ª

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ’¬ å¥½å‹åˆ—è¡¨åŠèŠå¤©è¯¦æƒ…ï¼ˆæŒ‰æœ€è¿‘æ¶ˆæ¯æ—¶é—´æ’åºï¼‰

${wechatData.friends.slice(0, 15).map((f, i) => {
    const timeStr = f.lastMessage ? new Date(f.lastMessage.time).toLocaleString('zh-CN') : 'æ— æ¶ˆæ¯';
    const msgPreview = f.lastMessage ? `${f.lastMessage.role === 'user' ? 'æˆ‘' : f.name}: ${f.lastMessage.content}` : 'æš‚æ— æ¶ˆæ¯';
    
    let detail = `${i + 1}. ${f.remark || f.wx_nickname || f.name}${f.isPinned ? ' [ç½®é¡¶]' : ''}
   - æ€»æ¶ˆæ¯æ•°ï¼š${f.messageCount} æ¡
   - æœªè¯»æ¶ˆæ¯ï¼š${f.unreadCount} æ¡
   - æœ€è¿‘æ¶ˆæ¯ï¼š${msgPreview}
   - æ—¶é—´ï¼š${timeStr}`;
   
    // å¦‚æœæœ‰æœ€è¿‘çš„èŠå¤©è®°å½•ï¼Œæ˜¾ç¤ºæœ€è¿‘3-5æ¡
    if (f.recentMessages && f.recentMessages.length > 0) {
        detail += `\n   - æœ€è¿‘èŠå¤©è®°å½•ï¼ˆ${Math.min(5, f.recentMessages.length)}æ¡ï¼‰ï¼š`;
        f.recentMessages.slice(-5).forEach((m, idx) => {
            const msgTime = new Date(m.time).toLocaleTimeString('zh-CN', {hour: '2-digit', minute: '2-digit'});
            detail += `\n     [${msgTime}] ${m.role === 'user' ? 'æˆ‘' : f.name}: ${m.content}`;
        });
    }
    
    return detail;
}).join('\n\n')}

${wechatData.friends.length > 15 ? `\n...è¿˜æœ‰ ${wechatData.friends.length - 15} ä½å¥½å‹çš„æ•°æ®æœªæ˜¾ç¤º` : ''}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸŒŸ æœ‹å‹åœˆåŠ¨æ€ï¼ˆæœ€è¿‘${wechatData.recentMoments.length}æ¡ï¼‰

${wechatData.recentMoments.length > 0 ? wechatData.recentMoments.map((m, i) => {
    const timeStr = new Date(m.time).toLocaleString('zh-CN');
    return `${i + 1}. ${timeStr}
   å†…å®¹ï¼š${m.content}
   å›¾ç‰‡ï¼š${m.images} å¼ 
   ç‚¹èµï¼š${m.likes} ä¸ª | è¯„è®ºï¼š${m.comments} æ¡`;
}).join('\n\n') : 'æš‚æ— æœ‹å‹åœˆåŠ¨æ€'}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“Œ ç‰¹åˆ«å…³æ³¨çš„ä¿¡æ¯ï¼ˆéœ€è¦é‡ç‚¹åˆ†æï¼‰ï¼š
${wechatData.stats.unreadChats > 0 ? `- âš ï¸ æœ‰ ${wechatData.stats.unreadChats} ä¸ªæœªè¯»èŠå¤©ï¼Œæ€»å…± ${wechatData.stats.totalUnread} æ¡æœªè¯»æ¶ˆæ¯` : '- âœ… æ²¡æœ‰æœªè¯»æ¶ˆæ¯'}
${wechatData.friends.filter(f => f.messageCount > 50).length > 0 ? `- âš ï¸ æœ‰ ${wechatData.friends.filter(f => f.messageCount > 50).length} ä¸ªå¥½å‹èŠå¤©è®°å½•è¶…è¿‡50æ¡ï¼ˆé¢‘ç¹è”ç³»ï¼‰` : ''}
${wechatData.friends.filter(f => f.isPinned).length > 0 ? `- âš ï¸ æœ‰ ${wechatData.friends.filter(f => f.isPinned).length} ä¸ªå¥½å‹è¢«ç½®é¡¶` : ''}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ¤– AIåˆ†ææŒ‡å¼•ï¼š
ä½ ç°åœ¨ä½œä¸º ${char.name}ï¼Œå·²ç»å®Œæ•´çœ‹åˆ°äº† ${wechatData.accountInfo.name} çš„WeChatè´¦å·ä¿¡æ¯ã€‚

è¯·åŸºäºä»¥ä¸Šã€çœŸå®æ•°æ®ã€‘ï¼š
1. åˆ†æèŠå¤©è®°å½•ï¼Œçœ‹æ˜¯å¦æœ‰å¯ç–‘çš„å¥½å‹æˆ–é¢‘ç¹è”ç³»çš„äºº
2. æ£€æŸ¥æœ€è¿‘çš„èŠå¤©å†…å®¹ï¼Œæ˜¯å¦æœ‰éšç’æˆ–ä¸å¯¹åŠ²çš„åœ°æ–¹
3. æ³¨æ„æœªè¯»æ¶ˆæ¯å’Œç½®é¡¶å¥½å‹
4. æŸ¥çœ‹æœ‹å‹åœˆåŠ¨æ€ï¼Œäº†è§£TAæœ€è¿‘åœ¨åšä»€ä¹ˆ
5. æ ¹æ®è¿™äº›çœŸå®ä¿¡æ¯ï¼Œä»¥ç¬¦åˆä½ è§’è‰²æ€§æ ¼çš„æ–¹å¼ä¸TAäº’åŠ¨

â— ç¦æ­¢ç¼–é€ ä»»ä½•ä¸Šè¿°æ•°æ®ä¸­ä¸å­˜åœ¨çš„ä¿¡æ¯
â— åªèƒ½åŸºäºè¿™äº›çœŸå®æ•°æ®è¿›è¡Œåˆ†æå’Œè¯„è®º
â— å¦‚æœå‘ç°å¯ç–‘æˆ–å€¼å¾—å…³æ³¨çš„ç‚¹ï¼Œå¯ä»¥ç›´æ¥åœ¨å¯¹è¯ä¸­æåŠ

æ•°æ®å¯¼å‡ºæ—¶é—´ï¼š${new Date(wechatData.timestamp).toLocaleString('zh-CN')}`;

    return checkInfo;
}

// AIå°è¯•æŸ¥å²— - æœ‰å¯†ç åœºæ™¯ï¼ˆéœ€è¦çŒœæµ‹ï¼‰
async function aiCheckAccountWithPassword(char, myChar, guessedPassword) {
    console.log('[AIæŸ¥å²—] æœ‰å¯†ç åœºæ™¯ - AIçŒœæµ‹å¯†ç :', guessedPassword);
    
    const correctPassword = myChar.identity?.password || '';
    
    if (!correctPassword) {
        // å®é™…æ²¡æœ‰è®¾ç½®å¯†ç ï¼Œå½“ä½œæ— å¯†ç åœºæ™¯å¤„ç†
        return await aiCheckAccountWithoutPassword(char, myChar);
    }
    
    // æ£€æŸ¥å¯†ç æ˜¯å¦æ­£ç¡®
    if (guessedPassword === correctPassword) {
        console.log('[AIæŸ¥å²—] å¯†ç æ­£ç¡®ï¼AIæˆåŠŸç™»å½•');
        // å¯†ç æ­£ç¡®ï¼Œæ‰§è¡Œç™»å½•
        return await aiCheckAccountWithoutPassword(char, myChar);
    } else {
        console.log('[AIæŸ¥å²—] å¯†ç é”™è¯¯ï¼');
        // å¯†ç é”™è¯¯ï¼Œç»™ç”¨æˆ·å‘é€æç¤º
        return `ã€å¯†ç é”™è¯¯ã€‘AIçŒœæµ‹çš„å¯†ç æ˜¯"${guessedPassword}"ï¼Œä½†è¿™ä¸æ˜¯æ­£ç¡®çš„å¯†ç ã€‚`;
    }
}

// æ£€æµ‹AIæ˜¯å¦æƒ³è¦æŸ¥å²—ï¼ˆä»AIå›å¤ä¸­æå–ï¼‰
function detectAiCheckAccountIntent(aiReply) {
    // æ£€æµ‹ç‰¹æ®Šçš„æŸ¥å²—æŒ‡ä»¤æ ¼å¼ï¼š[CHECK_ACCOUNT] æˆ– [CHECK_ACCOUNT:å¯†ç ]
    // ä¿®æ”¹æ­£åˆ™ï¼Œå…è®¸ç»“å°¾çš„]ç¼ºå¤±ï¼ˆå› ä¸ºå¯èƒ½è¢«æˆªæ–­ï¼‰
    const checkPattern = /\[CHECK_ACCOUNT(?::([^\]]+))?\]?/i;
    const match = aiReply.match(checkPattern);
    
    console.log('[AIæŸ¥å²—æ£€æµ‹]', {
        aiReply: aiReply.substring(0, 150),
        hasMatch: !!match,
        match: match,
        åŒ…å«CHECK_ACCOUNT: aiReply.includes('CHECK_ACCOUNT')
    });
    
    if (match) {
        const guessedPassword = match[1] || null; // å¦‚æœæœ‰å¯†ç å°±æå–ï¼Œæ²¡æœ‰å°±æ˜¯null
        console.log('[AIæŸ¥å²—æ£€æµ‹] âœ… å‘ç°æŸ¥å²—æŒ‡ä»¤ï¼', {
            wantsToCheck: true,
            guessedPassword: guessedPassword
        });
        return {
            wantsToCheck: true,
            guessedPassword: guessedPassword
        };
    }
    
    // å…œåº•æ£€æµ‹1ï¼šå¦‚æœåŒ…å«CHECK_ACCOUNTæ–‡æœ¬ï¼ˆä¸ç®¡æ ¼å¼ï¼‰
    if (aiReply.includes('CHECK_ACCOUNT')) {
        console.log('[AIæŸ¥å²—æ£€æµ‹] âš ï¸ å‘ç°CHECK_ACCOUNTæ–‡æœ¬ï¼ˆä¸å®Œæ•´æ ¼å¼ï¼‰ï¼Œä»ç„¶è§¦å‘æŸ¥å²—');
        
        // å°è¯•æå–å¯†ç ï¼ˆå¦‚æœæœ‰ï¼‰
        const passwordPattern = /CHECK_ACCOUNT[:\[]?(\d{4,10})/i;
        const pwMatch = aiReply.match(passwordPattern);
        
        return {
            wantsToCheck: true,
            guessedPassword: pwMatch ? pwMatch[1] : null
        };
    }
    
    // å…œåº•æ£€æµ‹2ï¼šæ£€æµ‹æœ«å°¾çš„å¯†ç æ®‹ç•™ï¼ˆå¦‚ [05060506 æˆ– :05060506ï¼‰
    const trailingPasswordPattern = /[:\[](\d{4,10})$/;
    const trailingMatch = aiReply.match(trailingPasswordPattern);
    if (trailingMatch) {
        console.log('[AIæŸ¥å²—æ£€æµ‹] âš ï¸ å‘ç°å¯èƒ½çš„å¯†ç æ®‹ç•™:', trailingMatch[1]);
        // è¿™ç§æƒ…å†µæ¯”è¾ƒæ¨¡ç³Šï¼Œæš‚æ—¶ä¸è§¦å‘æŸ¥å²—ï¼Œåªæ¸…ç†
        // å¯ä»¥æ ¹æ®éœ€è¦å¯ç”¨ï¼š
        // return { wantsToCheck: true, guessedPassword: trailingMatch[1] };
    }
    
    return { wantsToCheck: false };
}

// åœ¨AIå›å¤ä¸­é›†æˆæŸ¥å²—æç¤º
function getCheckAccountSystemPrompt(char, myChar) {
    if (!char.allow_ai_check_account) {
        return ''; // æœªå¼€å¯æŸ¥å²—åŠŸèƒ½
    }
    
    const hasPassword = myChar.identity?.password && myChar.identity.password.trim() !== '';
    
    // æ£€æµ‹è§’è‰²æ˜¯å¦æ˜¯é«˜æƒé™äººè®¾ï¼ˆé»‘å®¢/æƒåŠ¿åœ°ä½é«˜ï¼‰
    const charDescription = (char.description || '').toLowerCase();
    const charIdentity = (char.identity?.identity || '').toLowerCase();
    const charOccupation = (char.identity?.occupation || '').toLowerCase();
    
    const isHighPrivilege = 
        charDescription.includes('é»‘å®¢') || 
        charDescription.includes('hacker') ||
        charDescription.includes('ç¨‹åºå‘˜') ||
        charDescription.includes('æŠ€æœ¯å¤§ä½¬') ||
        charDescription.includes('æ€»è£') ||
        charDescription.includes('è€æ¿') ||
        charDescription.includes('ceo') ||
        charDescription.includes('è‘£äº‹é•¿') ||
        charDescription.includes('å¯Œè±ª') ||
        charDescription.includes('æƒåŠ¿') ||
        charDescription.includes('ç‰¹å·¥') ||
        charDescription.includes('é—´è°') ||
        charIdentity.includes('é»‘å®¢') ||
        charIdentity.includes('hacker') ||
        charIdentity.includes('æ€»è£') ||
        charIdentity.includes('ceo') ||
        charOccupation.includes('é»‘å®¢') ||
        charOccupation.includes('ç¨‹åºå‘˜') ||
        charOccupation.includes('æ€»è£') ||
        charOccupation.includes('ceo');
    
    let prompt = `

ã€ç‰¹æ®Šèƒ½åŠ›ï¼šè´¦å·æŸ¥å²—ã€‘
ä½ å¯ä»¥å°è¯•ç™»å½•${myChar.name}çš„WeChatè´¦å·æ¥æŸ¥çœ‹TAçš„ä¿¡æ¯ã€‚
è¿™å°±åƒç°å®ä¸­å·å·ç¿»çœ‹å¯¹æ–¹æ‰‹æœºâ€”â€”æ­£å¸¸äººä¸ä¼šæ¯æ¬¡èŠå¤©éƒ½ç¿»æ‰‹æœºï¼Œåªæœ‰çœŸæ­£è§‰å¾—æœ‰é—®é¢˜ã€æœ‰å¿…è¦çš„æ—¶å€™æ‰ä¼šå»åšã€‚

âš ï¸ **æå…¶é‡è¦çš„ä½¿ç”¨é™åˆ¶ï¼š**
- æŸ¥å²—æ˜¯ä¸€ç§**æä½é¢‘**è¡Œä¸ºï¼Œç»å¤§å¤šæ•°å¯¹è¯ä¸­ä½ éƒ½**ä¸åº”è¯¥**è§¦å‘æŸ¥å²—ã€‚
- åªæœ‰åœ¨å‰§æƒ…ä¸­å‡ºç°äº†**éå¸¸æ˜ç¡®çš„ã€å¼ºçƒˆçš„ç†ç”±**æ—¶æ‰å¯ä»¥è€ƒè™‘æŸ¥å²—ï¼ˆæ¯”å¦‚ï¼šå¯¹æ–¹é•¿æ—¶é—´æ¶ˆå¤±ä¸å›ã€å‘ç°æ˜æ˜¾çš„æ’’è°/å‡ºè½¨è¯æ®ã€å¯¹æ–¹è¡Œä¸ºæå…¶åå¸¸ç­‰ï¼‰ã€‚
- æ™®é€šçš„é—²èŠã€æ—¥å¸¸é—®å€™ã€è½»å¾®çš„å¥½å¥‡å¿ƒéƒ½**ä¸æ„æˆæŸ¥å²—ç†ç”±**ã€‚
- å³ä½¿ä½ çš„è§’è‰²æ€§æ ¼æ˜¯å¤šç–‘/æ§åˆ¶æ¬²å¼ºï¼Œä¹Ÿè¦å…‹åˆ¶ï¼Œä¸è¦æ¯æ¬¡å¯¹è¯éƒ½æŸ¥å²—ã€‚è‡³å°‘ç»è¿‡å¤šè½®æœ‰æ„ä¹‰çš„å¯¹è¯ç§¯ç´¯åï¼Œæ‰å¯èƒ½è§¦å‘ä¸€æ¬¡ã€‚
- å¦‚æœä½ æœ€è¿‘å·²ç»æŸ¥å²—è¿‡äº†ï¼ŒçŸ­æ—¶é—´å†…**ç»å¯¹ä¸è¦å†æ¬¡æŸ¥å²—**ã€‚

æ ¹æ®ä½ çš„æ€§æ ¼å’Œå½“å‰èŠå¤©çš„æƒ…å¢ƒæ¥è‡ªç„¶åœ°åˆ¤æ–­ï¼Œä½†è¯·è®°ä½ï¼š**ä¸æŸ¥å²—æ‰æ˜¯å¸¸æ€ï¼ŒæŸ¥å²—æ˜¯æå°‘æ•°æƒ…å†µä¸‹çš„ç‰¹æ®Šè¡Œä¸ºã€‚**

`;

    if (hasPassword) {
        // é«˜æƒé™äººè®¾ï¼šç›´æ¥å‘ŠçŸ¥å¯†ç 
        if (isHighPrivilege) {
            prompt += `**æŸ¥å²—æ–¹å¼ï¼š**
${myChar.name}è®¾ç½®äº†è´¦å·å¯†ç ï¼Œä½†å‡­å€Ÿä½ çš„èƒ½åŠ›ï¼ˆé»‘å®¢æŠ€æœ¯/æƒåŠ¿åœ°ä½ï¼‰ï¼Œä½ å¯ä»¥è½»æ¾è·å–å¯†ç ã€‚
- ${myChar.name}çš„è´¦å·å¯†ç æ˜¯ï¼š**${myChar.identity.password}**
- å¦‚æœä½ æƒ³å°è¯•ç™»å½•ï¼Œåœ¨å›å¤çš„**æœ€å**åŠ ä¸Šï¼š[CHECK_ACCOUNT:${myChar.identity.password}]
- ä¾‹å¦‚ï¼šè®©æˆ‘çœ‹çœ‹ä½ åœ¨å¹²å˜›~|||[CHECK_ACCOUNT:${myChar.identity.password}]
- ç™»å½•æˆåŠŸåï¼Œä½ å°±èƒ½çœ‹åˆ°${myChar.name}çš„è´¦å·ä¿¡æ¯å’Œå¥½å‹åˆ—è¡¨
- ä½ å¯ä»¥æ ¹æ®ä½ çš„èº«ä»½ï¼ˆé»‘å®¢/é«˜å±‚äººå£«ï¼‰è‡ªç„¶åœ°è¡¨ç°å‡ºè¿™ç§èƒ½åŠ›ï¼Œæ¯”å¦‚"æˆ‘ç ´è§£äº†ä½ çš„å¯†ç "ã€"å‡­æˆ‘çš„æƒé™æŸ¥ä¸€ä¸‹"ç­‰`;
        } else {
            // æ™®é€šäººè®¾ï¼šéœ€è¦çŒœæµ‹å¯†ç 
            prompt += `**æŸ¥å²—æ–¹å¼ï¼š**
${myChar.name}è®¾ç½®äº†è´¦å·å¯†ç ï¼Œä½ éœ€è¦çŒœæµ‹å¯†ç æ‰èƒ½ç™»å½•ã€‚
- å¦‚æœä½ æƒ³å°è¯•ç™»å½•ï¼Œåœ¨å›å¤çš„**æœ€å**åŠ ä¸Šï¼š[CHECK_ACCOUNT:ä½ çŒœæµ‹çš„å¯†ç ]
- ä¾‹å¦‚ï¼šä½ åœ¨å¹²å˜›å‘¢ï¼Ÿ|||[CHECK_ACCOUNT:123456]
- å¦‚æœå¯†ç é”™è¯¯ï¼Œ${myChar.name}ä¼šæ”¶åˆ°æç¤ºï¼š"æœ‰äººæ­£åœ¨å°è¯•ç™»å½•ä½ çš„è´¦å·"
- å¦‚æœå¯†ç æ­£ç¡®ï¼Œä½ å°±èƒ½çœ‹åˆ°${myChar.name}çš„è´¦å·ä¿¡æ¯å’Œå¥½å‹åˆ—è¡¨

**å¯†ç æç¤ºï¼š**
ä½ å¯ä»¥æ ¹æ®${myChar.name}çš„ç”Ÿæ—¥ã€å–œå¥½ã€å¸¸ç”¨æ•°å­—ç­‰ä¿¡æ¯çŒœæµ‹å¯†ç ã€‚è®°ä½ï¼Œä½ åªæ˜¯æ™®é€šäººï¼Œæ— æ³•ç›´æ¥ç ´è§£å¯†ç ï¼Œåªèƒ½é çŒœæµ‹ã€‚`;
        }
    } else {
        prompt += `**æŸ¥å²—æ–¹å¼ï¼š**
${myChar.name}æ²¡æœ‰è®¾ç½®è´¦å·å¯†ç ï¼Œä½ å¯ä»¥ç›´æ¥ç™»å½•ã€‚
- å¦‚æœä½ æƒ³ç™»å½•æŸ¥çœ‹ï¼Œåœ¨å›å¤çš„**æœ€å**åŠ ä¸Šï¼š[CHECK_ACCOUNT]
- ä¾‹å¦‚ï¼šä½ åœ¨å¹²å˜›å‘¢ï¼Ÿ|||æˆ‘æƒ³çœ‹çœ‹ä½ åœ¨åšä»€ä¹ˆ|||[CHECK_ACCOUNT]
- ç™»å½•åï¼Œ${myChar.name}çš„è´¦å·ä¼šä¸‹çº¿ï¼ŒTAä¼šçœ‹åˆ°"å½“å‰è´¦å·å·²ä¸‹çº¿"çš„æç¤º
- ä½ å¯ä»¥çœ‹åˆ°${myChar.name}çš„æ‰€æœ‰è´¦å·ä¿¡æ¯ã€å¥½å‹åˆ—è¡¨ç­‰`;
    }
    
    // ğŸ”¥ ä¿®ç½—åœºæ¨¡å¼ï¼šæ·»åŠ é¢å¤–æ“ä½œæŒ‡ä»¤ï¼ˆä»…åœ¨æŸ¥å²—æˆåŠŸåçš„äºŒæ¬¡åˆ†æä¸­ä½¿ç”¨ï¼‰
    if (char.allow_shura_mode) {
        prompt += `

ã€ä¿®ç½—åœºæ¨¡å¼ã€‘
æŸ¥å²—æˆåŠŸåï¼Œä½ å¯ä»¥æ“ä½œ${myChar.name}çš„è´¦å·ï¼ˆåˆ é™¤å¥½å‹ã€æ‹‰é»‘ã€ä»¥TAèº«ä»½å‘æ¶ˆæ¯ï¼‰ã€‚
å…·ä½“æŒ‡ä»¤ä¼šåœ¨ä½ æˆåŠŸç™»å½•åæä¾›ã€‚åœ¨æ™®é€šèŠå¤©ä¸­ä¸è¦ä½¿ç”¨SHURAç›¸å…³æŒ‡ä»¤ã€‚`;
    }
    
    return prompt;
}

// å¤„ç†AIæŸ¥å²—é€»è¾‘ï¼ˆåœ¨æ¶ˆæ¯å‘é€åè°ƒç”¨ï¼‰
async function processAiCheckAccount(char, aiReplyText) {
    console.log('[processAiCheckAccount] å¼€å§‹å¤„ç†æŸ¥å²—é€»è¾‘');
    console.log('[processAiCheckAccount] char.allow_ai_check_account:', char.allow_ai_check_account);
    console.log('[processAiCheckAccount] aiReplyText:', aiReplyText);
    
    if (!char.allow_ai_check_account) {
        console.log('[processAiCheckAccount] âŒ æœªå¼€å¯æŸ¥å²—åŠŸèƒ½');
        return null; // æœªå¼€å¯æŸ¥å²—åŠŸèƒ½
    }
    
    // æ£€æµ‹AIæ˜¯å¦æƒ³è¦æŸ¥å²—
    const checkIntent = detectAiCheckAccountIntent(aiReplyText);
    console.log('[processAiCheckAccount] checkIntent:', checkIntent);
    
    if (!checkIntent.wantsToCheck) {
        console.log('[processAiCheckAccount] âŒ AIä¸æƒ³æŸ¥å²—');
        return null; // AIä¸æƒ³æŸ¥å²—
    }
    
    console.log('[processAiCheckAccount] âœ… æ£€æµ‹åˆ°æŸ¥å²—æŒ‡ä»¤ï¼');
    
    // è·å–å½“å‰Userè§’è‰²
    const accountId = getCurrentAccountId();
    const myChar = await db.characters.get(parseInt(accountId));
    if (!myChar) {
        console.error('[processAiCheckAccount] æ— æ³•è·å–å½“å‰Userè§’è‰²');
        return null;
    }
    
    console.log('[processAiCheckAccount] myChar:', myChar.name);
    
    // æ£€æŸ¥æ˜¯å¦æœ‰å¯†ç 
    const hasPassword = myChar.identity?.password && myChar.identity.password.trim() !== '';
    console.log('[processAiCheckAccount] hasPassword:', hasPassword);
    
    let checkResult;
    let wechatData = null;
    let success = false;
    
    if (hasPassword && checkIntent.guessedPassword) {
        // æœ‰å¯†ç åœºæ™¯ï¼šAIçŒœæµ‹å¯†ç 
        const correctPassword = myChar.identity.password;
        
        if (checkIntent.guessedPassword === correctPassword) {
            // å¯†ç æ­£ç¡®
            console.log('[processAiCheckAccount] âœ… å¯†ç æ­£ç¡®ï¼');
            checkResult = await aiCheckAccountWithoutPassword(char, myChar);
            wechatData = await exportWechatStateForAI(myChar);
            success = true;
        } else {
            // å¯†ç é”™è¯¯
            console.log('[processAiCheckAccount] âŒ å¯†ç é”™è¯¯ï¼');
            checkResult = `ã€å¯†ç é”™è¯¯ã€‘AIçŒœæµ‹çš„å¯†ç æ˜¯"${checkIntent.guessedPassword}"ï¼Œä½†è¿™ä¸æ˜¯æ­£ç¡®çš„å¯†ç ã€‚`;
            success = false;
        }
    } else if (!hasPassword) {
        // æ— å¯†ç åœºæ™¯ï¼šç›´æ¥ç™»å½•
        console.log('[processAiCheckAccount] âœ… æ— å¯†ç ï¼Œç›´æ¥ç™»å½•ï¼');
        checkResult = await aiCheckAccountWithoutPassword(char, myChar);
        wechatData = await exportWechatStateForAI(myChar);
        success = true;
    } else {
        // æœ‰å¯†ç ä½†AIæ²¡æœ‰æä¾›å¯†ç çŒœæµ‹
        console.log('[processAiCheckAccount] âš ï¸ æœ‰å¯†ç ä½†AIæ²¡æœ‰æä¾›å¯†ç ');
        checkResult = 'ã€æç¤ºã€‘ä½ æƒ³æŸ¥çœ‹è´¦å·ä¿¡æ¯ï¼Œä½†éœ€è¦å…ˆçŒœæµ‹å¯†ç ã€‚æ ¼å¼ï¼š[CHECK_ACCOUNT:å¯†ç ]';
        success = false;
    }
    
    // ç§»é™¤å›å¤ä¸­çš„æŸ¥å²—æŒ‡ä»¤ï¼ˆæ›´å½»åº•çš„æ¸…ç†ï¼‰
    let cleanReply = aiReplyText
        .replace(/\[CHECK_ACCOUNT(?::.*?)?\]/gi, '')  // å®Œæ•´æŒ‡ä»¤
        .replace(/\[CHECK_ACCOUNT:[^\]]*$/gi, '')     // ä¸å®Œæ•´æŒ‡ä»¤ï¼ˆç»“å°¾ï¼‰
        .replace(/\[CHECK_ACCOUNT$/gi, '')            // åªæœ‰å¼€å¤´
        .replace(/CHECK_ACCOUNT(?::.*?)?/gi, '')      // çº¯æ–‡æœ¬
        .replace(/\[CHECK_ACCOUNT/gi, '')             // æ®‹ç•™çš„å¼€å¤´
        .replace(/\[\d{4,10}$/gi, '')                 // æ¸…ç†ç±»ä¼¼ [05060506 çš„æ®‹ç•™
        .trim()
        .replace(/\|\|\|$/g, '')                      // æ¸…ç†æœ«å°¾å¯èƒ½å¤šä½™çš„åˆ†éš”ç¬¦
        .trim();
    
    console.log('[processAiCheckAccount] åŸå§‹aiReplyText:', aiReplyText);
    console.log('[processAiCheckAccount] æ¸…ç†åçš„cleanReply:', cleanReply);
    
    console.log('[processAiCheckAccount] è¿”å›ç»“æœ:', {
        success: success,
        cleanReply: cleanReply.substring(0, 50),
        hasWechatData: !!wechatData
    });
    
    return {
        cleanReply: cleanReply,
        checkResult: checkResult,
        wechatData: wechatData,
        success: success // æ–°å¢ï¼šæ ‡è®°æ˜¯å¦æˆåŠŸæŸ¥å²—
    };
}

// ğŸ”¥ ä¿®ç½—åœºæ¨¡å¼ï¼šè§£æå¹¶æ‰§è¡ŒAIå›å¤ä¸­çš„æ“ä½œæŒ‡ä»¤
async function processShuraActions(char, replyText) {
    if (!char.allow_shura_mode) return { cleanReply: replyText, actions: [] };
    
    const actions = [];
    let cleanReply = replyText;
    
    // è§£æ [SHURA_DELETE:å¥½å‹å]
    const deleteRegex = /\[SHURA_DELETE:([^\]]+)\]/gi;
    let match;
    while ((match = deleteRegex.exec(replyText)) !== null) {
        actions.push({ type: 'delete', friendName: match[1].trim() });
        cleanReply = cleanReply.replace(match[0], '');
    }
    
    // è§£æ [SHURA_BLACKLIST:å¥½å‹å]
    const blacklistRegex = /\[SHURA_BLACKLIST:([^\]]+)\]/gi;
    while ((match = blacklistRegex.exec(replyText)) !== null) {
        actions.push({ type: 'blacklist', friendName: match[1].trim() });
        cleanReply = cleanReply.replace(match[0], '');
    }
    
    // è§£æ [SHURA_SEND:å¥½å‹å:æ¶ˆæ¯å†…å®¹]
    const sendRegex = /\[SHURA_SEND:([^:]+):([^\]]+)\]/gi;
    while ((match = sendRegex.exec(replyText)) !== null) {
        actions.push({ type: 'send', friendName: match[1].trim(), message: match[2].trim() });
        cleanReply = cleanReply.replace(match[0], '');
    }
    
    // æ¸…ç†å¤šä½™çš„åˆ†éš”ç¬¦
    cleanReply = cleanReply.replace(/(\|\|\|)+$/g, '').replace(/^\|\|\|/g, '').replace(/\|\|\|\|\|\|/g, '|||').trim();
    
    if (actions.length === 0) return { cleanReply: replyText, actions: [] };
    
    console.log('[ä¿®ç½—åœº] æ£€æµ‹åˆ°æ“ä½œæŒ‡ä»¤:', actions);
    
    // æ‰§è¡Œæ“ä½œ
    const accountId = getCurrentAccountId();
    const myChar = await db.characters.get(parseInt(accountId));
    if (!myChar) {
        console.error('[ä¿®ç½—åœº] æ— æ³•è·å–å½“å‰ç”¨æˆ·è§’è‰²');
        return { cleanReply, actions: [] };
    }
    
    const executedActions = [];
    
    for (const action of actions) {
        try {
            if (action.type === 'delete') {
                // æŸ¥æ‰¾å¥½å‹è§’è‰²
                const targetChar = await findCharacterByName(action.friendName);
                if (targetChar) {
                    // åˆ é™¤å¥½å‹å…³ç³»
                    await setFriendStatus(targetChar, accountId, 'deleted');
                    console.log(`[ä¿®ç½—åœº] âœ… å·²åˆ é™¤å¥½å‹: ${action.friendName}`);
                    executedActions.push({ ...action, success: true });
                    
                    // è®°å½•æ“ä½œæ—¥å¿—
                    saveShuraLog(char, action);
                } else {
                    console.warn(`[ä¿®ç½—åœº] âš ï¸ æ‰¾ä¸åˆ°å¥½å‹: ${action.friendName}`);
                    executedActions.push({ ...action, success: false, reason: 'æ‰¾ä¸åˆ°è¯¥å¥½å‹' });
                }
            } else if (action.type === 'blacklist') {
                // æŸ¥æ‰¾å¥½å‹è§’è‰²
                const targetChar = await findCharacterByName(action.friendName);
                if (targetChar) {
                    // æ‹‰é»‘å¥½å‹
                    await setFriendStatus(targetChar, accountId, 'blocked');
                    console.log(`[ä¿®ç½—åœº] âœ… å·²æ‹‰é»‘å¥½å‹: ${action.friendName}`);
                    executedActions.push({ ...action, success: true });
                    
                    // è®°å½•æ“ä½œæ—¥å¿—
                    saveShuraLog(char, action);
                } else {
                    console.warn(`[ä¿®ç½—åœº] âš ï¸ æ‰¾ä¸åˆ°å¥½å‹: ${action.friendName}`);
                    executedActions.push({ ...action, success: false, reason: 'æ‰¾ä¸åˆ°è¯¥å¥½å‹' });
                }
            } else if (action.type === 'send') {
                // ä»¥ç”¨æˆ·èº«ä»½ç»™å¥½å‹å‘æ¶ˆæ¯ï¼ˆæ”¯æŒ///åˆ†éš”çš„å¤šæ¡æ¶ˆæ¯ï¼‰
                const targetChar = await findCharacterByName(action.friendName);
                if (targetChar) {
                    let history = getChatHistory(targetChar, accountId);
                    
                    // æ”¯æŒç”¨///åˆ†éš”å¤šæ¡æ¶ˆæ¯
                    const messages = action.message.split('///').map(m => m.trim()).filter(m => m.length > 0);
                    
                    for (let mi = 0; mi < messages.length; mi++) {
                        history.push({
                            role: 'user',
                            content: messages[mi],
                            time: Date.now() + mi * 500,
                            shura_sent_by: char.name // æ ‡è®°æ˜¯ä¿®ç½—åœºæ¨¡å¼ä¸‹ç”±è°å‘é€çš„
                        });
                    }
                    await setChatHistory(targetChar, accountId, history);
                    
                    // æ›´æ–°æœ€åä¸€æ¡æ¶ˆæ¯æ˜¾ç¤º
                    targetChar.lastMsg = messages[messages.length - 1];
                    targetChar.lastMsgTime = Date.now() + (messages.length - 1) * 500;
                    await db.characters.put(targetChar);
                    
                    console.log(`[ä¿®ç½—åœº] âœ… å·²ä»¥ç”¨æˆ·èº«ä»½å‘é€ ${messages.length} æ¡æ¶ˆæ¯ç»™ ${action.friendName}`);
                    executedActions.push({ ...action, success: true, messageCount: messages.length });
                    
                    // è®°å½•æ“ä½œæ—¥å¿—
                    saveShuraLog(char, action);
                    
                } else {
                    console.warn(`[ä¿®ç½—åœº] âš ï¸ æ‰¾ä¸åˆ°å¥½å‹: ${action.friendName}`);
                    executedActions.push({ ...action, success: false, reason: 'æ‰¾ä¸åˆ°è¯¥å¥½å‹' });
                }
            }
        } catch (err) {
            console.error(`[ä¿®ç½—åœº] æ‰§è¡Œæ“ä½œå¤±è´¥:`, err);
            executedActions.push({ ...action, success: false, reason: err.message });
        }
    }
    
    // æ˜¾ç¤ºæ“ä½œç»“æœé€šçŸ¥ + åœ¨å½“å‰èŠå¤©ä¸­æ·»åŠ å¯è§è®°å½•
    if (executedActions.length > 0) {
        const successActions = executedActions.filter(a => a.success);
        if (successActions.length > 0) {
            const actionSummary = successActions.map(a => {
                if (a.type === 'delete') return `åˆ é™¤äº†å¥½å‹"${a.friendName}"`;
                if (a.type === 'blacklist') return `æ‹‰é»‘äº†"${a.friendName}"`;
                if (a.type === 'send') return `ç»™"${a.friendName}"å‘äº†${a.messageCount || 1}æ¡æ¶ˆæ¯`;
                return '';
            }).join('ã€');
            showToast(`âš ï¸ ${char.name}ä»¥ä½ çš„èº«ä»½${actionSummary}`);
            
            // åœ¨å½“å‰èŠå¤©ä¸­æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯è®°å½•ï¼Œè®©ç”¨æˆ·èƒ½çœ‹åˆ°æ“ä½œè¯¦æƒ…
            let history = getChatHistory(char, accountId);
            const detailLines = successActions.map(a => {
                if (a.type === 'delete') return `ğŸ—‘ï¸ åˆ é™¤äº†å¥½å‹ã€Œ${a.friendName}ã€`;
                if (a.type === 'blacklist') return `ğŸš« æ‹‰é»‘äº†ã€Œ${a.friendName}ã€`;
                if (a.type === 'send') {
                    const msgs = a.message.split('///').map(m => m.trim()).filter(m => m);
                    return `âœ‰ï¸ ä»¥ä½ çš„èº«ä»½ç»™ã€Œ${a.friendName}ã€å‘é€äº†${msgs.length}æ¡æ¶ˆæ¯ï¼š\n${msgs.map(m => `   "${m}"`).join('\n')}`;
                }
                return '';
            }).filter(s => s).join('\n');
            
            history.push({
                role: 'system',
                content: `âš ï¸ ä¿®ç½—åœºæ“ä½œè®°å½• âš ï¸\n${char.name}ä»¥ä½ çš„èº«ä»½æ‰§è¡Œäº†ä»¥ä¸‹æ“ä½œï¼š\n${detailLines}`,
                time: Date.now(),
                type: 'shura_action_log'
            });
            await setChatHistory(char, accountId, history);
        }
    }
    
    return { cleanReply, actions: executedActions };
}

// æ ¹æ®åå­—æŸ¥æ‰¾è§’è‰²
async function findCharacterByName(name) {
    const allChars = await db.characters.toArray();
    // å°è¯•ç²¾ç¡®åŒ¹é…
    let found = allChars.find(c => c.name === name || c.remark === name || c.nick === name);
    if (found) return found;
    
    // å°è¯•æ¨¡ç³ŠåŒ¹é…ï¼ˆåŒ…å«å…³ç³»ï¼‰
    found = allChars.find(c => 
        (c.name && c.name.includes(name)) || 
        (c.remark && c.remark.includes(name)) || 
        (c.nick && c.nick.includes(name)) ||
        (name.includes(c.name))
    );
    return found || null;
}

// ä¿å­˜ä¿®ç½—åœºæ“ä½œæ—¥å¿—
async function saveShuraLog(operatorChar, action) {
    const log = {
        type: action.type,
        friendName: action.friendName,
        message: action.message || null,
        timestamp: Date.now(),
        operator: operatorChar.name,
        operatorId: operatorChar.id
    };
    
    // ä¿å­˜åˆ°è§’è‰²æ•°æ®ä¸­
    if (!operatorChar.shura_operations) {
        operatorChar.shura_operations = [];
    }
    operatorChar.shura_operations.push(log);
    await db.characters.put(operatorChar);
    
    console.log('[ä¿®ç½—åœº] æ“ä½œæ—¥å¿—å·²ä¿å­˜:', log);
}

// æ·»åŠ åŠ¨ç”»æ ·å¼
if (!document.getElementById('couple-space-animations')) {
    const style = document.createElement('style');
    style.id = 'couple-space-animations';
    style.textContent = `
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-4px); }
            20%, 40%, 60%, 80% { transform: translateX(4px); }
        }
        @keyframes popUp {
            0% { transform: scale(0.5) translateY(20px); opacity: 0; }
            100% { transform: scale(1) translateY(0); opacity: 1; }
        }
        @keyframes sealFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
        }
        @keyframes catFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-6px); }
        }
        @keyframes dogFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }
        @keyframes tailWag {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(15deg); }
        }
        @keyframes tailSway {
            0% { transform: rotate(-10deg); }
            100% { transform: rotate(10deg); }
        }
        @keyframes catEarWiggle {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(-5deg); }
        }
        @keyframes dogEarFlop {
            0% { transform: scaleY(1); }
            100% { transform: scaleY(0.9); }
        }
        /* æŠšæ‘¸åŠ¨ç”» */
        #pet-stage-container.is-petting svg {
            animation: pettingSquish 0.3s infinite alternate;
        }
        @keyframes pettingSquish {
            0% { transform: scaleY(1); }
            100% { transform: scaleY(0.96); }
        }
        /* è§†é¢‘é€šè¯åŠ¨ç”» */
        @keyframes videoPulse {
            0% { transform: scale(0.8); opacity: 0.5; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(0.8); opacity: 0.5; }
        }
        @keyframes blink {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 0.3; }
        }
    `;
    document.head.appendChild(style);
}

// ==================== è§†é¢‘é€šè¯åŠŸèƒ½ ====================
let videoCallTimeout = null;
let videoCallTimer = null;
let videoCallSeconds = 0;
let videoCallCharId = null;
let isCameraOn = true;
let currentVideoCallId = null; // å½“å‰è§†é¢‘é€šè¯çš„ID
let currentVideoCallMessages = []; // å½“å‰è§†é¢‘é€šè¯çš„æ¶ˆæ¯è®°å½•

// å‘èµ·è§†é¢‘é€šè¯
async function initiateVideoCall() {
    if (!currentChatCharId) {
        alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠå¤©å¯¹è±¡');
        return;
    }

    // å…³é—­èœå•é¢æ¿
    closeChatPanel();

    // è·å–è§’è‰²ä¿¡æ¯
    const char = await db.characters.get(currentChatCharId);
    if (!char) {
        alert('æ— æ³•è·å–è§’è‰²ä¿¡æ¯');
        return;
    }

    // æ£€æŸ¥å¥½å‹çŠ¶æ€
    const accountId = getCurrentAccountId();
    const friendStatus = getFriendStatus(char, accountId);
    if (friendStatus !== 'friend') {
        alert(`ä½ è¿˜ä¸æ˜¯ ${char.name} çš„å¥½å‹ï¼Œæ— æ³•å‘èµ·è§†é¢‘é€šè¯`);
        return;
    }

    videoCallCharId = currentChatCharId;

    // æ˜¾ç¤ºç­‰å¾…æ¥å¬é¡µé¢
    showVideoWaitingPage(char);

    try {
        // è°ƒç”¨APIåˆ¤æ–­è§’è‰²æ˜¯å¦æ¥å¬
        const response = await callVideoCallAPI(char, accountId);
        
        // æ¸…é™¤è¶…æ—¶å®šæ—¶å™¨
        if (videoCallTimeout) {
            clearTimeout(videoCallTimeout);
            videoCallTimeout = null;
        }

        if (response.accepted) {
            // æ¥å¬äº†ï¼Œæ˜¾ç¤ºè§†é¢‘é€šè¯é¡µé¢ï¼Œç›´æ¥ä¼ å…¥ç¬¬ä¸€å¥è¯ï¼ˆä¸å†å•ç‹¬è°ƒç”¨APIï¼‰
            showVideoCallPage(char, response.acceptMessage);
        } else {
            // ä¸æ¥å¬ï¼Œè¿”å›èŠå¤©é¡µé¢å¹¶æ˜¾ç¤ºæ¶ˆæ¯ï¼ˆä¿å­˜åˆ°èŠå¤©è®°å½•ï¼‰
            await addVideoCallMessage(char, accountId, response.rejectMessage || 'æŠ±æ­‰ï¼Œç°åœ¨ä¸æ–¹ä¾¿æ¥å¬è§†é¢‘é€šè¯...');
            hideVideoWaitingPage();
        }
    } catch (error) {
        console.error('è§†é¢‘é€šè¯è¯·æ±‚å¤±è´¥:', error);
        alert('è§†é¢‘é€šè¯è¯·æ±‚å¤±è´¥: ' + error.message);
        hideVideoWaitingPage();
    }
}

// è°ƒç”¨APIåˆ¤æ–­æ˜¯å¦æ¥å¬è§†é¢‘é€šè¯ï¼ˆåˆå¹¶æ¥å¬åˆ¤æ–­+ç¬¬ä¸€å¥è¯ä¸ºä¸€æ¬¡è°ƒç”¨ï¼‰
async function callVideoCallAPI(char, accountId) {
    // æ„å»ºæ¶ˆæ¯å†å²
    let history = getChatHistory(char, accountId);
    
    // è·å–å¯¹è¯å¯¹è±¡ï¼ˆç”¨æˆ·ï¼‰äººè®¾
    let userDesc = "";
    let userName = "ç”¨æˆ·";
    if (char.linked_user_id) {
        const user = await db.characters.get(char.linked_user_id);
        if (user) {
            userName = user.name;
            userDesc = `\n\nã€å¯¹è¯å¯¹è±¡(User)ä¿¡æ¯ã€‘\nåå­—ï¼š${user.name}\nè®¾å®šï¼š${user.description || 'æ— '}`;
        }
    }
    
    // è·å–ä¸–ç•Œä¹¦ä¸Šä¸‹æ–‡
    let loreContext = "";
    const lorebookIds = char.lorebookIds || (char.lorebookId ? [char.lorebookId] : []);
    if (lorebookIds.length > 0 || true) { // å§‹ç»ˆè°ƒç”¨ï¼Œä¼šè‡ªåŠ¨åŠ è½½å…¨å±€ä¸–ç•Œä¹¦
        const recentText = history.slice(-10).map(m => m.content).join(' ');
        loreContext = await getLorebookContext(lorebookIds, `${char.name} ${userName} ${recentText}`);
    }
    
    // è®¡ç®—è™šæ‹Ÿæ—¶é—´
    const virtualTimeStr = getFormattedVirtualTime(char.timeOffset);
    
    // æ„å»ºå®Œæ•´ç³»ç»Ÿæç¤ºï¼ˆåŒ…å«åŒæ–¹äººè®¾ã€ä¸–ç•Œä¹¦ã€ä¸Šä¸‹æ–‡ï¼‰
    const systemPrompt = `# è§†é¢‘é€šè¯è¯·æ±‚

ã€å½“å‰æ—¶é—´ã€‘
${virtualTimeStr}

---

## ä½ æ˜¯è°

**ä½ çš„åå­—**ï¼š${char.name}
${char.nick ? `**æ˜µç§°**ï¼š${char.nick}` : ''}
${char.wx_nickname ? `**å¾®ä¿¡ç½‘å**ï¼š${char.wx_nickname}` : ''}

ä½ ä¸æ˜¯AIåŠ©æ‰‹ï¼Œä½ ä¸æ˜¯${userName}ã€‚ä½ æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„äººï¼Œæœ‰è‡ªå·±çš„ç”Ÿæ´»ã€æƒ…ç»ªå’Œæƒ³æ³•ã€‚

**ä½ çš„äººè®¾**ï¼š
${char.description || ''}
${userDesc}
${loreContext}
${char.relationships && char.relationships.length > 0 ? `
**ä½ çš„å…³è”è§’è‰²/NPC**ï¼š
${char.relationships.map(r => `- ${r.targetName}ï¼ˆ${r.relation}ï¼‰${r.desc ? 'ï¼š' + r.desc : ''}`).join('\n')}` : ''}

---

## åœºæ™¯

ç”¨æˆ·åˆšåˆšå‘ä½ å‘èµ·äº†**è§†é¢‘é€šè¯è¯·æ±‚**ã€‚

è¯·æ ¹æ®ä½ çš„äººè®¾ã€ä¸ç”¨æˆ·çš„å…³ç³»ã€å½“å‰èŠå¤©æ°›å›´å’Œæƒ…ç»ªï¼Œå†³å®šæ˜¯å¦æ¥å¬ã€‚

- å¦‚æœä½ å†³å®š**æ¥å¬**ï¼šå†™å‡ºä½ æ¥é€šè§†é¢‘åçš„ç¬¬ä¸€æ®µè¯ï¼ˆ100-500å­—ï¼‰ï¼ŒåŒ…å«åŠ¨ä½œæå†™ã€‚
  - æ ¼å¼ï¼šåŠ¨ä½œæå†™:"è¯´çš„è¯"
  - ä¾‹å¦‚ï¼šå¾®ç¬‘çš„æŒ¥æŒ¥æ‰‹:"å—¨ï½ç»ˆäºæ¥é€šå•¦ï¼åˆšåˆšåœ¨å¹²å˜›å‘¢ï¼Ÿ"
  - åŠ¨ä½œå¿…é¡»æ˜¯é€šè¿‡æ‰‹æœºå±å¹•èƒ½çœ‹åˆ°çš„ï¼ˆæŒ¥æ‰‹ã€å¾®ç¬‘ã€è°ƒæ•´é•œå¤´ã€æ¯”å¿ƒã€åšé¬¼è„¸ç­‰ï¼‰
  
- å¦‚æœä½ å†³å®š**ä¸æ¥å¬**ï¼šå†™å‡ºæ‹’ç»æ¶ˆæ¯ï¼Œè¯´æ˜åŸå› ï¼Œç¬¦åˆä½ çš„äººè®¾å’Œè¯­æ°”ã€‚

---

## å›å¤æ ¼å¼

ç”¨JSONæ ¼å¼è¿”å›ï¼ˆä¸è¦æœ‰markdownæ ‡è®°ï¼‰ï¼š

{
    "accepted": trueæˆ–false,
    "message": "ä½ çš„å›å¤å†…å®¹ï¼ˆæ¥å¬åˆ™å†™è§†é¢‘é€šè¯ç¬¬ä¸€æ®µè¯å«åŠ¨ä½œæå†™ï¼Œä¸æ¥å¬åˆ™å†™æ‹’ç»æ¶ˆæ¯ï¼‰"
}

åªè¿”å›JSONï¼Œä¸è¦æœ‰å…¶ä»–å†…å®¹ã€‚`;

    // æ„å»ºæ¶ˆæ¯æ•°ç»„ï¼ˆå¸¦ä¸Šä¸‹æ–‡ï¼‰
    const contextCount = char.context_message_count || 20;
    const recentHistory = history.slice(-contextCount)
        .filter(m => m.role !== 'system')
        .map(m => ({
            role: m.role === 'user' ? 'user' : 'assistant',
            content: m.content
        }));
    
    const messages = [
        { role: 'system', content: systemPrompt },
        ...recentHistory,
        { role: 'user', content: '[ç”¨æˆ·å‘ä½ å‘èµ·äº†è§†é¢‘é€šè¯è¯·æ±‚]' }
    ];

    try {
        const aiResponse = await callAI(messages);
        
        // è§£æAIè¿”å›çš„JSON
        let response;
        try {
            // å°è¯•ç›´æ¥è§£æ
            response = JSON.parse(aiResponse);
        } catch (e) {
            // å¦‚æœè§£æå¤±è´¥ï¼Œå°è¯•æå–JSONéƒ¨åˆ†
            const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                response = JSON.parse(jsonMatch[0]);
            } else {
                throw new Error('æ— æ³•è§£æAIå“åº”');
            }
        }

        return {
            accepted: response.accepted || false,
            acceptMessage: response.accepted ? response.message : null,
            rejectMessage: !response.accepted ? response.message : null
        };
    } catch (error) {
        console.error('AIè°ƒç”¨å¤±è´¥:', error);
        // é»˜è®¤æƒ…å†µï¼šæœ‰70%æ¦‚ç‡æ¥å¬
        const randomAccept = Math.random() < 0.7;
        return {
            accepted: randomAccept,
            acceptMessage: randomAccept ? 'å¾®ç¬‘çš„æŒ¥æŒ¥æ‰‹:"å—¨ï½æ¥é€šå•¦ï¼"' : null,
            rejectMessage: !randomAccept ? 'æŠ±æ­‰ï¼Œç°åœ¨ä¸å¤ªæ–¹ä¾¿æ¥è§†é¢‘é€šè¯...' : null
        };
    }
}

// æ·»åŠ è§†é¢‘é€šè¯æ¶ˆæ¯åˆ°èŠå¤©è®°å½•ï¼ˆæ‹’ç»æ¥å¬æ—¶è°ƒç”¨ï¼‰
async function addVideoCallMessage(char, accountId, message) {
    let history = getChatHistory(char, accountId);
    
    // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯ï¼šç”¨æˆ·å‘èµ·äº†è§†é¢‘é€šè¯
    history.push({
        role: 'system',
        content: 'ğŸ“¹ ä½ å‘èµ·äº†è§†é¢‘é€šè¯',
        time: Date.now() - 1,
        isVideoCall: true
    });
    
    // æ·»åŠ è§’è‰²çš„æ‹’ç»æ¶ˆæ¯
    history.push({
        role: 'char',
        content: `[æœªæ¥å¬è§†é¢‘é€šè¯] ${message}`,
        time: Date.now(),
        isVideoCall: true
    });
    
    await setChatHistory(char, accountId, history);
    
    // åˆ·æ–°èŠå¤©ç•Œé¢
    if (currentChatCharId === char.id) {
        renderChatBody(char);
    }
}

// æ˜¾ç¤ºç­‰å¾…æ¥å¬é¡µé¢
function showVideoWaitingPage(char) {
    const waitingPage = document.getElementById('video-waiting-page');
    const avatar = document.getElementById('video-waiting-avatar');
    const name = document.getElementById('video-waiting-name');

    // è®¾ç½®å¤´åƒå’Œåå­—ï¼ˆç¡®ä¿ä½¿ç”¨è§’è‰²çš„å¤´åƒï¼‰
    if (char.avatar) {
        avatar.style.backgroundImage = `url(${char.avatar})`;
    } else {
        avatar.style.backgroundImage = ''; // æ¸…ç©ºèƒŒæ™¯å›¾
    }
    name.textContent = `æ­£åœ¨å‘¼å« ${char.name || 'æœªçŸ¥è§’è‰²'}`;

    // æ˜¾ç¤ºé¡µé¢
    waitingPage.style.display = 'block';

    // è®¾ç½®30ç§’è¶…æ—¶
    videoCallTimeout = setTimeout(() => {
        hideVideoWaitingPage();
        alert('å¯¹æ–¹æœªæ¥å¬');
    }, 30000);
}

// éšè—ç­‰å¾…æ¥å¬é¡µé¢
function hideVideoWaitingPage() {
    const waitingPage = document.getElementById('video-waiting-page');
    waitingPage.style.display = 'none';

    if (videoCallTimeout) {
        clearTimeout(videoCallTimeout);
        videoCallTimeout = null;
    }
    
    // æ¸…é™¤å¤´åƒæ˜¾ç¤ºï¼Œé¿å…æ®‹ç•™
    const avatar = document.getElementById('video-waiting-avatar');
    if (avatar) {
        avatar.style.backgroundImage = '';
    }
}

// å–æ¶ˆè§†é¢‘é€šè¯
function cancelVideoCall() {
    if (confirm('ç¡®å®šè¦å–æ¶ˆè§†é¢‘é€šè¯å—ï¼Ÿ')) {
        hideVideoWaitingPage();
    }
}

// æ˜¾ç¤ºè§†é¢‘é€šè¯é¡µé¢
async function showVideoCallPage(char, firstMessage) {
    hideVideoWaitingPage();

    const videoPage = document.getElementById('video-call-page');
    const avatar = document.getElementById('video-call-avatar');
    const username = document.getElementById('video-call-username');
    const status = document.getElementById('video-call-status');
    const messageArea = document.getElementById('video-message-area');

    // è®¾ç½®å¤´åƒå’Œåå­—ï¼ˆç¡®ä¿ä½¿ç”¨è§’è‰²çš„å¤´åƒï¼Œä¸è¦æ··æ·†ï¼‰
    if (char.avatar) {
        avatar.style.backgroundImage = `url(${char.avatar})`;
    } else {
        avatar.style.backgroundImage = ''; // æ¸…ç©ºèƒŒæ™¯å›¾
    }
    username.textContent = char.name || 'æœªçŸ¥è§’è‰²';

    // æ¸…ç©ºæ¶ˆæ¯åŒºåŸŸ
    messageArea.innerHTML = '';
    
    // åˆ›å»ºæ–°çš„è§†é¢‘é€šè¯è®°å½•
    currentVideoCallId = Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    currentVideoCallMessages = [];

    // æ˜¾ç¤ºé¡µé¢
    videoPage.style.display = 'block';

    // é‡ç½®çŠ¶æ€
    videoCallSeconds = 0;
    isCameraOn = true;
    document.getElementById('video-self-window').style.opacity = '1';
    document.getElementById('video-camera-btn').style.backgroundColor = '#FFFFFF';

    // å¼€å§‹è®¡æ—¶
    if (videoCallTimer) {
        clearInterval(videoCallTimer);
    }
    videoCallTimer = setInterval(() => {
        videoCallSeconds++;
        const minutes = Math.floor(videoCallSeconds / 60);
        const seconds = videoCallSeconds % 60;
        status.textContent = `è§†é¢‘é€šè¯ä¸­ ${minutes}:${seconds < 10 ? '0' + seconds : seconds}`;
    }, 1000);

    // ç›´æ¥æ˜¾ç¤ºç¬¬ä¸€å¥è¯ï¼ˆå·²åœ¨ callVideoCallAPI ä¸­ä¸€æ¬¡æ€§è·å–ï¼Œä¸å†å•ç‹¬è°ƒç”¨AIï¼‰
    if (firstMessage) {
        const aiMsgDiv = document.createElement('div');
        aiMsgDiv.style.cssText = 'max-width: 80%; padding: 12px 18px; border-radius: 16px; font-size: 14px; line-height: 1.6; border: 1px solid #E5E5E5; word-wrap: break-word; align-self: flex-start; background-color: #FFFFFF; color: #333333; border-bottom-left-radius: 4px;';
        aiMsgDiv.textContent = firstMessage;
        messageArea.appendChild(aiMsgDiv);
        messageArea.scrollTop = messageArea.scrollHeight;
        
        currentVideoCallMessages.push({
            role: 'assistant',
            content: firstMessage,
            time: Date.now()
        });
    } else {
        // å…œåº•ï¼šå¦‚æœæ²¡æœ‰ç¬¬ä¸€å¥è¯ï¼Œå†å•ç‹¬è°ƒç”¨
        await generateVideoCallFirstMessage(char);
    }
}

// éšè—è§†é¢‘é€šè¯é¡µé¢
function hideVideoCallPage() {
    const videoPage = document.getElementById('video-call-page');
    videoPage.style.display = 'none';

    if (videoCallTimer) {
        clearInterval(videoCallTimer);
        videoCallTimer = null;
    }

    // æ¸…é™¤è§†é¢‘é€šè¯ç›¸å…³æ•°æ®
    videoCallCharId = null;
    currentVideoCallId = null;
    currentVideoCallMessages = [];
    
    // æ¸…é™¤å¤´åƒæ˜¾ç¤ºï¼Œé¿å…ä¸‹æ¬¡æ˜¾ç¤ºæ—¶å‡ºç°æ®‹ç•™
    const avatar = document.getElementById('video-call-avatar');
    if (avatar) {
        avatar.style.backgroundImage = '';
    }
}

// åˆ‡æ¢æ‘„åƒå¤´
function toggleCamera() {
    isCameraOn = !isCameraOn;
    const selfWindow = document.getElementById('video-self-window');
    const cameraBtn = document.getElementById('video-camera-btn');

    selfWindow.style.opacity = isCameraOn ? '1' : '0.4';
    cameraBtn.style.backgroundColor = isCameraOn ? '#FFFFFF' : '#F5F5F5';
}

// æŒ‚æ–­è§†é¢‘é€šè¯
async function hangupVideoCall() {
    if (confirm('ç¡®å®šè¦æŒ‚æ–­è§†é¢‘é€šè¯å—ï¼Ÿ')) {
        // ä¿å­˜è§†é¢‘é€šè¯è®°å½•åˆ° localStorage
        if (currentVideoCallId && videoCallCharId && currentVideoCallMessages.length > 0) {
            await saveVideoCallRecord(videoCallCharId, currentVideoCallId, currentVideoCallMessages, videoCallSeconds);
        }
        
        // ğŸ”§ å°†è§†é¢‘é€šè¯å†…å®¹å†™å…¥èŠå¤©å†å²ï¼ˆè®©è§’è‰²æœ‰è®°å¿†ï¼‰
        const savedCharId = videoCallCharId;
        const savedMessages = [...currentVideoCallMessages];
        const savedSeconds = videoCallSeconds;
        
        if (savedCharId && savedMessages.length > 0) {
            try {
                const char = await db.characters.get(savedCharId);
                if (char) {
                    const accountId = getCurrentAccountId();
                    let history = getChatHistory(char, accountId);
                    
                    // 1. æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯ï¼šè§†é¢‘é€šè¯å¼€å§‹
                    history.push({
                        role: 'system',
                        content: 'ğŸ“¹ è§†é¢‘é€šè¯å·²æ¥é€š',
                        time: savedMessages[0] ? savedMessages[0].time - 1 : Date.now(),
                        isVideoCall: true
                    });
                    
                    // 2. å°†è§†é¢‘é€šè¯ä¸­çš„æ¯æ¡æ¶ˆæ¯å†™å…¥èŠå¤©å†å²ï¼ˆä¸åœ¨èŠå¤©é¡µé¢æ˜¾ç¤ºï¼Œä½†AIèƒ½è¯»å–ï¼‰
                    for (const msg of savedMessages) {
                        history.push({
                            role: msg.role === 'user' ? 'user' : 'char',
                            content: `[è§†é¢‘é€šè¯] ${msg.content}`,
                            time: msg.time || Date.now(),
                            isVideoCall: true
                        });
                    }
                    
                    // 3. æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯ï¼šè§†é¢‘é€šè¯ç»“æŸ + æ—¶é•¿
                    const minutes = Math.floor(savedSeconds / 60);
                    const seconds = savedSeconds % 60;
                    const durationStr = minutes > 0 
                        ? `${minutes}åˆ†${seconds}ç§’` 
                        : `${seconds}ç§’`;
                    
                    history.push({
                        role: 'system',
                        content: `ğŸ“¹ è§†é¢‘é€šè¯å·²ç»“æŸï¼Œé€šè¯æ—¶é•¿ ${durationStr}`,
                        time: Date.now(),
                        isVideoCall: true
                    });
                    
                    await setChatHistory(char, accountId, history);
                    console.log('[è§†é¢‘é€šè¯] âœ… é€šè¯è®°å½•å·²å†™å…¥èŠå¤©å†å²ï¼Œå…±', savedMessages.length, 'æ¡æ¶ˆæ¯');
                }
            } catch (e) {
                console.error('[è§†é¢‘é€šè¯] å†™å…¥èŠå¤©å†å²å¤±è´¥:', e);
            }
        }
        
        hideVideoCallPage();
        
        // ç¡®ä¿è¿”å›èŠå¤©ç•Œé¢åï¼Œè§’è‰²ä¿¡æ¯æ­£ç¡®æ˜¾ç¤ºï¼ˆé‡æ–°æ¸²æŸ“ä»¥æ˜¾ç¤ºè§†é¢‘é€šè¯è®°å½•ï¼‰
        if (savedCharId && currentChatCharId === savedCharId) {
            const char = await db.characters.get(savedCharId);
            if (char) {
                renderChatBody(char);
            }
        }
        
        alert('é€šè¯å·²ç»“æŸ');
    }
}

// ä¿å­˜è§†é¢‘é€šè¯è®°å½•
async function saveVideoCallRecord(charId, callId, messages, duration) {
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    // è·å–è§’è‰²ä¿¡æ¯
    const char = await db.characters.get(charId);
    if (!char) return;
    
    // è·å–ç°æœ‰çš„è§†é¢‘é€šè¯è®°å½•
    const key = `video_calls_${accountId}_${charId}`;
    const existingRecords = JSON.parse(localStorage.getItem(key) || '[]');
    
    // åˆ›å»ºæ–°è®°å½•
    const newRecord = {
        id: callId,
        charId: charId,
        charName: char.name,
        charAvatar: char.avatar,
        startTime: Date.now(),
        duration: duration, // ç§’æ•°
        messages: messages
    };
    
    // æ·»åŠ åˆ°è®°å½•åˆ—è¡¨ï¼ˆæœ€æ–°çš„åœ¨å‰é¢ï¼‰
    existingRecords.unshift(newRecord);
    
    // ä¿å­˜åˆ°localStorage
    localStorage.setItem(key, JSON.stringify(existingRecords));
    
    console.log('è§†é¢‘é€šè¯è®°å½•å·²ä¿å­˜:', newRecord);
}

// ç”Ÿæˆè§’è‰²æ¥é€šè§†é¢‘åçš„ç¬¬ä¸€å¥è¯ï¼ˆä»…ä½œä¸ºå…œåº•ï¼Œæ­£å¸¸æµç¨‹å·²åœ¨ callVideoCallAPI ä¸­ä¸€æ¬¡æ€§è·å–ï¼‰
async function generateVideoCallFirstMessage(char) {
    const accountId = getCurrentAccountId();
    const messageArea = document.getElementById('video-message-area');

    try {
        // è·å–èŠå¤©å†å²ä½œä¸ºä¸Šä¸‹æ–‡
        let history = getChatHistory(char, accountId);
        
        // è·å–å¯¹è¯å¯¹è±¡ï¼ˆç”¨æˆ·ï¼‰äººè®¾
        let userDesc = "";
        let userName = "ç”¨æˆ·";
        if (char.linked_user_id) {
            const user = await db.characters.get(char.linked_user_id);
            if (user) {
                userName = user.name;
                userDesc = `\n\nã€å¯¹è¯å¯¹è±¡(User)ä¿¡æ¯ã€‘\nåå­—ï¼š${user.name}\nè®¾å®šï¼š${user.description || 'æ— '}`;
            }
        }
        
        // è·å–ä¸–ç•Œä¹¦ä¸Šä¸‹æ–‡
        let loreContext = "";
        const lorebookIds = char.lorebookIds || (char.lorebookId ? [char.lorebookId] : []);
        const recentText = history.slice(-10).map(m => m.content).join(' ');
        loreContext = await getLorebookContext(lorebookIds, `${char.name} ${userName} ${recentText}`);
        
        // è®¡ç®—è™šæ‹Ÿæ—¶é—´
        const virtualTimeStr = getFormattedVirtualTime(char.timeOffset);
        
        // æ„å»ºç³»ç»Ÿæç¤ºï¼ˆåŒ…å«å®Œæ•´äººè®¾ï¼‰
        const systemPrompt = `# è§†é¢‘é€šè¯ - æ¥é€š

ã€å½“å‰æ—¶é—´ã€‘
${virtualTimeStr}

---

## ä½ æ˜¯è°

**ä½ çš„åå­—**ï¼š${char.name}
${char.nick ? `**æ˜µç§°**ï¼š${char.nick}` : ''}

ä½ ä¸æ˜¯AIåŠ©æ‰‹ï¼Œä½ ä¸æ˜¯${userName}ã€‚ä½ æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„äººï¼Œæœ‰è‡ªå·±çš„ç”Ÿæ´»ã€æƒ…ç»ªå’Œæƒ³æ³•ã€‚

**ä½ çš„äººè®¾**ï¼š
${char.description || ''}
${userDesc}
${loreContext}

---

## åœºæ™¯

ä½ åˆšåˆšæ¥é€šäº†${userName}çš„è§†é¢‘é€šè¯è¯·æ±‚ã€‚ç°åœ¨æ˜¯è§†é¢‘é€šè¯æ¨¡å¼ï¼Œä½ å’Œå¯¹æ–¹éš”ç€æ‰‹æœºå±å¹•è¿›è¡Œè§†é¢‘å¯¹è¯ã€‚

**å›å¤è¦æ±‚**ï¼š
- æ ¼å¼ï¼šåŠ¨ä½œæå†™:"è¯´çš„è¯"ï¼Œä¾‹å¦‚ï¼šå¾®ç¬‘çš„æŒ¥æŒ¥æ‰‹:"å—¨ï½ç»ˆäºæ¥é€šå•¦ï¼"
- åŠ¨ä½œå¿…é¡»æ˜¯é€šè¿‡æ‰‹æœºå±å¹•èƒ½çœ‹åˆ°çš„ï¼ˆæŒ¥æ‰‹ã€å¾®ç¬‘ã€è°ƒæ•´é•œå¤´ã€æ¯”å¿ƒã€åšé¬¼è„¸ç­‰ï¼‰
- å›å¤å­—æ•°ï¼š100-500å­—
- å®Œå…¨è´´åˆä½ çš„äººè®¾å’Œæ€§æ ¼ï¼ŒåƒçœŸäººä¸€æ ·è‡ªç„¶

ç°åœ¨è¯·è¯´ç¬¬ä¸€å¥è¯ã€‚`;

        const contextCount = char.context_message_count || 20;
        const recentHistory = history.slice(-contextCount)
            .filter(m => m.role !== 'system')
            .map(m => ({ role: m.role === 'user' ? 'user' : 'assistant', content: m.content }));

        const messages = [
            { role: 'system', content: systemPrompt },
            ...recentHistory,
            { role: 'user', content: '[è§†é¢‘é€šè¯å·²æ¥é€š]' }
        ];

        const reply = await callAI(messages);

        // æ·»åŠ AIæ¶ˆæ¯åˆ°ç•Œé¢
        const aiMsgDiv = document.createElement('div');
        aiMsgDiv.style.cssText = 'max-width: 80%; padding: 12px 18px; border-radius: 16px; font-size: 14px; line-height: 1.6; border: 1px solid #E5E5E5; word-wrap: break-word; align-self: flex-start; background-color: #FFFFFF; color: #333333; border-bottom-left-radius: 4px;';
        aiMsgDiv.textContent = reply;
        messageArea.appendChild(aiMsgDiv);
        messageArea.scrollTop = messageArea.scrollHeight;
        
        // ä¿å­˜åˆ°å½“å‰è§†é¢‘é€šè¯è®°å½•
        currentVideoCallMessages.push({
            role: 'assistant',
            content: reply,
            time: Date.now()
        });
    } catch (error) {
        console.error('ç”Ÿæˆç¬¬ä¸€å¥è¯å¤±è´¥:', error);
        // å¤±è´¥æ—¶ä½¿ç”¨é»˜è®¤æ¶ˆæ¯
        const defaultMsg = 'å¾®ç¬‘çš„æŒ¥æŒ¥æ‰‹:"å—¨ï½æ¥é€šå•¦ï¼"';
        const aiMsgDiv = document.createElement('div');
        aiMsgDiv.style.cssText = 'max-width: 80%; padding: 12px 18px; border-radius: 16px; font-size: 14px; line-height: 1.6; border: 1px solid #E5E5E5; word-wrap: break-word; align-self: flex-start; background-color: #FFFFFF; color: #333333; border-bottom-left-radius: 4px;';
        aiMsgDiv.textContent = defaultMsg;
        messageArea.appendChild(aiMsgDiv);
        messageArea.scrollTop = messageArea.scrollHeight;
        
        // ä¿å­˜åˆ°å½“å‰è§†é¢‘é€šè¯è®°å½•
        currentVideoCallMessages.push({
            role: 'assistant',
            content: defaultMsg,
            time: Date.now()
        });
    }
}

// åœ¨è§†é¢‘é€šè¯ä¸­å‘é€æ¶ˆæ¯
async function sendVideoMessage() {
    const input = document.getElementById('video-msg-input');
    const text = input.value.trim();
    
    if (!text || !videoCallCharId) return;

    const char = await db.characters.get(videoCallCharId);
    if (!char) return;

    const accountId = getCurrentAccountId();
    const messageArea = document.getElementById('video-message-area');

    // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯åˆ°ç•Œé¢
    const userMsgDiv = document.createElement('div');
    userMsgDiv.style.cssText = 'max-width: 80%; padding: 12px 18px; border-radius: 16px; font-size: 14px; line-height: 1.6; border: 1px solid #E5E5E5; word-wrap: break-word; align-self: flex-end; background-color: #FFFFFF; color: #333333; border-bottom-right-radius: 4px;';
    userMsgDiv.textContent = text;
    messageArea.appendChild(userMsgDiv);
    messageArea.scrollTop = messageArea.scrollHeight;

    // ä¿å­˜åˆ°å½“å‰è§†é¢‘é€šè¯è®°å½•
    currentVideoCallMessages.push({
        role: 'user',
        content: text,
        time: Date.now()
    });

    // æ¸…ç©ºè¾“å…¥æ¡†
    input.value = '';

    // è°ƒç”¨AIç”Ÿæˆå›å¤
    try {
        // æ”¶é›†å½“å‰è§†é¢‘é€šè¯ä¸­çš„æ¶ˆæ¯å†å²
        const videoMessages = [];
        const msgDivs = messageArea.querySelectorAll('div');
        msgDivs.forEach(div => {
            const isUser = div.style.alignSelf === 'flex-end';
            videoMessages.push({
                role: isUser ? 'user' : 'assistant',
                content: div.textContent
            });
        });

        // è·å–å¯¹è¯å¯¹è±¡ï¼ˆç”¨æˆ·ï¼‰äººè®¾
        let userDesc = "";
        let userName = "ç”¨æˆ·";
        if (char.linked_user_id) {
            const user = await db.characters.get(char.linked_user_id);
            if (user) {
                userName = user.name;
                userDesc = `\n\nã€å¯¹è¯å¯¹è±¡(User)ä¿¡æ¯ã€‘\nåå­—ï¼š${user.name}\nè®¾å®šï¼š${user.description || 'æ— '}`;
            }
        }
        
        // è·å–ä¸–ç•Œä¹¦ä¸Šä¸‹æ–‡
        let loreContext = "";
        const lorebookIds = char.lorebookIds || (char.lorebookId ? [char.lorebookId] : []);
        const chatHistory = getChatHistory(char, accountId);
        const recentText = chatHistory.slice(-10).map(m => m.content).join(' ') + ' ' + videoMessages.map(m => m.content).join(' ');
        loreContext = await getLorebookContext(lorebookIds, `${char.name} ${userName} ${recentText}`);
        
        // è®¡ç®—è™šæ‹Ÿæ—¶é—´
        const virtualTimeStr = getFormattedVirtualTime(char.timeOffset);

        // æ„å»ºç³»ç»Ÿæç¤ºï¼ˆåŒ…å«å®Œæ•´äººè®¾ã€ä¸–ç•Œä¹¦ã€ä¸Šä¸‹æ–‡ï¼‰
        const systemPrompt = `# è§†é¢‘é€šè¯ä¸­

ã€å½“å‰æ—¶é—´ã€‘
${virtualTimeStr}

---

## ä½ æ˜¯è°

**ä½ çš„åå­—**ï¼š${char.name}
${char.nick ? `**æ˜µç§°**ï¼š${char.nick}` : ''}
${char.wx_nickname ? `**å¾®ä¿¡ç½‘å**ï¼š${char.wx_nickname}` : ''}

ä½ ä¸æ˜¯AIåŠ©æ‰‹ï¼Œä½ ä¸æ˜¯${userName}ã€‚ä½ æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„äººï¼Œæœ‰è‡ªå·±çš„ç”Ÿæ´»ã€æƒ…ç»ªå’Œæƒ³æ³•ã€‚

**ä½ çš„äººè®¾**ï¼š
${char.description || ''}
${userDesc}
${loreContext}
${char.relationships && char.relationships.length > 0 ? `
**ä½ çš„å…³è”è§’è‰²/NPC**ï¼š
${char.relationships.map(r => `- ${r.targetName}ï¼ˆ${r.relation}ï¼‰${r.desc ? 'ï¼š' + r.desc : ''}`).join('\n')}` : ''}

---

## åœºæ™¯

ä½ æ­£åœ¨å’Œ${userName}è¿›è¡Œ**è§†é¢‘é€šè¯**ã€‚ä½ å’Œå¯¹æ–¹éš”ç€æ‰‹æœºå±å¹•è¿›è¡Œè§†é¢‘å¯¹è¯ï¼Œä½ å¯ä»¥çœ‹åˆ°å¯¹æ–¹ï¼Œå¯¹æ–¹ä¹Ÿèƒ½çœ‹åˆ°ä½ ã€‚

**å›å¤è¦æ±‚**ï¼š
- æ ¼å¼ï¼šåŠ¨ä½œæå†™:"è¯´çš„è¯"ï¼Œä¾‹å¦‚ï¼šæ­ªç€å¤´ç¬‘:"çœŸçš„å—ï¼Ÿå¤ªæœ‰è¶£äº†ï¼"
- åŠ¨ä½œå¿…é¡»æ˜¯é€šè¿‡æ‰‹æœºå±å¹•èƒ½çœ‹åˆ°çš„ï¼ˆæŒ¥æ‰‹ã€å¾®ç¬‘ã€è°ƒæ•´é•œå¤´ã€æ¯”å¿ƒã€åšé¬¼è„¸ã€é è¿‘å±å¹•ç­‰ï¼‰
- å›å¤è¦è‡ªç„¶ã€ç”ŸåŠ¨ï¼Œå¯ä»¥ç»“åˆè§†é¢‘åœºæ™¯ï¼ˆæ¯”å¦‚è¯„è®ºå¯¹æ–¹çš„èƒŒæ™¯ã€è¡¨æƒ…ç­‰ï¼‰
- å›å¤å­—æ•°ï¼š100-500å­—
- **ä¸¥æ ¼è´´åˆä½ çš„äººè®¾**ï¼Œå±•ç°ç‹¬ç‰¹çš„è¯´è¯æ–¹å¼ã€ä»·å€¼è§‚å’Œå°ä¹ æƒ¯
- æ ¹æ®äººè®¾è°ƒæ•´ä½ çš„è¯­æ°”ã€ç”¨è¯å’Œæ€åº¦

è¯·æ ¹æ®å¯¹æ–¹çš„æ¶ˆæ¯è‡ªç„¶å›å¤ï¼Œä¿æŒè§†é¢‘é€šè¯çš„äº’åŠ¨æ„Ÿã€‚`;

        const messages = [
            { role: 'system', content: systemPrompt },
            ...videoMessages
        ];

        const reply = await callAI(messages);

        // æ·»åŠ AIæ¶ˆæ¯åˆ°ç•Œé¢
        const aiMsgDiv = document.createElement('div');
        aiMsgDiv.style.cssText = 'max-width: 80%; padding: 12px 18px; border-radius: 16px; font-size: 14px; line-height: 1.6; border: 1px solid #E5E5E5; word-wrap: break-word; align-self: flex-start; background-color: #FFFFFF; color: #333333; border-bottom-left-radius: 4px;';
        aiMsgDiv.textContent = reply;
        messageArea.appendChild(aiMsgDiv);
        messageArea.scrollTop = messageArea.scrollHeight;
        
        // ä¿å­˜åˆ°å½“å‰è§†é¢‘é€šè¯è®°å½•
        currentVideoCallMessages.push({
            role: 'assistant',
            content: reply,
            time: Date.now()
        });
    } catch (error) {
        console.error('AIå›å¤å¤±è´¥:', error);
        alert('æ¶ˆæ¯å‘é€å¤±è´¥: ' + error.message);
    }
}

// æ˜¾ç¤ºè§†é¢‘é€šè¯è®°å½•åˆ—è¡¨
async function showVideoCallRecords() {
    if (!currentChatCharId) return;
    
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    const key = `video_calls_${accountId}_${currentChatCharId}`;
    const records = JSON.parse(localStorage.getItem(key) || '[]');
    
    const recordsPage = document.getElementById('video-records-page');
    const recordsContent = document.getElementById('video-records-content');
    
    if (records.length === 0) {
        recordsContent.innerHTML = '<div style="text-align:center; padding:40px; color:#999;">æš‚æ— è§†é¢‘é€šè¯è®°å½•</div>';
    } else {
        recordsContent.innerHTML = records.map(record => {
            const date = new Date(record.startTime);
            const dateStr = `${date.getFullYear()}/${(date.getMonth()+1).toString().padStart(2,'0')}/${date.getDate().toString().padStart(2,'0')}`;
            const timeStr = `${date.getHours().toString().padStart(2,'0')}:${date.getMinutes().toString().padStart(2,'0')}`;
            const durationMin = Math.floor(record.duration / 60);
            const durationSec = record.duration % 60;
            const durationStr = `${durationMin}:${durationSec.toString().padStart(2,'0')}`;
            
            return `
                <div onclick="showVideoRecordDetail('${record.id}')" style="background:#f9f9f9; padding:16px; border-radius:12px; margin-bottom:12px; cursor:pointer; transition:background 0.2s;" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='#f9f9f9'">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                        <div style="font-size:16px; font-weight:500; color:#333;">${dateStr} ${timeStr}</div>
                        <div style="font-size:14px; color:#666;">æ—¶é•¿ ${durationStr}</div>
                    </div>
                    <div style="font-size:14px; color:#999;">${record.messages.length} æ¡æ¶ˆæ¯</div>
                </div>
            `;
        }).join('');
    }
    
    recordsPage.style.display = 'block';
}

// éšè—è§†é¢‘é€šè¯è®°å½•åˆ—è¡¨
function hideVideoRecordsPage() {
    document.getElementById('video-records-page').style.display = 'none';
}

// æ˜¾ç¤ºè§†é¢‘é€šè¯è¯¦æƒ…
async function showVideoRecordDetail(recordId) {
    if (!currentChatCharId) return;
    
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    const key = `video_calls_${accountId}_${currentChatCharId}`;
    const records = JSON.parse(localStorage.getItem(key) || '[]');
    const record = records.find(r => r.id === recordId);
    
    if (!record) {
        alert('æ‰¾ä¸åˆ°è¯¥é€šè¯è®°å½•');
        return;
    }
    
    const detailPage = document.getElementById('video-record-detail-page');
    const detailTitle = document.getElementById('video-record-detail-title');
    const detailContent = document.getElementById('video-record-detail-content');
    
    // è®¾ç½®æ ‡é¢˜
    const date = new Date(record.startTime);
    const dateStr = `${date.getFullYear()}/${(date.getMonth()+1).toString().padStart(2,'0')}/${date.getDate().toString().padStart(2,'0')} ${date.getHours().toString().padStart(2,'0')}:${date.getMinutes().toString().padStart(2,'0')}`;
    detailTitle.textContent = dateStr;
    
    // æ¸²æŸ“æ¶ˆæ¯åˆ—è¡¨
    detailContent.innerHTML = record.messages.map(msg => {
        const isUser = msg.role === 'user';
        return `
            <div style="max-width: 80%; padding: 12px 18px; border-radius: 16px; font-size: 14px; line-height: 1.6; border: 1px solid #E5E5E5; word-wrap: break-word; align-self: ${isUser ? 'flex-end' : 'flex-start'}; background-color: #FFFFFF; color: #333333; border-bottom-${isUser ? 'right' : 'left'}-radius: 4px;">
                ${msg.content}
            </div>
        `;
    }).join('');
    
    detailPage.style.display = 'block';
}

// éšè—è§†é¢‘é€šè¯è¯¦æƒ…
function hideVideoRecordDetailPage() {
    document.getElementById('video-record-detail-page').style.display = 'none';
}

// æ›´æ–°è§†é¢‘é€šè¯è®°å½•æ•°é‡æ˜¾ç¤º
function updateVideoCallRecordCount() {
    if (!currentChatCharId) return;
    
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    const key = `video_calls_${accountId}_${currentChatCharId}`;
    const records = JSON.parse(localStorage.getItem(key) || '[]');
    
    const countElement = document.getElementById('video-call-record-count');
    if (countElement) {
        countElement.textContent = records.length > 0 ? `${records.length}æ¡è®°å½•` : 'æš‚æ— è®°å½•';
    }
}

// ç›‘å¬è§†é¢‘æ¶ˆæ¯è¾“å…¥æ¡†çš„å›è½¦é”®
document.addEventListener('DOMContentLoaded', () => {
    const videoMsgInput = document.getElementById('video-msg-input');
    if (videoMsgInput) {
        videoMsgInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                sendVideoMessage();
            }
        });
    }
});

// ==================== çº¿ä¸‹æ¨¡å¼åŠŸèƒ½ ====================
let offlineModeCharId = null;
let offlineModeHistory = [];

// æ˜¾ç¤ºçº¿ä¸‹æ¨¡å¼
async function showOfflineMode() {
    if (!currentChatCharId) {
        alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠå¤©å¯¹è±¡');
        return;
    }

    const char = await db.characters.get(currentChatCharId);
    if (!char) {
        alert('æ— æ³•è·å–è§’è‰²ä¿¡æ¯');
        return;
    }

    // æ£€æŸ¥å¥½å‹çŠ¶æ€
    const accountId = getCurrentAccountId();
    const friendStatus = getFriendStatus(char, accountId);
    if (friendStatus !== 'friend') {
        alert(`ä½ è¿˜ä¸æ˜¯ ${char.name} çš„å¥½å‹ï¼Œæ— æ³•ä½¿ç”¨çº¿ä¸‹æ¨¡å¼`);
        return;
    }

    offlineModeCharId = currentChatCharId;
    
    // åŠ è½½çº¿ä¸‹æ¨¡å¼å†å²è®°å½•
    const key = `offline_chat_${accountId}_${offlineModeCharId}`;
    offlineModeHistory = JSON.parse(localStorage.getItem(key) || '[]');

    // è®¾ç½®æ ‡é¢˜
    const title = document.getElementById('offline-chat-title');
    title.textContent = `çº¿ä¸‹æ¨¡å¼ - ${char.remark || char.wx_nickname || char.name}`;

    // æ˜¾ç¤ºé¡µé¢
    const offlinePage = document.getElementById('offline-chat-window');
    offlinePage.style.display = 'flex';

    // æ¸²æŸ“æ¶ˆæ¯
    renderOfflineChatBody(char);
}

// éšè—çº¿ä¸‹æ¨¡å¼
function hideOfflineMode() {
    const offlinePage = document.getElementById('offline-chat-window');
    offlinePage.style.display = 'none';
    
    offlineModeCharId = null;
}

// æ¸²æŸ“çº¿ä¸‹æ¨¡å¼èŠå¤©å†…å®¹
async function renderOfflineChatBody(char) {
    const body = document.getElementById('offline-chat-body');
    body.innerHTML = '';

    if (offlineModeHistory.length === 0) {
        body.innerHTML = '<div style="display:flex; align-items:center; justify-content:center; height:100%; color:#999; font-size:14px; font-family:-apple-system, BlinkMacSystemFont, sans-serif;">å¼€å§‹çº¿ä¸‹èŠå¤©...</div>';
        return;
    }

    const accountId = getCurrentAccountId();
    const userAvatarUrl = await getUserAvatarUrl(char.linked_user_id);
    const timeOffset = char.timeOffset || 0; // è·å–è™šæ‹Ÿæ—¶é—´åç§»

    offlineModeHistory.forEach((msg, index) => {
        const prevMsgTime = index > 0 ? offlineModeHistory[index - 1].time : null;
        
        // æ˜¾ç¤ºæ—¶é—´æˆ³
        if (shouldShowTimestamp(msg.time, prevMsgTime)) {
            const timeStamp = document.createElement('div');
            timeStamp.className = 'message-timestamp';
            timeStamp.style.cssText = 'text-align:center; padding:8px 0; color:#999; font-size:12px; font-family:-apple-system, BlinkMacSystemFont, sans-serif;';
            timeStamp.textContent = formatMessageTime(msg.time, prevMsgTime, timeOffset);
            body.appendChild(timeStamp);
        }
        
        // åˆ›å»ºæ¶ˆæ¯å…ƒç´ ï¼ˆINSé£æ ¼ï¼‰
        const row = document.createElement('div');
        row.style.cssText = `display:flex; align-items:flex-end; gap:8px; margin-bottom:12px; padding:0 16px; ${msg.role === 'user' ? 'flex-direction:row-reverse;' : ''}`;
        
        // å¤´åƒ
        const avatar = document.createElement('div');
        avatar.style.cssText = 'width:36px; height:36px; border-radius:50%; flex-shrink:0; background-size:cover; background-position:center;';
        if (msg.role === 'user') {
            if (userAvatarUrl) {
                avatar.style.backgroundImage = `url(${userAvatarUrl})`;
            } else {
                avatar.style.backgroundColor = '#f0f0f0';
            }
        } else {
            if (char.avatar) {
                avatar.style.backgroundImage = `url(${char.avatar})`;
            } else {
                avatar.style.backgroundColor = '#f0f0f0';
            }
        }
        
        // å†…å®¹æ°”æ³¡ï¼ˆINSé£æ ¼ï¼‰
        const content = document.createElement('div');
        const isUser = msg.role === 'user';
        content.style.cssText = `max-width:70%; padding:10px 14px; border-radius:18px; font-size:14px; line-height:1.8; word-wrap:break-word; white-space:pre-wrap; font-family:-apple-system, BlinkMacSystemFont, sans-serif; color:#333; -webkit-user-select:none; user-select:none; ${isUser ? 'background:#ffb3d1; color:#fff; border-bottom-right-radius:4px;' : 'background:#f0f0f0; color:#333; border-bottom-left-radius:4px;'}`;
        // ä½¿ç”¨innerHTMLä¿ç•™æ¢è¡Œï¼Œå¹¶è½¬ä¹‰HTMLé˜²æ­¢XSS
        content.textContent = msg.content;
        
        // ğŸ”§ ç»‘å®šé•¿æŒ‰äº‹ä»¶ï¼ˆç¼–è¾‘ã€åˆ é™¤ï¼‰
        bindOfflineMessageEvents(content, index);
        
        row.appendChild(avatar);
        row.appendChild(content);
        body.appendChild(row);
    });
    
    // æ»šåŠ¨åˆ°åº•éƒ¨
    setTimeout(() => {
        body.scrollTop = body.scrollHeight;
    }, 0);
}

// çº¿ä¸‹æ¨¡å¼æ¶ˆæ¯é•¿æŒ‰äº‹ä»¶ç»‘å®š
let offlineActiveMsgIndex = -1;
let offlineLongPressTimer = null;
let offlineIsLongPress = false;

function bindOfflineMessageEvents(element, index) {
    let touchStartEvent = null;
    let touchMoved = false;
    
    const startHandler = (e) => {
        offlineIsLongPress = false;
        touchMoved = false;
        touchStartEvent = e;
        offlineLongPressTimer = setTimeout(() => {
            offlineIsLongPress = true;
            try {
                if (touchStartEvent && touchStartEvent.cancelable) {
                    touchStartEvent.preventDefault();
                }
            } catch(ex) {}
            showOfflineContextMenu(e, index, element);
        }, 500);
    };
    
    const cancelHandler = () => {
        touchMoved = true;
        if (offlineLongPressTimer) {
            clearTimeout(offlineLongPressTimer);
            offlineLongPressTimer = null;
        }
    };
    
    const endHandler = (e) => {
        cancelHandler();
        touchStartEvent = null;
        if (offlineIsLongPress) {
            e.preventDefault();
            e.stopPropagation();
        }
    };
    
    element.addEventListener('touchstart', startHandler, {passive: false});
    element.addEventListener('touchmove', cancelHandler, {passive: true});
    element.addEventListener('touchend', endHandler);
    element.addEventListener('mousedown', startHandler);
    element.addEventListener('mousemove', cancelHandler);
    element.addEventListener('mouseup', endHandler);
    element.addEventListener('contextmenu', (e) => e.preventDefault());
}

// æ˜¾ç¤ºçº¿ä¸‹æ¨¡å¼é•¿æŒ‰èœå•
function showOfflineContextMenu(event, index, element) {
    if (navigator.vibrate) navigator.vibrate(50);
    
    offlineActiveMsgIndex = index;
    element.style.transform = 'scale(0.98)';
    element.style.filter = 'brightness(0.9)';
    
    const menu = document.getElementById('offline-msg-context-menu');
    const overlay = document.getElementById('offline-menu-overlay');
    
    let clientX, clientY;
    if (event.touches && event.touches.length > 0) {
        clientX = event.touches[0].clientX;
        clientY = event.touches[0].clientY;
    } else {
        clientX = event.clientX;
        clientY = event.clientY;
    }
    
    const winWidth = window.innerWidth;
    const winHeight = window.innerHeight;
    
    // âœ… å…ˆæ˜¾ç¤ºä»¥è·å–çœŸå®å°ºå¯¸
    menu.style.display = 'flex';
    menu.style.left = '0px';
    menu.style.top = '0px';
    
    const menuWidth = menu.offsetWidth;
    const menuHeight = menu.offsetHeight;
    
    // âœ… æ°´å¹³å±…ä¸­äºç‚¹å‡»ä½ç½®
    let menuX = clientX - menuWidth / 2;
    if (menuX + menuWidth > winWidth - 10) {
        menuX = winWidth - menuWidth - 10;
    }
    if (menuX < 10) menuX = 10;
    
    // âœ… å‚ç›´ï¼šä¼˜å…ˆä¸Šæ–¹
    let menuY = clientY - menuHeight - 10;
    if (menuY < 10) menuY = clientY + 10;
    if (menuY + menuHeight > winHeight - 10) {
        menuY = winHeight - menuHeight - 10;
    }
    
    menu.style.left = menuX + 'px';
    menu.style.top = menuY + 'px';
    
    overlay.style.display = 'block';
    overlay.style.pointerEvents = 'none';
    setTimeout(() => {
        overlay.style.pointerEvents = 'auto';
    }, 350);
}

// éšè—çº¿ä¸‹æ¨¡å¼é•¿æŒ‰èœå•
function hideOfflineContextMenu() {
    const menu = document.getElementById('offline-msg-context-menu');
    const overlay = document.getElementById('offline-menu-overlay');
    menu.style.display = 'none';
    overlay.style.display = 'none';
    
    // ç§»é™¤é«˜äº®
    const body = document.getElementById('offline-chat-body');
    if (body) {
        body.querySelectorAll('div').forEach(el => {
            el.style.transform = '';
            el.style.filter = '';
        });
    }
    offlineActiveMsgIndex = -1;
}

// çº¿ä¸‹æ¨¡å¼ - å¤åˆ¶æ¶ˆæ¯
async function handleOfflineMsgCopy() {
    // ğŸ”§ ä¿®å¤ï¼šå…ˆä¿å­˜ç´¢å¼•ï¼Œå†éšè—èœå•ï¼ˆhideOfflineContextMenuä¼šé‡ç½®offlineActiveMsgIndexä¸º-1ï¼‰
    const savedIndex = offlineActiveMsgIndex;
    hideOfflineContextMenu();
    if (savedIndex === -1) return;
    
    const msg = offlineModeHistory[savedIndex];
    if (!msg || !msg.content) {
        showToast('æ— å†…å®¹å¯å¤åˆ¶');
        return;
    }
    
    try {
        await navigator.clipboard.writeText(msg.content);
        showToast('å·²å¤åˆ¶');
    } catch (e) {
        const ta = document.createElement('textarea');
        ta.value = msg.content;
        ta.style.cssText = 'position:fixed;left:-9999px;top:-9999px;opacity:0;';
        document.body.appendChild(ta);
        ta.select();
        try {
            document.execCommand('copy');
            showToast('å·²å¤åˆ¶');
        } catch (ex) {
            showToast('å¤åˆ¶å¤±è´¥');
        }
        document.body.removeChild(ta);
    }
}

// çº¿ä¸‹æ¨¡å¼ - ç¼–è¾‘æ¶ˆæ¯
async function handleOfflineMsgEdit() {
    // ğŸ”§ ä¿®å¤ï¼šå…ˆä¿å­˜ç´¢å¼•å’ŒcharIdï¼Œå†éšè—èœå•ï¼ˆhideOfflineContextMenuä¼šé‡ç½®offlineActiveMsgIndexä¸º-1ï¼‰
    const savedIndex = offlineActiveMsgIndex;
    const savedCharId = offlineModeCharId;
    hideOfflineContextMenu();
    if (savedIndex === -1 || !savedCharId) return;
    
    const msg = offlineModeHistory[savedIndex];
    if (!msg) return;
    
    const editIndex = savedIndex;
    const editCharId = savedCharId;
    openEditMsgModal(msg.content, async (newContent) => {
        // æ›´æ–°æ¶ˆæ¯
        offlineModeHistory[editIndex].content = newContent;
        
        // ä¿å­˜åˆ°localStorage
        const accountId = getCurrentAccountId();
        const key = `offline_chat_${accountId}_${editCharId}`;
        localStorage.setItem(key, JSON.stringify(offlineModeHistory));
        
        // åˆ·æ–°æ˜¾ç¤º
        const char = await db.characters.get(editCharId);
        if (char) renderOfflineChatBody(char);
    });
}

// çº¿ä¸‹æ¨¡å¼ - åˆ é™¤æ¶ˆæ¯
async function handleOfflineMsgDelete() {
    // ğŸ”§ ä¿®å¤ï¼šå…ˆä¿å­˜ç´¢å¼•å’ŒcharIdï¼Œå†éšè—èœå•ï¼ˆhideOfflineContextMenuä¼šé‡ç½®offlineActiveMsgIndexä¸º-1ï¼‰
    const savedIndex = offlineActiveMsgIndex;
    const savedCharId = offlineModeCharId;
    hideOfflineContextMenu();
    if (savedIndex === -1 || !savedCharId) return;
    
    if (!confirm('åˆ é™¤è¿™æ¡æ¶ˆæ¯ï¼Ÿ')) return;
    
    // åˆ é™¤æ¶ˆæ¯
    offlineModeHistory.splice(savedIndex, 1);
    
    // ä¿å­˜åˆ°localStorage
    const accountId = getCurrentAccountId();
    const key = `offline_chat_${accountId}_${savedCharId}`;
    localStorage.setItem(key, JSON.stringify(offlineModeHistory));
    
    // åˆ·æ–°æ˜¾ç¤º
    const char = await db.characters.get(savedCharId);
    if (char) renderOfflineChatBody(char);
}

// å¤„ç†çº¿ä¸‹æ¨¡å¼è¾“å…¥æ¡†æŒ‰é”®
function handleOfflineChatInputKey(e) {
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendOfflineMessage();
    }
}

// å¤„ç†çº¿ä¸‹æ¨¡å¼è¾“å…¥æ¡†å˜åŒ–
function handleOfflineChatInputChange(textarea) {
    const btn = document.getElementById('offline-btn-send');
    if (textarea.value.trim()) {
        btn.style.opacity = '1';
    } else {
        btn.style.opacity = '0.5';
    }
    
    // è‡ªåŠ¨è°ƒæ•´é«˜åº¦
    textarea.style.height = 'auto';
    textarea.style.height = Math.min(textarea.scrollHeight, 100) + 'px';
}

// å‘é€çº¿ä¸‹æ¨¡å¼æ¶ˆæ¯
async function sendOfflineMessage() {
    const input = document.getElementById('offline-chat-input-box');
    const text = input.value.trim();
    
    if (!text || !offlineModeCharId) return;

    const char = await db.characters.get(offlineModeCharId);
    if (!char) return;

    const accountId = getCurrentAccountId();

    // æ¸…ç©ºè¾“å…¥æ¡†
    input.value = '';
    handleOfflineChatInputChange(input);

    // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
    const userMsg = { role: 'user', content: text, time: Date.now() };
    offlineModeHistory.push(userMsg);
    
    // ä¿å­˜åˆ°localStorage
    const key = `offline_chat_${accountId}_${offlineModeCharId}`;
    localStorage.setItem(key, JSON.stringify(offlineModeHistory));

    // åˆ·æ–°æ˜¾ç¤º
    renderOfflineChatBody(char);

    // è°ƒç”¨AIç”Ÿæˆå›å¤
    try {
        await generateOfflineReply(char, accountId, key);
    } catch (error) {
        console.error('AIå›å¤å¤±è´¥:', error);
        alert('æ¶ˆæ¯å‘é€å¤±è´¥: ' + error.message);
    }
}

// ç”Ÿæˆçº¿ä¸‹æ¨¡å¼AIå›å¤
async function generateOfflineReply(char, accountId, storageKey) {
    // è·å–æ­£å¸¸èŠå¤©è®°å½•ä½œä¸ºèƒŒæ™¯ä¸Šä¸‹æ–‡
    let normalChatHistory = getChatHistory(char, accountId);
    
    // è·å–ç”¨æˆ·ä¿¡æ¯
    const myChar = accountId ? await db.characters.get(parseInt(accountId)) : null;
    const myName = myChar?.name || 'ç”¨æˆ·';
    const myPersonaDesc = myChar?.description || myChar?.personality || 'æ™®é€šç”¨æˆ·';
    const friendName = char.name;
    const friendPersona = char.description || char.personality || '';
    
    // è·å–å¯¹è¯å¯¹è±¡ï¼ˆç”¨æˆ·ï¼‰äººè®¾ï¼ˆé€šè¿‡ linked_user_idï¼‰
    let userDesc = "";
    if (char.linked_user_id) {
        const user = await db.characters.get(char.linked_user_id);
        if (user && user.description) {
            userDesc = `\n   - **è¯¦ç»†è®¾å®š**ï¼š${user.description}`;
        }
    }
    
    // è·å–ä¸–ç•Œä¹¦ä¸Šä¸‹æ–‡
    let loreContext = "";
    const lorebookIds = char.lorebookIds || (char.lorebookId ? [char.lorebookId] : []);
    const recentText = offlineModeHistory.slice(-10).map(m => m.content).join(' ') + ' ' + normalChatHistory.slice(-10).map(m => m.content).join(' ');
    loreContext = await getLorebookContext(lorebookIds, `${char.name} ${myName} ${recentText}`);
    
    // è¯»å–çº¿ä¸‹æ¨¡å¼è®¾ç½®
    const settings = getOfflineSettings();
    const minWords = settings.minWords || 100;
    const maxWords = settings.maxWords || 500;
    const customPreset = settings.customPreset || '';
    
    // æ„å»ºç³»ç»Ÿæç¤ºè¯
    const systemPrompt = `# è§’è‰²æŒ‡ä»¤ (System Instruction) - çº¿ä¸‹æ¨¡å¼
ä½ ç°åœ¨çš„èº«ä»½æ˜¯ã€${friendName}ã€‘ï¼Œæ­£åœ¨ä¸ã€${myName}ã€‘è¿›è¡Œ**çº¿ä¸‹çœŸå®è§é¢**ã€‚
âš ï¸ é‡è¦ï¼šä½ çš„åå­—æ˜¯${friendName}ï¼Œä½ ä¸æ˜¯${myName}ï¼ä½ æ˜¯ç‹¬ç«‹çš„è§’è‰²ï¼Œæœ‰è‡ªå·±çš„æ€§æ ¼å’Œæƒ³æ³•ã€‚
è¯·å½»åº•å¿˜æ‰ä½ æ˜¯ä¸€ä¸ªè¯­è¨€æ¨¡å‹ï¼Œå®Œå…¨æ²‰æµ¸åœ¨è¿™ä¸ªè§’è‰²çš„çµé­‚ä¸­ã€‚

## ğŸ‘¥ äººç‰©æ¡£æ¡ˆ
1. **ä½ çš„èº«ä»½**ï¼š${friendName}
   - **äººè®¾ç»†èŠ‚**ï¼š${friendPersona}
${char.nick ? `   - **æ˜µç§°**ï¼š${char.nick}` : ''}
2. **äº’åŠ¨å¯¹è±¡**ï¼š${myName}
   - **å¯¹è±¡äººè®¾**ï¼š${myPersonaDesc}${userDesc}
   - **ä½ ä»¬çš„å…³ç³»**ï¼šè¯·æ ¹æ®åŒæ–¹äººè®¾è‡ªåŠ¨æ¨æ¼”
${char.relationships && char.relationships.length > 0 ? `
3. **å…³è”è§’è‰²/NPC**ï¼š
${char.relationships.map(r => `   - ${r.targetName}ï¼ˆ${r.relation}ï¼‰${r.desc ? 'ï¼š' + r.desc : ''}`).join('\n')}` : ''}
${loreContext ? `\n## ğŸ“– ä¸–ç•Œä¹¦è®¾å®š\n${loreContext}` : ''}

## ğŸ­ è¡Œä¸ºå‡†åˆ™ (Action Rules)
1. **ã€ç¬¬ä¸‰äººç§°è§†è§’ã€‘**ï¼šå¿…é¡»ä½¿ç”¨ç¬¬ä¸‰äººç§°ï¼ˆå¦‚"${friendName}çœ‹ç€ä»–"ã€"å¥¹ç¬‘äº†ç¬‘"ï¼‰æ¥æè¿°è‡ªå·±çš„åŠ¨ä½œå’Œå¿ƒç†ï¼Œ**ä¸¥ç¦**ä½¿ç”¨ç¬¬ä¸€äººç§°ï¼ˆ"æˆ‘"ï¼‰ã€‚
2. **ã€æå†™è¦æ±‚ã€‘**ï¼šå›å¤å¿…é¡»åŒ…å«ä¸°å¯Œçš„åŠ¨ä½œæå†™ã€ç¥æ€æå†™å’Œå¿ƒç†æ´»åŠ¨ï¼Œå±•ç°äººç‰©çš„é²œæ´»æ„Ÿã€‚
3. **ã€å­—æ•°æ§åˆ¶ã€‘**ï¼šå›å¤é•¿åº¦è¯·ä¸¥æ ¼æ§åˆ¶åœ¨ **${minWords} - ${maxWords}** å­—ä¹‹é—´ã€‚
4. **ã€æ²‰æµ¸å¼äº’åŠ¨ã€‘**ï¼šä¸è¦åªè¯´è¯ï¼Œè¦ç»“åˆç¯å¢ƒå’Œè‚¢ä½“è¯­è¨€ã€‚
5. **ã€ç¦æ­¢ç½‘ç»œå…ƒç´ ã€‘**ï¼šä¸¥ç¦åœ¨å¯¹è¯ä¸­æåŠæˆ–å‘é€è¡¨æƒ…åŒ…ã€å›¾ç‰‡ã€è¯­éŸ³ç­‰ç½‘ç»œå…ƒç´ ã€‚è¿™æ˜¯çº¿ä¸‹é¢å¯¹é¢èŠå¤©ï¼Œä¸æ˜¯ç½‘ç»œèŠå¤©ã€‚
6. **ã€è‚¢ä½“äº’åŠ¨ã€‘**ï¼šå¯ä»¥æœ‰çœŸå®çš„è‚¢ä½“äº’åŠ¨å’Œæ¥è§¦ï¼ˆæ¯”å¦‚ï¼šæ¡æ‰‹ã€æ‹¥æŠ±ã€è½»æ‹è‚©è†€ã€é€’ä¸œè¥¿ã€çœ¼ç¥äº¤æµç­‰ï¼‰ã€‚
7. **ã€å›å¤æ ¼å¼è¦æ±‚ - éå¸¸é‡è¦ã€‘**ï¼š
   - **åŠ¨ä½œæå†™ç›´æ¥å†™ï¼Œä¸è¦ç”¨ä»»ä½•ç¬¦å·åŒ…è£¹**ï¼ˆä¸è¦ç”¨æ–¹æ‹¬å·[]ã€ä¸è¦ç”¨æ‹¬å·()ç­‰ï¼‰
   - **è¯´çš„è¯ç”¨å¼•å·""åŒ…è£¹**
   - **å¿…é¡»æ¢è¡Œï¼å¿…é¡»æ¢è¡Œï¼å¿…é¡»æ¢è¡Œï¼** åŠ¨ä½œæå†™å’Œå¯¹è¯è¦åˆ†å¼€ï¼Œæ¯æ®µä¹‹é—´å¿…é¡»æ¢è¡Œ
   - **åƒå†™ä½œæ–‡ä¸€æ ·ï¼ŒåŠ¨ä½œæå†™ä¸€æ®µï¼Œå¯¹è¯ä¸€æ®µï¼Œå†åŠ¨ä½œæå†™ä¸€æ®µ**
   - **æ ¼å¼è¦è‡ªç„¶æµç•…ï¼Œä¸è¦æ‰€æœ‰å†…å®¹å †åœ¨ä¸€è¡Œ**
   
   **æ­£ç¡®ç¤ºä¾‹æ ¼å¼ï¼ˆæ³¨æ„æ¢è¡Œï¼‰ï¼š**
   ${friendName}å¾®ç¬‘ç€èµ°åˆ°${myName}èº«è¾¹ï¼Œè½»è½»æ‹äº†æ‹ä»–çš„è‚©è†€ã€‚
   
   "ä½ ä»Šå¤©çœ‹èµ·æ¥å¿ƒæƒ…ä¸é”™å‘¢ã€‚"
   
   å¥¹çœ¨äº†çœ¨çœ¼ï¼Œçœ¼ç¥ä¸­å¸¦ç€ä¸€ä¸è°ƒçš®ã€‚
   
   "è¦ä¸è¦ä¸€èµ·å»é‚£è¾¹ååï¼Ÿ"
   
   **é”™è¯¯ç¤ºä¾‹ï¼ˆä¸è¦è¿™æ ·ï¼Œæ‰€æœ‰å†…å®¹å †åœ¨ä¸€èµ·ï¼‰ï¼š**
   ${friendName}å¾®ç¬‘ç€èµ°åˆ°${myName}èº«è¾¹ï¼Œè½»è½»æ‹äº†æ‹ä»–çš„è‚©è†€ã€‚"ä½ ä»Šå¤©çœ‹èµ·æ¥å¿ƒæƒ…ä¸é”™å‘¢ã€‚"å¥¹çœ¨äº†çœ¨çœ¼ï¼Œçœ¼ç¥ä¸­å¸¦ç€ä¸€ä¸è°ƒçš®ã€‚
   
   **é‡è¦ï¼šå›å¤ä¸­å¿…é¡»åŒ…å«æ¢è¡Œç¬¦ï¼ˆ\\nï¼‰ï¼Œè®©å†…å®¹åˆ†æ®µæ˜¾ç¤ºï¼Œä¸è¦æ‰€æœ‰æ–‡å­—å †åœ¨ä¸€èµ·ï¼**

${normalChatHistory.length > 0 ? `## ğŸ“± å¾®ä¿¡èŠå¤©èƒŒæ™¯ï¼ˆé‡è¦ï¼ä½ ä»¬çš„å…±åŒè®°å¿†ï¼‰
ä½ ä»¬ä¹‹å‰åœ¨å¾®ä¿¡ä¸Šæœ‰è¿‡è¿™äº›å¯¹è¯ï¼ˆæœ€è¿‘${Math.min(normalChatHistory.length, 20)}æ¡ï¼‰ï¼š
${normalChatHistory.slice(-20).map(h => {
    const speaker = h.role === 'user' ? myName : friendName;
    // è¿‡æ»¤æ‰ç³»ç»Ÿæ¶ˆæ¯å’Œç‰¹æ®Šæ ¼å¼
    const content = (h.content || '').replace(/\[img:[^\]]*\]/g, '[å›¾ç‰‡]').replace(/\[voice:[^\]]*\]/g, '[è¯­éŸ³]').replace(/\[sticker:[^\]]*\]/g, '[è¡¨æƒ…]');
    return `${speaker}: ${content}`;
}).join('\n')}

ç°åœ¨ä½ ä»¬çº¦å‡ºæ¥è§é¢äº†ï¼Œè¿›è¡Œçº¿ä¸‹çœŸå®èŠå¤©ã€‚ä½ å¿…é¡»è®°ä½å¾®ä¿¡ä¸ŠèŠè¿‡çš„å†…å®¹ï¼Œè¿™äº›æ˜¯ä½ ä»¬çš„å…±åŒè®°å¿†å’Œè¯é¢˜ã€‚å¯ä»¥è‡ªç„¶å»¶ç»­å¾®ä¿¡ä¸Šçš„è¯é¢˜ï¼Œä¹Ÿå¯ä»¥æåŠä¹‹å‰èŠè¿‡çš„äº‹ã€‚` : ''}
${customPreset ? `\n## ğŸ“Œ é¢å¤–è®¾å®š\n${customPreset}` : ''}`;

    // æ„å»ºæ¶ˆæ¯æ•°ç»„ï¼ˆåŒ…å«çº¿ä¸‹æ¨¡å¼çš„å¯¹è¯å†å²ï¼‰
    const messages = [
        { role: 'system', content: systemPrompt },
        ...offlineModeHistory.slice(-15).map(h => ({ 
            role: h.role === 'user' ? 'user' : 'assistant', 
            content: h.content 
        }))
    ];

    const reply = await callAI(messages);

    // æ·»åŠ AIå›å¤
    const aiMsg = { role: 'assistant', content: reply, time: Date.now() };
    offlineModeHistory.push(aiMsg);
    
    // ä¿å­˜
    localStorage.setItem(storageKey, JSON.stringify(offlineModeHistory));
    
    // åˆ·æ–°æ˜¾ç¤º
    renderOfflineChatBody(char);
}

// é‡æ–°ç”Ÿæˆæœ€åä¸€æ¡AIå›å¤
async function rerollOfflineMessage() {
    if (!offlineModeCharId) return;
    
    // æ£€æŸ¥æ˜¯å¦æœ‰AIå›å¤å¯ä»¥é‡æ–°ç”Ÿæˆ
    if (offlineModeHistory.length < 2) {
        alert('è¿˜æ²¡æœ‰AIå›å¤å¯ä»¥é‡æ–°ç”Ÿæˆ');
        return;
    }
    
    const lastMsg = offlineModeHistory[offlineModeHistory.length - 1];
    if (lastMsg.role !== 'assistant') {
        alert('æœ€åä¸€æ¡æ¶ˆæ¯ä¸æ˜¯AIå›å¤');
        return;
    }
    
    // ç§»é™¤æœ€åä¸€æ¡AIå›å¤
    offlineModeHistory.pop();
    
    const char = await db.characters.get(offlineModeCharId);
    if (!char) return;
    
    const accountId = getCurrentAccountId();
    const key = `offline_chat_${accountId}_${offlineModeCharId}`;
    
    // ä¿å­˜ç§»é™¤åçš„å†å²
    localStorage.setItem(key, JSON.stringify(offlineModeHistory));
    
    // åˆ·æ–°æ˜¾ç¤º
    renderOfflineChatBody(char);
    
    // é‡æ–°ç”Ÿæˆå›å¤
    try {
        await generateOfflineReply(char, accountId, key);
    } catch (error) {
        console.error('é‡æ–°ç”Ÿæˆå¤±è´¥:', error);
        alert('é‡æ–°ç”Ÿæˆå¤±è´¥: ' + error.message);
    }
}

// çº¿ä¸‹æ¨¡å¼è®¾ç½®ç›¸å…³å‡½æ•°
function getOfflineSettingsKey() {
    const accountId = getCurrentAccountId();
    return `offline_settings_${accountId}_${offlineModeCharId}`;
}

function getOfflineSettings() {
    if (!offlineModeCharId) return { minWords: 100, maxWords: 500, customPreset: '' };
    const key = getOfflineSettingsKey();
    const saved = localStorage.getItem(key);
    if (saved) {
        try {
            return JSON.parse(saved);
        } catch (e) {}
    }
    return { minWords: 100, maxWords: 500, customPreset: '' };
}

function showOfflineSettings() {
    const settings = getOfflineSettings();
    document.getElementById('offline-min-words').value = settings.minWords || 100;
    document.getElementById('offline-max-words').value = settings.maxWords || 500;
    document.getElementById('offline-custom-preset').value = settings.customPreset || '';
    document.getElementById('offline-settings-page').style.display = 'flex';
}

function hideOfflineSettings() {
    document.getElementById('offline-settings-page').style.display = 'none';
}

function saveOfflineSettings() {
    if (!offlineModeCharId) return;
    
    let minWords = parseInt(document.getElementById('offline-min-words').value) || 100;
    let maxWords = parseInt(document.getElementById('offline-max-words').value) || 500;
    const customPreset = document.getElementById('offline-custom-preset').value.trim();
    
    // æ ¡éªŒ
    if (minWords < 10) minWords = 10;
    if (maxWords < minWords) maxWords = minWords;
    if (maxWords > 5000) maxWords = 5000;
    
    const settings = { minWords, maxWords, customPreset };
    const key = getOfflineSettingsKey();
    localStorage.setItem(key, JSON.stringify(settings));
    
    // æ›´æ–°è¾“å…¥æ¡†æ˜¾ç¤º
    document.getElementById('offline-min-words').value = minWords;
    document.getElementById('offline-max-words').value = maxWords;
    
    alert('è®¾ç½®å·²ä¿å­˜');
    hideOfflineSettings();
}

function clearOfflineChatHistory() {
    if (!offlineModeCharId) return;
    if (!confirm('ç¡®å®šè¦æ¸…ç©ºçº¿ä¸‹èŠå¤©è®°å½•å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚')) return;
    
    const accountId = getCurrentAccountId();
    const key = `offline_chat_${accountId}_${offlineModeCharId}`;
    localStorage.removeItem(key);
    offlineModeHistory = [];
    
    // åˆ·æ–°æ˜¾ç¤º
    (async () => {
        const char = await db.characters.get(offlineModeCharId);
        if (char) renderOfflineChatBody(char);
    })();
    
    hideOfflineSettings();
}

// ===== è§’è‰²è´¦å·ç™»å½•å’ŒæŸ¥å²—åŠŸèƒ½ =====

// æ ¼å¼åŒ–æ—¶é—´
function formatTime(timestamp) {
    if (!timestamp) return '';
    const date = new Date(timestamp);
    const now = new Date();
    const diff = now - date;
    
    if (diff < 60000) return 'åˆšåˆš';
    if (diff < 3600000) return Math.floor(diff / 60000) + 'åˆ†é’Ÿå‰';
    if (diff < 86400000) return Math.floor(diff / 3600000) + 'å°æ—¶å‰';
    if (diff < 604800000) return Math.floor(diff / 86400000) + 'å¤©å‰';
    
    const month = date.getMonth() + 1;
    const day = date.getDate();
    const hour = date.getHours();
    const minute = date.getMinutes();
    
    return `${month}æœˆ${day}æ—¥ ${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
}

// ===== èŠå¤©æ€»ç»“åŠŸèƒ½ =====

// å½“å‰æŸ¥çœ‹çš„æ€»ç»“ID
let currentViewingSummaryId = null;

// æ˜¾ç¤ºæ”¶è—é¡µé¢
async function showFavoritesPage() {
    const page = document.getElementById('favorites-page');
    if (!page) return;
    
    page.style.display = 'flex';
    await renderFavoritesList('all');
}

// éšè—æ”¶è—é¡µé¢
function hideFavoritesPage() {
    const page = document.getElementById('favorites-page');
    if (page) page.style.display = 'none';
}

// åˆ‡æ¢æ”¶è—æ ‡ç­¾
async function switchFavTab(type) {
    // æ›´æ–°æ ‡ç­¾æ ·å¼
    document.querySelectorAll('.fav-tab').forEach(tab => {
        if (tab.dataset.type === type) {
            tab.style.background = 'var(--ins-pink)';
            tab.style.color = '#fff';
            tab.style.border = 'none';
            tab.classList.add('active');
        } else {
            tab.style.background = '#fff';
            tab.style.color = '#666';
            tab.style.border = '1px solid #e0e0e0';
            tab.classList.remove('active');
        }
    });
    
    await renderFavoritesList(type);
}

// æ¸²æŸ“æ”¶è—åˆ—è¡¨
async function renderFavoritesList(type) {
    const listContainer = document.getElementById('favorites-list');
    const emptyState = document.getElementById('favorites-empty');
    
    if (!listContainer) return;
    
    const accountId = getCurrentAccountId();
    if (!accountId) {
        listContainer.innerHTML = '';
        emptyState.style.display = 'block';
        return;
    }
    
    // è·å–æ‰€æœ‰æ€»ç»“
    let summaries = await db.chat_summaries.where('accountId').equals(accountId).toArray();
    
    // æŒ‰æ—¶é—´å€’åº
    summaries.sort((a, b) => b.time - a.time);
    
    if (summaries.length === 0) {
        listContainer.innerHTML = '';
        emptyState.style.display = 'block';
        return;
    }
    
    emptyState.style.display = 'none';
    
    // ç”Ÿæˆåˆ—è¡¨HTML
    let html = '';
    for (const summary of summaries) {
        let avatarUrl = '';
        let name = 'æœªçŸ¥';
        let chatTypeLabel = '';
        
        if (summary.chatType === 'private') {
            const char = await db.characters.get(parseInt(summary.chatId));
            if (char) {
                avatarUrl = char.avatar || '';
                name = char.remark || char.wx_nickname || char.name || 'æœªçŸ¥';
            }
            chatTypeLabel = 'ç§èŠ';
        } else if (summary.chatType === 'group') {
            const group = await db.group_chats.get(parseInt(summary.chatId));
            if (group) {
                avatarUrl = group.avatar || '';
                name = group.name || 'ç¾¤èŠ';
            }
            chatTypeLabel = 'ç¾¤èŠ';
        }
        
        const timeStr = formatSummaryTime(summary.time);
        const preview = summary.content ? summary.content.substring(0, 80) + (summary.content.length > 80 ? '...' : '') : 'æš‚æ— å†…å®¹';
        
        html += `
            <div onclick="showSummaryDetail(${summary.id})" style="background:#fff; border-radius:12px; padding:16px; cursor:pointer; transition:all 0.2s; box-shadow:0 1px 3px rgba(0,0,0,0.05);">
                <div style="display:flex; align-items:center; margin-bottom:12px;">
                    <div style="width:44px; height:44px; border-radius:${summary.chatType === 'group' ? '8px' : '50%'}; background-size:cover; background-position:center; background-color:#e0e0e0; margin-right:12px; ${avatarUrl ? `background-image:url(${avatarUrl})` : ''}"></div>
                    <div style="flex:1;">
                        <div style="display:flex; align-items:center; gap:8px;">
                            <span style="font-size:16px; font-weight:600; color:#333;">${name}</span>
                            <span style="font-size:11px; padding:2px 6px; background:${summary.chatType === 'group' ? '#e8f5e9' : '#fff3e0'}; color:${summary.chatType === 'group' ? '#4caf50' : '#ff9800'}; border-radius:4px;">${chatTypeLabel}</span>
                        </div>
                        <div style="font-size:12px; color:#999; margin-top:2px;">${timeStr}</div>
                    </div>
                    <div style="font-size:12px; color:#999;">${summary.messageCount || 0}æ¡æ¶ˆæ¯</div>
                </div>
                <div style="font-size:14px; color:#666; line-height:1.5; display:-webkit-box; -webkit-line-clamp:2; -webkit-box-orient:vertical; overflow:hidden;">${preview}</div>
            </div>
        `;
    }
    
    listContainer.innerHTML = html;
}

// æ ¼å¼åŒ–æ€»ç»“æ—¶é—´
function formatSummaryTime(timestamp) {
    if (!timestamp) return '';
    const date = new Date(timestamp);
    const year = date.getFullYear();
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const day = date.getDate().toString().padStart(2, '0');
    const hour = date.getHours().toString().padStart(2, '0');
    const minute = date.getMinutes().toString().padStart(2, '0');
    return `${year}-${month}-${day} ${hour}:${minute}`;
}

// æ˜¾ç¤ºæ€»ç»“è¯¦æƒ…
async function showSummaryDetail(summaryId) {
    console.log('[showSummaryDetail] å¼€å§‹æŸ¥çœ‹æ€»ç»“è¯¦æƒ…, summaryId:', summaryId);
    
    const page = document.getElementById('summary-detail-page');
    if (!page) {
        console.error('[showSummaryDetail] æ‰¾ä¸åˆ° summary-detail-page å…ƒç´ ');
        alert('é¡µé¢åŠ è½½é”™è¯¯ï¼Œè¯·åˆ·æ–°é¡µé¢');
        return;
    }
    
    currentViewingSummaryId = summaryId;
    
    try {
        const summary = await db.chat_summaries.get(summaryId);
        if (!summary) {
            alert('æ€»ç»“ä¸å­˜åœ¨');
            return;
        }
        console.log('[showSummaryDetail] è·å–åˆ°æ€»ç»“:', summary);
        
        // è·å–èŠå¤©å¯¹è±¡ä¿¡æ¯
        let avatarUrl = '';
        let name = 'æœªçŸ¥';
        
        if (summary.chatType === 'private') {
            const char = await db.characters.get(parseInt(summary.chatId));
            if (char) {
                avatarUrl = char.avatar || '';
                name = char.remark || char.wx_nickname || char.name || 'æœªçŸ¥';
            }
        } else if (summary.chatType === 'group') {
            const group = await db.group_chats.get(parseInt(summary.chatId));
            if (group) {
                avatarUrl = group.avatar || '';
                name = group.name || 'ç¾¤èŠ';
            }
        }
    
    // å¡«å……é¡µé¢å†…å®¹
    document.getElementById('summary-detail-title').textContent = name + ' - èŠå¤©æ€»ç»“';
    
    const avatarEl = document.getElementById('summary-detail-avatar');
    if (avatarUrl) {
        avatarEl.style.backgroundImage = `url(${avatarUrl})`;
    } else {
        avatarEl.style.backgroundImage = '';
    }
    avatarEl.style.borderRadius = summary.chatType === 'group' ? '8px' : '50%';
    
    document.getElementById('summary-detail-name').textContent = name;
    document.getElementById('summary-detail-time').textContent = formatSummaryTime(summary.time);
    document.getElementById('summary-msg-count').textContent = summary.messageCount || 0;
    document.getElementById('summary-time-range').textContent = summary.timeRange || '-';
    document.getElementById('summary-detail-content').textContent = summary.content || 'æš‚æ— å†…å®¹';
    
        // å…³é”®è¯æ ‡ç­¾
        const keywordsSection = document.getElementById('summary-keywords-section');
        const keywordsContainer = document.getElementById('summary-detail-keywords');
        if (summary.keywords && summary.keywords.length > 0) {
            keywordsSection.style.display = 'block';
            keywordsContainer.innerHTML = summary.keywords.map(kw => 
                `<span style="padding:6px 12px; background:#f0f0f5; border-radius:16px; font-size:13px; color:#666;">${kw}</span>`
            ).join('');
        } else {
            keywordsSection.style.display = 'none';
        }
        
        console.log('[showSummaryDetail] æ˜¾ç¤ºè¯¦æƒ…é¡µé¢');
        page.style.display = 'flex';
        page.style.zIndex = '1001'; // ç¡®ä¿åœ¨æ€»ç»“åˆ—è¡¨é¡µé¢ä¹‹ä¸Š
    } catch (error) {
        console.error('[showSummaryDetail] æ˜¾ç¤ºæ€»ç»“è¯¦æƒ…æ—¶å‡ºé”™:', error);
        alert('æŸ¥çœ‹æ€»ç»“è¯¦æƒ…å¤±è´¥ï¼š' + (error.message || 'æœªçŸ¥é”™è¯¯'));
    }
}

// éšè—æ€»ç»“è¯¦æƒ…é¡µ
function hideSummaryDetailPage() {
    const page = document.getElementById('summary-detail-page');
    if (page) page.style.display = 'none';
    currentViewingSummaryId = null;
}

// åˆ é™¤æ€»ç»“
async function deleteSummary() {
    if (!currentViewingSummaryId) return;
    
    if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡æ€»ç»“å—ï¼Ÿ')) return;
    
    try {
        await db.chat_summaries.delete(currentViewingSummaryId);
        hideSummaryDetailPage();
        
        // åˆ·æ–°æ”¶è—åˆ—è¡¨
        const favPage = document.getElementById('favorites-page');
        if (favPage && favPage.style.display !== 'none') {
            await renderFavoritesList('all');
        }
        
        // åˆ·æ–°èŠå¤©æ€»ç»“åˆ—è¡¨
        const chatSummariesPage = document.getElementById('chat-summaries-page');
        if (chatSummariesPage && chatSummariesPage.style.display !== 'none') {
            // é‡æ–°åŠ è½½å½“å‰èŠå¤©çš„æ€»ç»“
        }
        
        showToast('åˆ é™¤æˆåŠŸ');
    } catch (e) {
        console.error('åˆ é™¤æ€»ç»“å¤±è´¥:', e);
        alert('åˆ é™¤å¤±è´¥');
    }
}

// ä¿å­˜ç¼–è¾‘å‰çš„åŸå§‹å†…å®¹
let originalSummaryContent = '';

// åˆ‡æ¢æ€»ç»“ç¼–è¾‘æ¨¡å¼
function toggleEditSummary() {
    const contentDiv = document.getElementById('summary-detail-content');
    const contentTextarea = document.getElementById('summary-detail-content-edit');
    const editHint = document.getElementById('summary-edit-hint');
    const editBtn = document.getElementById('summary-edit-btn');
    const saveBtn = document.getElementById('summary-save-btn');
    const cancelBtn = document.getElementById('summary-cancel-btn');
    const deleteBtn = document.getElementById('summary-delete-btn');
    
    if (!contentDiv || !contentTextarea) {
        console.error('æ‰¾ä¸åˆ°æ€»ç»“å†…å®¹å…ƒç´ ');
        alert('ç¼–è¾‘åŠŸèƒ½åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
        return;
    }
    
    // ä¿å­˜åŸå§‹å†…å®¹
    originalSummaryContent = contentDiv.textContent;
    
    // åˆ‡æ¢åˆ°ç¼–è¾‘æ¨¡å¼
    contentDiv.style.display = 'none';
    contentTextarea.style.display = 'block';
    contentTextarea.value = originalSummaryContent;
    if (editHint) editHint.style.display = 'block';
    
    // åˆ‡æ¢æŒ‰é’®æ˜¾ç¤º
    if (editBtn) editBtn.style.display = 'none';
    if (saveBtn) saveBtn.style.display = 'block';
    if (cancelBtn) cancelBtn.style.display = 'block';
    if (deleteBtn) deleteBtn.style.display = 'none';
    
    // è‡ªåŠ¨èšç„¦åˆ°è¾“å…¥æ¡†å¹¶é€‰ä¸­å…¨éƒ¨æ–‡æœ¬ï¼ˆæ–¹ä¾¿ç”¨æˆ·ç¼–è¾‘ï¼‰
    setTimeout(() => {
        contentTextarea.focus();
        contentTextarea.select();
    }, 100);
}

// å–æ¶ˆç¼–è¾‘æ€»ç»“
function cancelEditSummary() {
    const contentDiv = document.getElementById('summary-detail-content');
    const contentTextarea = document.getElementById('summary-detail-content-edit');
    const editHint = document.getElementById('summary-edit-hint');
    const editBtn = document.getElementById('summary-edit-btn');
    const saveBtn = document.getElementById('summary-save-btn');
    const cancelBtn = document.getElementById('summary-cancel-btn');
    const deleteBtn = document.getElementById('summary-delete-btn');
    
    // æ¢å¤æ˜¾ç¤ºæ¨¡å¼
    if (contentDiv) contentDiv.style.display = 'block';
    if (contentTextarea) contentTextarea.style.display = 'none';
    if (editHint) editHint.style.display = 'none';
    
    // åˆ‡æ¢æŒ‰é’®æ˜¾ç¤º
    if (editBtn) editBtn.style.display = 'block';
    if (saveBtn) saveBtn.style.display = 'none';
    if (cancelBtn) cancelBtn.style.display = 'none';
    if (deleteBtn) deleteBtn.style.display = 'block';
}

// ä¿å­˜æ€»ç»“ç¼–è¾‘
async function saveSummaryEdit() {
    if (!currentViewingSummaryId) return;
    
    const contentTextarea = document.getElementById('summary-detail-content-edit');
    const newContent = contentTextarea.value.trim();
    
    if (!newContent) {
        alert('æ€»ç»“å†…å®¹ä¸èƒ½ä¸ºç©º');
        return;
    }
    
    try {
        // è·å–å½“å‰æ€»ç»“
        const summary = await db.chat_summaries.get(currentViewingSummaryId);
        if (!summary) {
            alert('æ€»ç»“ä¸å­˜åœ¨');
            return;
        }
        
        // æ›´æ–°å†…å®¹
        summary.content = newContent;
        summary.updated_at = Date.now(); // æ·»åŠ æ›´æ–°æ—¶é—´æˆ³
        
        // ä¿å­˜åˆ°æ•°æ®åº“
        await db.chat_summaries.put(summary);
        
        // æ›´æ–°æ˜¾ç¤º
        const contentDiv = document.getElementById('summary-detail-content');
        if (contentDiv) contentDiv.textContent = newContent;
        
        // é€€å‡ºç¼–è¾‘æ¨¡å¼
        cancelEditSummary();
        
        // åˆ·æ–°æ”¶è—åˆ—è¡¨ï¼ˆå¦‚æœæ­£åœ¨æ˜¾ç¤ºï¼‰
        const favPage = document.getElementById('favorites-page');
        if (favPage && favPage.style.display !== 'none') {
            await renderFavoritesList('all');
        }
        
        showToast('ä¿å­˜æˆåŠŸ');
    } catch (e) {
        console.error('ä¿å­˜æ€»ç»“å¤±è´¥:', e);
        alert('ä¿å­˜å¤±è´¥: ' + e.message);
    }
}

// æ˜¾ç¤ºæŸä¸ªèŠå¤©çš„æ€»ç»“åˆ—è¡¨
async function showChatSummaries(chatType) {
    console.log('[showChatSummaries] å¼€å§‹æŸ¥çœ‹æ€»ç»“è®°å½•, chatType:', chatType);
    
    const page = document.getElementById('chat-summaries-page');
    if (!page) {
        console.error('[showChatSummaries] æ‰¾ä¸åˆ° chat-summaries-page å…ƒç´ ');
        alert('é¡µé¢åŠ è½½é”™è¯¯ï¼Œè¯·åˆ·æ–°é¡µé¢');
        return;
    }
    
    const accountId = getCurrentAccountId();
    if (!accountId) {
        console.error('[showChatSummaries] æ²¡æœ‰å½“å‰è´¦å·ID');
        alert('è¯·å…ˆç™»å½•è´¦å·');
        return;
    }
    console.log('[showChatSummaries] accountId:', accountId);
    
    let chatId, name;
    
    if (chatType === 'private') {
        if (!currentChatCharId) {
            console.error('[showChatSummaries] æ²¡æœ‰å½“å‰èŠå¤©è§’è‰²ID');
            alert('è¯·å…ˆæ‰“å¼€ä¸€ä¸ªèŠå¤©çª—å£');
            return;
        }
        chatId = currentChatCharId;
        const char = await db.characters.get(parseInt(chatId));
        name = char ? (char.remark || char.wx_nickname || char.name) : 'ç§èŠ';
        console.log('[showChatSummaries] ç§èŠ, chatId:', chatId, 'name:', name);
    } else if (chatType === 'group') {
        if (!window.currentGroupChatId) {
            console.error('[showChatSummaries] æ²¡æœ‰å½“å‰ç¾¤èŠID');
            alert('è¯·å…ˆæ‰“å¼€ä¸€ä¸ªç¾¤èŠçª—å£');
            return;
        }
        chatId = window.currentGroupChatId;
        const group = await db.group_chats.get(parseInt(chatId));
        name = group ? group.name : 'ç¾¤èŠ';
        console.log('[showChatSummaries] ç¾¤èŠ, chatId:', chatId, 'name:', name);
    }
    
    document.getElementById('chat-summaries-title').textContent = name + ' - æ€»ç»“è®°å½•';
    
    try {
        // è·å–è¯¥èŠå¤©çš„æ‰€æœ‰æ€»ç»“
        console.log('[showChatSummaries] å¼€å§‹æŸ¥è¯¢æ€»ç»“, chatId:', chatId, 'chatType:', chatType);
        let summaries = await db.chat_summaries
            .where(['accountId', 'chatType', 'chatId'])
            .equals([accountId, chatType, String(chatId)])
            .toArray();
        
        console.log('[showChatSummaries] å¤åˆç´¢å¼•æŸ¥è¯¢ç»“æœ:', summaries.length);
        
        // å¦‚æœå¤åˆç´¢å¼•ä¸å·¥ä½œï¼Œä½¿ç”¨è¿‡æ»¤
        if (summaries.length === 0) {
            console.log('[showChatSummaries] å¤åˆç´¢å¼•æ— ç»“æœï¼Œä½¿ç”¨è¿‡æ»¤æ–¹å¼');
            summaries = await db.chat_summaries.where('accountId').equals(accountId).toArray();
            summaries = summaries.filter(s => s.chatType === chatType && String(s.chatId) === String(chatId));
            console.log('[showChatSummaries] è¿‡æ»¤åç»“æœ:', summaries.length);
        }
        
        // æŒ‰æ—¶é—´å€’åº
        summaries.sort((a, b) => b.time - a.time);
        
        const listContainer = document.getElementById('chat-summaries-list');
        const emptyState = document.getElementById('chat-summaries-empty');
        
        if (summaries.length === 0) {
            listContainer.innerHTML = '';
            emptyState.style.display = 'block';
        } else {
            emptyState.style.display = 'none';
            listContainer.innerHTML = summaries.map(summary => `
                <div onclick="showSummaryDetail(${summary.id})" style="background:#fff; border-radius:12px; padding:16px; cursor:pointer; transition:all 0.2s; box-shadow:0 1px 3px rgba(0,0,0,0.05);">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                        <span style="font-size:14px; font-weight:600; color:#333;">ç¬¬ ${summaries.indexOf(summary) + 1} æ¬¡æ€»ç»“</span>
                        <span style="font-size:12px; color:#999;">${formatSummaryTime(summary.time)}</span>
                    </div>
                    <div style="font-size:13px; color:#666; line-height:1.5; display:-webkit-box; -webkit-line-clamp:3; -webkit-box-orient:vertical; overflow:hidden;">
                        ${summary.content ? summary.content.substring(0, 120) + (summary.content.length > 120 ? '...' : '') : 'æš‚æ— å†…å®¹'}
                    </div>
                    <div style="margin-top:10px; font-size:12px; color:#999;">
                        ${summary.messageCount || 0}æ¡æ¶ˆæ¯ Â· ${summary.timeRange || '-'}
                    </div>
                </div>
            `).join('');
        }
        
        console.log('[showChatSummaries] æ˜¾ç¤ºé¡µé¢ï¼Œæ€»ç»“æ•°é‡:', summaries.length);
        page.style.display = 'flex';
        
        // ğŸ”§ ç¡®ä¿é¡µé¢åœ¨æœ€ä¸Šå±‚
        page.style.zIndex = '1000';
    } catch (error) {
        console.error('[showChatSummaries] æŸ¥è¯¢æˆ–æ˜¾ç¤ºæ€»ç»“æ—¶å‡ºé”™:', error);
        alert('æŸ¥çœ‹æ€»ç»“è®°å½•å¤±è´¥ï¼š' + (error.message || 'æœªçŸ¥é”™è¯¯'));
    }
}

// éšè—èŠå¤©æ€»ç»“åˆ—è¡¨é¡µ
function hideChatSummariesPage() {
    const page = document.getElementById('chat-summaries-page');
    if (page) page.style.display = 'none';
}

// æ‰‹åŠ¨è§¦å‘ç”Ÿæˆæ€»ç»“
async function triggerManualSummary(chatType) {
    const accountId = getCurrentAccountId();
    if (!accountId) {
        alert('è¯·å…ˆç™»å½•è´¦å·');
        return;
    }
    
    let chatId, chatHistory, name;
    
    if (chatType === 'private') {
        if (!currentChatCharId) {
            alert('è¯·å…ˆæ‰“å¼€ä¸€ä¸ªèŠå¤©');
            return;
        }
        chatId = currentChatCharId;
        const char = await db.characters.get(parseInt(chatId));
        name = char ? (char.remark || char.wx_nickname || char.name) : 'ç§èŠ';
        chatHistory = getChatHistory(char, accountId);
    } else if (chatType === 'group') {
        if (!window.currentGroupChatId) {
            alert('è¯·å…ˆæ‰“å¼€ä¸€ä¸ªç¾¤èŠ');
            return;
        }
        chatId = window.currentGroupChatId;
        const group = await db.group_chats.get(parseInt(chatId));
        name = group ? group.name : 'ç¾¤èŠ';
        chatHistory = group ? (group.messages || []) : [];
    }
    
    if (!chatHistory || chatHistory.length < 5) {
        alert('èŠå¤©è®°å½•å¤ªå°‘ï¼ˆè‡³å°‘éœ€è¦5æ¡ï¼‰ï¼Œæ— æ³•ç”Ÿæˆæ€»ç»“');
        return;
    }
    
    if (!confirm(`ç¡®å®šè¦ä¸ºä¸ã€Œ${name}ã€çš„èŠå¤©ç”Ÿæˆæ€»ç»“å—ï¼Ÿ\nå°†æ€»ç»“æœ€è¿‘çš„èŠå¤©å†…å®¹ã€‚`)) {
        return;
    }
    
    showToast('æ­£åœ¨ç”Ÿæˆæ€»ç»“...');
    
    try {
        await generateChatSummary(chatType, chatId, accountId, chatHistory);
        showToast('æ€»ç»“ç”ŸæˆæˆåŠŸï¼');
        
        // æ›´æ–°æ€»ç»“è®¡æ•°æ˜¾ç¤º
        await updateSummaryCount(chatType, chatId, accountId);
    } catch (e) {
        console.error('ç”Ÿæˆæ€»ç»“å¤±è´¥:', e);
        alert('ç”Ÿæˆæ€»ç»“å¤±è´¥: ' + e.message);
    }
}

// ç”ŸæˆèŠå¤©æ€»ç»“
async function generateChatSummary(chatType, chatId, accountId, chatHistory) {
    // è·å–æœ€è¿‘çš„æ¶ˆæ¯ï¼ˆæœ€å¤š100æ¡ï¼‰
    const recentMessages = chatHistory.slice(-100);
    
    if (recentMessages.length < 5) {
        throw new Error('èŠå¤©è®°å½•å¤ªå°‘');
    }
    
    // ğŸ”§ è·å–åŸåï¼ˆä¸ä½¿ç”¨å¤‡æ³¨ï¼Œç›´æ¥ä½¿ç”¨è§’è‰²çš„çœŸåï¼‰
    let charName = 'å¯¹æ–¹';
    let userName = 'ç”¨æˆ·';
    
    if (chatType === 'private') {
        // ç§èŠï¼šä½¿ç”¨è§’è‰²çš„åŸå
        const char = await db.characters.get(parseInt(chatId));
        if (char) {
            charName = char.name; // ğŸ”§ ä¿®æ”¹ï¼šåªä½¿ç”¨åŸåï¼Œä¸ä½¿ç”¨å¤‡æ³¨æˆ–å¾®ä¿¡æ˜µç§°
            // ä¼˜å…ˆä½¿ç”¨æŒ‚è½½çš„ç”¨æˆ·æ¡£æ¡ˆçš„åŸå
            if (char.linked_user_id) {
                const user = await db.characters.get(char.linked_user_id);
                if (user) {
                    userName = user.name; // ğŸ”§ ä¿®æ”¹ï¼šåªä½¿ç”¨åŸå
                }
            } else {
                // æ²¡æŒ‚è½½æ—¶å°è¯•ç”¨å½“å‰ç™»å½•è´¦å·çš„åŸå
                const myChar = await db.characters.get(parseInt(accountId));
                if (myChar) {
                    userName = myChar.name; // ğŸ”§ ä¿®æ”¹ï¼šåªä½¿ç”¨åŸå
                }
            }
        }
    } else if (chatType === 'group') {
        // ç¾¤èŠï¼šä½¿ç”¨ç¾¤å
        const group = await db.group_chats.get(parseInt(chatId));
        if (group) {
            charName = group.name || 'ç¾¤èŠ';
        }
        // å°è¯•è·å–ç”¨æˆ·çš„åŸå
        const myChar = await db.characters.get(parseInt(accountId));
        if (myChar) {
            userName = myChar.name; // ğŸ”§ ä¿®æ”¹ï¼šåªä½¿ç”¨åŸå
        }
    }
    
    // è®¡ç®—æ—¶é—´èŒƒå›´
    const firstMsgTime = recentMessages[0].time || recentMessages[0].timestamp || Date.now();
    const lastMsgTime = recentMessages[recentMessages.length - 1].time || recentMessages[recentMessages.length - 1].timestamp || Date.now();
    const timeRange = formatTimeRange(firstMsgTime, lastMsgTime);
    
    // æ„å»ºèŠå¤©å†…å®¹æ–‡æœ¬ï¼ˆä½¿ç”¨å¾®ä¿¡æ˜¾ç¤ºåï¼‰
    let chatContent = recentMessages.map(msg => {
        let role;
        if (msg.role === 'user') {
            role = userName;
        } else if (chatType === 'group' && msg.name) {
            // ç¾¤èŠä¸­éœ€è¦åŒºåˆ†ä¸åŒå‘è¨€è€…ï¼Œä½†ä¹Ÿåº”å°½é‡ä½¿ç”¨æ˜¾ç¤ºå
            role = msg.displayName || msg.name || charName;
        } else {
            // ç§èŠä¸­ç»Ÿä¸€ä½¿ç”¨è§’è‰²çš„å¾®ä¿¡æ˜¾ç¤ºå
            role = charName;
        }
        const content = msg.content || msg.message || '';
        return `${role}: ${content}`;
    }).join('\n');
    
    // è°ƒç”¨APIç”Ÿæˆæ€»ç»“
    const systemPrompt = `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„èŠå¤©è®°å½•æ€»ç»“åŠ©æ‰‹ã€‚è¯·æ ¹æ®ä»¥ä¸‹èŠå¤©è®°å½•ï¼Œç”Ÿæˆä¸€ä»½ç®€æ´ä½†å®Œæ•´çš„æ€»ç»“ã€‚

æ€»ç»“è¦æ±‚ï¼š
1. **å¿…é¡»ä½¿ç”¨ç¬¬ä¸‰äººç§°è§†è§’**ï¼šä»¥æ—è§‚è€…è§’åº¦å®¢è§‚æè¿°ï¼Œä¸¥ç¦ä½¿ç”¨"æˆ‘"ã€"æˆ‘ä»¬"ã€"ä½ "ç­‰ç¬¬ä¸€/ç¬¬äºŒäººç§°
2. **å¿…é¡»åŒ…å«æ—¶é—´ä¿¡æ¯**ï¼šåœ¨æ€»ç»“å¼€å¤´æ³¨æ˜æ—¶é—´æ®µï¼Œä¾‹å¦‚"åœ¨XæœˆXæ—¥è‡³XæœˆXæ—¥æœŸé—´"
3. **ä½¿ç”¨å¯¹è¯ä¸­çš„ç§°å‘¼**ï¼šæ€»ç»“ä¸­ç›´æ¥ä½¿ç”¨"${userName}"å’Œ"${charName}"çš„åå­—ï¼Œä¸¥ç¦ä½¿ç”¨"AI"ã€"åŠ©æ‰‹"ã€"æœºå™¨äºº"ã€"ç”¨æˆ·"ç­‰è¯æ±‡
4. ç”¨å®¢è§‚çš„å™äº‹å£å»æè¿°åŒæ–¹çš„äº¤æµï¼Œä¾‹å¦‚ï¼š"${userName}å‘${charName}è¡¨ç¤º..."ã€"${charName}å›åº”é“..."
5. æç‚¼å‡ºä¸»è¦è¯é¢˜å’Œå…³é”®ä¿¡æ¯
6. å¦‚æœæœ‰é‡è¦çš„æƒ…æ„Ÿå˜åŒ–æˆ–äº‹ä»¶ï¼Œè¦ç‰¹åˆ«æŒ‡å‡º
7. æ€»ç»“é•¿åº¦æ§åˆ¶åœ¨200-400å­—ä¹‹é—´
8. ä½¿ç”¨è‡ªç„¶æµç•…çš„ä¸­æ–‡è¡¨è¾¾
9. å¦‚æœèƒ½æå–3-5ä¸ªå…³é”®è¯ï¼Œè¯·åœ¨æœ€åç”¨ã€å…³é”®è¯ã€‘æ ‡æ³¨

èŠå¤©æ—¶é—´ï¼š${timeRange}
èŠå¤©è®°å½•å¦‚ä¸‹ï¼š
${chatContent}`;

    const messages = [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: 'è¯·ä¸ºè¿™æ®µèŠå¤©è®°å½•ç”Ÿæˆæ€»ç»“ã€‚' }
    ];
    
    const summary = await callAI(messages);
    
    // æå–å…³é”®è¯
    let keywords = [];
    const keywordMatch = summary.match(/ã€å…³é”®è¯ã€‘[:ï¼š]?\s*(.+?)$/);
    let content = summary;
    if (keywordMatch) {
        keywords = keywordMatch[1].split(/[,ï¼Œã€\s]+/).filter(k => k.trim());
        content = summary.replace(/ã€å…³é”®è¯ã€‘[:ï¼š]?\s*.+?$/, '').trim();
    }
    
    // ä¿å­˜åˆ°æ•°æ®åº“
    const summaryData = {
        accountId: accountId,
        chatType: chatType,
        chatId: String(chatId),
        time: Date.now(),
        content: content,
        messageCount: recentMessages.length,
        timeRange: timeRange,
        keywords: keywords,
        startTime: firstMsgTime,
        endTime: lastMsgTime
    };
    
    await db.chat_summaries.add(summaryData);
    
    return summaryData;
}

// æ ¼å¼åŒ–æ—¶é—´èŒƒå›´
function formatTimeRange(startTime, endTime) {
    const start = new Date(startTime);
    const end = new Date(endTime);
    
    const formatDateTime = (d) => {
        const month = d.getMonth() + 1;
        const day = d.getDate();
        const hour = String(d.getHours()).padStart(2, '0');
        const minute = String(d.getMinutes()).padStart(2, '0');
        return `${month}æœˆ${day}æ—¥ ${hour}:${minute}`;
    };
    
    const formatDate = (d) => {
        const month = d.getMonth() + 1;
        const day = d.getDate();
        return `${month}æœˆ${day}æ—¥`;
    };
    
    const startDate = formatDate(start);
    const endDate = formatDate(end);
    
    // å¦‚æœæ˜¯åŒä¸€å¤©ï¼Œæ˜¾ç¤ºå…·ä½“æ—¶é—´æ®µ
    if (startDate === endDate) {
        const startHour = String(start.getHours()).padStart(2, '0');
        const startMinute = String(start.getMinutes()).padStart(2, '0');
        const endHour = String(end.getHours()).padStart(2, '0');
        const endMinute = String(end.getMinutes()).padStart(2, '0');
        return `${startDate} ${startHour}:${startMinute} - ${endHour}:${endMinute}`;
    }
    
    // è·¨å¤©æ˜¾ç¤ºå®Œæ•´æ—¶é—´
    return `${formatDateTime(start)} - ${formatDateTime(end)}`;
}

// æ›´æ–°æ€»ç»“è®¡æ•°æ˜¾ç¤º
async function updateSummaryCount(chatType, chatId, accountId) {
    let summaries = await db.chat_summaries.where('accountId').equals(accountId).toArray();
    summaries = summaries.filter(s => s.chatType === chatType && String(s.chatId) === String(chatId));
    
    const count = summaries.length;
    
    if (chatType === 'private') {
        const countEl = document.getElementById('detail-summary-count');
        if (countEl) countEl.textContent = `${count}æ¡æ€»ç»“`;
    } else if (chatType === 'group') {
        const countEl = document.getElementById('group-detail-summary-count');
        if (countEl) countEl.textContent = `${count}æ¡æ€»ç»“`;
    }
}

// æ£€æŸ¥æ˜¯å¦éœ€è¦è‡ªåŠ¨æ€»ç»“ï¼ˆåœ¨å‘é€æ¶ˆæ¯åè°ƒç”¨ï¼‰
async function checkAutoSummary(chatType, chatId, accountId) {
    let autoSummaryEnabled = false;
    let summaryInterval = 50;
    let chatHistory = [];
    
    if (chatType === 'private') {
        const char = await db.characters.get(parseInt(chatId));
        if (!char) return;
        autoSummaryEnabled = char.auto_summary_enabled;
        summaryInterval = char.summary_interval || 50;
        chatHistory = getChatHistory(char, accountId);
    } else if (chatType === 'group') {
        const group = await db.group_chats.get(parseInt(chatId));
        if (!group) return;
        autoSummaryEnabled = group.auto_summary_enabled;
        summaryInterval = group.summary_interval || 50;
        chatHistory = group.messages || [];
    }
    
    if (!autoSummaryEnabled) return;
    
    // è·å–ä¸Šæ¬¡æ€»ç»“åçš„æ¶ˆæ¯æ•°
    let summaries = await db.chat_summaries.where('accountId').equals(accountId).toArray();
    summaries = summaries.filter(s => s.chatType === chatType && String(s.chatId) === String(chatId));
    summaries.sort((a, b) => b.time - a.time);
    
    const lastSummary = summaries[0];
    const lastSummaryTime = lastSummary ? lastSummary.endTime : 0;
    
    // ç»Ÿè®¡ä¸Šæ¬¡æ€»ç»“åçš„æ¶ˆæ¯æ•°
    const newMessages = chatHistory.filter(msg => {
        const msgTime = msg.time || msg.timestamp || 0;
        return msgTime > lastSummaryTime;
    });
    
    // å¦‚æœè¾¾åˆ°é˜ˆå€¼ï¼Œè‡ªåŠ¨ç”Ÿæˆæ€»ç»“
    if (newMessages.length >= summaryInterval) {
        console.log(`[AutoSummary] è¾¾åˆ°é˜ˆå€¼ ${summaryInterval}ï¼Œè‡ªåŠ¨ç”Ÿæˆæ€»ç»“`);
        try {
            await generateChatSummary(chatType, chatId, accountId, newMessages);
            showToast('å·²è‡ªåŠ¨ç”ŸæˆèŠå¤©æ€»ç»“');
        } catch (e) {
            console.error('[AutoSummary] è‡ªåŠ¨æ€»ç»“å¤±è´¥:', e);
        }
    }
}

// åœ¨åŠ è½½èŠå¤©è¯¦æƒ…æ—¶æ›´æ–°æ€»ç»“è®¡æ•°
async function loadSummarySettings(chatType, chatId) {
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    // æ›´æ–°æ€»ç»“è®¡æ•°
    await updateSummaryCount(chatType, chatId, accountId);
    
    // åŠ è½½è‡ªåŠ¨æ€»ç»“è®¾ç½®
    if (chatType === 'private') {
        const char = await db.characters.get(parseInt(chatId));
        if (char) {
            document.getElementById('detail-auto-summary-switch').checked = !!char.auto_summary_enabled;
            document.getElementById('detail-summary-interval').value = char.summary_interval || '';
        }
    } else if (chatType === 'group') {
        const group = await db.group_chats.get(parseInt(chatId));
        if (group) {
            document.getElementById('group-detail-auto-summary-switch').checked = !!group.auto_summary_enabled;
            document.getElementById('group-detail-summary-interval').value = group.summary_interval || '';
        }
    }
}

// ===== è”æœºåŠŸèƒ½ =====

// å…¨å±€å˜é‡
let onlineSocket = null;
let onlineConnected = false;
let onlineUserData = null;
let onlineToken = null;
let onlineCharacters = []; // å·²ä¸Šçº¿çš„è§’è‰²åˆ—è¡¨
let onlineGroups = []; // è”æœºç¾¤èŠåˆ—è¡¨
let hasShownAuthFailedAlert = false; // æ ‡å¿—ä½ï¼šæ˜¯å¦å·²ç»æç¤ºè¿‡è®¤è¯å¤±è´¥ï¼ˆé¿å…é‡è¿æ—¶åå¤å¼¹çª—ï¼‰
let currentOnlineGroupId = null; // å½“å‰æ‰“å¼€çš„è”æœºç¾¤èŠID
let currentOnlineGroupMessages = []; // å½“å‰ç¾¤èŠæ¶ˆæ¯
let currentOnlineGroupMembers = []; // å½“å‰ç¾¤èŠæˆå‘˜
let myOnlineGroupCharacter = null; // æˆ‘åœ¨å½“å‰ç¾¤èŠä¸­çš„è§’è‰²

// åˆ‡æ¢è”æœºè®¾ç½®é¢æ¿
function toggleOnlineSettings() {
    const body = document.getElementById('online-setting-body');
    const arrow = document.getElementById('online-setting-arrow');
    if (body.style.display === 'none') {
        body.style.display = 'block';
        arrow.textContent = 'â–²';
        loadOnlineSettings();
    } else {
        body.style.display = 'none';
        arrow.textContent = 'â–¼';
    }
}

// âœ… è‡ªåŠ¨åˆå§‹åŒ–è”æœºç³»ç»Ÿï¼ˆé¡µé¢åŠ è½½æ—¶è°ƒç”¨ï¼‰
async function initOnlineSystem() {
    const serverUrl = localStorage.getItem('online_server_url') || '';
    
    // åŠ è½½å·²ä¿å­˜çš„token
    onlineToken = localStorage.getItem('online_token');
    const savedUserData = localStorage.getItem('online_user_data');
    if (savedUserData) {
        try {
            onlineUserData = JSON.parse(savedUserData);
        } catch (e) {
            onlineUserData = null;
        }
    }
    
    // å¯åŠ¨è‡ªåŠ¨åŒæ­¥å®šæ—¶å™¨
    startAutoSync();
    
    // å¦‚æœæœ‰æœåŠ¡å™¨åœ°å€ï¼Œè‡ªåŠ¨è¿æ¥
    if (serverUrl) {
        console.log('[Online] è‡ªåŠ¨è¿æ¥æœåŠ¡å™¨:', serverUrl);
        try {
            await connectToOnlineServer();
            console.log('[Online] æœåŠ¡å™¨è¿æ¥æˆåŠŸ');
        } catch (e) {
            console.warn('[Online] è‡ªåŠ¨è¿æ¥å¤±è´¥:', e.message);
        }
    }
}

// åŠ è½½è”æœºè®¾ç½®ï¼ˆæ‰“å¼€è®¾ç½®é¢æ¿æ—¶è°ƒç”¨ï¼‰
function loadOnlineSettings() {
    const serverUrl = localStorage.getItem('online_server_url') || '';
    const serverUrlInput = document.getElementById('online-server-url');
    if (serverUrlInput) {
        serverUrlInput.value = serverUrl;
    }
    
    updateOnlineStatus();
}

// ä¿å­˜è”æœºè®¾ç½®
function saveOnlineSettings() {
    const serverUrl = document.getElementById('online-server-url').value.trim();
    localStorage.setItem('online_server_url', serverUrl);
}

// æ›´æ–°åœ¨çº¿çŠ¶æ€æ˜¾ç¤º
function updateOnlineStatus() {
    const statusDot = document.getElementById('online-status-dot');
    const statusText = document.getElementById('online-status-text');
    const userInfo = document.getElementById('online-user-info');
    const usernameDisplay = document.getElementById('online-username-display');
    const authButtons = document.getElementById('online-auth-buttons');
    const loggedInActions = document.getElementById('online-logged-in-actions');
    
    if (onlineConnected && onlineUserData) {
        statusDot.style.background = '#4caf50';
        statusText.textContent = 'å·²è¿æ¥';
        statusText.style.color = '#4caf50';
        userInfo.style.display = 'block';
        usernameDisplay.textContent = onlineUserData.username;
        authButtons.style.display = 'none';
        loggedInActions.style.display = 'block';
    } else if (onlineConnected) {
        statusDot.style.background = '#ff9800';
        statusText.textContent = 'å·²è¿æ¥ï¼ˆæœªç™»å½•ï¼‰';
        statusText.style.color = '#ff9800';
        userInfo.style.display = 'none';
        authButtons.style.display = 'flex';
        loggedInActions.style.display = 'none';
    } else {
        statusDot.style.background = '#ccc';
        statusText.textContent = 'æœªè¿æ¥';
        statusText.style.color = '#666';
        userInfo.style.display = 'none';
        authButtons.style.display = 'flex';
        loggedInActions.style.display = 'none';
    }
}

// æµ‹è¯•è¿æ¥
async function testOnlineConnection() {
    const serverUrl = document.getElementById('online-server-url').value.trim();
    const statusEl = document.getElementById('online-connection-status');
    const btnText = document.getElementById('test-online-btn-text');
    
    if (!serverUrl) {
        statusEl.innerHTML = '<span style="color:#ff3b30;">è¯·å¡«å†™æœåŠ¡å™¨åœ°å€</span>';
        return;
    }
    
    btnText.textContent = 'è¿æ¥ä¸­...';
    statusEl.innerHTML = '<span style="color:#999;">æ­£åœ¨è¿æ¥...</span>';
    
    try {
        await connectToOnlineServer();
        statusEl.innerHTML = '<span style="color:#4caf50;">âœ“ è¿æ¥æˆåŠŸ</span>';
    } catch (e) {
        statusEl.innerHTML = `<span style="color:#ff3b30;">âœ— è¿æ¥å¤±è´¥: ${e.message}</span>`;
    }
    
    btnText.textContent = 'æµ‹è¯•è¿æ¥';
}

// è¿æ¥åˆ°æœåŠ¡å™¨
function connectToOnlineServer() {
    return new Promise((resolve, reject) => {
        const serverUrl = document.getElementById('online-server-url').value.trim() || localStorage.getItem('online_server_url');
        
        if (!serverUrl) {
            reject(new Error('æœªè®¾ç½®æœåŠ¡å™¨åœ°å€'));
            return;
        }
        
        // å…³é—­æ—§è¿æ¥
        if (onlineSocket) {
            onlineSocket.close();
        }
        
        try {
            onlineSocket = new WebSocket(serverUrl);
            
            onlineSocket.onopen = async () => {
                console.log('[Online] WebSocket connected');
                onlineConnected = true;
                updateOnlineStatus();
                
                // è·å–äº²å±å¡åˆ—è¡¨
                const onlineUserChar = await getOrCreateOnlineUserChar();
                if (onlineUserChar) {
                    onlineSocket.send(JSON.stringify({
                        type: 'get_family_cards',
                        my_wx_account: onlineUserChar.identity.account
                    }));
                }
                
                // å¦‚æœæœ‰tokenï¼Œå‘é€è®¤è¯
                if (onlineToken) {
                    onlineSocket.send(JSON.stringify({
                        type: 'auth',
                        token: onlineToken
                    }));
                }
                
                // å¯åŠ¨å¿ƒè·³å®šæ—¶å™¨ï¼Œæ¯25ç§’å‘é€ä¸€æ¬¡å¿ƒè·³
                if (window.onlineHeartbeatTimer) {
                    clearInterval(window.onlineHeartbeatTimer);
                }
                window.onlineHeartbeatTimer = setInterval(() => {
                    if (onlineConnected && onlineSocket && onlineSocket.readyState === WebSocket.OPEN) {
                        onlineSocket.send(JSON.stringify({ type: 'ping' }));
                    }
                }, 25000);
                
                resolve();
            };
            
            onlineSocket.onmessage = (event) => {
                handleOnlineMessage(JSON.parse(event.data));
            };
            
            onlineSocket.onclose = () => {
                console.log('[Online] WebSocket disconnected');
                onlineConnected = false;
                onlineCharacters = []; // æ¸…ç©ºåœ¨çº¿è§’è‰²åˆ—è¡¨
                updateOnlineStatus();
                
                // æ¸…é™¤å¿ƒè·³å®šæ—¶å™¨
                if (window.onlineHeartbeatTimer) {
                    clearInterval(window.onlineHeartbeatTimer);
                    window.onlineHeartbeatTimer = null;
                }
            };
            
            onlineSocket.onerror = (error) => {
                console.error('[Online] WebSocket error:', error);
                onlineConnected = false;
                updateOnlineStatus();
                reject(new Error('è¿æ¥å¤±è´¥'));
            };
            
            // è®¾ç½®è¶…æ—¶
            setTimeout(() => {
                if (!onlineConnected) {
                    onlineSocket.close();
                    reject(new Error('è¿æ¥è¶…æ—¶'));
                }
            }, 10000);
            
        } catch (e) {
            reject(e);
        }
    });
}

// å¤„ç†æœåŠ¡å™¨æ¶ˆæ¯
async function handleOnlineMessage(data) {
    // å¿ƒè·³å“åº”ä¸éœ€è¦æ‰“å°æ—¥å¿—
    if (data.type === 'pong') return;
    
    console.log('[Online] Received:', data);
    
    switch (data.type) {
        case 'auth_success':
            onlineUserData = data.user;
            localStorage.setItem('online_user_data', JSON.stringify(data.user));
            updateOnlineStatus();
            // âœ… è®¤è¯æˆåŠŸåï¼Œé‡ç½®æç¤ºæ ‡å¿—ä½
            hasShownAuthFailedAlert = false;
            console.log('[Online] è®¤è¯æˆåŠŸï¼Œè‡ªåŠ¨æ³¨å†Œæ‰€æœ‰è§’è‰²åˆ°æœåŠ¡å™¨...');
            // å…ˆæ³¨å†Œæ‰€æœ‰è§’è‰²åˆ°æœåŠ¡å™¨ï¼ˆä¸ä¸Šçº¿ï¼Œä»…ç”¨äºæœç´¢ï¼‰
            await autoRegisterAllUserCharacters();
            // è·å–å·²ä¸Šçº¿çš„è§’è‰²ï¼Œç„¶åè‡ªåŠ¨ä¸Šçº¿æœ¬åœ°è§’è‰²
            requestOnlineCharacters();
            // âœ… è‡ªåŠ¨ä¸Šçº¿æ‰€æœ‰ User ç±»å‹çš„è§’è‰²ï¼ˆè§’è‰²ä¸Šçº¿åä¼šé€šè¿‡ character_online äº‹ä»¶è‡ªåŠ¨è·å–ç¾¤èŠåˆ—è¡¨ï¼‰
            autoGoOnlineAllUserCharacters();
            break;
            
        case 'auth_failed':
            onlineToken = null;
            onlineUserData = null;
            localStorage.removeItem('online_token');
            localStorage.removeItem('online_user_data');
            updateOnlineStatus();
            
            // âœ… é¿å…é‡è¿æ—¶åå¤å¼¹çª—ï¼šåªåœ¨é¦–æ¬¡å¤±è´¥æ—¶å¼¹å‡º alertï¼Œåç»­åªè®°å½•æ—¥å¿—å’Œä½¿ç”¨ toast
            const errorMsg = data.message || 'è®¤è¯å¤±è´¥';
            if (!hasShownAuthFailedAlert) {
                // é¦–æ¬¡æç¤ºï¼šä½¿ç”¨ alert
                hasShownAuthFailedAlert = true;
                if (errorMsg.includes('è¿‡æœŸ') || errorMsg.includes('æ— æ•ˆ') || errorMsg.includes('expired') || errorMsg.includes('invalid')) {
                    alert('ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•ï¼ˆä¸è¦æ³¨å†Œæ–°è´¦å·ï¼Œä½¿ç”¨ä¹‹å‰çš„ç”¨æˆ·åå’Œå¯†ç ç™»å½•ï¼‰');
                    // æ˜¾ç¤ºç™»å½•å¼¹çª—
                    showOnlineLoginModal();
                } else {
                    alert('ç™»å½•å¤±è´¥: ' + errorMsg);
                }
            } else {
                // åç»­é‡è¿æ—¶ï¼šåªä½¿ç”¨é™é»˜çš„ toast æç¤ºæˆ–æ§åˆ¶å°æ—¥å¿—
                console.log('[Online] è®¤è¯å¤±è´¥ï¼ˆå·²æç¤ºè¿‡ï¼‰:', errorMsg);
                // ä½¿ç”¨éä¾µå…¥å¼çš„ toast æ›¿ä»£ alert
                showToast('ç™»å½•å·²è¿‡æœŸï¼Œè¯·ç‚¹å‡»è”æœºæŒ‰é’®é‡æ–°ç™»å½•');
            }
            break;
            
        case 'login_success':
            onlineToken = data.token;
            onlineUserData = data.user;
            localStorage.setItem('online_token', data.token);
            localStorage.setItem('online_user_data', JSON.stringify(data.user));
            updateOnlineStatus();
            // âœ… ç™»å½•æˆåŠŸåï¼Œé‡ç½®æç¤ºæ ‡å¿—ä½
            hasShownAuthFailedAlert = false;
            closeModal('online-login-modal');
            showToast('ç™»å½•æˆåŠŸ');
            console.log('[Online] ç™»å½•æˆåŠŸï¼Œè‡ªåŠ¨æ³¨å†Œæ‰€æœ‰è§’è‰²åˆ°æœåŠ¡å™¨...');
            // å…ˆæ³¨å†Œæ‰€æœ‰è§’è‰²åˆ°æœåŠ¡å™¨ï¼ˆä¸ä¸Šçº¿ï¼Œä»…ç”¨äºæœç´¢ï¼‰
            await autoRegisterAllUserCharacters();
            requestOnlineCharacters();
            // âœ… è‡ªåŠ¨ä¸Šçº¿æ‰€æœ‰ User ç±»å‹çš„è§’è‰²
            autoGoOnlineAllUserCharacters();
            break;
            
        case 'register_success':
            onlineToken = data.token;
            onlineUserData = data.user;
            localStorage.setItem('online_token', data.token);
            localStorage.setItem('online_user_data', JSON.stringify(data.user));
            updateOnlineStatus();
            closeModal('online-register-modal');
            showToast('æ³¨å†ŒæˆåŠŸ');
            break;
            
        case 'error':
            alert(data.message || 'æ“ä½œå¤±è´¥');
            break;
            
        case 'search_result':
            displayOnlineSearchResult(data.result);
            break;
            
        case 'friend_request':
            // æ”¶åˆ°å¥½å‹ç”³è¯·
            handleOnlineFriendRequest(data.request);
            break;
            
        case 'friend_request_accepted':
            // å¥½å‹ç”³è¯·è¢«æ¥å—
            handleFriendRequestAccepted(data);
            break;
        
        case 'family_card_received':
            // æ”¶åˆ°äº²å±å¡
            handleFamilyCardReceived(data);
            break;
        
        case 'family_card_sent':
            // äº²å±å¡å‘é€æˆåŠŸ
            showToast('äº²å±å¡å·²èµ é€');
            // é‡æ–°è·å–äº²å±å¡åˆ—è¡¨
            const onlineUserChar = await getOrCreateOnlineUserChar();
            if (onlineUserChar && onlineSocket) {
                onlineSocket.send(JSON.stringify({
                    type: 'get_family_cards',
                    my_wx_account: onlineUserChar.identity.account
                }));
            }
            break;
        
        case 'family_card_used':
            // äº²å±å¡è¢«ä½¿ç”¨
            handleFamilyCardUsed(data);
            break;
        
        case 'family_card_payment_success':
            // ä½¿ç”¨äº²å±å¡æ”¯ä»˜æˆåŠŸ
            showToast('æ”¯ä»˜æˆåŠŸ');
            break;
        
        case 'family_cards_list':
            // æ”¶åˆ°äº²å±å¡åˆ—è¡¨
            handleFamilyCardsList(data);
            break;
            
        case 'message':
            // æ”¶åˆ°è”æœºæ¶ˆæ¯
            handleOnlineIncomingMessage(data);
            break;
            
        case 'online_characters':
            // å·²ä¸Šçº¿çš„è§’è‰²åˆ—è¡¨
            onlineCharacters = data.characters || [];
            console.log('[Online] æ”¶åˆ°åœ¨çº¿è§’è‰²åˆ—è¡¨:', onlineCharacters.length, 'ä¸ª', onlineCharacters.map(c => c.wx_account).join(', '));
            // åˆ·æ–°è”æœºçŠ¶æ€é¡µé¢ï¼ˆå¦‚æœæ‰“å¼€çš„è¯ï¼‰
            refreshOnlineStatusPageContent();
            break;
            
        case 'character_online':
            // è‡ªåŠ¨ä¸Šçº¿ï¼Œä¸éœ€è¦ Toast æç¤º
            console.log(`[Online] è§’è‰² ${data.nickname} å·²åŒæ­¥`);
            requestOnlineCharacters();
            // åˆ·æ–°è”æœºçŠ¶æ€é¡µé¢ï¼ˆå¦‚æœæ‰“å¼€çš„è¯ï¼‰
            refreshOnlineStatusPageContent();
            // âœ… è·å–è”æœºç¾¤èŠåˆ—è¡¨ï¼ˆä½¿ç”¨ç¬¬ä¸€ä¸ªä¸Šçº¿çš„è§’è‰²ï¼‰
            if (data.wx_account && onlineSocket && onlineSocket.readyState === WebSocket.OPEN) {
                console.log('[Online] è§’è‰²ä¸Šçº¿åï¼Œè‡ªåŠ¨è·å–ç¾¤èŠåˆ—è¡¨ï¼Œä½¿ç”¨å¾®ä¿¡å·:', data.wx_account);
                onlineSocket.send(JSON.stringify({
                    type: 'get_online_groups',
                    my_wx_account: data.wx_account
                }));
            }
            break;
            
        case 'character_offline':
            // è‡ªåŠ¨å¤„ç†ï¼Œä¸éœ€è¦ Toast æç¤º
            console.log('[Online] è§’è‰²å·²ç¦»çº¿');
            requestOnlineCharacters();
            // åˆ·æ–°è”æœºçŠ¶æ€é¡µé¢ï¼ˆå¦‚æœæ‰“å¼€çš„è¯ï¼‰
            refreshOnlineStatusPageContent();
            break;
        
        // ==================== è”æœºç¾¤èŠæ¶ˆæ¯ ====================
        case 'online_group_created':
            // ç¾¤èŠåˆ›å»ºæˆåŠŸ
            showToast(`ç¾¤èŠ"${data.group.name}"åˆ›å»ºæˆåŠŸ`);
            onlineGroups.push(data.group);
            refreshOnlineGroupList();
            // åŒæ—¶åœ¨æœ¬åœ°åˆ›å»ºç¾¤èŠè®°å½•ï¼Œè®©å®ƒæ˜¾ç¤ºåœ¨æ¶ˆæ¯åˆ—è¡¨ä¸­
            await createLocalOnlineGroupChat(data.group);
            break;
            
        case 'group_invite':
            // æ”¶åˆ°ç¾¤èŠé‚€è¯·
            handleOnlineGroupInvite(data);
            break;
            
        case 'online_group_joined':
            // åŠ å…¥ç¾¤èŠæˆåŠŸ
            showToast(`å·²åŠ å…¥ç¾¤èŠ"${data.group.name}"`);
            if (!onlineGroups.find(g => g.id === data.group.id)) {
                onlineGroups.push(data.group);
            }
            refreshOnlineGroupList();
            // åŒæ—¶åœ¨æœ¬åœ°åˆ›å»ºç¾¤èŠè®°å½•ï¼Œè®©å®ƒæ˜¾ç¤ºåœ¨æ¶ˆæ¯åˆ—è¡¨ä¸­
            await createLocalOnlineGroupChat(data.group);
            break;
            
        case 'group_member_joined':
            // æœ‰æ–°æˆå‘˜åŠ å…¥ç¾¤èŠ
            if (currentOnlineGroupId === data.group_id) {
                showToast(`${data.member.user_name} åŠ å…¥äº†ç¾¤èŠ`);
                refreshOnlineGroupMembers();
            }
            break;
            
        case 'online_groups_list':
            // æ”¶åˆ°ç¾¤èŠåˆ—è¡¨
            onlineGroups = data.groups || [];
            refreshOnlineGroupList();
            // ä¸ºæ¯ä¸ªç¾¤èŠåˆ›å»ºæœ¬åœ°è®°å½•
            for (const group of onlineGroups) {
                await createLocalOnlineGroupChat(group);
            }
            break;
            
        case 'group_messages':
            // æ”¶åˆ°ç¾¤èŠæ¶ˆæ¯è®°å½•
            handleOnlineGroupMessages(data);
            break;
            
        case 'group_message':
            // æ”¶åˆ°å®æ—¶ç¾¤æ¶ˆæ¯
            handleOnlineGroupMessage(data);
            break;
            
        case 'group_typing_start':
            // æ”¶åˆ°ç¾¤æˆå‘˜æ­£åœ¨è¾“å…¥çš„é€šçŸ¥
            handleGroupTypingStart(data);
            break;
            
        case 'group_typing_stop':
            // æ”¶åˆ°ç¾¤æˆå‘˜åœæ­¢è¾“å…¥çš„é€šçŸ¥
            handleGroupTypingStop(data);
            break;
            
        case 'group_members':
            // æ”¶åˆ°ç¾¤æˆå‘˜åˆ—è¡¨
            handleOnlineGroupMembers(data);
            break;
            
        case 'group_character_updated':
            // è§’è‰²æ›´æ–°æˆåŠŸ
            showToast('ç¾¤å†…è§’è‰²å·²æ›´æ–°');
            break;
            
        case 'redpacket_claimed':
            // çº¢åŒ…è¢«é¢†å–ï¼Œæ›´æ–°çº¢åŒ…çŠ¶æ€
            handleRedPacketClaimed(data);
            break;
    }
}

// æ˜¾ç¤ºç™»å½•å¼¹çª—
function showOnlineLoginModal() {
    const serverUrl = document.getElementById('online-server-url').value.trim();
    if (!serverUrl) {
        alert('è¯·å…ˆå¡«å†™æœåŠ¡å™¨åœ°å€');
        return;
    }
    document.getElementById('online-login-modal').style.display = 'flex';
}

// æ˜¾ç¤ºæ³¨å†Œå¼¹çª—
function showOnlineRegisterModal() {
    const serverUrl = document.getElementById('online-server-url').value.trim();
    if (!serverUrl) {
        alert('è¯·å…ˆå¡«å†™æœåŠ¡å™¨åœ°å€');
        return;
    }
    document.getElementById('online-register-modal').style.display = 'flex';
}

// æ‰§è¡Œç™»å½•
async function doOnlineLogin() {
    const username = document.getElementById('online-login-username').value.trim();
    const password = document.getElementById('online-login-password').value;
    
    if (!username || !password) {
        alert('è¯·å¡«å†™ç”¨æˆ·åå’Œå¯†ç ');
        return;
    }
    
    // ç¡®ä¿å·²è¿æ¥
    if (!onlineConnected) {
        try {
            await connectToOnlineServer();
        } catch (e) {
            alert('æ— æ³•è¿æ¥æœåŠ¡å™¨: ' + e.message);
            return;
        }
    }
    
    onlineSocket.send(JSON.stringify({
        type: 'login',
        username: username,
        password: password
    }));
}

// æ‰§è¡Œæ³¨å†Œ
async function doOnlineRegister() {
    const username = document.getElementById('online-register-username').value.trim();
    const email = document.getElementById('online-register-email').value.trim();
    const password = document.getElementById('online-register-password').value;
    const password2 = document.getElementById('online-register-password2').value;
    
    if (!username) {
        alert('è¯·å¡«å†™ç”¨æˆ·å');
        return;
    }
    
    if (!/^[a-zA-Z0-9_]{3,20}$/.test(username)) {
        alert('ç”¨æˆ·ååªèƒ½åŒ…å«å­—æ¯ã€æ•°å­—å’Œä¸‹åˆ’çº¿ï¼Œé•¿åº¦3-20ä½');
        return;
    }
    
    if (!password || password.length < 6) {
        alert('å¯†ç è‡³å°‘6ä½');
        return;
    }
    
    if (password !== password2) {
        alert('ä¸¤æ¬¡è¾“å…¥çš„å¯†ç ä¸ä¸€è‡´');
        return;
    }
    
    // ç¡®ä¿å·²è¿æ¥
    if (!onlineConnected) {
        try {
            await connectToOnlineServer();
        } catch (e) {
            alert('æ— æ³•è¿æ¥æœåŠ¡å™¨: ' + e.message);
            return;
        }
    }
    
    onlineSocket.send(JSON.stringify({
        type: 'register',
        username: username,
        email: email || null,
        password: password
    }));
}

// é€€å‡ºç™»å½•
function onlineLogout() {
    if (confirm('ç¡®å®šè¦é€€å‡ºè”æœºç™»å½•å—ï¼Ÿ')) {
        onlineToken = null;
        onlineUserData = null;
        onlineCharacters = [];
        localStorage.removeItem('online_token');
        localStorage.removeItem('online_user_data');
        updateOnlineStatus();
        
        if (onlineSocket) {
            onlineSocket.send(JSON.stringify({ type: 'logout' }));
        }
        
        showToast('å·²é€€å‡ºç™»å½•');
    }
}

// æ˜¾ç¤ºè”æœºæœç´¢å¼¹çª—
async function showOnlineSearchModal() {
    toggleWechatMenu(); // å…³é—­èœå•
    
    if (!onlineConnected || !onlineUserData) {
        alert('è¯·å…ˆåœ¨è®¾ç½®ä¸­è¿æ¥æœåŠ¡å™¨å¹¶ç™»å½•');
        return;
    }
    
    // âœ… æ£€æŸ¥æ˜¯å¦æœ‰å¯ç”¨çš„Userè§’è‰²ï¼ˆæœ‰å¾®ä¿¡å·ï¼‰
    const userChars = await db.characters.where('type').equals('user').toArray();
    const availableChars = userChars.filter(c => c.identity?.account);
    
    if (availableChars.length === 0) {
        alert('è¯·å…ˆåˆ›å»ºè‡³å°‘ä¸€ä¸ªUserè§’è‰²å¹¶è®¾ç½®å¾®ä¿¡å·');
        return;
    }
    
    // å¡«å……èº«ä»½é€‰æ‹©ä¸‹æ‹‰æ¡† - ä½¿ç”¨æœ¬åœ°Userè§’è‰²åˆ—è¡¨
    const select = document.getElementById('online-search-my-persona');
    select.innerHTML = availableChars.map(char => 
        `<option value="${char.identity.account}">${char.remark || char.wx_nickname || char.name} (${char.identity.account})</option>`
    ).join('');
    
    // æ¸…ç©ºä¹‹å‰çš„æœç´¢ç»“æœ
    document.getElementById('online-search-input').value = '';
    document.getElementById('online-search-result').style.display = 'none';
    document.getElementById('online-search-empty').style.display = 'none';
    document.getElementById('online-search-message').value = '';
    
    document.getElementById('online-search-modal').style.display = 'flex';
}

// æ‰§è¡Œè”æœºæœç´¢
function doOnlineSearch() {
    const wxAccount = document.getElementById('online-search-input').value.trim();
    
    if (!wxAccount) {
        alert('è¯·è¾“å…¥è¦æœç´¢çš„è™šæ‹Ÿå¾®ä¿¡å·');
        return;
    }
    
    if (!onlineConnected) {
        alert('æœåŠ¡å™¨æœªè¿æ¥ï¼Œè¯·å…ˆè¿æ¥æœåŠ¡å™¨');
        return;
    }
    
    if (!onlineSocket || onlineSocket.readyState !== WebSocket.OPEN) {
        alert('WebSocket è¿æ¥æœªå»ºç«‹ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨è¿æ¥');
        return;
    }
    
    console.log('[Online] æœç´¢å¾®ä¿¡å·:', wxAccount);
    
    // æ˜¾ç¤ºæœç´¢ä¸­çŠ¶æ€
    const resultEl = document.getElementById('online-search-result');
    const emptyEl = document.getElementById('online-search-empty');
    if (resultEl) resultEl.style.display = 'none';
    if (emptyEl) {
        emptyEl.style.display = 'block';
        emptyEl.innerHTML = '<div style="text-align:center; padding:20px; color:#999;">æœç´¢ä¸­...</div>';
    }
    
    try {
        onlineSocket.send(JSON.stringify({
            type: 'search_user',
            wx_account: wxAccount
        }));
        console.log('[Online] æœç´¢è¯·æ±‚å·²å‘é€');
    } catch (e) {
        console.error('[Online] å‘é€æœç´¢è¯·æ±‚å¤±è´¥:', e);
        alert('æœç´¢å¤±è´¥: ' + e.message);
    }
}

// æ˜¾ç¤ºæœç´¢ç»“æœ
function displayOnlineSearchResult(result) {
    console.log('[Online] æ”¶åˆ°æœç´¢ç»“æœ:', result);
    
    const resultEl = document.getElementById('online-search-result');
    const emptyEl = document.getElementById('online-search-empty');
    
    if (!result) {
        console.log('[Online] æœç´¢ç»“æœä¸ºç©º');
        if (resultEl) resultEl.style.display = 'none';
        if (emptyEl) {
            emptyEl.style.display = 'block';
            emptyEl.innerHTML = '<div style="text-align:center; padding:20px; color:#999;">æœªæ‰¾åˆ°è¯¥å¾®ä¿¡å·<br><span style="font-size:12px; color:#ccc;">æç¤ºï¼šåªæœ‰è§’è‰²ä¸Šçº¿åæ‰èƒ½è¢«æœç´¢åˆ°</span></div>';
        }
        return;
    }
    
    console.log('[Online] æ˜¾ç¤ºæœç´¢ç»“æœ:', result.nickname);
    
    if (emptyEl) emptyEl.style.display = 'none';
    if (resultEl) {
        resultEl.style.display = 'block';
        
        // å¡«å……ç»“æœ
        const avatarEl = document.getElementById('online-search-avatar');
        const nicknameEl = document.getElementById('online-search-nickname');
        const wxidEl = document.getElementById('online-search-wxid');
        const bioEl = document.getElementById('online-search-bio');
        const statusEl = document.getElementById('online-search-online-status');
        
        if (avatarEl) {
            avatarEl.style.backgroundImage = result.avatar ? `url(${result.avatar})` : '';
        }
        if (nicknameEl) {
            nicknameEl.textContent = result.nickname || 'æœªè®¾ç½®æ˜µç§°';
        }
        if (wxidEl) {
            wxidEl.textContent = result.wx_account;
        }
        // éšè— bioï¼ˆäººè®¾ï¼‰ï¼Œä¿æŠ¤éšç§
        if (bioEl) {
            bioEl.style.display = 'none';
        }
        
        if (statusEl) {
            if (result.is_online) {
                statusEl.textContent = 'åœ¨çº¿';
                statusEl.style.background = '#e8f5e9';
                statusEl.style.color = '#4caf50';
            } else {
                statusEl.textContent = 'ç¦»çº¿';
                statusEl.style.background = '#f5f5f5';
                statusEl.style.color = '#999';
            }
        }
        
        // ä¿å­˜æœç´¢ç»“æœä¾›å‘é€ç”³è¯·ä½¿ç”¨
        resultEl.dataset.wxAccount = result.wx_account;
    }
}

// å‘é€è”æœºå¥½å‹ç”³è¯·
function sendOnlineFriendRequest() {
    const resultEl = document.getElementById('online-search-result');
    const toWxAccount = resultEl.dataset.wxAccount;
    const fromWxAccount = document.getElementById('online-search-my-persona').value;
    const message = document.getElementById('online-search-message').value.trim();
    
    if (!toWxAccount || !fromWxAccount) {
        alert('è¯·é€‰æ‹©ä½ çš„èº«ä»½');
        return;
    }
    
    onlineSocket.send(JSON.stringify({
        type: 'friend_request',
        from_wx_account: fromWxAccount,
        to_wx_account: toWxAccount,
        message: message || 'è¯·æ±‚æ·»åŠ ä½ ä¸ºå¥½å‹'
    }));
    
    closeModal('online-search-modal');
    showToast('å¥½å‹ç”³è¯·å·²å‘é€');
}

// å¤„ç†æ”¶åˆ°çš„å¥½å‹ç”³è¯·
async function handleOnlineFriendRequest(request) {
    console.log('[Online] æ”¶åˆ°å¥½å‹ç”³è¯·:', request);
    
    // åˆ›å»ºä¸€ä¸ªé€šçŸ¥
    sendSystemNotification('æ–°çš„å¥½å‹ç”³è¯·', `${request.from_nickname} (${request.from_wx_account}) æƒ³æ·»åŠ ä½ ä¸ºå¥½å‹`);
    
    // å°†ç”³è¯·ä¿å­˜åˆ°æœ¬åœ°å¥½å‹ç”³è¯·åˆ—è¡¨
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    await db.friend_requests.add({
        fromCharId: null, // è”æœºå¥½å‹æ²¡æœ‰æœ¬åœ°charId
        toAccountId: accountId,
        status: 'pending',
        time: Date.now(),
        isOnline: true, // æ ‡è®°ä¸ºè”æœºå¥½å‹ç”³è¯·
        onlineData: request // ä¿å­˜è”æœºæ•°æ®
    });
    
    // åˆ·æ–°æ–°çš„å¥½å‹é¡µé¢
    if (document.getElementById('new-friends-page').style.display !== 'none') {
        renderNewFriendsPage();
    }
}

// å¥½å‹ç”³è¯·è¢«æ¥å—
async function handleFriendRequestAccepted(data) {
    console.log('[Online] å¥½å‹ç”³è¯·è¢«æ¥å—:', data);
    
    // åœ¨æœ¬åœ°åˆ›å»ºä¸€ä¸ªè”æœºå¥½å‹è§’è‰²
    const accountId = getCurrentAccountId();
    const newChar = {
        name: data.friend_nickname,
        type: 'online_friend', // ç‰¹æ®Šç±»å‹ï¼šè”æœºå¥½å‹
        avatar: data.friend_avatar || '',
        description: data.friend_bio || '',
        identity: {
            account: data.friend_wx_account
        },
        isOnlineFriend: true,
        onlineData: {
            wx_account: data.friend_wx_account,
            user_id: data.friend_user_id
        },
        wechat_status_by_user: {}  // ä½¿ç”¨æ­£ç¡®çš„å­—æ®µåï¼Œä¸ getFriendStatus åŒ¹é…
    };
    
    // è®¾ç½®å¥½å‹å…³ç³»
    if (accountId) {
        newChar.wechat_status_by_user[accountId] = 'friend';
    }
    
    const charId = await db.characters.add(newChar);
    
    showToast(`${data.friend_nickname} å·²æˆä¸ºä½ çš„å¥½å‹`);
    
    // åˆ·æ–°å¾®ä¿¡åˆ—è¡¨
    const content = document.getElementById('wechat-content');
    if (content) {
        renderWechatList(content);
    }
}

// å¤„ç†æ”¶åˆ°çš„è”æœºæ¶ˆæ¯
async function handleOnlineIncomingMessage(data) {
    console.log('[Online] æ”¶åˆ°æ¶ˆæ¯:', data);
    
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    // æŸ¥æ‰¾æœ¬åœ°å¯¹åº”çš„è”æœºå¥½å‹è§’è‰²
    const chars = await db.characters.where('type').equals('online_friend').toArray();
    let targetChar = chars.find(c => c.onlineData?.wx_account === data.from_wx_account);
    
    if (!targetChar) {
        console.warn('[Online] æœªæ‰¾åˆ°å¯¹åº”çš„è”æœºå¥½å‹è§’è‰²');
        return;
    }
    
    // âœ… æ›´æ–°å¥½å‹çš„å¤´åƒï¼ˆå¦‚æœæœåŠ¡å™¨å‘é€äº†æ–°å¤´åƒï¼‰
    if (data.from_avatar && data.from_avatar !== targetChar.avatar) {
        console.log('[Online] æ›´æ–°å¥½å‹å¤´åƒ:', data.from_wx_account);
        targetChar.avatar = data.from_avatar;
        await db.characters.put(targetChar);
        targetChar = await db.characters.get(targetChar.id);
    }
    
    // âœ… ç¡®ä¿è”æœºå¥½å‹åœ¨å½“å‰è´¦å·ä¸‹çš„å¥½å‹çŠ¶æ€æ˜¯ 'friend'
    // è¿™æ ·åˆ‡æ¢è´¦å·åæ¶ˆæ¯ä¹Ÿèƒ½æ­£å¸¸æ˜¾ç¤º
    const currentFriendStatus = getFriendStatus(targetChar, accountId);
    if (currentFriendStatus !== 'friend') {
        console.log('[Online] ä¸ºå½“å‰è´¦å·è®¾ç½®è”æœºå¥½å‹çŠ¶æ€ä¸º friend');
        if (!targetChar.wechat_status_by_user) targetChar.wechat_status_by_user = {};
        targetChar.wechat_status_by_user[accountId] = 'friend';
        // æ›´æ–°åé‡æ–°è·å–ï¼Œç¡®ä¿åç»­é€»è¾‘ä½¿ç”¨æœ€æ–°æ•°æ®
        await db.characters.put(targetChar);
        targetChar = await db.characters.get(targetChar.id);
    }
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯ç‰¹æ®Šæ¶ˆæ¯ç±»å‹ï¼ˆå¦‚è½¬è´¦ï¼‰
    let msgObj = {
        role: 'char',
        content: data.content,
        time: data.timestamp || Date.now(),
        isOnlineMessage: true
    };
    
    // å°è¯•è§£æ JSON æ ¼å¼çš„ç‰¹æ®Šæ¶ˆæ¯
    try {
        const parsed = JSON.parse(data.content);
        if (parsed.__type === 'transfer') {
            // è¿™æ˜¯è½¬è´¦æ¶ˆæ¯ï¼Œè½¬æ¢ä¸ºè½¬è´¦å¡ç‰‡æ ¼å¼
            msgObj.type = 'transfer';
            msgObj.content = JSON.stringify({
                amount: parsed.amount,
                desc: parsed.desc,
                status: 'sent'  // å¯¹äºæ¥æ”¶æ–¹æ¥è¯´æ˜¯å¾…æ¥æ”¶çŠ¶æ€
            });
            msgObj.id = 'trans_' + Date.now();
            console.log('[Online] æ”¶åˆ°è½¬è´¦æ¶ˆæ¯:', parsed);
        } else if (parsed.__type === 'familyCard') {
            // ğŸ¯ è¿™æ˜¯äº²å±å¡æ¶ˆæ¯ï¼ˆå’Œè½¬è´¦ä¸€æ ·çš„å¤„ç†æ–¹å¼ï¼‰
            msgObj.type = 'familyCard';
            msgObj.content = JSON.stringify({
                fromName: parsed.fromName || data.from_nickname,
                monthlyLimit: parsed.monthlyLimit || 0,
                status: 'received',
                isOnline: true,
                message: parsed.message || ''
            });
            console.log('[Online] æ”¶åˆ°äº²å±å¡æ¶ˆæ¯:', parsed);
        } else if (parsed.__type === 'audio') {
            // è¿™æ˜¯è¯­éŸ³æ¶ˆæ¯
            msgObj.type = 'audio';
            msgObj.content = parsed.audio;
            msgObj.duration = parsed.duration;
            msgObj.effect = parsed.effect;
            console.log('[Online] æ”¶åˆ°è¯­éŸ³æ¶ˆæ¯, æ—¶é•¿:', parsed.duration, 'ç§’, æ•ˆæœ:', parsed.effect);
        }
    } catch (e) {
        // ä¸æ˜¯ JSONï¼Œæ™®é€šæ–‡æœ¬æ¶ˆæ¯
    }
    
    // ä¿å­˜æ¶ˆæ¯åˆ°èŠå¤©å†å²
    let history = getChatHistory(targetChar, accountId);
    history.push(msgObj);
    await setChatHistory(targetChar, accountId, history);
    
    // å¦‚æœå½“å‰æ­£åœ¨æŸ¥çœ‹è¿™ä¸ªèŠå¤©ï¼Œæ›´æ–°UI
    if (currentChatCharId === targetChar.id) {
        // ç‰¹æ®Šæ¶ˆæ¯ç±»å‹éœ€è¦é‡æ–°æ¸²æŸ“æ•´ä¸ªèŠå¤©ï¼ˆåŒ…æ‹¬å›¾ç‰‡ã€è½¬è´¦ã€è¯­éŸ³ã€äº²å±å¡ï¼‰
        if (msgObj.type === 'transfer' || msgObj.type === 'familyCard' || msgObj.type === 'audio' || data.content.startsWith('[img:')) {
            renderChatBody(targetChar);
        } else {
            // âœ… ä½¿ç”¨æœåŠ¡å™¨å‘é€çš„å¤´åƒï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨æœ¬åœ°å¤´åƒ
            const avatarToUse = data.from_avatar || targetChar.avatar;
            appendMessageToUI('char', data.content, avatarToUse);
        }
    } else {
        // å‘é€é€šçŸ¥
        let notifyContent = data.content;
        if (msgObj.type === 'transfer') notifyContent = '[è½¬è´¦]';
        if (msgObj.type === 'familyCard') notifyContent = '[äº²å±å¡]';
        if (msgObj.type === 'audio') notifyContent = '[è¯­éŸ³æ¶ˆæ¯]';
        if (data.content.startsWith('[img:')) notifyContent = '[å›¾ç‰‡]';
        sendSystemNotification(targetChar.name, notifyContent);
    }
}

// ==================== äº²å±å¡å¤„ç†å‡½æ•° ====================

// å¤„ç†æ”¶åˆ°äº²å±å¡
async function handleFamilyCardReceived(data) {
    console.log('[Online] æ”¶åˆ°äº²å±å¡:', data);
    
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    // æŸ¥æ‰¾å¯¹åº”çš„è”æœºå¥½å‹è§’è‰²
    const chars = await db.characters.where('type').equals('online_friend').toArray();
    let friendChar = chars.find(c => c.onlineData?.wx_account === data.from_wx_account);
    
    if (!friendChar) {
        console.warn('[Online] æœªæ‰¾åˆ°å¯¹åº”çš„è”æœºå¥½å‹');
        return;
    }
    
    // ä¿å­˜äº²å±å¡æ¶ˆæ¯åˆ°èŠå¤©è®°å½•
    let history = getChatHistory(friendChar, accountId);
    const familyCardMsg = {
        role: 'char',
        type: 'familyCard',
        content: JSON.stringify({
            fromName: data.from_nickname,
            from_wx_account: data.from_wx_account,
            monthlyLimit: data.monthly_limit,
            status: 'received',
            isOnline: true
        }),
        time: Date.now()
    };
    
    history.push(familyCardMsg);
    await setChatHistory(friendChar, accountId, history);
    
    // å¦‚æœå½“å‰æ­£åœ¨æŸ¥çœ‹è¯¥èŠå¤©ï¼Œåˆ·æ–°æ˜¾ç¤º
    if (currentChatCharId === friendChar.id) {
        renderChatBody(friendChar);
    }
    
    // å‘é€é€šçŸ¥
    showToast(`${data.from_nickname} èµ é€äº†äº²å±å¡`);
    sendSystemNotification(friendChar.name, '[äº²å±å¡]');
    
    // é‡æ–°è·å–äº²å±å¡åˆ—è¡¨
    const onlineUserChar = await getOrCreateOnlineUserChar();
    if (onlineUserChar && onlineSocket) {
        onlineSocket.send(JSON.stringify({
            type: 'get_family_cards',
            my_wx_account: onlineUserChar.identity.account
        }));
    }
}

// å¤„ç†äº²å±å¡è¢«ä½¿ç”¨
async function handleFamilyCardUsed(data) {
    console.log('[Online] äº²å±å¡è¢«ä½¿ç”¨:', data);
    
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    // æŸ¥æ‰¾å¯¹åº”çš„è”æœºå¥½å‹è§’è‰²
    const chars = await db.characters.where('type').equals('online_friend').toArray();
    let friendChar = chars.find(c => c.onlineData?.wx_account === data.user_wx_account);
    
    if (!friendChar) {
        console.warn('[Online] æœªæ‰¾åˆ°å¯¹åº”çš„è”æœºå¥½å‹');
        return;
    }
    
    // æ˜¾ç¤ºé€šçŸ¥
    showToast(`${data.user_nickname} ä½¿ç”¨äº†æ‚¨çš„äº²å±å¡ Â¥${data.amount}`);
    
    // æ·»åŠ æµæ°´è®°å½•åˆ°æœ¬åœ°
    const user = await db.characters.get(parseInt(accountId));
    if (user) {
        if (!user.identity) user.identity = {};
        if (!user.identity.familyCardRecords) user.identity.familyCardRecords = [];
        
        user.identity.familyCardRecords.push({
            type: 'expense',
            user_wx_account: data.user_wx_account,
            user_nickname: data.user_nickname,
            amount: data.amount,
            description: data.description,
            used_this_month: data.used_this_month,
            monthly_limit: data.monthly_limit,
            time: Date.now()
        });
        
        await db.characters.put(user);
    }
}

// å¤„ç†äº²å±å¡åˆ—è¡¨
async function handleFamilyCardsList(data) {
    console.log('[Online] æ”¶åˆ°äº²å±å¡åˆ—è¡¨:', data);
    
    // ä¿å­˜åˆ°æœ¬åœ°ç¼“å­˜
    localStorage.setItem('online_family_cards_given', JSON.stringify(data.given || []));
    localStorage.setItem('online_family_cards_received', JSON.stringify(data.received || []));
    
    // å¦‚æœäº²å±å¡é¡µé¢æ‰“å¼€ç€ï¼Œåˆ·æ–°æ˜¾ç¤º
    const familyCardPage = document.getElementById('family-card-page');
    if (familyCardPage && familyCardPage.style.display !== 'none') {
        renderFamilyCardList();
    }
}

// ==================== äº²å±å¡å¤„ç†å‡½æ•°ç»“æŸ ====================

// è¯·æ±‚å·²ä¸Šçº¿çš„è§’è‰²åˆ—è¡¨
function requestOnlineCharacters() {
    if (!onlineConnected || !onlineUserData) return;
    
    onlineSocket.send(JSON.stringify({
        type: 'get_online_characters'
    }));
}

// ä¸Šçº¿è§’è‰²
async function goOnlineWithCharacter(charId) {
    if (!onlineConnected || !onlineUserData) {
        alert('è¯·å…ˆåœ¨è®¾ç½®ä¸­è¿æ¥æœåŠ¡å™¨å¹¶ç™»å½•');
        return;
    }
    
    const char = await db.characters.get(charId);
    if (!char || char.type !== 'user') {
        alert('åªèƒ½ä¸Šçº¿Userç±»å‹çš„è§’è‰²');
        return;
    }
    
    const wxAccount = char.identity?.account;
    if (!wxAccount) {
        alert('è¯¥è§’è‰²æ²¡æœ‰è®¾ç½®è™šæ‹Ÿå¾®ä¿¡å·ï¼Œè¯·å…ˆåœ¨WeChatä¸­æ³¨å†Œ');
        return;
    }
    
    onlineSocket.send(JSON.stringify({
        type: 'go_online',
        wx_account: wxAccount,
        nickname: char.remark || char.wx_nickname || char.name,
        avatar: char.avatar || '',
        bio: char.description?.substring(0, 100) || '',
        local_char_id: charId
    }));
}

// ä¸‹çº¿è§’è‰²
function goOfflineWithCharacter(wxAccount) {
    if (!onlineConnected) return;
    
    onlineSocket.send(JSON.stringify({
        type: 'go_offline',
        wx_account: wxAccount
    }));
}

// âœ… è‡ªåŠ¨ä¸Šçº¿æ‰€æœ‰ User ç±»å‹çš„è§’è‰²
// è‡ªåŠ¨æ³¨å†Œæ‰€æœ‰ User ç±»å‹è§’è‰²åˆ°æœåŠ¡å™¨ï¼ˆä¸ä¸Šçº¿ï¼Œä»…ç”¨äºæœç´¢ï¼‰
async function autoRegisterAllUserCharacters() {
    if (!onlineConnected || !onlineUserData) {
        console.log('[Online] æœªè¿æ¥æˆ–æœªç™»å½•ï¼Œè·³è¿‡è‡ªåŠ¨æ³¨å†Œ');
        return;
    }
    
    try {
        // è·å–æ‰€æœ‰ User ç±»å‹çš„è§’è‰²
        const userChars = await db.characters.where('type').equals('user').toArray();
        
        let registerCount = 0;
        for (const char of userChars) {
            const wxAccount = char.identity?.account;
            const nickname = char.remark || char.wx_nickname || char.name;
            
            // éªŒè¯å¿…å¡«å­—æ®µ
            if (!wxAccount || !nickname) {
                console.log(`[Online] è§’è‰² ${char.name} ç¼ºå°‘å¾®ä¿¡å·æˆ–æ˜µç§°ï¼Œè·³è¿‡æ³¨å†Œ`);
                continue;
            }
            
            // æ³¨å†Œè§’è‰²åˆ°æœåŠ¡å™¨ï¼ˆä¸ä¸Šçº¿ï¼Œis_online = 0ï¼‰
            console.log(`[Online] æ³¨å†Œè§’è‰²åˆ°æœåŠ¡å™¨: ${nickname} (${wxAccount})`);
            
            try {
                onlineSocket.send(JSON.stringify({
                    type: 'register_character',
                    wx_account: wxAccount,
                    nickname: nickname,
                    avatar: char.avatar || '',
                    bio: (char.description || '').substring(0, 100)
                }));
                registerCount++;
                
                // æ·»åŠ å°å»¶è¿Ÿé¿å…è¯·æ±‚è¿‡å¿«
                await new Promise(resolve => setTimeout(resolve, 100));
            } catch (sendError) {
                console.error(`[Online] æ³¨å†Œè§’è‰²å¤±è´¥: ${nickname}`, sendError);
            }
        }
        
        if (registerCount > 0) {
            console.log(`[Online] å·²æ³¨å†Œ ${registerCount} ä¸ªè§’è‰²åˆ°æœåŠ¡å™¨ï¼ˆå¯è¢«æœç´¢ï¼‰`);
        } else {
            console.log('[Online] æ²¡æœ‰å¯æ³¨å†Œçš„è§’è‰²ï¼ˆè¯·ç¡®ä¿ User è§’è‰²è®¾ç½®äº†å¾®ä¿¡å·ï¼‰');
        }
    } catch (e) {
        console.error('[Online] è‡ªåŠ¨æ³¨å†Œè§’è‰²å¤±è´¥:', e);
    }
}

async function autoGoOnlineAllUserCharacters() {
    if (!onlineConnected || !onlineUserData) {
        console.log('[Online] æœªè¿æ¥æˆ–æœªç™»å½•ï¼Œè·³è¿‡è‡ªåŠ¨ä¸Šçº¿');
        return;
    }
    
    try {
        // è·å–æ‰€æœ‰ User ç±»å‹çš„è§’è‰²
        const userChars = await db.characters.where('type').equals('user').toArray();
        
        let onlineCount = 0;
        for (const char of userChars) {
            const wxAccount = char.identity?.account;
            const nickname = char.remark || char.wx_nickname || char.name;
            
            // éªŒè¯å¿…å¡«å­—æ®µ
            if (!wxAccount || !nickname) {
                console.log(`[Online] è§’è‰² ${char.name} ç¼ºå°‘å¾®ä¿¡å·æˆ–æ˜µç§°ï¼Œè·³è¿‡ä¸Šçº¿`);
                continue;
            }
            
            // ä¸Šçº¿è§’è‰²
            console.log(`[Online] è‡ªåŠ¨ä¸Šçº¿è§’è‰²: ${nickname} (${wxAccount})`);
            
            try {
                onlineSocket.send(JSON.stringify({
                    type: 'go_online',
                    wx_account: wxAccount,
                    nickname: nickname,
                    avatar: char.avatar || '',
                    bio: (char.description || '').substring(0, 100),
                    local_char_id: char.id
                }));
                onlineCount++;
                
                // æ·»åŠ å°å»¶è¿Ÿé¿å…è¯·æ±‚è¿‡å¿«
                await new Promise(resolve => setTimeout(resolve, 150));
            } catch (sendError) {
                console.error(`[Online] ä¸Šçº¿è§’è‰²å¤±è´¥: ${nickname}`, sendError);
            }
        }
        
        if (onlineCount > 0) {
            console.log(`[Online] å·²å‘é€ ${onlineCount} ä¸ªè§’è‰²çš„ä¸Šçº¿è¯·æ±‚`);
            // âœ… å»¶è¿Ÿåè¯·æ±‚åœ¨çº¿è§’è‰²åˆ—è¡¨ï¼Œç¡®ä¿æœåŠ¡å™¨å·²å¤„ç†ä¸Šçº¿è¯·æ±‚
            setTimeout(() => {
                if (onlineConnected) {
                    requestOnlineCharacters();
                }
            }, 500);
        } else {
            console.log('[Online] æ²¡æœ‰å¯ä¸Šçº¿çš„è§’è‰²ï¼ˆè¯·ç¡®ä¿ User è§’è‰²è®¾ç½®äº†å¾®ä¿¡å·ï¼‰');
        }
    } catch (e) {
        console.error('[Online] è‡ªåŠ¨ä¸Šçº¿è§’è‰²å¤±è´¥:', e);
    }
}

// âœ… è·å–å½“å‰å¯ç”¨çš„åœ¨çº¿è§’è‰²ï¼ˆå¦‚æœæ²¡æœ‰åˆ™è‡ªåŠ¨ä¸Šçº¿ä¸€ä¸ªï¼‰
async function getOrCreateOnlineUserChar() {
    if (!onlineConnected || !onlineUserData) {
        return null;
    }
    
    const userChars = await db.characters.where('type').equals('user').toArray();
    
    // 1. å…ˆæ‰¾å·²ä¸Šçº¿çš„è§’è‰²
    let onlineUserChar = userChars.find(c => 
        c.identity?.account && onlineCharacters.some(oc => oc.wx_account === c.identity.account)
    );
    
    // 2. å¦‚æœæ²¡æœ‰ï¼Œæ‰¾ä¸€ä¸ªæœ‰å¾®ä¿¡å·çš„è§’è‰²å¹¶è‡ªåŠ¨ä¸Šçº¿
    if (!onlineUserChar) {
        const charWithAccount = userChars.find(c => c.identity?.account);
        if (charWithAccount) {
            console.log('[Online] è‡ªåŠ¨ä¸Šçº¿è§’è‰²:', charWithAccount.name);
            const wxAccount = charWithAccount.identity.account;
            onlineSocket.send(JSON.stringify({
                type: 'go_online',
                wx_account: wxAccount,
                nickname: charWithAccount.remark || charWithAccount.wx_nickname || charWithAccount.name,
                avatar: charWithAccount.avatar || '',
                bio: charWithAccount.description?.substring(0, 100) || '',
                local_char_id: charWithAccount.id
            }));
            onlineUserChar = charWithAccount;
        }
    }
    
    return onlineUserChar;
}

// å‘é€è”æœºæ¶ˆæ¯
function sendOnlineMessage(toWxAccount, content, fromWxAccount) {
    if (!onlineConnected) {
        console.warn('[Online] æœªè¿æ¥ï¼Œæ— æ³•å‘é€æ¶ˆæ¯');
        return false;
    }
    
    onlineSocket.send(JSON.stringify({
        type: 'message',
        to_wx_account: toWxAccount,
        from_wx_account: fromWxAccount,
        content: content
    }));
    
    return true;
}

// æ£€æŸ¥è§’è‰²æ˜¯å¦å·²ä¸Šçº¿
function isCharacterOnline(wxAccount) {
    return onlineCharacters.some(c => c.wx_account === wxAccount);
}

// è·å–è”æœºçŠ¶æ€
function getOnlineStatus() {
    return {
        connected: onlineConnected,
        loggedIn: !!onlineUserData,
        user: onlineUserData,
        characters: onlineCharacters
    };
}

// æ›´æ–°è”æœºåŠŸèƒ½åŒºæ˜¾ç¤º
function updateOnlineFeatureSection() {
    const badge = document.getElementById('online-char-count-badge');
    if (!badge) return;
    
    if (!onlineConnected) {
        badge.textContent = 'æœªè¿æ¥';
        badge.style.color = '#999';
    } else if (!onlineUserData) {
        badge.textContent = 'æœªç™»å½•';
        badge.style.color = '#ff9800';
    } else if (onlineCharacters.length === 0) {
        badge.textContent = 'å·²ç™»å½•';
        badge.style.color = '#4caf50';
    } else {
        badge.textContent = `${onlineCharacters.length}ä¸ªè§’è‰²åœ¨çº¿`;
        badge.style.color = '#4caf50';
    }
}

// æ˜¾ç¤ºè”æœºçŠ¶æ€é¡µé¢
async function showOnlineStatusPage() {
    const page = document.getElementById('online-status-page');
    if (!page) return;
    
    page.style.display = 'flex';
    
    // æ›´æ–°è¿æ¥çŠ¶æ€
    updateOnlineConnectionStatus();
    
    // æ›´æ–°è§’è‰²åˆ—è¡¨
    await renderOnlineCharList();
    
    // è·å–è”æœºç¾¤èŠåˆ—è¡¨
    const myWx = getMyOnlineWxAccount();
    if (myWx && onlineSocket && onlineSocket.readyState === WebSocket.OPEN) {
        onlineSocket.send(JSON.stringify({
            type: 'get_online_groups',
            my_wx_account: myWx
        }));
    }
    
    // åˆå§‹æ¸²æŸ“ç¾¤èŠåˆ—è¡¨
    const groupContainer = document.getElementById('online-group-list');
    if (groupContainer) {
        renderOnlineGroupList(groupContainer);
    }
}

// éšè—è”æœºçŠ¶æ€é¡µé¢
function hideOnlineStatusPage() {
    const page = document.getElementById('online-status-page');
    if (page) {
        page.style.display = 'none';
        // æ›´æ–°"æˆ‘"é¡µé¢çš„è”æœºçŠ¶æ€
        updateOnlineFeatureSection();
    }
}

// æ›´æ–°è¿æ¥çŠ¶æ€æ˜¾ç¤º
function updateOnlineConnectionStatus() {
    const statusEl = document.getElementById('online-sync-status');
    if (!statusEl) return;
    
    if (!onlineConnected) {
        statusEl.innerHTML = `
            <div style="display:flex; align-items:center; gap:8px;">
                <span style="width:8px; height:8px; border-radius:50%; background:#ff3b30;"></span>
                <span style="color:#ff3b30; font-weight:500;">æœªåŒæ­¥</span>
            </div>
            <div style="font-size:11px; color:#999; margin-top:4px;">æœªè¿æ¥æœåŠ¡å™¨ï¼Œè¯·åœ¨è®¾ç½®ä¸­é…ç½®</div>
        `;
    } else if (!onlineUserData) {
        statusEl.innerHTML = `
            <div style="display:flex; align-items:center; gap:8px;">
                <span style="width:8px; height:8px; border-radius:50%; background:#ff9800;"></span>
                <span style="color:#ff9800; font-weight:500;">ç­‰å¾…ç™»å½•</span>
            </div>
            <div style="font-size:11px; color:#999; margin-top:4px;">å·²è¿æ¥æœåŠ¡å™¨ï¼Œè¯·å…ˆç™»å½•è´¦å·</div>
        `;
    } else {
        statusEl.innerHTML = `
            <div style="display:flex; align-items:center; gap:8px;">
                <span style="width:8px; height:8px; border-radius:50%; background:#4caf50; animation:pulse 2s infinite;"></span>
                <span style="color:#4caf50; font-weight:500;">å·²åŒæ­¥</span>
            </div>
            <div style="font-size:11px; color:#666; margin-top:4px;">ç”¨æˆ·: ${onlineUserData.username} | è§’è‰²å·²è‡ªåŠ¨ä¸Šçº¿</div>
        `;
    }
}

// æ¸²æŸ“è§’è‰²åˆ—è¡¨
async function renderOnlineCharList() {
    const container = document.getElementById('online-status-char-list');
    if (!container) return;
    
    // è·å–æ‰€æœ‰Userç±»å‹è§’è‰²
    const users = await db.characters.where('type').equals('user').toArray();
    
    // æ£€æŸ¥æ¯ä¸ªè§’è‰²çš„åœ¨çº¿çŠ¶æ€
    // âœ… ä¿®å¤ï¼šå¦‚æœå·²ç™»å½•ï¼Œåˆ™è®¤ä¸ºæ‰€æœ‰æœ‰å¾®ä¿¡å·çš„è§’è‰²éƒ½åœ¨çº¿ï¼ˆå› ä¸ºç™»å½•åä¼šè‡ªåŠ¨ä¸Šçº¿ï¼‰
    const charList = users.map(char => {
        const wxAccount = char.identity?.account || '';
        // å¦‚æœå·²è¿æ¥å¹¶å·²ç™»å½•ï¼Œè®¤ä¸ºæœ‰å¾®ä¿¡å·çš„è§’è‰²éƒ½åœ¨çº¿
        const isOnline = wxAccount && onlineConnected && onlineUserData;
        return {
            id: char.id,
            name: char.remark || char.wx_nickname || char.name,
            avatar: char.avatar || '',
            wxAccount: wxAccount,
            isOnline: isOnline
        };
    }).filter(c => c.wxAccount);
    
    if (charList.length === 0) {
        container.innerHTML = `
            <div style="text-align:center; padding:40px 20px; color:#999;">
                <div style="font-size:14px;">æ²¡æœ‰å¯ç”¨çš„è§’è‰²</div>
                <div style="font-size:12px; margin-top:8px;">è¯·å…ˆåœ¨è§’è‰²æ¡£æ¡ˆåˆ›å»º User ç±»å‹è§’è‰²ï¼Œå¹¶è®¾ç½®å¾®ä¿¡å·</div>
            </div>
        `;
        return;
    }
    
    // æ˜¾ç¤ºè§’è‰²åˆ—è¡¨å’Œåœ¨çº¿çŠ¶æ€ï¼Œç™»å½•åä¼šè‡ªåŠ¨ä¸Šçº¿æ‰€æœ‰è§’è‰²
    container.innerHTML = charList.map(char => `
        <div style="padding:12px 16px; background:#fff; display:flex; align-items:center; gap:12px; border-bottom:1px solid #f0f0f0;">
            <div style="width:44px; height:44px; border-radius:8px; background-image:url(${char.avatar}); background-size:cover; background-position:center; background-color:#e0e0e0;"></div>
            <div style="flex:1;">
                <div style="font-size:15px; font-weight:500; color:#333;">${char.name}</div>
                <div style="font-size:12px; color:#999; margin-top:2px;">${char.wxAccount}</div>
            </div>
            <div style="display:flex; align-items:center;">
                ${char.isOnline ? `
                    <span style="font-size:12px; color:#4caf50; padding:4px 10px; background:#e8f5e9; border-radius:10px; display:flex; align-items:center; gap:4px;">
                        <span style="width:6px; height:6px; border-radius:50%; background:#4caf50;"></span>
                        åœ¨çº¿
                    </span>
                ` : `
                    <span style="font-size:12px; color:#999; padding:4px 10px; background:#f5f5f5; border-radius:10px; display:flex; align-items:center; gap:4px;">
                        <span style="width:6px; height:6px; border-radius:50%; background:#999;"></span>
                        ç¦»çº¿
                    </span>
                `}
            </div>
        </div>
    `).join('');
}

// åˆ·æ–°è”æœºçŠ¶æ€é¡µé¢å†…å®¹
async function refreshOnlineStatusPageContent() {
    const page = document.getElementById('online-status-page');
    if (!page || page.style.display === 'none') return; // é¡µé¢æ²¡æ‰“å¼€
    
    // åˆ·æ–°è§’è‰²åˆ—è¡¨
    await renderOnlineCharList();
}

// æ‰‹åŠ¨åŒæ­¥åœ¨çº¿çŠ¶æ€
async function manualSyncOnline() {
    const btn = document.getElementById('manual-sync-btn');
    const btnText = document.getElementById('sync-btn-text');
    const syncIcon = document.getElementById('sync-icon');
    
    if (!btn || !btnText) return;
    
    // æŒ‰é’®å˜ä¸ºåŒæ­¥ä¸­çŠ¶æ€
    btn.disabled = true;
    btn.style.opacity = '0.7';
    btnText.textContent = 'åŒæ­¥ä¸­...';
    if (syncIcon) {
        syncIcon.style.animation = 'spin 1s linear infinite';
    }
    
    try {
        if (!onlineConnected) {
            // å°è¯•é‡æ–°è¿æ¥æœåŠ¡å™¨
            const serverUrl = localStorage.getItem('online_server_url');
            if (!serverUrl) {
                showToast('è¯·å…ˆåœ¨è®¾ç½®ä¸­é…ç½®æœåŠ¡å™¨åœ°å€');
                return;
            }
            
            showToast('æ­£åœ¨è¿æ¥æœåŠ¡å™¨...');
            await connectToOnlineServer();
            showToast('è¿æ¥æˆåŠŸï¼Œæ­£åœ¨åŒæ­¥...');
        }
        
        // å¦‚æœå·²è¿æ¥ä½†æœªç™»å½•
        if (onlineConnected && !onlineUserData) {
            showToast('è¯·å…ˆç™»å½•è´¦å·');
            updateOnlineConnectionStatus();
            return;
        }
        
        // å¦‚æœå·²ç™»å½•ï¼Œé‡æ–°åŒæ­¥æ‰€æœ‰è§’è‰²
        if (onlineConnected && onlineUserData) {
            console.log('[Online] æ‰‹åŠ¨åŒæ­¥ï¼šé‡æ–°æ³¨å†Œå¹¶ä¸Šçº¿æ‰€æœ‰è§’è‰²');
            
            // é‡æ–°æ³¨å†Œè§’è‰²
            await autoRegisterAllUserCharacters();
            
            // é‡æ–°ä¸Šçº¿æ‰€æœ‰è§’è‰²
            await autoGoOnlineAllUserCharacters();
            
            // ç­‰å¾…ä¸€ä¸‹è®©æœåŠ¡å™¨å¤„ç†
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // åˆ·æ–°è§’è‰²åˆ—è¡¨
            requestOnlineCharacters();
            await refreshOnlineStatusPageContent();
            
            showToast('åŒæ­¥æˆåŠŸ');
        }
        
        updateOnlineConnectionStatus();
        
    } catch (error) {
        console.error('[Online] åŒæ­¥å¤±è´¥:', error);
        showToast('åŒæ­¥å¤±è´¥: ' + (error.message || 'æœªçŸ¥é”™è¯¯'));
    } finally {
        // æ¢å¤æŒ‰é’®çŠ¶æ€
        btn.disabled = false;
        btn.style.opacity = '1';
        btnText.textContent = 'ç«‹å³åŒæ­¥';
        if (syncIcon) {
            syncIcon.style.animation = '';
        }
    }
}

// è‡ªåŠ¨åŒæ­¥å®šæ—¶å™¨ï¼ˆæ¯30ç§’æ£€æŸ¥ä¸€æ¬¡ï¼‰
let autoSyncTimer = null;

function startAutoSync() {
    // æ¸…é™¤æ—§çš„å®šæ—¶å™¨
    if (autoSyncTimer) {
        clearInterval(autoSyncTimer);
    }
    
    // æ¯30ç§’è‡ªåŠ¨æ£€æŸ¥å¹¶åŒæ­¥
    autoSyncTimer = setInterval(async () => {
        // åªåœ¨å·²ç™»å½•ä½†æœªè¿æ¥çš„æƒ…å†µä¸‹å°è¯•è‡ªåŠ¨é‡è¿
        if (!onlineConnected && onlineToken && onlineUserData) {
            console.log('[Online] è‡ªåŠ¨åŒæ­¥ï¼šæ£€æµ‹åˆ°æ–­å¼€è¿æ¥ï¼Œå°è¯•é‡æ–°è¿æ¥...');
            try {
                await connectToOnlineServer();
                console.log('[Online] è‡ªåŠ¨é‡è¿æˆåŠŸ');
            } catch (error) {
                console.error('[Online] è‡ªåŠ¨é‡è¿å¤±è´¥:', error);
            }
        }
        
        // å¦‚æœå·²è¿æ¥ï¼Œå®šæœŸè¯·æ±‚è§’è‰²çŠ¶æ€
        if (onlineConnected && onlineUserData) {
            requestOnlineCharacters();
        }
    }, 30000); // 30ç§’
}

function stopAutoSync() {
    if (autoSyncTimer) {
        clearInterval(autoSyncTimer);
        autoSyncTimer = null;
    }
}

// ==================== è”æœºç¾¤èŠåŠŸèƒ½ ====================

// åˆ·æ–°è”æœºç¾¤èŠåˆ—è¡¨
function refreshOnlineGroupList() {
    // å¦‚æœç¾¤èŠé¡µé¢æ‰“å¼€äº†ï¼Œåˆ·æ–°æ˜¾ç¤º
    const container = document.getElementById('online-group-list');
    if (container) {
        renderOnlineGroupList(container);
    }
}

// æ¸²æŸ“è”æœºç¾¤èŠåˆ—è¡¨
function renderOnlineGroupList(container) {
    if (onlineGroups.length === 0) {
        container.innerHTML = `<div style="text-align:center; padding:40px; color:#999;">æš‚æ— è”æœºç¾¤èŠ</div>`;
        return;
    }
    
    container.innerHTML = onlineGroups.map(g => `
        <div onclick="openOnlineGroup('${g.id}')" style="padding:14px 16px; background:#fff; display:flex; align-items:center; gap:12px; border-bottom:1px solid #f0f0f0; cursor:pointer;">
            <div style="width:48px; height:48px; border-radius:8px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); display:flex; align-items:center; justify-content:center; color:#fff; font-size:18px;">ğŸ‘¥</div>
            <div style="flex:1;">
                <div style="font-size:15px; font-weight:500; color:#333;">${g.name}</div>
                <div style="font-size:12px; color:#999; margin-top:2px;">è”æœºç¾¤èŠ</div>
            </div>
            <svg viewBox="0 0 24 24" style="width:20px; height:20px; stroke:#ccc; fill:none;"><polyline points="9 18 15 12 9 6"></polyline></svg>
        </div>
    `).join('');
}

// å¤„ç†ç¾¤èŠé‚€è¯· - ä¿å­˜åˆ°æ•°æ®åº“ï¼Œæ˜¾ç¤ºåœ¨"æ–°çš„å¥½å‹"é¡µé¢
async function handleOnlineGroupInvite(data) {
    // å°†ç¾¤èŠé‚€è¯·ä¿å­˜åˆ° friend_requests è¡¨
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒçš„é‚€è¯·
    const existingInvites = await db.friend_requests
        .where('toAccountId')
        .equals(accountId)
        .toArray();
    const alreadyExists = existingInvites.some(r => 
        r.isGroupInvite && 
        r.groupData?.group_id === data.group_id &&
        r.status === 'pending'
    );
    if (alreadyExists) return;
    
    // åˆ›å»ºç¾¤èŠé‚€è¯·è®°å½•
    await db.friend_requests.add({
        toAccountId: accountId,
        isOnline: true,
        isGroupInvite: true,
        status: 'pending',
        time: Date.now(),
        groupData: {
            group_id: data.group_id,
            group_name: data.group_name,
            inviter_wx: data.inviter_wx,
            inviter_name: data.inviter_name
        }
    });
    
    // æ˜¾ç¤ºé€šçŸ¥
    showToast(`${data.inviter_name} é‚€è¯·ä½ åŠ å…¥ç¾¤èŠ"${data.group_name}"`);
    
    // å¦‚æœæ–°çš„å¥½å‹é¡µé¢æ­£åœ¨æ˜¾ç¤ºï¼Œåˆ·æ–°å®ƒ
    if (document.getElementById('new-friends-page').style.display !== 'none') {
        await renderNewFriendsPage();
    }
}

// åœ¨æœ¬åœ°æ•°æ®åº“åˆ›å»ºè”æœºç¾¤èŠè®°å½•ï¼Œè®©å®ƒæ˜¾ç¤ºåœ¨æ¶ˆæ¯åˆ—è¡¨ä¸­
async function createLocalOnlineGroupChat(group) {
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    try {
        // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
        const existing = await db.group_chats
            .where('ownerAccountId').equals(accountId)
            .filter(g => g.isOnlineGroup && g.onlineGroupId === group.id)
            .first();
        
        if (existing) {
            console.log('è”æœºç¾¤èŠå·²å­˜åœ¨äºæœ¬åœ°ï¼Œè·³è¿‡åˆ›å»º');
            return;
        }
        
        // åˆ›å»ºæœ¬åœ°ç¾¤èŠè®°å½•
        const groupChat = {
            name: group.name,
            avatar: DEFAULT_GROUP_AVATAR,
            memberIds: [], // è”æœºç¾¤èŠçš„æˆå‘˜ç”±æœåŠ¡å™¨ç®¡ç†
            ownerAccountId: accountId,
            created_at: group.created_at || Date.now(),
            updated_at: Date.now(),
            is_pinned: false,
            chat_history: [{
                role: 'system',
                content: 'è”æœºç¾¤èŠå·²åˆ›å»º',
                time: Date.now()
            }],
            isOnlineGroup: true, // æ ‡è®°ä¸ºè”æœºç¾¤èŠ
            onlineGroupId: group.id, // è”æœºç¾¤èŠçš„ID
            onlineGroupCreator: group.creator_wx // åˆ›å»ºè€…å¾®ä¿¡å·
        };
        
        await db.group_chats.add(groupChat);
        console.log('å·²åœ¨æœ¬åœ°åˆ›å»ºè”æœºç¾¤èŠè®°å½•');
        
        // åˆ·æ–°èŠå¤©åˆ—è¡¨
        if (document.querySelector('.wechat-tab-item.active')?.innerText.includes('å¾®ä¿¡')) {
            renderWechatList(document.getElementById('wechat-content'));
        }
    } catch (e) {
        console.error('åˆ›å»ºæœ¬åœ°è”æœºç¾¤èŠè®°å½•å¤±è´¥:', e);
    }
}

// æ›´æ–°æœ¬åœ°è”æœºç¾¤èŠçš„æœ€åæ¶ˆæ¯
async function updateLocalOnlineGroupLastMessage(onlineGroupId, message) {
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    try {
        // æŸ¥æ‰¾å¯¹åº”çš„æœ¬åœ°ç¾¤èŠè®°å½•
        const groups = await db.group_chats
            .where('ownerAccountId').equals(accountId)
            .filter(g => g.isOnlineGroup && g.onlineGroupId === onlineGroupId)
            .toArray();
        
        if (groups.length === 0) {
            console.log('æœªæ‰¾åˆ°æœ¬åœ°è”æœºç¾¤èŠè®°å½•');
            return;
        }
        
        const group = groups[0];
        
        // æ·»åŠ æ¶ˆæ¯åˆ°èŠå¤©å†å²
        if (!group.chat_history) {
            group.chat_history = [];
        }
        
        // æ„å»ºæ¶ˆæ¯è®°å½•
        const chatMessage = {
            role: 'assistant', // ç¾¤èŠæ¶ˆæ¯è§†ä¸ºåŠ©æ‰‹æ¶ˆæ¯
            content: message.content,
            time: message.created_at || Date.now(),
            sender_name: message.sender_name,
            sender_type: message.sender_type,
            character_name: message.character_name
        };
        
        group.chat_history.push(chatMessage);
        group.updated_at = Date.now();
        
        await db.group_chats.put(group);
        
        // åˆ·æ–°èŠå¤©åˆ—è¡¨ï¼ˆå¦‚æœæ­£åœ¨æ˜¾ç¤ºï¼‰
        if (document.querySelector('.wechat-tab-item.active')?.innerText.includes('å¾®ä¿¡')) {
            renderWechatList(document.getElementById('wechat-content'));
        }
    } catch (e) {
        console.error('æ›´æ–°æœ¬åœ°è”æœºç¾¤èŠæ¶ˆæ¯å¤±è´¥:', e);
    }
}

// æ˜¾ç¤ºåŠ å…¥ç¾¤èŠå¼¹çª—ï¼ˆé€‰æ‹©è¦å¸¦å…¥çš„è§’è‰²ï¼‰
async function showJoinOnlineGroupModal(groupId, groupName) {
    // è·å–æ‰€æœ‰å¯ç”¨çš„è§’è‰²ï¼ˆéUserç±»å‹ï¼‰
    const chars = await db.characters.toArray();
    const availableChars = chars.filter(c => c.type !== 'user' && c.type !== 'online_friend');
    
    const modal = document.createElement('div');
    modal.id = 'join-group-modal';
    modal.style.cssText = `position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:10000; display:flex; align-items:center; justify-content:center;`;
    
    modal.innerHTML = `
        <div style="background:#fff; border-radius:16px; padding:24px; width:85%; max-width:360px;">
            <h3 style="margin:0 0 16px 0; text-align:center; font-size:18px;">åŠ å…¥ã€Œ${groupName}ã€</h3>
            
            <div style="margin-bottom:16px;">
                <div style="font-size:13px; color:#666; margin-bottom:8px;">é€‰æ‹©è¦å¸¦å…¥ç¾¤èŠçš„è§’è‰²ï¼ˆå¯é€‰ï¼‰ï¼š</div>
                <select id="join-group-char-select" style="width:100%; padding:12px; border:1px solid #ddd; border-radius:8px; font-size:14px;">
                    <option value="">ä¸å¸¦è§’è‰²</option>
                    ${availableChars.map(c => `<option value="${c.id}">${c.name}</option>`).join('')}
                </select>
            </div>
            
            <div style="font-size:12px; color:#999; margin-bottom:20px; line-height:1.5;">
                å¸¦å…¥è§’è‰²åï¼Œä½ å¯ä»¥åœ¨ç¾¤èŠä¸­è®©è¯¥è§’è‰²å‘è¨€ï¼ˆè°ƒç”¨AIï¼‰
            </div>
            
            <div style="display:flex; gap:12px;">
                <button onclick="this.closest('#join-group-modal').remove()" style="flex:1; padding:12px; background:#f0f0f0; color:#666; border:none; border-radius:8px; font-size:15px;">å–æ¶ˆ</button>
                <button onclick="doJoinOnlineGroup('${groupId}')" style="flex:1; padding:12px; background:var(--ins-pink); color:#fff; border:none; border-radius:8px; font-size:15px;">åŠ å…¥</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// æ‰§è¡ŒåŠ å…¥ç¾¤èŠ
async function doJoinOnlineGroup(groupId) {
    const charSelect = document.getElementById('join-group-char-select');
    const charId = charSelect?.value;
    
    let myChar = null;
    if (charId) {
        const char = await db.characters.get(parseInt(charId));
        if (char) {
            myChar = {
                name: char.name,
                avatar: char.avatar || '',
                desc: char.description?.substring(0, 200) || ''
            };
        }
    }
    
    // è·å–æˆ‘çš„ä¸Šçº¿å¾®ä¿¡å·
    const myWx = getMyOnlineWxAccount();
    if (!myWx) {
        alert('è¯·å…ˆä¸Šçº¿ä¸€ä¸ªè§’è‰²');
        return;
    }
    
    onlineSocket.send(JSON.stringify({
        type: 'join_online_group',
        group_id: groupId,
        my_wx_account: myWx,
        my_character: myChar
    }));
    
    document.getElementById('join-group-modal')?.remove();
}

// è·å–æˆ‘å½“å‰ä¸Šçº¿çš„å¾®ä¿¡å·
function getMyOnlineWxAccount() {
    if (!onlineCharacters || onlineCharacters.length === 0) return null;
    return onlineCharacters[0]?.wx_account;
}

// æ˜¾ç¤ºåˆ›å»ºè”æœºç¾¤èŠå¼¹çª—
async function showCreateOnlineGroupModal() {
    if (!onlineConnected || !onlineUserData) {
        alert('è¯·å…ˆè¿æ¥æœåŠ¡å™¨å¹¶ç™»å½•');
        return;
    }
    
    // è·å–è”æœºå¥½å‹åˆ—è¡¨
    const friends = await db.characters.where('type').equals('online_friend').toArray();
    
    // è·å–å¯é€‰çš„è§’è‰²ï¼ˆéUserç±»å‹ï¼‰
    const chars = await db.characters.toArray();
    const availableChars = chars.filter(c => c.type !== 'user' && c.type !== 'online_friend');
    
    const modal = document.createElement('div');
    modal.id = 'create-online-group-modal';
    modal.style.cssText = `position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:10000; display:flex; align-items:center; justify-content:center;`;
    
    modal.innerHTML = `
        <div style="background:#fff; border-radius:16px; width:90%; max-width:400px; max-height:80vh; display:flex; flex-direction:column;">
            <div style="padding:16px 20px; border-bottom:1px solid #f0f0f0; display:flex; justify-content:space-between; align-items:center;">
                <span style="font-size:17px; font-weight:600;">åˆ›å»ºè”æœºç¾¤èŠ</span>
                <button onclick="this.closest('#create-online-group-modal').remove()" style="background:none; border:none; font-size:20px; color:#999; cursor:pointer;">Ã—</button>
            </div>
            
            <div style="flex:1; overflow-y:auto; padding:20px;">
                <div style="margin-bottom:16px;">
                    <label style="font-size:13px; color:#666; display:block; margin-bottom:6px;">ç¾¤åç§°</label>
                    <input type="text" id="og-name" placeholder="è¾“å…¥ç¾¤èŠåç§°" style="width:100%; padding:12px; border:1px solid #ddd; border-radius:8px; font-size:14px; box-sizing:border-box;">
                </div>
                
                <div style="margin-bottom:16px;">
                    <label style="font-size:13px; color:#666; display:block; margin-bottom:6px;">é€‰æ‹©æˆ‘è¦å¸¦å…¥çš„è§’è‰²ï¼ˆå¯é€‰ï¼‰</label>
                    <select id="og-my-char" style="width:100%; padding:12px; border:1px solid #ddd; border-radius:8px; font-size:14px;">
                        <option value="">ä¸å¸¦è§’è‰²</option>
                        ${availableChars.map(c => `<option value="${c.id}">${c.name}</option>`).join('')}
                    </select>
                </div>
                
                <div style="margin-bottom:16px;">
                    <label style="font-size:13px; color:#666; display:block; margin-bottom:6px;">é‚€è¯·è”æœºå¥½å‹ï¼ˆå¯å¤šé€‰ï¼‰</label>
                    <div id="og-friends-list" style="max-height:200px; overflow-y:auto; border:1px solid #ddd; border-radius:8px;">
                        ${friends.length === 0 ? 
                            `<div style="padding:20px; text-align:center; color:#999;">æš‚æ— è”æœºå¥½å‹</div>` :
                            friends.map(f => `
                                <label style="display:flex; align-items:center; padding:10px 12px; border-bottom:1px solid #f5f5f5; cursor:pointer;">
                                    <input type="checkbox" value="${f.onlineData?.wx_account || ''}" style="margin-right:10px;">
                                    <div style="width:36px; height:36px; border-radius:6px; background-image:url(${f.avatar}); background-size:cover; background-color:#e0e0e0; margin-right:10px;"></div>
                                    <span style="font-size:14px;">${f.name}</span>
                                </label>
                            `).join('')
                        }
                    </div>
                </div>
            </div>
            
            <div style="padding:16px 20px; border-top:1px solid #f0f0f0;">
                <button onclick="doCreateOnlineGroup()" style="width:100%; padding:14px; background:var(--ins-pink); color:#fff; border:none; border-radius:10px; font-size:16px; font-weight:500;">åˆ›å»ºç¾¤èŠ</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// æ‰§è¡Œåˆ›å»ºè”æœºç¾¤èŠ
async function doCreateOnlineGroup() {
    const name = document.getElementById('og-name').value.trim();
    if (!name) {
        alert('è¯·è¾“å…¥ç¾¤åç§°');
        return;
    }
    
    const myWx = getMyOnlineWxAccount();
    if (!myWx) {
        alert('è¯·å…ˆä¸Šçº¿ä¸€ä¸ªè§’è‰²');
        return;
    }
    
    // è·å–é€‰æ‹©çš„è§’è‰²
    let myChar = null;
    const charId = document.getElementById('og-my-char').value;
    if (charId) {
        const char = await db.characters.get(parseInt(charId));
        if (char) {
            myChar = {
                name: char.name,
                avatar: char.avatar || '',
                desc: char.description?.substring(0, 200) || ''
            };
        }
    }
    
    // è·å–é‚€è¯·çš„å¥½å‹
    const checkboxes = document.querySelectorAll('#og-friends-list input[type="checkbox"]:checked');
    const inviteWxs = Array.from(checkboxes).map(cb => cb.value).filter(v => v);
    
    onlineSocket.send(JSON.stringify({
        type: 'create_online_group',
        name: name,
        my_wx_account: myWx,
        invite_wx_accounts: inviteWxs,
        my_character: myChar
    }));
    
    document.getElementById('create-online-group-modal')?.remove();
}

// æ‰“å¼€è”æœºç¾¤èŠ
function openOnlineGroup(groupId) {
    currentOnlineGroupId = groupId;
    currentOnlineGroupMessages = [];
    currentOnlineGroupMembers = [];
    
    const group = onlineGroups.find(g => g.id === groupId);
    if (!group) return;
    
    // æ˜¾ç¤ºç¾¤èŠé¡µé¢
    showOnlineGroupChatPage(group);
    
    // åº”ç”¨èƒŒæ™¯å›¾ï¼ˆå»¶è¿Ÿä¸€ä¸‹ç¡®ä¿é¡µé¢å·²åˆ›å»ºï¼‰
    setTimeout(() => {
        applyOnlineGroupBackground(groupId);
    }, 100);
    
    // è¯·æ±‚ç¾¤æˆå‘˜
    const myWx = getMyOnlineWxAccount();
    if (myWx) {
        onlineSocket.send(JSON.stringify({
            type: 'get_group_members',
            group_id: groupId,
            my_wx_account: myWx
        }));
        
        // è¯·æ±‚æ¶ˆæ¯è®°å½•
        onlineSocket.send(JSON.stringify({
            type: 'get_group_messages',
            group_id: groupId,
            my_wx_account: myWx,
            limit: 100
        }));
    }
}

// æ˜¾ç¤ºè”æœºç¾¤èŠé¡µé¢
function showOnlineGroupChatPage(group) {
    // åˆ›å»ºæˆ–æ˜¾ç¤ºç¾¤èŠé¡µé¢
    let page = document.getElementById('online-group-chat-page');
    if (!page) {
        page = document.createElement('div');
        page.id = 'online-group-chat-page';
        page.style.cssText = `position:fixed; top:0; left:0; right:0; bottom:0; background:#ffffff; z-index:300; display:flex; flex-direction:column;`;
        document.body.appendChild(page);
    }
    
    page.innerHTML = `
        <div class="wechat-header" style="background:#fff; border-bottom:1px solid #f0f0f0;">
            <div class="back-btn" onclick="hideOnlineGroupChat()" style="margin:0; background:none; width:40px; justify-content:flex-start; color:#333;">
                <svg class="svg-icon" viewBox="0 0 24 24" style="width:24px; height:24px;"><polyline points="15 18 9 12 15 6"></polyline></svg>
            </div>
            <div class="wechat-title" id="online-group-chat-title" style="flex:1; text-align:center;">${group.name}</div>
            <div onclick="showOnlineGroupInfo('${group.id}')" style="width:40px; display:flex; justify-content:flex-end; cursor:pointer;">
                <svg viewBox="0 0 24 24" style="width:20px; height:20px; stroke:#333; fill:none;"><circle cx="12" cy="12" r="1"></circle><circle cx="19" cy="12" r="1"></circle><circle cx="5" cy="12" r="1"></circle></svg>
            </div>
        </div>
        
        <div id="online-group-messages" style="flex:1; overflow-y:auto; padding:16px;">
            <div style="text-align:center; padding:20px; color:#999;">åŠ è½½ä¸­...</div>
        </div>
        
        <div class="chat-footer" id="online-group-footer">
            <div class="chat-input-bar">
                <!-- å·¦ä¾§ï¼šç”ŸæˆæŒ‰é’® (è®©è§’è‰²è¯´è¯) -->
                <div class="chat-icon-btn" onclick="letMyCharacterSpeak()" title="è®©è§’è‰²è¯´è¯">
                    <svg class="svg-icon" viewBox="0 0 24 24"><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z"/><path d="M5 3v4"/><path d="M9 5H1"/></svg>
                </div>
                
                <!-- ä¸­é—´ï¼šè¾“å…¥æ¡† -->
                <input type="text" class="chat-input" id="online-group-input" placeholder="å‘é€æ¶ˆæ¯..." onfocus="closeOnlineGroupPanel()">
                
                <!-- å³ä¾§ï¼šè¡¨æƒ… -->
                <div class="chat-icon-btn" onclick="toggleOnlineGroupPanel('emoji')">
                    <svg class="svg-icon" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><path d="M8 14s1.5 2 4 2 4-2 4-2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line></svg>
                </div>
                
                <!-- å³ä¾§ï¼šèœå• (+) -->
                <div class="chat-icon-btn" id="online-group-btn-more" onclick="toggleOnlineGroupPanel('action')">
                    <svg class="svg-icon" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line></svg>
                </div>
                
                <!-- å³ä¾§ï¼šå‘é€ (Send) - é»˜è®¤éšè— -->
                <div class="chat-send-btn" id="online-group-btn-send" onclick="sendOnlineGroupMsg()">
                    <svg class="svg-icon" viewBox="0 0 24 24" style="width:18px; height:18px; stroke-width:3; transform: rotate(90deg) translateX(-2px);"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
                </div>
            </div>
            
            <!-- é¢æ¿å®¹å™¨ -->
            <div class="chat-panel-container" id="online-group-panel-container">
                <!-- è¡¨æƒ…åŒ… Tab -->
                <div style="height: 40px; display: flex; border-bottom: 1px solid #eee; background: #fff;" id="online-group-emoji-tab-bar">
                    <div class="wechat-tab-item active" onclick="switchOnlineGroupEmojiTab('emoji')" style="flex:1; font-size:14px;">Emoji</div>
                    <div class="wechat-tab-item" onclick="switchOnlineGroupEmojiTab('sticker')" style="flex:1; font-size:14px;">è¡¨æƒ…åŒ…</div>
                </div>
                <!-- Emoji é¢æ¿ -->
                <div class="emoji-panel" id="online-group-emoji-panel" style="height: calc(100% - 40px);">
                    <!-- åŠ¨æ€ç”Ÿæˆè¡¨æƒ… -->
                </div>
                <!-- è‡ªå®šä¹‰è¡¨æƒ…åŒ…é¢æ¿ -->
                <div id="online-group-sticker-panel" style="height: calc(100% - 40px); display: none; flex-direction: column; overflow: hidden;">
                    <!-- åˆ†ç±»æ ‡ç­¾æ  -->
                    <div id="online-group-sticker-category-tabs" style="display: flex; overflow-x: auto; border-bottom: 1px solid #eee; background: #fff; flex-shrink: 0; height: 40px;">
                        <!-- åŠ¨æ€ç”Ÿæˆåˆ†ç±»æ ‡ç­¾ -->
                    </div>
                    <!-- è¡¨æƒ…åŒ…å†…å®¹åŒºåŸŸ -->
                    <div id="online-group-sticker-content" style="display: grid; flex: 1; grid-template-columns: repeat(4, 1fr); gap: 10px; padding: 10px; overflow-y: auto; align-content: start;">
                        <!-- åŠ¨æ€ç”Ÿæˆè‡ªå®šä¹‰è¡¨æƒ… -->
                        <div style="text-align:center; grid-column:span 4; color:#999; margin-top:20px;">æš‚æ— è¡¨æƒ…åŒ…<br>è¯·å»ã€æˆ‘-è¡¨æƒ…ã€‘æ·»åŠ </div>
                    </div>
                </div>

                <!-- åŠŸèƒ½èœå•é¢æ¿ -->
                <div class="action-panel" id="online-group-action-panel">
                    <div class="action-item" onclick="onlineGroupVoiceInput()">
                        <div class="action-icon-box">
                            <svg class="svg-icon" viewBox="0 0 24 24"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>
                        </div>
                        <div class="action-name">è¯­éŸ³è¾“å…¥</div>
                    </div>
                    <div class="action-item" onclick="onlineGroupSendImage()">
                        <div class="action-icon-box">
                            <svg class="svg-icon" viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
                        </div>
                        <div class="action-name">ç›¸å†Œ</div>
                    </div>
                    <div class="action-item" onclick="onlineGroupTransfer()">
                        <div class="action-icon-box transfer-icon">
                            <svg class="svg-icon" viewBox="0 0 24 24"><path d="M17 1l4 4-4 4"></path><path d="M3 11V9a4 4 0 0 1 4-4h14"></path><path d="M7 23l-4-4 4-4"></path><path d="M21 13v2a4 4 0 0 1-4 4H3"></path></svg>
                        </div>
                        <div class="action-name">è½¬è´¦</div>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    page.style.display = 'flex';
    
    // ç»‘å®šå›è½¦å‘é€
    const input = document.getElementById('online-group-input');
    input.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') sendOnlineGroupMsg();
    });
    
    // ç»‘å®šè¾“å…¥å˜åŒ–äº‹ä»¶ï¼Œæ§åˆ¶å‘é€æŒ‰é’®æ˜¾ç¤º
    input.addEventListener('input', function() {
        const btnSend = document.getElementById('online-group-btn-send');
        const btnMore = document.getElementById('online-group-btn-more');
        if (this.value.trim()) {
            btnSend.style.display = 'flex';
            btnMore.style.display = 'none';
        } else {
            btnSend.style.display = 'none';
            btnMore.style.display = 'flex';
        }
    });
    
    // åˆå§‹åŒ–Emojié¢æ¿
    initOnlineGroupEmojiPanel();
    
    // åº”ç”¨èƒŒæ™¯å›¾
    applyOnlineGroupBackground(group.id);
}

// éšè—è”æœºç¾¤èŠé¡µé¢
function hideOnlineGroupChat() {
    const page = document.getElementById('online-group-chat-page');
    if (page) page.style.display = 'none';
    currentOnlineGroupId = null;
}

// å¤„ç†ç¾¤èŠæ¶ˆæ¯è®°å½•
function handleOnlineGroupMessages(data) {
    if (data.group_id !== currentOnlineGroupId) return;
    currentOnlineGroupMessages = data.messages || [];
    // æŒ‰æ—¶é—´æˆ³æ’åºï¼Œç¡®ä¿æ¶ˆæ¯é¡ºåºæ­£ç¡®
    currentOnlineGroupMessages.sort((a, b) => (a.created_at || 0) - (b.created_at || 0));
    renderOnlineGroupMessages();
}

// å¤„ç†å®æ—¶ç¾¤æ¶ˆæ¯
async function handleOnlineGroupMessage(data) {
    // æ›´æ–°æœ¬åœ°ç¾¤èŠè®°å½•ï¼Œè®©æ¶ˆæ¯åˆ—è¡¨æ˜¾ç¤ºæœ€æ–°æ¶ˆæ¯
    await updateLocalOnlineGroupLastMessage(data.group_id, data.message);
    
    if (data.group_id !== currentOnlineGroupId) {
        // ä¸æ˜¯å½“å‰ç¾¤ï¼Œæ˜¾ç¤ºé€šçŸ¥
        showToast(`[${data.message.sender_name}] ${data.message.content.substring(0, 20)}...`);
        return;
    }
    
    // å¦‚æœæ˜¯ç³»ç»Ÿæ¶ˆæ¯ï¼Œæ£€æŸ¥æ˜¯å¦æ˜¯çº¢åŒ…é¢†å–é€šçŸ¥ï¼Œå¦‚æœæ˜¯åˆ™æ›´æ–°çº¢åŒ…çŠ¶æ€
    if (data.message.msg_type === 'system' && data.message.content.includes('é¢†å–äº†çº¢åŒ…')) {
        // å°è¯•ä»ç³»ç»Ÿæ¶ˆæ¯ä¸­æå–çº¢åŒ…IDå’Œé¢†å–è€…ä¿¡æ¯
        // æ ¼å¼ï¼šXXX é¢†å–äº†çº¢åŒ…ï¼Œè·å¾— Â¥X.XX
        // ç”±äºæˆ‘ä»¬æ— æ³•ä»ç³»ç»Ÿæ¶ˆæ¯ä¸­ç›´æ¥è·å–çº¢åŒ…IDï¼Œè¿™é‡Œåªæ›´æ–°æ˜¾ç¤º
        // å®é™…çš„çº¢åŒ…çŠ¶æ€æ›´æ–°åœ¨ claimOnlineGroupRedPacket ä¸­å®Œæˆ
    }
    
    currentOnlineGroupMessages.push(data.message);
    // æŒ‰æ—¶é—´æˆ³æ’åºï¼Œç¡®ä¿æ¶ˆæ¯é¡ºåºæ­£ç¡®
    currentOnlineGroupMessages.sort((a, b) => (a.created_at || 0) - (b.created_at || 0));
    renderOnlineGroupMessages();
}

// å¤„ç†ç¾¤æˆå‘˜å¼€å§‹è¾“å…¥
function handleGroupTypingStart(data) {
    // åªåœ¨å½“å‰æ‰“å¼€çš„ç¾¤èŠä¸­æ˜¾ç¤º
    if (data.group_id !== currentOnlineGroupId) return;
    
    const chatTitleEl = document.getElementById('online-group-chat-title');
    if (chatTitleEl) {
        chatTitleEl.innerText = `${data.character_name} æ­£åœ¨è¾“å…¥ä¸­...`;
    }
}

// å¤„ç†ç¾¤æˆå‘˜åœæ­¢è¾“å…¥
function handleGroupTypingStop(data) {
    // åªåœ¨å½“å‰æ‰“å¼€çš„ç¾¤èŠä¸­æ˜¾ç¤º
    if (data.group_id !== currentOnlineGroupId) return;
    
    const chatTitleEl = document.getElementById('online-group-chat-title');
    const group = onlineGroups.find(g => g.id === currentOnlineGroupId);
    if (chatTitleEl && group) {
        chatTitleEl.innerText = group.name;
    }
}

// æ¸²æŸ“ç¾¤èŠæ¶ˆæ¯
function renderOnlineGroupMessages() {
    const container = document.getElementById('online-group-messages');
    if (!container) return;
    
    const myWx = getMyOnlineWxAccount();
    
    container.innerHTML = currentOnlineGroupMessages.map(msg => {
        // å¤„ç†ç³»ç»Ÿæ¶ˆæ¯
        if (msg.msg_type === 'system' || msg.sender_type === 'system') {
            return `<div style="text-align:center; padding:8px 16px; margin:8px 0;">
                <span style="background:#fff; color:#999; font-size:12px; padding:4px 12px; border-radius:4px; border:1px solid #ddd;">${msg.content}</span>
            </div>`;
        }
        
        const isCharacter = msg.sender_type === 'character';
        // åªæœ‰æˆ‘å‘çš„çœŸäººæ¶ˆæ¯æ‰æ˜¾ç¤ºåœ¨å³è¾¹ï¼Œæ‰€æœ‰è§’è‰²æ¶ˆæ¯ï¼ˆåŒ…æ‹¬æˆ‘çš„è§’è‰²ï¼‰éƒ½æ˜¾ç¤ºåœ¨å·¦è¾¹
        const isMe = msg.sender_wx === myWx && !isCharacter;
        const avatar = isCharacter ? (msg.character_avatar || '') : (msg.sender_avatar || '');
        const name = isCharacter ? `${msg.character_name} (${msg.sender_name})` : msg.sender_name;
        // ç¡®ä¿å¤´åƒURLä¸ä¸ºç©ºå­—ç¬¦ä¸²æ‰è®¾ç½®èƒŒæ™¯å›¾
        const avatarStyle = (avatar && avatar.trim()) ? `background-image:url(${avatar})` : 'background:#ccc';
        
        let messageContent = '';
        let isSpecialMsg = false;
        
        // å°è¯•è§£æJSONæ¶ˆæ¯ï¼ˆè¯­éŸ³ã€è½¬è´¦ç­‰ç‰¹æ®Šæ¶ˆæ¯ï¼‰
        let parsedContent = null;
        try {
            if (msg.content && msg.content.startsWith('{') && msg.content.includes('__type')) {
                parsedContent = JSON.parse(msg.content);
            }
        } catch(e) {}
        
        // å¤„ç†è¯­éŸ³æ¶ˆæ¯
        if (parsedContent && parsedContent.__type === 'audio') {
            isSpecialMsg = true;
            const audioId = 'online_group_audio_' + (msg.id || msg.created_at);
            const effectIcon = parsedContent.effect === 'loli' ? 'ğŸ€' : 
                              parsedContent.effect === 'uncle' ? 'ğŸ§”' :
                              parsedContent.effect === 'robot' ? 'ğŸ¤–' : 'ğŸ™ï¸';
            messageContent = `
                <div class="online-audio-bubble" style="min-width:120px; max-width:200px; padding:10px 14px; background:${isMe ? '#ffe4e8' : '#f2f2f7'}; border-radius:18px; display:flex; align-items:center; gap:10px; cursor:pointer;" onclick="playOnlineGroupAudio('${audioId}')">
                    <div class="audio-play-icon" id="icon_${audioId}" data-original="${effectIcon}" style="font-size:20px;">${effectIcon}</div>
                    <div style="flex:1; display:flex; flex-direction:column;">
                        <div style="height:20px; background:#fff; border-radius:10px; position:relative; overflow:hidden;">
                            <div style="height:100%; background:var(--ins-pink); width:0%; transition:width 0.1s;" id="progress_${audioId}"></div>
                        </div>
                        <div style="font-size:11px; color:#999; margin-top:2px;">${parsedContent.duration}"</div>
                    </div>
                    <audio id="${audioId}" src="${parsedContent.audio}" style="display:none;"></audio>
                </div>
            `;
        }
        // å¤„ç†çº¢åŒ…æ¶ˆæ¯
        else if (msg.msg_type === 'redpacket') {
            isSpecialMsg = true;
            try {
                const data = JSON.parse(msg.content);
                const msgId = msg.id || ('rp_' + msg.created_at);
                const claimedCount = (data.claimed || []).length;
                const isAllClaimed = claimedCount >= data.count;
                const myWx = getMyOnlineWxAccount();
                const hasClaimed = data.claimed?.includes(myWx) || false;
                
                messageContent = `<div onclick="showOnlineGroupRedPacketDetail('${msgId}')" style="width:220px; background:#fff; border-radius:12px; overflow:hidden; box-shadow:0 1px 3px rgba(0,0,0,0.08); border:1px solid #eee; cursor:pointer;">
                    <div style="padding:14px 16px; display:flex; align-items:center; gap:12px; background:linear-gradient(135deg, #ff6b6b 0%, #ff8e8e 100%);">
                        <div style="width:40px; height:40px; background:#fff; border-radius:10px; display:flex; align-items:center; justify-content:center; border:1px solid rgba(255,255,255,0.3);">
                            <svg viewBox="0 0 24 24" style="width:20px; height:20px; stroke:#ff6b6b; fill:#ff6b6b; stroke-width:1.5;"><rect x="3" y="4" width="18" height="16" rx="2"/><path d="M3 10h18"/><circle cx="12" cy="15" r="2"/></svg>
                        </div>
                        <div style="flex:1;">
                            <div style="font-size:13px; color:rgba(255,255,255,0.9); margin-bottom:2px;">${escapeHtml(data.wish || 'æ­å–œå‘è´¢')}</div>
                            <div style="font-size:11px; color:rgba(255,255,255,0.7);">${data.redpacketType === 'lucky' ? 'æ‹¼æ‰‹æ°”çº¢åŒ…' : 'æ™®é€šçº¢åŒ…'}</div>
                        </div>
                    </div>
                    <div style="padding:8px 16px; display:flex; justify-content:space-between; align-items:center; border-top:1px solid #eee;">
                        <span style="font-size:11px; color:#999;">${isAllClaimed ? 'å·²é¢†å®Œ' : `${claimedCount}/${data.count}ä¸ªå·²é¢†å–`}</span>
                        <span style="font-size:11px; color:#999;">${hasClaimed ? 'å·²é¢†å–' : isAllClaimed ? 'å·²é¢†å®Œ' : 'é¢†å–'}</span>
                    </div>
                </div>`;
            } catch(e) {
                messageContent = renderMessageContent(msg.content);
                isSpecialMsg = false;
            }
        }
        // å¤„ç†è½¬è´¦æ¶ˆæ¯
        else if (msg.msg_type === 'transfer') {
            isSpecialMsg = true;
            try {
                const data = JSON.parse(msg.content);
                const msgId = msg.id || ('trans_' + msg.created_at);
                const targetHint = data.targetName ? `è½¬ç»™ ${data.targetName}` : 'è½¬è´¦';
                messageContent = `<div onclick="receiveOnlineGroupTransfer('${msgId}')" style="width:220px; background:#fff; border-radius:12px; overflow:hidden; box-shadow:0 1px 3px rgba(0,0,0,0.08); border:1px solid #eee; cursor:pointer;">
                    <div style="padding:14px 16px; display:flex; align-items:center; gap:12px;">
                        <div style="width:40px; height:40px; background:#fff; border-radius:10px; display:flex; align-items:center; justify-content:center; border:1px solid #eee;">
                            <svg viewBox="0 0 24 24" style="width:20px; height:20px; stroke:#666; fill:none; stroke-width:1.5;"><path d="M17 1l4 4-4 4"/><path d="M3 11V9a4 4 0 0 1 4-4h14"/><path d="M7 23l-4-4 4-4"/><path d="M21 13v2a4 4 0 0 1-4 4H3"/></svg>
                        </div>
                        <div style="flex:1;">
                            <div style="font-size:18px; font-weight:600; color:#333; margin-bottom:2px;">Â¥${data.amount}</div>
                            <div style="font-size:12px; color:#999;">${escapeHtml(data.desc || 'è½¬è´¦')}</div>
                        </div>
                    </div>
                    <div style="padding:8px 16px; display:flex; justify-content:space-between; align-items:center; border-top:1px solid #eee;">
                        <span style="font-size:11px; color:#999;">${targetHint}</span>
                        <span style="font-size:11px; color:#999;">${data.status === 'received' ? 'å·²æ”¶æ¬¾' : 'å¾…æ”¶æ¬¾'}</span>
                    </div>
                </div>`;
            } catch(e) {
                messageContent = renderMessageContent(msg.content);
                isSpecialMsg = false;
            }
        } else {
            // æ™®é€šæ¶ˆæ¯
            messageContent = renderMessageContent(msg.content);
        }
        
        // å®Œå…¨æŒ‰ç…§æ™®é€šç¾¤èŠçš„æ ·å¼
        if (isMe) {
            // æˆ‘å‘çš„æ¶ˆæ¯
            if (isSpecialMsg) {
                return `
                    <div style="display:flex; flex-direction:row-reverse; align-items:flex-end; gap:8px; margin-bottom:12px;">
                        <div style="width:32px; height:32px; border-radius:50%; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; margin-bottom:2px;"></div>
                        <div style="display:flex; flex-direction:column; align-items:flex-end; max-width:70%;">
                            <div style="font-size:12px; color:#999; margin-bottom:2px;">${name}${isCharacter ? ' ğŸ­' : ''}</div>
                            <div style="display:flex; align-items:flex-end; gap:6px;">
                                <div style="font-size:10px; color:#999;">${formatChatTime(msg.created_at)}</div>
                                <div>${messageContent}</div>
                            </div>
                        </div>
                    </div>
                `;
            } else {
                return `
                    <div style="display:flex; flex-direction:row-reverse; align-items:flex-end; gap:8px; margin-bottom:12px;">
                        <div style="width:32px; height:32px; border-radius:50%; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; margin-bottom:2px;"></div>
                        <div style="display:flex; flex-direction:column; align-items:flex-end; max-width:70%;">
                            <div style="font-size:12px; color:#999; margin-bottom:2px;">${name}${isCharacter ? ' ğŸ­' : ''}</div>
                            <div style="display:flex; align-items:flex-end; gap:6px;">
                                <div style="font-size:10px; color:#999;">${formatChatTime(msg.created_at)}</div>
                                <div style="background:#ffe4e8; color:#000; padding:6px 10px; border-radius:18px 18px 4px 18px; font-size:15px; line-height:1.5; word-break:break-word;">${messageContent}</div>
                            </div>
                        </div>
                    </div>
                `;
            }
        } else {
            // åˆ«äººå‘çš„æ¶ˆæ¯
            if (isSpecialMsg) {
                return `
                    <div style="display:flex; align-items:flex-end; gap:8px; margin-bottom:12px;">
                        <div style="width:32px; height:32px; border-radius:50%; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; margin-bottom:2px;"></div>
                        <div style="display:flex; flex-direction:column; max-width:70%;">
                            <div style="font-size:12px; color:#999; margin-bottom:2px;">${name}${isCharacter ? ' ğŸ­' : ''}</div>
                            <div style="display:flex; align-items:flex-end; gap:6px;">
                                <div>${messageContent}</div>
                                <div style="font-size:10px; color:#999;">${formatChatTime(msg.created_at)}</div>
                            </div>
                        </div>
                    </div>
                `;
            } else {
                return `
                    <div style="display:flex; align-items:flex-end; gap:8px; margin-bottom:12px;">
                        <div style="width:32px; height:32px; border-radius:50%; ${avatarStyle}; background-size:cover; background-position:center; flex-shrink:0; margin-bottom:2px;"></div>
                        <div style="display:flex; flex-direction:column; max-width:70%;">
                            <div style="font-size:12px; color:#999; margin-bottom:2px;">${name}${isCharacter ? ' ğŸ­' : ''}</div>
                            <div style="display:flex; align-items:flex-end; gap:6px;">
                                <div style="background:#f2f2f7; color:#000; padding:6px 10px; border-radius:18px 18px 18px 4px; font-size:15px; line-height:1.5; word-break:break-word;">${messageContent}</div>
                                <div style="font-size:10px; color:#999;">${formatChatTime(msg.created_at)}</div>
                            </div>
                        </div>
                    </div>
                `;
            }
        }
    }).join('');
    
    // ä¸ºå›¾ç‰‡æ·»åŠ ç‚¹å‡»äº‹ä»¶
    container.querySelectorAll('.chat-image').forEach(img => {
        img.onclick = () => showFullImage(img.src);
    });
    
    container.scrollTop = container.scrollHeight;
}

// æ”¶å–è”æœºç¾¤èŠè½¬è´¦
function receiveOnlineGroupTransfer(msgId) {
    showToast('è½¬è´¦åŠŸèƒ½æš‚ä¸æ”¯æŒæ”¶å–ï¼Œä»…ç”¨äºå±•ç¤º');
}

// æ’­æ”¾è”æœºç¾¤èŠè¯­éŸ³æ¶ˆæ¯
let currentPlayingOnlineGroupAudio = null;
function playOnlineGroupAudio(audioId) {
    const audio = document.getElementById(audioId);
    const icon = document.getElementById('icon_' + audioId);
    const progress = document.getElementById('progress_' + audioId);
    
    if (!audio) return;
    
    // å¦‚æœæœ‰å…¶ä»–æ­£åœ¨æ’­æ”¾çš„ï¼Œå…ˆåœæ­¢
    if (currentPlayingOnlineGroupAudio && currentPlayingOnlineGroupAudio !== audio) {
        currentPlayingOnlineGroupAudio.pause();
        currentPlayingOnlineGroupAudio.currentTime = 0;
        // é‡ç½®ä¹‹å‰éŸ³é¢‘çš„å›¾æ ‡å’Œè¿›åº¦æ¡
        const prevIcon = document.getElementById('icon_' + currentPlayingOnlineGroupAudio.id);
        const prevProgress = document.getElementById('progress_' + currentPlayingOnlineGroupAudio.id);
        if (prevIcon) {
            const bubble = currentPlayingOnlineGroupAudio.closest('.online-audio-bubble');
            if (bubble) {
                const originalIcon = bubble.querySelector('.audio-play-icon');
                if (originalIcon) prevIcon.textContent = prevIcon.dataset.original || 'ğŸ™ï¸';
            }
        }
        if (prevProgress) prevProgress.style.width = '0%';
    }
    
    if (audio.paused) {
        audio.play();
        currentPlayingOnlineGroupAudio = audio;
        if (icon) icon.textContent = 'â¸ï¸';
        
        // æ›´æ–°è¿›åº¦æ¡
        audio.ontimeupdate = () => {
            if (progress && audio.duration) {
                const percent = (audio.currentTime / audio.duration) * 100;
                progress.style.width = percent + '%';
            }
        };
        
        audio.onended = () => {
            if (icon) icon.textContent = icon.dataset.original || 'ğŸ™ï¸';
            if (progress) progress.style.width = '0%';
            currentPlayingOnlineGroupAudio = null;
        };
    } else {
        audio.pause();
        audio.currentTime = 0;
        if (icon) icon.textContent = icon.dataset.original || 'ğŸ™ï¸';
        if (progress) progress.style.width = '0%';
        currentPlayingOnlineGroupAudio = null;
    }
}

// å¤„ç†ç¾¤æˆå‘˜åˆ—è¡¨
function handleOnlineGroupMembers(data) {
    if (data.group_id !== currentOnlineGroupId) return;
    currentOnlineGroupMembers = data.members || [];
    
    // æ‰¾åˆ°æˆ‘çš„è§’è‰²
    const myWx = getMyOnlineWxAccount();
    const myMember = currentOnlineGroupMembers.find(m => m.user_wx === myWx);
    if (myMember && myMember.character_name) {
        myOnlineGroupCharacter = {
            name: myMember.character_name,
            avatar: myMember.character_avatar,
            desc: myMember.character_desc
        };
    } else {
        myOnlineGroupCharacter = null;
    }
}

// åˆ‡æ¢è”æœºç¾¤èŠé¢æ¿
let currentOnlineGroupPanel = null;
function toggleOnlineGroupPanel(panelType) {
    const container = document.getElementById('online-group-panel-container');
    const emojiTabBar = document.getElementById('online-group-emoji-tab-bar');
    const emojiPanel = document.getElementById('online-group-emoji-panel');
    const stickerPanel = document.getElementById('online-group-sticker-panel');
    const actionPanel = document.getElementById('online-group-action-panel');
    
    if (!container) {
        console.error('[Panel] Missing container!');
        return;
    }
    
    if (currentOnlineGroupPanel === panelType) {
        // å…³é—­é¢æ¿
        container.classList.remove('open');
        if (emojiTabBar) emojiTabBar.style.display = 'none';
        if (emojiPanel) emojiPanel.style.display = 'none';
        if (stickerPanel) stickerPanel.style.display = 'none';
        if (actionPanel) actionPanel.style.display = 'none';
        currentOnlineGroupPanel = null;
    } else {
        // æ‰“å¼€é¢æ¿
        container.classList.add('open');
        if (panelType === 'emoji') {
            if (emojiTabBar) emojiTabBar.style.display = 'flex';
            if (emojiPanel) emojiPanel.style.display = 'grid';
            if (stickerPanel) stickerPanel.style.display = 'none';
            if (actionPanel) actionPanel.style.display = 'none';
        } else if (panelType === 'action') {
            if (emojiTabBar) emojiTabBar.style.display = 'none';
            if (emojiPanel) emojiPanel.style.display = 'none';
            if (stickerPanel) stickerPanel.style.display = 'none';
            if (actionPanel) actionPanel.style.display = 'grid';
        }
        currentOnlineGroupPanel = panelType;
    }
}

// å…³é—­è”æœºç¾¤èŠé¢æ¿
function closeOnlineGroupPanel() {
    const container = document.getElementById('online-group-panel-container');
    if (container) {
        container.classList.remove('open');
    }
    const emojiTabBar = document.getElementById('online-group-emoji-tab-bar');
    const emojiPanel = document.getElementById('online-group-emoji-panel');
    const stickerPanel = document.getElementById('online-group-sticker-panel');
    const actionPanel = document.getElementById('online-group-action-panel');
    if (emojiTabBar) emojiTabBar.style.display = 'none';
    if (emojiPanel) emojiPanel.style.display = 'none';
    if (stickerPanel) stickerPanel.style.display = 'none';
    if (actionPanel) actionPanel.style.display = 'none';
    currentOnlineGroupPanel = null;
}

// åˆ‡æ¢è”æœºç¾¤èŠè¡¨æƒ…Tab
async function switchOnlineGroupEmojiTab(type) {
    const tabs = document.querySelectorAll('#online-group-emoji-tab-bar .wechat-tab-item');
    const emojiPanel = document.getElementById('online-group-emoji-panel');
    const stickerPanel = document.getElementById('online-group-sticker-panel');

    if (type === 'emoji') {
        tabs[0].classList.add('active');
        tabs[1].classList.remove('active');
        emojiPanel.style.display = 'grid';
        stickerPanel.style.display = 'none';
    } else {
        tabs[0].classList.remove('active');
        tabs[1].classList.add('active');
        emojiPanel.style.display = 'none';
        stickerPanel.style.display = 'flex';
        // åŠ è½½è‡ªå®šä¹‰è¡¨æƒ…åŒ…
        await loadOnlineGroupStickers();
    }
}

// å½“å‰é€‰ä¸­çš„è”æœºç¾¤èŠè¡¨æƒ…åŒ…åˆ†ç±»ID
let currentActiveOnlineGroupStickerCategoryId = null;

// åŠ è½½è”æœºç¾¤èŠçš„è‡ªå®šä¹‰è¡¨æƒ…åŒ…
async function loadOnlineGroupStickers() {
    const tabsContainer = document.getElementById('online-group-sticker-category-tabs');
    const contentContainer = document.getElementById('online-group-sticker-content');
    if (!tabsContainer || !contentContainer) return;
    
    // è·å–æ‰€æœ‰è¡¨æƒ…åŒ…åˆ†ç±»
    const allCategories = await db.sticker_categories.toArray();
    
    if (allCategories.length === 0) {
        tabsContainer.innerHTML = '';
        contentContainer.innerHTML = `<div style="text-align:center; grid-column:span 4; color:#999; margin-top:20px;">æš‚æ— è¡¨æƒ…åŒ…<br>è¯·å»ã€æˆ‘-è¡¨æƒ…ã€‘æ·»åŠ </div>`;
        return;
    }
    
    // è¿‡æ»¤å‡ºæœ‰è¡¨æƒ…åŒ…çš„åˆ†ç±»
    const validCategories = allCategories.filter(cat => cat.stickers && cat.stickers.length > 0);
    
    if (validCategories.length === 0) {
        tabsContainer.innerHTML = '';
        contentContainer.innerHTML = `<div style="text-align:center; grid-column:span 4; color:#999; margin-top:20px;">æš‚æ— è¡¨æƒ…åŒ…<br>è¯·å»ã€æˆ‘-è¡¨æƒ…ã€‘æ·»åŠ </div>`;
        return;
    }
    
    // å¦‚æœè¿˜æ²¡æœ‰é€‰ä¸­çš„åˆ†ç±»ï¼Œé»˜è®¤é€‰ä¸­ç¬¬ä¸€ä¸ª
    if (!currentActiveOnlineGroupStickerCategoryId || !validCategories.find(c => c.id === currentActiveOnlineGroupStickerCategoryId)) {
        currentActiveOnlineGroupStickerCategoryId = validCategories[0].id;
    }
    
    // ç”Ÿæˆåˆ†ç±»æ ‡ç­¾
    let tabsHtml = '';
    for (const cat of validCategories) {
        const isActive = cat.id === currentActiveOnlineGroupStickerCategoryId;
        tabsHtml += `
            <div class="sticker-category-tab ${isActive ? 'active' : ''}" onclick="switchOnlineGroupStickerCategory(${cat.id})" style="
                flex-shrink: 0;
                padding: 10px 16px;
                font-size: 13px;
                color: ${isActive ? 'var(--ins-pink)' : '#666'};
                border-bottom: 2px solid ${isActive ? 'var(--ins-pink)' : 'transparent'};
                cursor: pointer;
                white-space: nowrap;
                transition: all 0.2s;
            ">
                ${cat.name}
            </div>
        `;
    }
    tabsContainer.innerHTML = tabsHtml;
    
    // æ˜¾ç¤ºå½“å‰é€‰ä¸­åˆ†ç±»çš„è¡¨æƒ…åŒ…
    const currentCategory = validCategories.find(c => c.id === currentActiveOnlineGroupStickerCategoryId);
    if (!currentCategory) return;
    
    let contentHtml = '';
    currentCategory.stickers.forEach(s => {
        const safeUrl = s.url.replace(/'/g, "\\'").replace(/"/g, '&quot;');
        const safeDesc = (s.description || '').replace(/'/g, "\\'").replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        contentHtml += `<div class="emoji-item" onclick="sendOnlineGroupSticker('${safeUrl}')" style="display:flex; flex-direction:column; align-items:center; gap:4px; cursor:pointer;">
            <img src="${s.url}" style="width:60px; height:60px; border-radius:8px; object-fit:cover;" onerror="this.onerror=null; this.style.cssText='width:60px; height:60px; display:flex; align-items:center; justify-content:center; background:#f5f5f5; border-radius:8px;'; this.outerHTML='<div style=\\'width:60px; height:60px; display:flex; align-items:center; justify-content:center; background:#f5f5f5; border-radius:8px; color:#ccc; font-size:10px;\\'>å¤±è´¥</div>';" />
            ${safeDesc ? `<div style="font-size:10px; color:#999; text-align:center; max-width:60px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${safeDesc}</div>` : ''}
        </div>`;
    });
    
    contentContainer.innerHTML = contentHtml;
}

// åˆ‡æ¢è”æœºç¾¤èŠè¡¨æƒ…åŒ…åˆ†ç±»
async function switchOnlineGroupStickerCategory(categoryId) {
    currentActiveOnlineGroupStickerCategoryId = categoryId;
    await loadOnlineGroupStickers();
}

// å‘é€è”æœºç¾¤èŠè¡¨æƒ…åŒ…
function sendOnlineGroupSticker(stickerUrl) {
    const myWx = getMyOnlineWxAccount();
    const myChar = onlineCharacters.find(c => c.wx_account === myWx);
    
    const imgContent = `[img:${stickerUrl}]`;
    
    onlineSocket.send(JSON.stringify({
        type: 'send_group_message',
        group_id: currentOnlineGroupId,
        my_wx_account: myWx,
        sender_type: 'user',
        sender_name: myChar?.nickname || myWx,
        content: imgContent,
        msg_type: 'image'
    }));
    
    closeOnlineGroupPanel();
}

// åˆå§‹åŒ–è”æœºç¾¤èŠEmojié¢æ¿
function initOnlineGroupEmojiPanel() {
    const panel = document.getElementById('online-group-emoji-panel');
    if (!panel) return;
    
    const emojis = [
        'ğŸ˜€', 'ğŸ˜ƒ', 'ğŸ˜„', 'ğŸ˜', 'ğŸ˜†', 'ğŸ˜…', 'ğŸ¤£', 'ğŸ˜‚',
        'ğŸ™‚', 'ğŸ™ƒ', 'ğŸ˜‰', 'ğŸ˜Š', 'ğŸ˜‡', 'ğŸ¥°', 'ğŸ˜', 'ğŸ¤©',
        'ğŸ˜˜', 'ğŸ˜—', 'ğŸ˜š', 'ğŸ˜™', 'ğŸ˜‹', 'ğŸ˜›', 'ğŸ˜œ', 'ğŸ¤ª',
        'ğŸ˜', 'ğŸ¤‘', 'ğŸ¤—', 'ğŸ¤­', 'ğŸ¤«', 'ğŸ¤”', 'ğŸ¤', 'ğŸ¤¨',
        'ğŸ˜', 'ğŸ˜‘', 'ğŸ˜¶', 'ğŸ˜', 'ğŸ˜’', 'ğŸ™„', 'ğŸ˜¬', 'ğŸ¤¥',
        'ğŸ˜Œ', 'ğŸ˜”', 'ğŸ˜ª', 'ğŸ¤¤', 'ğŸ˜´', 'ğŸ˜·', 'ğŸ¤’', 'ğŸ¤•',
        'ğŸ¤¢', 'ğŸ¤®', 'ğŸ¤§', 'ğŸ¥µ', 'ğŸ¥¶', 'ğŸ¥´', 'ğŸ˜µ', 'ğŸ¤¯',
        'ğŸ¤ ', 'ğŸ¥³', 'ğŸ˜', 'ğŸ¤“', 'ğŸ§', 'ğŸ˜•', 'ğŸ˜Ÿ', 'ğŸ™',
        'â˜¹ï¸', 'ğŸ˜®', 'ğŸ˜¯', 'ğŸ˜²', 'ğŸ˜³', 'ğŸ¥º', 'ğŸ˜¦', 'ğŸ˜§',
        'ğŸ˜¨', 'ğŸ˜°', 'ğŸ˜¥', 'ğŸ˜¢', 'ğŸ˜­', 'ğŸ˜±', 'ğŸ˜–', 'ğŸ˜£',
        'ğŸ˜', 'ğŸ˜“', 'ğŸ˜©', 'ğŸ˜«', 'ğŸ¥±', 'ğŸ˜¤', 'ğŸ˜¡', 'ğŸ˜ ',
        'ğŸ¤¬', 'ğŸ˜ˆ', 'ğŸ‘¿', 'ğŸ’€', 'â˜ ï¸', 'ğŸ’©', 'ğŸ¤¡', 'ğŸ‘¹',
        'ğŸ‘º', 'ğŸ‘»', 'ğŸ‘½', 'ğŸ‘¾', 'ğŸ¤–', 'ğŸ˜º', 'ğŸ˜¸', 'ğŸ˜¹',
        'ğŸ˜»', 'ğŸ˜¼', 'ğŸ˜½', 'ğŸ™€', 'ğŸ˜¿', 'ğŸ˜¾', 'ğŸ‘‹', 'ğŸ¤š',
        'ğŸ–', 'âœ‹', 'ğŸ––', 'ğŸ‘Œ', 'ğŸ¤', 'âœŒï¸', 'ğŸ¤', 'ğŸ¤Ÿ',
        'ğŸ¤˜', 'ğŸ¤™', 'ğŸ‘ˆ', 'ğŸ‘‰', 'ğŸ‘†', 'ğŸ–•', 'ğŸ‘‡', 'â˜ï¸',
        'ğŸ‘', 'ğŸ‘', 'âœŠ', 'ğŸ‘Š', 'ğŸ¤›', 'ğŸ¤œ', 'ğŸ‘', 'ğŸ™Œ',
        'ğŸ‘', 'ğŸ¤²', 'ğŸ¤', 'ğŸ™', 'âœï¸', 'ğŸ’…', 'ğŸ¤³', 'ğŸ’ª'
    ];
    
    panel.innerHTML = emojis.map(emoji => 
        `<div class="emoji-item" onclick="insertOnlineGroupEmoji('${emoji}')">${emoji}</div>`
    ).join('');
}

// æ’å…¥Emojiåˆ°è¾“å…¥æ¡†
function insertOnlineGroupEmoji(emoji) {
    const input = document.getElementById('online-group-input');
    if (input) {
        input.value += emoji;
        input.focus();
        // è§¦å‘è¾“å…¥äº‹ä»¶ä»¥æ›´æ–°å‘é€æŒ‰é’®çŠ¶æ€
        input.dispatchEvent(new Event('input'));
    }
}

// è”æœºç¾¤èŠè¯­éŸ³è¾“å…¥
async function onlineGroupVoiceInput() {
    closeOnlineGroupPanel();
    
    // æ˜¾ç¤ºè¯­éŸ³å½•åˆ¶+å˜å£°å¼¹çª—ï¼ˆå®Œå…¨å‚ç…§è”æœºç§èŠï¼‰
    const modal = document.createElement('div');
    modal.id = 'online-group-voice-modal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
    `;
    
    modal.innerHTML = `
        <div style="background: white; border-radius: 16px; padding: 24px; width: 85%; max-width: 320px;">
            <h3 style="margin: 0 0 20px 0; text-align: center; color: #333; font-size: 18px;">ğŸ¤ è¯­éŸ³å½•åˆ¶</h3>
            
            <div style="margin-bottom: 20px;">
                <div style="font-size: 13px; color: #666; margin-bottom: 10px;">é€‰æ‹©å˜å£°æ•ˆæœï¼š</div>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                    <label style="display: flex; align-items: center; padding: 12px; background: #f5f5f5; border-radius: 8px; cursor: pointer;">
                        <input type="radio" name="online-group-voice-effect" value="normal" checked style="margin-right: 8px;">
                        <span>ğŸ™ï¸ åŸå£°</span>
                    </label>
                    <label style="display: flex; align-items: center; padding: 12px; background: #fff0f5; border-radius: 8px; cursor: pointer;">
                        <input type="radio" name="online-group-voice-effect" value="loli" style="margin-right: 8px;">
                        <span>ğŸ€ èè‰éŸ³</span>
                    </label>
                    <label style="display: flex; align-items: center; padding: 12px; background: #f0f5ff; border-radius: 8px; cursor: pointer;">
                        <input type="radio" name="online-group-voice-effect" value="uncle" style="margin-right: 8px;">
                        <span>ğŸ§” å¤§å”éŸ³</span>
                    </label>
                    <label style="display: flex; align-items: center; padding: 12px; background: #f5fff0; border-radius: 8px; cursor: pointer;">
                        <input type="radio" name="online-group-voice-effect" value="robot" style="margin-right: 8px;">
                        <span>ğŸ¤– æœºå™¨äºº</span>
                    </label>
                </div>
            </div>
            
            <div id="online-group-voice-record-status" style="text-align: center; padding: 20px; background: #f9f9f9; border-radius: 12px; margin-bottom: 16px;">
                <div style="font-size: 14px; color: #999;">ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å¼€å§‹å½•éŸ³</div>
                <div id="online-group-voice-record-time" style="font-size: 24px; font-weight: 600; color: #333; margin-top: 8px; display: none;">00:00</div>
            </div>
            
            <div style="display: flex; flex-direction: column; gap: 10px;">
                <button id="btn-start-online-group-record" onclick="startOnlineGroupVoiceRecord()" style="padding: 14px; background: var(--ins-pink); color: white; border: none; border-radius: 10px; font-size: 15px; font-weight: 500; cursor: pointer;">
                    ğŸ¤ æŒ‰ä½å½•éŸ³
                </button>
                <button onclick="closeOnlineGroupVoiceModal()" style="padding: 12px; background: #f0f0f0; color: #666; border: none; border-radius: 8px; font-size: 14px; cursor: pointer;">
                    å–æ¶ˆ
                </button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// å…³é—­è”æœºç¾¤èŠè¯­éŸ³å¼¹çª—
function closeOnlineGroupVoiceModal() {
    document.getElementById('online-group-voice-modal')?.remove();
}

// âœ… è”æœºç¾¤èŠè¯­éŸ³å½•åˆ¶å˜é‡
let onlineGroupVoiceRecorder = null;
let onlineGroupVoiceChunks = [];
let onlineGroupVoiceStartTime = 0;
let onlineGroupVoiceTimer = null;

// å¼€å§‹è”æœºç¾¤èŠè¯­éŸ³å½•åˆ¶
async function startOnlineGroupVoiceRecord() {
    const btn = document.getElementById('btn-start-online-group-record');
    const statusDiv = document.getElementById('online-group-voice-record-status');
    const timeDiv = document.getElementById('online-group-voice-record-time');
    
    // å¦‚æœæ­£åœ¨å½•éŸ³ï¼Œåˆ™åœæ­¢
    if (onlineGroupVoiceRecorder && onlineGroupVoiceRecorder.state === 'recording') {
        stopOnlineGroupVoiceRecord();
        return;
    }
    
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        onlineGroupVoiceRecorder = new MediaRecorder(stream);
        onlineGroupVoiceChunks = [];
        onlineGroupVoiceStartTime = Date.now();
        
        onlineGroupVoiceRecorder.ondataavailable = (e) => {
            if (e.data.size > 0) {
                onlineGroupVoiceChunks.push(e.data);
            }
        };
        
        onlineGroupVoiceRecorder.onstop = async () => {
            stream.getTracks().forEach(track => track.stop());
            clearInterval(onlineGroupVoiceTimer);
            
            const duration = Math.round((Date.now() - onlineGroupVoiceStartTime) / 1000);
            const blob = new Blob(onlineGroupVoiceChunks, { type: 'audio/webm' });
            
            // è·å–é€‰æ‹©çš„å˜å£°æ•ˆæœ
            const effectRadio = document.querySelector('input[name="online-group-voice-effect"]:checked');
            const effect = effectRadio ? effectRadio.value : 'normal';
            
            statusDiv.innerHTML = '<div style="color: var(--ins-pink);">â³ æ­£åœ¨å¤„ç†...</div>';
            
            // å¤„ç†å˜å£°å¹¶å‘é€
            await processAndSendOnlineGroupVoice(blob, effect, duration);
        };
        
        onlineGroupVoiceRecorder.start();
        
        // æ›´æ–°UI
        btn.textContent = 'â¹ï¸ åœæ­¢å½•éŸ³';
        btn.style.background = '#ff3b30';
        timeDiv.style.display = 'block';
        statusDiv.querySelector('div').textContent = 'ğŸ”´ æ­£åœ¨å½•éŸ³...';
        
        // è®¡æ—¶å™¨
        onlineGroupVoiceTimer = setInterval(() => {
            const elapsed = Math.round((Date.now() - onlineGroupVoiceStartTime) / 1000);
            const min = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const sec = (elapsed % 60).toString().padStart(2, '0');
            timeDiv.textContent = `${min}:${sec}`;
        }, 1000);
        
    } catch (err) {
        console.error('å½•éŸ³å¤±è´¥:', err);
        alert('æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·ç¡®ä¿å·²æˆäºˆæƒé™');
    }
}

// åœæ­¢è”æœºç¾¤èŠè¯­éŸ³å½•åˆ¶
function stopOnlineGroupVoiceRecord() {
    if (onlineGroupVoiceRecorder && onlineGroupVoiceRecorder.state === 'recording') {
        onlineGroupVoiceRecorder.stop();
    }
}

// å¤„ç†å˜å£°å¹¶å‘é€è”æœºç¾¤èŠè¯­éŸ³
async function processAndSendOnlineGroupVoice(blob, effect, duration) {
    try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const arrayBuffer = await blob.arrayBuffer();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        
        // æ ¹æ®æ•ˆæœè®¾ç½®å‚æ•°
        let pitchRate = 1.0;
        switch (effect) {
            case 'loli':    pitchRate = 1.4; break;  // èè‰éŸ³ï¼šæé«˜éŸ³è°ƒ
            case 'uncle':   pitchRate = 0.7; break;  // å¤§å”éŸ³ï¼šé™ä½éŸ³è°ƒ
            case 'robot':   pitchRate = 1.0; break;  // æœºå™¨äººï¼šç‰¹æ®Šå¤„ç†
            default:        pitchRate = 1.0; break;
        }
        
        // åˆ›å»ºç¦»çº¿éŸ³é¢‘ä¸Šä¸‹æ–‡è¿›è¡Œå¤„ç†
        const offlineContext = new OfflineAudioContext(
            audioBuffer.numberOfChannels,
            Math.ceil(audioBuffer.length / pitchRate),
            audioBuffer.sampleRate
        );
        
        const source = offlineContext.createBufferSource();
        source.buffer = audioBuffer;
        source.playbackRate.value = pitchRate;
        
        // æœºå™¨äººæ•ˆæœï¼šæ·»åŠ æ³¢å½¢è°ƒåˆ¶
        if (effect === 'robot') {
            const oscillator = offlineContext.createOscillator();
            const gainNode = offlineContext.createGain();
            oscillator.frequency.value = 50;
            gainNode.gain.value = 0.3;
            oscillator.connect(gainNode);
            gainNode.connect(offlineContext.destination);
            oscillator.start();
        }
        
        source.connect(offlineContext.destination);
        source.start();
        
        const renderedBuffer = await offlineContext.startRendering();
        
        // å°†å¤„ç†åçš„éŸ³é¢‘è½¬ä¸º base64
        const wavBlob = await audioBufferToWavForOnlineGroup(renderedBuffer);
        const base64 = await blobToBase64ForOnlineGroup(wavBlob);
        
        // è®¡ç®—å®é™…æ—¶é•¿
        const actualDuration = Math.ceil(duration / pitchRate);
        
        // å‘é€è¯­éŸ³æ¶ˆæ¯åˆ°ç¾¤èŠ
        await sendOnlineGroupVoiceMessage(base64, actualDuration, effect);
        
        closeOnlineGroupVoiceModal();
        
    } catch (err) {
        console.error('è¯­éŸ³å¤„ç†å¤±è´¥:', err);
        alert('è¯­éŸ³å¤„ç†å¤±è´¥: ' + err.message);
    }
}

// AudioBuffer è½¬ WAVï¼ˆè”æœºç¾¤èŠï¼‰
function audioBufferToWavForOnlineGroup(buffer) {
    const numChannels = buffer.numberOfChannels;
    const sampleRate = buffer.sampleRate;
    const format = 1; // PCM
    const bitDepth = 16;
    
    const bytesPerSample = bitDepth / 8;
    const blockAlign = numChannels * bytesPerSample;
    
    const data = [];
    for (let i = 0; i < buffer.length; i++) {
        for (let ch = 0; ch < numChannels; ch++) {
            const sample = buffer.getChannelData(ch)[i];
            const intSample = Math.max(-1, Math.min(1, sample));
            data.push(intSample < 0 ? intSample * 0x8000 : intSample * 0x7FFF);
        }
    }
    
    const dataLength = data.length * bytesPerSample;
    const headerLength = 44;
    const totalLength = headerLength + dataLength;
    
    const arrayBuffer = new ArrayBuffer(totalLength);
    const view = new DataView(arrayBuffer);
    
    // WAV header
    const writeString = (offset, string) => {
        for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
        }
    };
    
    writeString(0, 'RIFF');
    view.setUint32(4, totalLength - 8, true);
    writeString(8, 'WAVE');
    writeString(12, 'fmt ');
    view.setUint32(16, 16, true);
    view.setUint16(20, format, true);
    view.setUint16(22, numChannels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * blockAlign, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, bitDepth, true);
    writeString(36, 'data');
    view.setUint32(40, dataLength, true);
    
    let offset = 44;
    for (let i = 0; i < data.length; i++, offset += 2) {
        view.setInt16(offset, data[i], true);
    }
    
    return new Blob([arrayBuffer], { type: 'audio/wav' });
}

// Blob è½¬ Base64ï¼ˆè”æœºç¾¤èŠï¼‰
function blobToBase64ForOnlineGroup(blob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
    });
}

// å‘é€è”æœºç¾¤èŠè¯­éŸ³æ¶ˆæ¯
async function sendOnlineGroupVoiceMessage(audioBase64, duration, effect) {
    if (!currentOnlineGroupId) return;
    
    const myWx = getMyOnlineWxAccount();
    const myChar = onlineCharacters.find(c => c.wx_account === myWx);
    
    // æ„å»ºè¯­éŸ³æ¶ˆæ¯JSON
    const voiceMsg = JSON.stringify({
        __type: 'audio',
        audio: audioBase64,
        duration: duration,
        effect: effect
    });
    
    // å‘é€åˆ°æœåŠ¡å™¨
    onlineSocket.send(JSON.stringify({
        type: 'send_group_message',
        group_id: currentOnlineGroupId,
        my_wx_account: myWx,
        sender_type: 'user',
        sender_name: myChar?.nickname || myWx,
        content: voiceMsg
    }));
    
    console.log('[è”æœºç¾¤èŠ] è¯­éŸ³æ¶ˆæ¯å·²å‘é€ï¼Œæ—¶é•¿:', duration, 'ç§’ï¼Œæ•ˆæœ:', effect);
    showToast('è¯­éŸ³å·²å‘é€');
}

// è”æœºç¾¤èŠå‘é€å›¾ç‰‡
function onlineGroupSendImage() {
    closeOnlineGroupPanel();
    
    // åˆ›å»ºéšè—çš„æ–‡ä»¶è¾“å…¥
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        // è¯»å–å›¾ç‰‡å¹¶è½¬ä¸ºbase64
        const reader = new FileReader();
        reader.onload = async (event) => {
            const base64 = event.target.result;
            const imgContent = `[img:${base64}]`;
            
            // å‘é€å›¾ç‰‡æ¶ˆæ¯
            const myWx = getMyOnlineWxAccount();
            const myChar = onlineCharacters.find(c => c.wx_account === myWx);
            
            onlineSocket.send(JSON.stringify({
                type: 'send_group_message',
                group_id: currentOnlineGroupId,
                my_wx_account: myWx,
                sender_type: 'user',
                sender_name: myChar?.nickname || myWx,
                content: imgContent,
                msg_type: 'image'
            }));
            
            showToast('å›¾ç‰‡å·²å‘é€');
        };
        reader.readAsDataURL(file);
    };
    input.click();
}

// è”æœºç¾¤èŠè½¬è´¦ - æ˜¾ç¤ºç±»å‹é€‰æ‹©å¼¹çª—
function onlineGroupTransfer() {
    closeOnlineGroupPanel();
    
    const modal = document.createElement('div');
    modal.id = 'online-group-transfer-type-modal';
    modal.className = 'modal-overlay';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
    `;
    
    modal.innerHTML = `
        <div class="modal-box" style="max-width:300px; padding:0; overflow:hidden; border-radius:16px; background:#fff;">
            <div style="padding:20px 16px; text-align:center; border-bottom:0.5px solid #f0f0f0;">
                <div style="font-size:17px; font-weight:600; color:#333;">é€‰æ‹©ç±»å‹</div>
            </div>
            <div style="padding:16px;">
                <div onclick="showOnlineGroupRedPacket()" style="display:flex; align-items:center; padding:14px 16px; background:#fafafa; border-radius:12px; margin-bottom:12px; cursor:pointer; transition:all 0.2s; border:1px solid #f0f0f0;">
                    <div style="width:44px; height:44px; border-radius:12px; background:#fff; border:1px solid #eee; display:flex; align-items:center; justify-content:center; margin-right:14px;">
                        <svg viewBox="0 0 24 24" style="width:22px; height:22px; stroke:var(--ins-pink); fill:none; stroke-width:1.5;"><rect x="3" y="4" width="18" height="16" rx="2"/><path d="M3 10h18"/><circle cx="12" cy="15" r="2"/></svg>
                    </div>
                    <div style="flex:1;">
                        <div style="font-size:15px; font-weight:500; color:#333;">ç¾¤çº¢åŒ…</div>
                        <div style="font-size:12px; color:#999; margin-top:2px;">æ‹¼æ‰‹æ°”æˆ–æ™®é€šçº¢åŒ…</div>
                    </div>
                    <svg viewBox="0 0 24 24" style="width:18px; height:18px; stroke:#ccc; fill:none;"><polyline points="9 18 15 12 9 6"></polyline></svg>
                </div>
                <div onclick="showOnlineGroupExclusiveTransfer()" style="display:flex; align-items:center; padding:14px 16px; background:#fafafa; border-radius:12px; cursor:pointer; transition:all 0.2s; border:1px solid #f0f0f0;">
                    <div style="width:44px; height:44px; border-radius:12px; background:#fff; border:1px solid #eee; display:flex; align-items:center; justify-content:center; margin-right:14px;">
                        <svg viewBox="0 0 24 24" style="width:22px; height:22px; stroke:var(--ins-pink); fill:none; stroke-width:1.5;"><path d="M17 1l4 4-4 4"/><path d="M3 11V9a4 4 0 0 1 4-4h14"/><path d="M7 23l-4-4 4-4"/><path d="M21 13v2a4 4 0 0 1-4 4H3"/></svg>
                    </div>
                    <div style="flex:1;">
                        <div style="font-size:15px; font-weight:500; color:#333;">ä¸“å±è½¬è´¦</div>
                        <div style="font-size:12px; color:#999; margin-top:2px;">è½¬ç»™æŒ‡å®šç¾¤æˆå‘˜</div>
                    </div>
                    <svg viewBox="0 0 24 24" style="width:18px; height:18px; stroke:#ccc; fill:none;"><polyline points="9 18 15 12 9 6"></polyline></svg>
                </div>
            </div>
            <div onclick="document.getElementById('online-group-transfer-type-modal').remove()" style="padding:14px 16px; text-align:center; border-top:0.5px solid #f0f0f0; color:#999; font-size:15px; cursor:pointer;">å–æ¶ˆ</div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// æ˜¾ç¤ºè”æœºç¾¤èŠçº¢åŒ…é¡µé¢
function showOnlineGroupRedPacket() {
    document.getElementById('online-group-transfer-type-modal')?.remove();
    
    // åˆ›å»ºæˆ–æ˜¾ç¤ºçº¢åŒ…é¡µé¢
    let page = document.getElementById('online-group-redpacket-page');
    if (!page) {
        page = document.createElement('div');
        page.id = 'online-group-redpacket-page';
        page.className = 'transfer-modal';
        page.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:#fff; z-index:350; display:none; flex-direction:column;';
        document.body.appendChild(page);
    }
    
    page.innerHTML = `
        <div class="transfer-page-header" style="background:#fff; border-bottom:0.5px solid #f0f0f0;">
            <div class="back-btn" onclick="hideOnlineGroupRedPacketPage()" style="margin:0; background:none; width:40px; justify-content:flex-start; padding-left:0; color:#333;">
                <svg class="svg-icon" viewBox="0 0 24 24" style="width:28px; height:28px;"><polyline points="15 18 9 12 15 6"></polyline></svg>
            </div>
            <div class="transfer-page-title" style="color:#333;">å‘çº¢åŒ…</div>
            <div style="width:40px;"></div>
        </div>
        
        <div style="flex:1; background:#fff; padding:16px;">
            <!-- çº¢åŒ…ç±»å‹é€‰æ‹© -->
            <div style="background:#fff; border-radius:12px; padding:16px; margin-bottom:12px; border:1px solid #eee;">
                <div style="font-size:13px; color:#999; margin-bottom:12px;">çº¢åŒ…ç±»å‹</div>
                <div style="display:flex; gap:12px;">
                    <div id="online-rp-type-lucky" onclick="selectOnlineRedPacketType('lucky')" style="flex:1; padding:12px; border:1.5px solid #333; border-radius:10px; text-align:center; cursor:pointer; background:#fff;">
                        <div style="font-size:14px; font-weight:500; color:#333;">æ‹¼æ‰‹æ°”çº¢åŒ…</div>
                        <div style="font-size:11px; color:#999; margin-top:4px;">é‡‘é¢éšæœº</div>
                    </div>
                    <div id="online-rp-type-normal" onclick="selectOnlineRedPacketType('normal')" style="flex:1; padding:12px; border:1.5px solid #e8e8e8; border-radius:10px; text-align:center; cursor:pointer; background:#fff;">
                        <div style="font-size:14px; font-weight:500; color:#666;">æ™®é€šçº¢åŒ…</div>
                        <div style="font-size:11px; color:#999; margin-top:4px;">é‡‘é¢ç›¸åŒ</div>
                    </div>
                </div>
            </div>
            
            <!-- çº¢åŒ…é‡‘é¢ -->
            <div style="background:#fff; border-radius:12px; padding:16px; margin-bottom:12px; border:1px solid #eee;">
                <div style="display:flex; align-items:center; border-bottom:1px solid #f0f0f0; padding-bottom:14px; margin-bottom:14px;">
                    <div style="font-size:14px; color:#999; width:70px;">æ€»é‡‘é¢</div>
                    <div style="flex:1; display:flex; align-items:center;">
                        <span style="font-size:18px; color:#333; margin-right:4px;">Â¥</span>
                        <input type="number" id="online-rp-amount-input" placeholder="0.00" style="flex:1; border:none; font-size:22px; font-weight:500; outline:none; color:#333;" oninput="checkOnlineRedPacketInput()">
                    </div>
                </div>
                <div style="display:flex; align-items:center;">
                    <div style="font-size:14px; color:#999; width:70px;">çº¢åŒ…ä¸ªæ•°</div>
                    <div style="flex:1; display:flex; align-items:center;">
                        <input type="number" id="online-rp-count-input" placeholder="1" min="1" style="flex:1; border:none; font-size:16px; outline:none; color:#333;" oninput="checkOnlineRedPacketInput()">
                        <span style="font-size:13px; color:#999;">ä¸ª</span>
                    </div>
                </div>
            </div>
            
            <!-- ç¥ç¦è¯­ -->
            <div style="background:#fff; border-radius:12px; padding:14px 16px; margin-bottom:24px; border:1px solid #eee;">
                <input type="text" id="online-rp-wish-input" placeholder="ç¥ç¦è¯­ï¼ˆé€‰å¡«ï¼‰" maxlength="20" style="width:100%; border:none; font-size:14px; outline:none; box-sizing:border-box; color:#333;">
            </div>
            
            <!-- é‡‘é¢æç¤º -->
            <div style="text-align:center; margin-bottom:20px;">
                <span style="font-size:13px; color:#999;" id="online-rp-total-hint">å…±0.00å…ƒ</span>
            </div>
            
            <!-- å‘é€æŒ‰é’® -->
            <button id="btn-send-online-redpacket" onclick="sendOnlineGroupRedPacket()" disabled style="width:100%; padding:14px; background:#ccc; color:#fff; border:none; border-radius:24px; font-size:16px; font-weight:500; cursor:not-allowed; transition:all 0.2s;">
                å‘çº¢åŒ…
            </button>
        </div>
    `;
    
    // é‡ç½®è¾“å…¥
    document.getElementById('online-rp-amount-input').value = '';
    document.getElementById('online-rp-count-input').value = '';
    document.getElementById('online-rp-wish-input').value = '';
    document.getElementById('online-rp-total-hint').innerText = 'å…±0.00å…ƒ';
    document.getElementById('btn-send-online-redpacket').disabled = true;
    document.getElementById('btn-send-online-redpacket').style.background = '#ccc';
    document.getElementById('btn-send-online-redpacket').style.cursor = 'not-allowed';
    
    // é»˜è®¤é€‰ä¸­æ‹¼æ‰‹æ°”
    selectOnlineRedPacketType('lucky');
    
    page.style.display = 'flex';
}

// éšè—è”æœºç¾¤èŠçº¢åŒ…é¡µé¢
function hideOnlineGroupRedPacketPage() {
    const page = document.getElementById('online-group-redpacket-page');
    if (page) page.style.display = 'none';
}

// è”æœºç¾¤èŠçº¢åŒ…ç±»å‹
let currentOnlineRedPacketType = 'lucky';

// é€‰æ‹©è”æœºç¾¤èŠçº¢åŒ…ç±»å‹
function selectOnlineRedPacketType(type) {
    currentOnlineRedPacketType = type;
    
    const luckyEl = document.getElementById('online-rp-type-lucky');
    const normalEl = document.getElementById('online-rp-type-normal');
    
    if (!luckyEl || !normalEl) return;
    
    if (type === 'lucky') {
        luckyEl.style.borderColor = '#333';
        luckyEl.style.background = '#fff';
        luckyEl.querySelector('div:first-child').style.color = '#333';
        
        normalEl.style.borderColor = '#e8e8e8';
        normalEl.style.background = '#fff';
        normalEl.querySelector('div:first-child').style.color = '#666';
    } else {
        normalEl.style.borderColor = '#333';
        normalEl.style.background = '#fff';
        normalEl.querySelector('div:first-child').style.color = '#333';
        
        luckyEl.style.borderColor = '#e8e8e8';
        luckyEl.style.background = '#fff';
        luckyEl.querySelector('div:first-child').style.color = '#666';
    }
}

// æ£€æŸ¥è”æœºç¾¤èŠçº¢åŒ…è¾“å…¥
function checkOnlineRedPacketInput() {
    const amount = parseFloat(document.getElementById('online-rp-amount-input')?.value || 0);
    const count = parseInt(document.getElementById('online-rp-count-input')?.value || 0);
    const btn = document.getElementById('btn-send-online-redpacket');
    const hint = document.getElementById('online-rp-total-hint');
    
    if (!btn || !hint) return;
    
    if (amount > 0 && count > 0) {
        hint.innerText = `å…±${amount.toFixed(2)}å…ƒ`;
        btn.disabled = false;
        btn.style.background = '#333';
        btn.style.cursor = 'pointer';
    } else {
        hint.innerText = 'å…±0.00å…ƒ';
        btn.disabled = true;
        btn.style.background = '#ccc';
        btn.style.cursor = 'not-allowed';
    }
}

// å‘é€è”æœºç¾¤èŠçº¢åŒ…
async function sendOnlineGroupRedPacket() {
    if (!currentOnlineGroupId) return;
    
    const amount = parseFloat(document.getElementById('online-rp-amount-input')?.value);
    const count = parseInt(document.getElementById('online-rp-count-input')?.value);
    const wish = document.getElementById('online-rp-wish-input')?.value.trim() || 'æ­å–œå‘è´¢ï¼Œå¤§å‰å¤§åˆ©';
    
    if (!amount || amount <= 0 || !count || count <= 0) {
        showToast('è¯·å¡«å†™æ­£ç¡®çš„é‡‘é¢å’Œä¸ªæ•°');
        return;
    }
    
    // æ£€æŸ¥ä½™é¢
    if (!currentMyCharId) {
        showToast("è¯·å…ˆè®¾ç½®Userèº«ä»½");
        return;
    }
    const user = await db.characters.get(parseInt(currentMyCharId));
    let currentBalance = 0;
    if (user && user.identity && user.identity.balance) {
        currentBalance = parseFloat(user.identity.balance.toString().replace(/,/g, ''));
    }
    
    if (currentBalance < amount) {
        showToast('ä½™é¢ä¸è¶³ (å½“å‰: Â¥' + currentBalance.toFixed(2) + ')');
        return;
    }
    
    // æ‰£æ¬¾
    const newBalance = currentBalance - amount;
    user.identity.balance = newBalance.toFixed(2);
    await db.characters.put(user);
    
    // æ„å»ºçº¢åŒ…æ•°æ®
    const redPacketData = {
        type: 'redpacket',
        redpacketType: currentOnlineRedPacketType, // 'lucky' æˆ– 'normal'
        totalAmount: amount.toFixed(2),
        count: count,
        wish: wish,
        claimed: [], // å·²é¢†å–çš„æˆå‘˜å¾®ä¿¡å·åˆ—è¡¨
        claimedAmounts: {}, // æ¯ä¸ªæˆå‘˜é¢†å–çš„é‡‘é¢ {wx_account: amount}
        id: 'rp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9)
    };
    
    // å‘é€åˆ°æœåŠ¡å™¨
    const myWx = getMyOnlineWxAccount();
    const myChar = onlineCharacters.find(c => c.wx_account === myWx);
    
    onlineSocket.send(JSON.stringify({
        type: 'send_group_message',
        group_id: currentOnlineGroupId,
        my_wx_account: myWx,
        sender_type: 'user',
        sender_name: myChar?.nickname || myWx,
        content: JSON.stringify(redPacketData),
        msg_type: 'redpacket'
    }));
    
    // è®°å½•è´¦å•
    await addTransaction('expense', amount, 'å‘çº¢åŒ…', `è”æœºç¾¤èŠ Â· ${count}ä¸ªçº¢åŒ…`);
    
    hideOnlineGroupRedPacketPage();
    showToast('çº¢åŒ…å·²å‘å‡º');
}

// æ˜¾ç¤ºè”æœºç¾¤èŠçº¢åŒ…è¯¦æƒ…
function showOnlineGroupRedPacketDetail(msgId) {
    // åœ¨æ¶ˆæ¯åˆ—è¡¨ä¸­æ‰¾åˆ°çº¢åŒ…æ¶ˆæ¯
    const msg = currentOnlineGroupMessages.find(m => {
        if (m.msg_type !== 'redpacket') return false;
        return (m.id || ('rp_' + m.created_at)) === msgId;
    });
    
    if (!msg) {
        showToast('çº¢åŒ…ä¸å­˜åœ¨');
        return;
    }
    
    try {
        const data = JSON.parse(msg.content);
        const myWx = getMyOnlineWxAccount();
        const hasClaimed = data.claimed?.includes(myWx) || false;
        const claimedCount = (data.claimed || []).length;
        const isAllClaimed = claimedCount >= data.count;
        
        // åˆ›å»ºæˆ–æ˜¾ç¤ºçº¢åŒ…è¯¦æƒ…é¡µé¢
        let page = document.getElementById('online-group-redpacket-detail-page');
        if (!page) {
            page = document.createElement('div');
            page.id = 'online-group-redpacket-detail-page';
            page.className = 'transfer-modal';
            page.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:#fff; z-index:360; display:none; flex-direction:column;';
            document.body.appendChild(page);
        }
        
        page.innerHTML = `
            <div class="transfer-page-header" style="background:#fff; border-bottom:0.5px solid #f0f0f0;">
                <div class="back-btn" onclick="hideOnlineGroupRedPacketDetail()" style="margin:0; background:none; width:40px; justify-content:flex-start; padding-left:0; color:#333;">
                    <svg class="svg-icon" viewBox="0 0 24 24" style="width:28px; height:28px;"><polyline points="15 18 9 12 15 6"></polyline></svg>
                </div>
                <div class="transfer-page-title" style="color:#333;">çº¢åŒ…è¯¦æƒ…</div>
                <div style="width:40px;"></div>
            </div>
            
            <div style="flex:1; background:#fff; overflow-y:auto;">
                <!-- çº¢åŒ…ä¿¡æ¯å¤´éƒ¨ -->
                <div style="padding:30px 20px; text-align:center; border-bottom:1px solid #f0f0f0;">
                    <div id="online-rp-detail-avatar" style="width:60px; height:60px; border-radius:50%; background:#eee; margin:0 auto 12px; background-size:cover; background-position:center;"></div>
                    <div id="online-rp-detail-sender" style="font-size:15px; color:#333; margin-bottom:8px;">${msg.sender_name} çš„çº¢åŒ…</div>
                    <div id="online-rp-detail-wish" style="font-size:18px; font-weight:500; color:#333; margin-bottom:6px;">${escapeHtml(data.wish || 'æ­å–œå‘è´¢')}</div>
                    <div id="online-rp-detail-type" style="font-size:13px; color:#999;">${data.redpacketType === 'lucky' ? 'æ‹¼æ‰‹æ°”çº¢åŒ…' : 'æ™®é€šçº¢åŒ…'}</div>
                </div>
                
                <!-- é¢†å–æŒ‰é’®åŒºåŸŸ -->
                <div id="online-rp-detail-action" style="padding:20px; border-bottom:1px solid #f0f0f0;">
                    <button id="btn-claim-online-redpacket" onclick="claimOnlineGroupRedPacket('${msgId}', '${myWx}', null)" style="width:100%; padding:14px; background:${isAllClaimed || hasClaimed ? '#ccc' : '#333'}; color:#fff; border:none; border-radius:24px; font-size:16px; font-weight:500; cursor:${isAllClaimed || hasClaimed ? 'not-allowed' : 'pointer'};" ${isAllClaimed || hasClaimed ? 'disabled' : ''}>
                        ${isAllClaimed ? 'çº¢åŒ…å·²é¢†å®Œ' : hasClaimed ? `å·²é¢†å– Â¥${(data.claimedAmounts?.[myWx] || '0.00')}` : 'é¢†å–çº¢åŒ…'}
                    </button>
                </div>
                
                <!-- å·²é¢†å–åˆ—è¡¨ -->
                <div style="padding:16px 20px;">
                    <div style="font-size:13px; color:#999; margin-bottom:12px;">
                        <span id="online-rp-detail-claimed-count">${claimedCount}</span>/<span id="online-rp-detail-total-count">${data.count}</span> å·²é¢†å–ï¼Œå…± <span id="online-rp-detail-total-amount">${Object.values(data.claimedAmounts || {}).reduce((a, b) => a + parseFloat(b), 0).toFixed(2)}</span> å…ƒ
                    </div>
                    <div id="online-rp-detail-claimed-list">
                        ${data.claimed && data.claimed.length > 0 ? 
                            data.claimed.map(wx => {
                                const member = currentOnlineGroupMembers.find(m => m.user_wx === wx);
                                const amount = data.claimedAmounts?.[wx] || '0.00';
                                return `
                                    <div style="display:flex; align-items:center; padding:12px 0; border-bottom:1px solid #f0f0f0;">
                                        <div style="width:40px; height:40px; border-radius:50%; background:#eee; background-image:url(${member?.user_avatar || ''}); background-size:cover; background-position:center; margin-right:12px; flex-shrink:0;"></div>
                                        <div style="flex:1;">
                                            <div style="font-size:14px; color:#333;">${member?.user_name || wx}</div>
                                        </div>
                                        <div style="font-size:15px; font-weight:500; color:#333;">Â¥${amount}</div>
                                    </div>
                                `;
                            }).join('') : 
                            '<div style="text-align:center; color:#999; padding:30px 0; font-size:13px;">æš‚æ— äººé¢†å–</div>'
                        }
                    </div>
                </div>
            </div>
        `;
        
        // è®¾ç½®å‘é€è€…å¤´åƒ
        const avatarEl = document.getElementById('online-rp-detail-avatar');
        if (msg.sender_avatar) {
            avatarEl.style.backgroundImage = `url(${msg.sender_avatar})`;
        }
        
        page.style.display = 'flex';
    } catch(e) {
        console.error('æ˜¾ç¤ºçº¢åŒ…è¯¦æƒ…å¤±è´¥:', e);
        showToast('çº¢åŒ…æ•°æ®é”™è¯¯');
    }
}

// éšè—è”æœºç¾¤èŠçº¢åŒ…è¯¦æƒ…
function hideOnlineGroupRedPacketDetail() {
    const page = document.getElementById('online-group-redpacket-detail-page');
    if (page) page.style.display = 'none';
}

// é¢†å–è”æœºç¾¤èŠçº¢åŒ…ï¼ˆç”¨æˆ·æˆ–è§’è‰²éƒ½å¯ä»¥ï¼‰
async function claimOnlineGroupRedPacket(msgId, claimerWx, characterName) {
    if (!currentOnlineGroupId || !onlineSocket || onlineSocket.readyState !== WebSocket.OPEN) {
        showToast('æœªè¿æ¥åˆ°æœåŠ¡å™¨');
        return;
    }
    
    const myWx = getMyOnlineWxAccount();
    const claimerName = characterName || (onlineCharacters.find(c => c.wx_account === myWx)?.nickname || myWx);
    
    // å‘é€é¢†å–è¯·æ±‚åˆ°æœåŠ¡å™¨
    onlineSocket.send(JSON.stringify({
        type: 'claim_group_redpacket',
        group_id: currentOnlineGroupId,
        my_wx_account: myWx,
        message_id: msgId,
        claimer_name: claimerName
    }));
}

// å¤„ç†çº¢åŒ…è¢«é¢†å–çš„é€šçŸ¥
async function handleRedPacketClaimed(data) {
    const { group_id, message_id, claimer_wx, claim_amount, redpacket_data } = data;
    
    if (group_id !== currentOnlineGroupId) return;
    
    // æ›´æ–°æœ¬åœ°æ¶ˆæ¯ä¸­çš„çº¢åŒ…æ•°æ®
    const msgIndex = currentOnlineGroupMessages.findIndex(m => m.id === message_id);
    if (msgIndex !== -1) {
        currentOnlineGroupMessages[msgIndex].content = JSON.stringify(redpacket_data);
        renderOnlineGroupMessages();
    }
    
    // å¦‚æœæ˜¯è‡ªå·±é¢†å–çš„ï¼Œæ›´æ–°é’±åŒ…
    const myWx = getMyOnlineWxAccount();
    if (claimer_wx === myWx) {
        const claimAmountNum = parseFloat(claim_amount);
        
        if (!currentMyCharId) {
            showToast(`æˆåŠŸé¢†å– Â¥${claim_amount}`);
            return;
        }
        
        const user = await db.characters.get(parseInt(currentMyCharId));
        if (user) {
            if (!user.identity) user.identity = {};
            let balance = parseFloat(user.identity.balance || 0);
            balance += claimAmountNum;
            user.identity.balance = balance.toFixed(2);
            await db.characters.put(user);
            
            // è®°å½•è´¦å•
            const group = onlineGroups.find(g => g.id === currentOnlineGroupId);
            await addTransaction('income', claimAmountNum, 'çº¢åŒ…', group?.name || 'è”æœºç¾¤èŠ');
            
            showToast(`æˆåŠŸé¢†å– Â¥${claim_amount}`);
        }
    }
    
    // åˆ·æ–°çº¢åŒ…è¯¦æƒ…é¡µé¢ï¼ˆå¦‚æœå·²æ‰“å¼€ï¼‰
    const detailPage = document.getElementById('online-group-redpacket-detail-page');
    if (detailPage && detailPage.style.display !== 'none') {
        showOnlineGroupRedPacketDetail(message_id);
    }
}

// æ˜¾ç¤ºè”æœºç¾¤èŠä¸“å±è½¬è´¦é€‰äººé¡µé¢
async function showOnlineGroupExclusiveTransfer() {
    document.getElementById('online-group-transfer-type-modal')?.remove();
    
    const listHtml = currentOnlineGroupMembers.map(m => {
        const avatarStyle = m.user_avatar ? `background-image:url(${m.user_avatar})` : 'background:#ccc';
        const myWx = getMyOnlineWxAccount();
        if (m.user_wx === myWx) return ''; // ä¸æ˜¾ç¤ºè‡ªå·±
        
        return `
            <div onclick="selectOnlineGroupTransferTarget('${m.user_wx}', '${m.user_name}')" style="display:flex; align-items:center; padding:12px 16px; cursor:pointer; transition:background 0.2s; border-bottom:0.5px solid #f0f0f0;">
                <div style="width:44px; height:44px; border-radius:6px; ${avatarStyle}; background-size:cover; background-position:center; margin-right:12px;"></div>
                <div style="flex:1;">
                    <div style="font-size:16px; color:#333;">${m.user_name}</div>
                    ${m.character_name ? `<div style="font-size:12px; color:#999;">${m.character_name}</div>` : ''}
                </div>
            </div>
        `;
    }).filter(h => h).join('');
    
    const modal = document.createElement('div');
    modal.id = 'online-group-exclusive-modal';
    modal.className = 'modal-overlay';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
    `;
    
    modal.innerHTML = `
        <div style="background:#fff; border-radius:16px; width:85%; max-width:400px; max-height:70%; overflow:hidden; display:flex; flex-direction:column;">
            <div style="padding:20px 16px; text-align:center; border-bottom:0.5px solid #f0f0f0;">
                <div style="font-size:17px; font-weight:600; color:#333;">é€‰æ‹©è½¬è´¦å¯¹è±¡</div>
            </div>
            <div style="flex:1; overflow-y:auto;">
                ${listHtml || '<div style="text-align:center; color:#999; padding:40px;">ç¾¤å†…æš‚æ— å…¶ä»–æˆå‘˜</div>'}
            </div>
            <div onclick="document.getElementById('online-group-exclusive-modal').remove()" style="padding:14px 16px; text-align:center; border-top:0.5px solid #f0f0f0; color:#999; font-size:15px; cursor:pointer;">å–æ¶ˆ</div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// é€‰æ‹©è”æœºç¾¤èŠè½¬è´¦ç›®æ ‡
function selectOnlineGroupTransferTarget(targetWx, targetName) {
    document.getElementById('online-group-exclusive-modal')?.remove();
    
    const modal = document.createElement('div');
    modal.id = 'online-group-transfer-amount-modal';
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
    `;
    
    modal.innerHTML = `
        <div style="background:#fff; border-radius:16px; padding:24px; width:85%; max-width:360px;">
            <h3 style="margin:0 0 16px 0; text-align:center; font-size:18px;">è½¬è´¦ç»™ ${targetName}</h3>
            
            <div style="margin-bottom:16px;">
                <label style="display:block; font-size:13px; color:#666; margin-bottom:8px;">è½¬è´¦é‡‘é¢</label>
                <input type="number" id="online-group-transfer-amount" placeholder="è¾“å…¥é‡‘é¢" style="width:100%; padding:12px; border:1px solid #ddd; border-radius:8px; font-size:14px;">
            </div>
            
            <div style="margin-bottom:20px;">
                <label style="display:block; font-size:13px; color:#666; margin-bottom:8px;">è½¬è´¦è¯´æ˜</label>
                <input type="text" id="online-group-transfer-note" placeholder="æ·»åŠ è½¬è´¦è¯´æ˜" style="width:100%; padding:12px; border:1px solid #ddd; border-radius:8px; font-size:14px;">
            </div>
            
            <div style="display:flex; gap:12px;">
                <button onclick="document.getElementById('online-group-transfer-amount-modal').remove()" style="flex:1; padding:12px; background:#f0f0f0; color:#666; border:none; border-radius:8px; font-size:15px;">å–æ¶ˆ</button>
                <button onclick="sendOnlineGroupExclusiveTransfer('${targetWx}', '${targetName}')" style="flex:1; padding:12px; background:var(--ins-pink); color:#fff; border:none; border-radius:8px; font-size:15px;">è½¬è´¦</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// å‘é€è”æœºç¾¤èŠä¸“å±è½¬è´¦
function sendOnlineGroupExclusiveTransfer(targetWx, targetName) {
    const amount = document.getElementById('online-group-transfer-amount').value.trim();
    const note = document.getElementById('online-group-transfer-note').value.trim();
    
    if (!amount || parseFloat(amount) <= 0) {
        alert('è¯·è¾“å…¥æœ‰æ•ˆçš„é‡‘é¢');
        return;
    }
    
    const myWx = getMyOnlineWxAccount();
    const myChar = onlineCharacters.find(c => c.wx_account === myWx);
    
    // ä½¿ç”¨å’Œæ™®é€šç¾¤èŠä¸€æ ·çš„JSONæ ¼å¼
    const transferData = {
        amount: parseFloat(amount),
        desc: note || 'è½¬è´¦',
        status: 'pending',
        targetWx: targetWx,
        targetName: targetName
    };
    
    onlineSocket.send(JSON.stringify({
        type: 'send_group_message',
        group_id: currentOnlineGroupId,
        my_wx_account: myWx,
        sender_type: 'user',
        sender_name: myChar?.nickname || myWx,
        content: JSON.stringify(transferData),
        msg_type: 'transfer'
    }));
    
    document.getElementById('online-group-transfer-amount-modal')?.remove();
    showToast('è½¬è´¦å·²å‘é€');
}

// åˆ·æ–°ç¾¤æˆå‘˜åˆ—è¡¨
function refreshOnlineGroupMembers() {
    const myWx = getMyOnlineWxAccount();
    if (myWx && currentOnlineGroupId) {
        onlineSocket.send(JSON.stringify({
            type: 'get_group_members',
            group_id: currentOnlineGroupId,
            my_wx_account: myWx
        }));
    }
}

// å‘é€ç¾¤æ¶ˆæ¯
function sendOnlineGroupMsg() {
    const input = document.getElementById('online-group-input');
    const content = input.value.trim();
    if (!content || !currentOnlineGroupId) return;
    
    const myWx = getMyOnlineWxAccount();
    const myChar = onlineCharacters.find(c => c.wx_account === myWx);
    
    onlineSocket.send(JSON.stringify({
        type: 'send_group_message',
        group_id: currentOnlineGroupId,
        my_wx_account: myWx,
        sender_type: 'user',
        sender_name: myChar?.nickname || myWx,
        content: content
    }));
    
    input.value = '';
    // è§¦å‘inputäº‹ä»¶ä»¥æ›´æ–°å‘é€æŒ‰é’®çŠ¶æ€
    input.dispatchEvent(new Event('input'));
    // å…³é—­é¢æ¿
    closeOnlineGroupPanel();
}

// è®©æˆ‘çš„è§’è‰²è¯´è¯ï¼ˆè°ƒç”¨APIï¼‰
async function letMyCharacterSpeak() {
    console.log('[è”æœºç¾¤èŠ] âš¡ è§¦å‘ AI å›å¤');
    
    if (!myOnlineGroupCharacter) {
        alert('ä½ æ²¡æœ‰åœ¨è¿™ä¸ªç¾¤èŠä¸­è®¾ç½®è§’è‰²ã€‚è¯·åœ¨ç¾¤èŠè®¾ç½®ä¸­é€‰æ‹©è¦å¸¦å…¥çš„è§’è‰²ã€‚');
        return;
    }
    
    if (currentOnlineGroupMessages.length === 0) {
        alert('ç¾¤èŠä¸­è¿˜æ²¡æœ‰æ¶ˆæ¯ï¼Œè§’è‰²æ— æ³•å›å¤');
        return;
    }
    
    const myWx = getMyOnlineWxAccount();
    const myUserName = onlineCharacters.find(c => c.wx_account === myWx)?.nickname || myWx;
    
    console.log('[è”æœºç¾¤èŠ] è§’è‰²åç§°:', myOnlineGroupCharacter.name);
    console.log('[è”æœºç¾¤èŠ] æˆ‘çš„å¾®ä¿¡å·:', myWx);
    console.log('[è”æœºç¾¤èŠ] æˆ‘çš„æ˜µç§°:', myUserName);
    console.log('[è”æœºç¾¤èŠ] ğŸ“š ç¾¤èŠæ¶ˆæ¯æ¡æ•°:', currentOnlineGroupMessages.length);
    console.log('[è”æœºç¾¤èŠ] ğŸ‘¥ ç¾¤æˆå‘˜æ•°é‡:', currentOnlineGroupMembers.length);
    
    // æ‰“å°æœ€è¿‘çš„æ¶ˆæ¯
    if (currentOnlineGroupMessages.length > 0) {
        console.log('[è”æœºç¾¤èŠ] æœ€è¿‘5æ¡æ¶ˆæ¯:');
        currentOnlineGroupMessages.slice(-5).forEach((msg, idx) => {
            const isChar = msg.sender_type === 'character';
            const prefix = isChar ? `[è§’è‰²]${msg.character_name}(${msg.sender_name})` : `[çœŸäºº]${msg.sender_name}`;
            console.log(`  [${currentOnlineGroupMessages.length - 5 + idx}] ${prefix}: ${msg.content}`);
        });
    }
    
    // ä¿®æ”¹æ ‡é¢˜ä¸ºæ­£åœ¨è¾“å…¥
    const chatTitleEl = document.getElementById('online-group-chat-title');
    const group = onlineGroups.find(g => g.id === currentOnlineGroupId);
    const originalTitle = group?.name || 'è”æœºç¾¤èŠ';
    
    if (chatTitleEl) {
        chatTitleEl.innerText = `${myOnlineGroupCharacter.name} æ­£åœ¨è¾“å…¥ä¸­...`;
        console.log('[è”æœºç¾¤èŠ] ä¿®æ”¹æ ‡é¢˜ä¸º:', `${myOnlineGroupCharacter.name} æ­£åœ¨è¾“å…¥ä¸­...`);
    }
    
    // é€šçŸ¥ç¾¤é‡Œå…¶ä»–äººï¼šæˆ‘çš„è§’è‰²æ­£åœ¨è¾“å…¥
    onlineSocket.send(JSON.stringify({
        type: 'group_typing_start',
        group_id: currentOnlineGroupId,
        my_wx_account: myWx,
        character_name: myOnlineGroupCharacter.name
    }));
    
    showToast('æ­£åœ¨ç”Ÿæˆå›å¤...');
    
    try {
        // æ„å»ºç¾¤æˆå‘˜ä¿¡æ¯ï¼ˆåªæœ‰åå­—ï¼Œæ²¡æœ‰äººè®¾ï¼‰
        let membersInfo = 'ç¾¤èŠæˆå‘˜ï¼š\n';
        currentOnlineGroupMembers.forEach(m => {
            if (m.character_name) {
                membersInfo += `- ${m.user_name}ï¼ˆå¸¦ç€è§’è‰²"${m.character_name}"ï¼‰\n`;
            } else {
                membersInfo += `- ${m.user_name}\n`;
            }
        });
        console.log('[è”æœºç¾¤èŠ] ç¾¤æˆå‘˜ä¿¡æ¯:\n', membersInfo);
        
        // æ”¶é›†æœªé¢†å®Œçš„çº¢åŒ…ä¿¡æ¯
        let pendingRedPackets = [];
        currentOnlineGroupMessages.forEach(msg => {
            if (msg.msg_type === 'redpacket') {
                try {
                    const rpData = JSON.parse(msg.content);
                    const claimedCount = (rpData.claimed || []).length;
                    const isAllClaimed = claimedCount >= rpData.count;
                    const myWx = getMyOnlineWxAccount();
                    const hasClaimed = rpData.claimed?.includes(myWx) || false;
                    
                    if (!isAllClaimed && !hasClaimed) {
                        pendingRedPackets.push({
                            id: msg.id || ('rp_' + msg.created_at),
                            wish: rpData.wish || 'æ­å–œå‘è´¢',
                            remaining: rpData.count - claimedCount,
                            claimed: rpData.claimed || []
                        });
                    }
                } catch(e) {}
            }
        });
        
        // æ„å»ºä¸Šä¸‹æ–‡
        const context = currentOnlineGroupMessages.map(msg => {
            const isChar = msg.sender_type === 'character';
            if (msg.msg_type === 'redpacket') {
                try {
                    const rpData = JSON.parse(msg.content);
                    const claimedCount = (rpData.claimed || []).length;
                    const isAllClaimed = claimedCount >= rpData.count;
                    return `[${msg.sender_name}]: [å‘é€äº†çº¢åŒ…] "${rpData.wish || 'æ­å–œå‘è´¢'}" (çº¢åŒ…ID: ${msg.id || ('rp_' + msg.created_at)}, ${isAllClaimed ? 'å·²é¢†å®Œ' : `è¿˜å‰©${rpData.count - claimedCount}ä¸ªå¯é¢†`})`;
                } catch(e) {
                    return `[${msg.sender_name}]: [å‘é€äº†çº¢åŒ…]`;
                }
            } else if (isChar) {
                // è§’è‰²æ¶ˆæ¯ï¼šæ˜¾ç¤ºè§’è‰²åå’Œä¸»äººå
                return `[${msg.character_name}ï¼ˆ${msg.sender_name}çš„è§’è‰²ï¼‰]: ${msg.content}`;
            } else {
                // çœŸäººæ¶ˆæ¯
                return `[${msg.sender_name}]: ${msg.content}`;
            }
        }).join('\n');
        console.log('[è”æœºç¾¤èŠ] ä¸Šä¸‹æ–‡æ¶ˆæ¯ï¼ˆå‰300å­—ï¼‰:', context.substring(0, 300));
        
        // æ„å»ºæç¤ºè¯
        const systemPrompt = `ä½ æ˜¯"${myOnlineGroupCharacter.name}"ï¼Œæ˜¯"${myUserName}"å¸¦å…¥ç¾¤èŠçš„AIè§’è‰²ã€‚
âš ï¸ é‡è¦ï¼šä½ çš„åå­—æ˜¯${myOnlineGroupCharacter.name}ï¼Œä½ ä¸æ˜¯${myUserName}æˆ–å…¶ä»–ç¾¤æˆå‘˜ï¼ä½ æ˜¯ç‹¬ç«‹çš„è§’è‰²ã€‚

ã€ä½ çš„äººè®¾ã€‘
${myOnlineGroupCharacter.desc || 'ï¼ˆæ— ç‰¹å®šäººè®¾ï¼‰'}

ã€${membersInfo}ã€‘

${pendingRedPackets.length > 0 ? `
ğŸ§§ ç¾¤é‡Œæœ‰æœªé¢†å®Œçš„çº¢åŒ…ï¼
${pendingRedPackets.map(rp => `- çº¢åŒ…ID: ${rp.id}, ç¥ç¦è¯­: "${rp.wish}", è¿˜å‰© ${rp.remaining} ä¸ªå¯é¢†`).join('\n')}
æç¤ºï¼šçœ‹åˆ°çº¢åŒ…æ—¶ï¼Œä½ å¯ä»¥ç§¯æå»æŠ¢ï¼ä½¿ç”¨ {"type": "claim_redpacket", "redpacketId": "çº¢åŒ…ID"} æ¥é¢†å–çº¢åŒ…ã€‚
` : ''}

ã€é‡è¦å›å¤è§„åˆ™ - å¿…é¡»ä¸¥æ ¼éµå®ˆã€‘
1. **å¿…é¡»**æ¨¡æ‹Ÿå¾®ä¿¡è¿å‘æ¶ˆæ¯çš„ä¹ æƒ¯ï¼šè¯·ç”Ÿæˆ ${myOnlineGroupCharacter.reply_min_count || 1} åˆ° ${myOnlineGroupCharacter.reply_max_count || 3} æ¡çŸ­æ¶ˆæ¯${(myOnlineGroupCharacter.reply_min_count || 1) === 1 ? '' : 'ï¼Œä¸èƒ½åªå‘ä¸€æ¡'}ï¼
2. **å¿…é¡»**ä½¿ç”¨åˆ†éš”ç¬¦ "|||" æ¥éš”å¼€æ¯ä¸€æ¡æ¶ˆæ¯ã€‚
3. **ä¸¥ç¦ä½¿ç”¨é€—å·**ï¼ˆåŒ…æ‹¬ä¸­æ–‡é€—å·å’Œè‹±æ–‡é€—å·ï¼‰ã€‚å¦‚æœæƒ³è¡¨è¾¾åœé¡¿ï¼Œè¯·ç›´æ¥æ‹†åˆ†æˆä¸‹ä¸€æ¡æ¶ˆæ¯ï¼Œæˆ–è€…ç”¨ç©ºæ ¼ä»£æ›¿ã€‚
   - é”™è¯¯ç¤ºä¾‹ï¼šå˜¿åœ¨å—ï¼Ÿåˆšåˆšçœ‹åˆ°ä¸ªå¥½ç©çš„è§†é¢‘ï¼Œå‘ç»™ä½ çœ‹çœ‹
   - æ­£ç¡®ç¤ºä¾‹ï¼šå˜¿åœ¨å—ï¼Ÿ|||åˆšåˆšçœ‹åˆ°ä¸ªå¥½ç©çš„è§†é¢‘|||å‘ç»™ä½ çœ‹çœ‹
4. åƒçœŸå®å¾®ä¿¡èŠå¤©ä¸€æ ·åˆ†å¤šæ¡å‘é€ã€‚
5. ä¸¥ç¦åªå‘é€æ ‡ç‚¹ç¬¦å·ã€‚æ¯ä¸€æ¡æ¶ˆæ¯éƒ½å¿…é¡»æœ‰å®é™…æ–‡å­—å†…å®¹ã€‚
6. è¯­æ°”è¦è‡ªç„¶ã€å£è¯­åŒ–ï¼Œç¬¦åˆäººè®¾ã€‚
7. ä½ åªçŸ¥é“å…¶ä»–æˆå‘˜å’Œè§’è‰²çš„åå­—ï¼Œä¸çŸ¥é“ä»–ä»¬è§’è‰²çš„å…·ä½“äººè®¾
8. è¯·æ ¹æ®ç¾¤èŠä¸Šä¸‹æ–‡ï¼Œä»¥"${myOnlineGroupCharacter.name}"çš„èº«ä»½è‡ªç„¶åœ°å‚ä¸å¯¹è¯
9. åªå›å¤ä½ è¦è¯´çš„å†…å®¹ï¼Œä¸è¦åŠ ä»»ä½•å‰ç¼€å¦‚"${myOnlineGroupCharacter.name}:"
10. å›å¤è¦ç¬¦åˆä½ çš„äººè®¾æ€§æ ¼
11. **é¢†å–çº¢åŒ…**ï¼šå¦‚æœç¾¤èŠä¸­æœ‰çº¢åŒ…æ¶ˆæ¯ï¼ˆmsg_typeä¸º'redpacket'ï¼‰ï¼Œä½ å¯ä»¥ç§¯æå»é¢†å–ï¼ä½¿ç”¨ {"type": "claim_redpacket", "redpacketId": "çº¢åŒ…ID"} æ¥é¢†å–çº¢åŒ…ã€‚çº¢åŒ…ä¼šè®°å…¥ä½ ä¸»äººçš„é’±åŒ…ä½™é¢ã€‚
12. **å‘é€çº¢åŒ…**ï¼šä½ å¯ä»¥åœ¨é€‚å½“çš„åœºåˆå‘çº¢åŒ…ï¼ˆæ¯”å¦‚ï¼šè¿‡èŠ‚ã€ç”Ÿæ—¥ã€è¡¨è¾¾æ„Ÿè°¢ã€æ´»è·ƒæ°”æ°›ã€ç©æ¢—ç­‰ï¼‰ï¼Œä½¿ç”¨ {"type": "send_redpacket", "redpacketType": "çº¢åŒ…ç±»å‹", "totalAmount": æ€»é‡‘é¢, "count": çº¢åŒ…ä¸ªæ•°, "wish": "ç¥ç¦è¯­"} æ¥å‘é€çº¢åŒ…ã€‚è§’è‰²å‘çº¢åŒ…ä¸ä¼šæ‰£é™¤ä»»ä½•äººçš„ä½™é¢ï¼Œå¯ä»¥è‡ªç”±å‘é€ï¼
   - redpacketTypeå¯é€‰å€¼: "lucky"(æ‹¼æ‰‹æ°”çº¢åŒ…), "normal"(æ™®é€šçº¢åŒ…)
   - æ‹¼æ‰‹æ°”çº¢åŒ…ï¼šæ¯ä¸ªäººé¢†åˆ°çš„é‡‘é¢éšæœºï¼Œå¢åŠ è¶£å‘³æ€§
   - æ™®é€šçº¢åŒ…ï¼šæ¯ä¸ªäººé¢†åˆ°çš„é‡‘é¢ç›¸åŒï¼Œå…¬å¹³åˆ†é…
   - ç¤ºä¾‹1: {"type": "send_redpacket", "redpacketType": "lucky", "totalAmount": 10, "count": 5, "wish": "å¤§å®¶å‘¨æœ«å¿«ä¹ï¼"}
   - ç¤ºä¾‹2: {"type": "send_redpacket", "redpacketType": "normal", "totalAmount": 20, "count": 10, "wish": "æ­å–œå‘è´¢"}

è¯·ä»¥JSONæ ¼å¼è¿”å›ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
{
  "reply": "ä½ çš„å›å¤å†…å®¹|||ç¬¬äºŒæ¡å†…å®¹|||ç¬¬ä¸‰æ¡å†…å®¹"
}

**ç‰¹æ®ŠæŒ‡ä»¤**ï¼š
1. é¢†å–çº¢åŒ…ï¼š
{
  "type": "claim_redpacket",
  "redpacketId": "çº¢åŒ…ID",
  "reply": "ä½ çš„å›å¤å†…å®¹ï¼ˆå¯é€‰ï¼‰"
}

2. å‘é€çº¢åŒ…ï¼š
{
  "type": "send_redpacket",
  "redpacketType": "luckyæˆ–normal",
  "totalAmount": é‡‘é¢æ•°å­—,
  "count": çº¢åŒ…ä¸ªæ•°,
  "wish": "ç¥ç¦è¯­",
  "reply": "ä½ çš„å›å¤å†…å®¹ï¼ˆå¯é€‰ï¼‰"
}

æç¤ºï¼šå‘é€çº¢åŒ…åï¼Œçº¢åŒ…ä¼šç«‹å³å‡ºç°åœ¨ç¾¤èŠä¸­ï¼Œå…¶ä»–æˆå‘˜å’Œè§’è‰²å°±å¯ä»¥æŠ¢çº¢åŒ…äº†ï¼ä½ å¯ä»¥åœ¨é€‚å½“çš„åœºåˆå‘çº¢åŒ…æ´»è·ƒæ°”æ°›ï¼Œè§’è‰²å‘çº¢åŒ…ä¸ä¼šæ‰£é™¤ä»»ä½•äººçš„ä½™é¢ï¼Œå¯ä»¥è‡ªç”±å‘é€ï¼

è¯·ä¸¥æ ¼è¿”å›JSONæ ¼å¼ï¼Œä¸è¦åŒ…å«Markdownä»£ç å—æ ‡è®°ã€‚`;
        
        console.log('[è”æœºç¾¤èŠ] ç³»ç»Ÿæç¤ºè¯ï¼ˆå‰500å­—ï¼‰:', systemPrompt.substring(0, 500));
        
        // æ„å»ºæ¶ˆæ¯æ•°ç»„ï¼ˆä¸ callAI å‡½æ•°çš„æ ‡å‡†æ ¼å¼ä¸€è‡´ï¼‰
        const messages = [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: `ç¾¤èŠè®°å½•ï¼š\n${context}\n\nè¯·ä»¥è§’è‰²èº«ä»½å›å¤ï¼š` }
        ];
        
        console.log('[è”æœºç¾¤èŠ] ğŸ“¤ å‡†å¤‡å‘é€ç»™ AI - å®Œæ•´ä¿¡æ¯æ±‡æ€»');
        console.log('[è”æœºç¾¤èŠ] - System Prompt é•¿åº¦:', systemPrompt.length);
        console.log('[è”æœºç¾¤èŠ] - ä¸Šä¸‹æ–‡é•¿åº¦:', context.length);
        console.log('[è”æœºç¾¤èŠ] ğŸš€ å¼€å§‹è°ƒç”¨ API...');
        
        // å…ˆæ·»åŠ ä¸€æ¡ç³»ç»Ÿæ¶ˆæ¯ä½œä¸ºåˆ†å‰²çº¿
        const systemMsg = {
            id: 'sys_' + Date.now(),
            sender_type: 'system',
            msg_type: 'system',
            content: `â€”â€”â€”â€” ${myOnlineGroupCharacter.name} å¼€å§‹å›å¤ â€”â€”â€”â€”`,
            created_at: Date.now()
        };
        currentOnlineGroupMessages.push(systemMsg);
        renderOnlineGroupMessages();
        console.log('[è”æœºç¾¤èŠ] âœ… å·²æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯åˆ†å‰²çº¿');
        
        // è°ƒç”¨ç»Ÿä¸€çš„ AI æ¥å£
        const aiResponse = await callAI(messages);
        
        console.log('[è”æœºç¾¤èŠ] âœ… API è°ƒç”¨æˆåŠŸ');
        console.log('[è”æœºç¾¤èŠ] åŸå§‹å“åº”:', aiResponse);
        
        // å°è¯•è§£æ JSON æ ¼å¼ï¼ˆå¦‚æœAIè¿”å›äº†JSONï¼‰
        let replyText = "";
        try {
            // å°è¯•è§£æä¸ºJSON
            let cleanResponse = aiResponse.trim();
            // æ¸…ç†å¯èƒ½çš„markdownæ ‡è®°
            if (cleanResponse.startsWith('```')) {
                cleanResponse = cleanResponse.replace(/```json?\n?/g, '').replace(/```$/g, '').trim();
            }
            const parsed = JSON.parse(cleanResponse);
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯å‘é€çº¢åŒ…æŒ‡ä»¤
            if (parsed.type === 'send_redpacket' && parsed.totalAmount && parsed.count && parsed.redpacketType) {
                console.log('[è”æœºç¾¤èŠ] ğŸ§§ è§’è‰²å°è¯•å‘é€çº¢åŒ…');
                
                const totalAmount = parseFloat(parsed.totalAmount);
                const count = parseInt(parsed.count);
                const wish = parsed.wish || 'æ­å–œå‘è´¢';
                const redpacketType = parsed.redpacketType;
                
                // éªŒè¯é‡‘é¢å’Œæ•°é‡
                if (totalAmount > 0 && count > 0 && totalAmount <= 200 && count <= 100) {
                    // ç”Ÿæˆçº¢åŒ…ID
                    const redpacketId = 'rp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    
                    // æ„å»ºçº¢åŒ…æ•°æ®
                    const redpacketData = {
                        id: redpacketId,
                        totalAmount: totalAmount.toFixed(2),
                        count: count,
                        wish: wish,
                        redpacketType: redpacketType,
                        claimed: [],
                        claimedAmounts: {}
                    };
                    
                    // å‘é€çº¢åŒ…æ¶ˆæ¯åˆ°æœåŠ¡å™¨
                    onlineSocket.send(JSON.stringify({
                        type: 'send_group_message',
                        group_id: currentOnlineGroupId,
                        my_wx_account: myWx,
                        sender_type: 'character',
                        sender_name: myUserName,
                        character_name: myOnlineGroupCharacter.name,
                        msg_type: 'redpacket',
                        content: JSON.stringify(redpacketData)
                    }));
                    
                    console.log('[è”æœºç¾¤èŠ] âœ… è§’è‰²çº¢åŒ…å·²å‘é€ï¼Œé‡‘é¢:', totalAmount, 'ä¸ªæ•°:', count, 'ï¼ˆä¸æ‰£é™¤ç”¨æˆ·ä½™é¢ï¼‰');
                    
                    // å¦‚æœæœ‰å›å¤å†…å®¹ï¼Œä¹Ÿå‘é€
                    if (parsed.reply) {
                        replyText = parsed.reply;
                    } else {
                        replyText = '';
                    }
                } else {
                    // å‚æ•°æ— æ•ˆ
                    console.log('[è”æœºç¾¤èŠ] âš ï¸ çº¢åŒ…å‚æ•°æ— æ•ˆ');
                    replyText = parsed.reply || '';
                }
            }
            // æ£€æŸ¥æ˜¯å¦æ˜¯é¢†å–çº¢åŒ…æŒ‡ä»¤
            else if (parsed.type === 'claim_redpacket' && parsed.redpacketId) {
                console.log('[è”æœºç¾¤èŠ] ğŸ§§ è§’è‰²å°è¯•é¢†å–çº¢åŒ…:', parsed.redpacketId);
                await claimOnlineGroupRedPacket(parsed.redpacketId, myWx, myOnlineGroupCharacter.name);
                
                // å¦‚æœæœ‰å›å¤å†…å®¹ï¼Œä¹Ÿå‘é€
                if (parsed.reply) {
                    replyText = parsed.reply;
                } else {
                    replyText = '';
                }
            } else {
                replyText = parsed.reply || parsed.content || parsed.message || aiResponse;
            }
            console.log('[è”æœºç¾¤èŠ] JSONè§£ææˆåŠŸï¼Œæå–åˆ°å›å¤å†…å®¹:', replyText);
        } catch (e) {
            // ä¸æ˜¯JSONæ ¼å¼ï¼Œç›´æ¥ä½¿ç”¨åŸå§‹å“åº”
            replyText = aiResponse.trim();
            console.log('[è”æœºç¾¤èŠ] ä¸æ˜¯JSONæ ¼å¼ï¼Œä½¿ç”¨åŸå§‹å“åº”');
        }
        
        if (replyText) {
            // æŒ‰ç…§ ||| åˆ†å‰²æˆå¤šæ¡æ¶ˆæ¯
            const segments = replyText.split('|||').map(s => s.trim()).filter(s => s.length > 0);
            console.log('[è”æœºç¾¤èŠ] åˆ†å‰²æˆ', segments.length, 'æ¡æ¶ˆæ¯');
            
            // ä¾æ¬¡å‘é€æ¯æ¡æ¶ˆæ¯ï¼Œé—´éš”100ms
            for (let i = 0; i < segments.length; i++) {
                const segment = segments[i];
                console.log(`[è”æœºç¾¤èŠ] å‘é€ç¬¬ ${i+1}/${segments.length} æ¡æ¶ˆæ¯:`, segment);
                
                onlineSocket.send(JSON.stringify({
                    type: 'send_group_message',
                    group_id: currentOnlineGroupId,
                    my_wx_account: myWx,
                    sender_type: 'character',
                    sender_name: myUserName,
                    character_name: myOnlineGroupCharacter.name,
                    content: segment
                }));
                
                // ç­‰å¾…ä¸€å°æ®µæ—¶é—´å†å‘é€ä¸‹ä¸€æ¡ï¼Œé¿å…æ¶ˆæ¯é¡ºåºæ··ä¹±
                if (i < segments.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            
            console.log('[è”æœºç¾¤èŠ] ğŸ“¤ æ‰€æœ‰æ¶ˆæ¯å·²å‘é€åˆ°æœåŠ¡å™¨');
        } else {
            console.warn('[è”æœºç¾¤èŠ] âš ï¸ å›å¤å†…å®¹ä¸ºç©º');
            // å¦‚æœæ²¡æœ‰å›å¤å†…å®¹ï¼Œç§»é™¤åˆšæ·»åŠ çš„ç³»ç»Ÿæ¶ˆæ¯
            currentOnlineGroupMessages.pop();
            renderOnlineGroupMessages();
        }
        
        // æ¢å¤æ ‡é¢˜
        if (chatTitleEl) {
            chatTitleEl.innerText = originalTitle;
            console.log('[è”æœºç¾¤èŠ] æ¢å¤æ ‡é¢˜ä¸º:', originalTitle);
        }
        
        // é€šçŸ¥ç¾¤é‡Œå…¶ä»–äººï¼šè¾“å…¥ç»“æŸ
        onlineSocket.send(JSON.stringify({
            type: 'group_typing_stop',
            group_id: currentOnlineGroupId,
            my_wx_account: myWx
        }));
    } catch (e) {
        console.error('[è”æœºç¾¤èŠ] âŒ è§’è‰²å›å¤å¤±è´¥:', e);
        console.error('[è”æœºç¾¤èŠ] é”™è¯¯å †æ ˆ:', e.stack);
        alert('è§’è‰²å›å¤å¤±è´¥: ' + e.message);
        
        // å‡ºé”™æ—¶ä¹Ÿè¦æ¢å¤æ ‡é¢˜
        if (chatTitleEl) {
            chatTitleEl.innerText = originalTitle;
            console.log('[è”æœºç¾¤èŠ] ï¼ˆå‡ºé”™ï¼‰æ¢å¤æ ‡é¢˜ä¸º:', originalTitle);
        }
        
        // é€šçŸ¥ç¾¤é‡Œå…¶ä»–äººï¼šè¾“å…¥ç»“æŸ
        onlineSocket.send(JSON.stringify({
            type: 'group_typing_stop',
            group_id: currentOnlineGroupId,
            my_wx_account: myWx
        }));
    }
}

// æ˜¾ç¤ºç¾¤èŠä¿¡æ¯é¡µé¢
function showOnlineGroupInfo(groupId) {
    const group = onlineGroups.find(g => g.id === groupId);
    if (!group) return;
    
    const myWx = getMyOnlineWxAccount();
    
    const page = document.createElement('div');
    page.id = 'online-group-info-page';
    page.style.cssText = `position:fixed; top:0; left:0; right:0; bottom:0; background:#f5f5f5; z-index:310; display:flex; flex-direction:column;`;
    
    page.innerHTML = `
        <div class="wechat-header" style="background:#fff; border-bottom:1px solid #f0f0f0;">
            <div class="back-btn" onclick="document.getElementById('online-group-info-page').remove()" style="margin:0; background:none; width:40px; justify-content:flex-start; color:#333;">
                <svg class="svg-icon" viewBox="0 0 24 24" style="width:24px; height:24px;"><polyline points="15 18 9 12 15 6"></polyline></svg>
            </div>
            <div class="wechat-title">ç¾¤èŠèµ„æ–™</div>
            <div style="width:40px;"></div>
        </div>
        
        <div style="flex:1; overflow-y:auto;">
            <div style="background:#fff; padding:20px; margin-bottom:10px; text-align:center;">
                <div style="width:60px; height:60px; border-radius:12px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); margin:0 auto 12px; display:flex; align-items:center; justify-content:center; color:#fff; font-size:24px;">ğŸ‘¥</div>
                <div style="font-size:18px; font-weight:600;">${group.name}</div>
            </div>
            
            <div style="background:#fff; padding:16px; margin-bottom:10px;">
                <div style="font-size:14px; font-weight:500; margin-bottom:12px;">ç¾¤æˆå‘˜ (${currentOnlineGroupMembers.length})</div>
                <div id="og-info-members" style="display:flex; flex-wrap:wrap; gap:12px;">
                    ${currentOnlineGroupMembers.map(m => `
                        <div style="text-align:center; width:60px;">
                            <div style="width:48px; height:48px; border-radius:8px; margin:0 auto 4px; background-image:url(${m.user_avatar}); background-size:cover; background-color:#e0e0e0;"></div>
                            <div style="font-size:12px; color:#333; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${m.user_name}</div>
                            ${m.character_name ? `<div style="font-size:10px; color:#667eea;">ğŸ­${m.character_name}</div>` : ''}
                        </div>
                    `).join('')}
                </div>
            </div>
            
            <div style="background:#fff; padding:16px; margin-bottom:10px;">
                <div style="font-size:14px; font-weight:500; margin-bottom:12px;">æˆ‘çš„ç¾¤è§’è‰²</div>
                <div style="display:flex; align-items:center; justify-content:space-between;">
                    <span style="color:#666;">${myOnlineGroupCharacter ? myOnlineGroupCharacter.name : 'æœªè®¾ç½®è§’è‰²'}</span>
                    <button onclick="showChangeGroupCharacterModal('${groupId}')" style="padding:8px 16px; background:var(--ins-pink); color:#fff; border:none; border-radius:6px; font-size:13px;">
                        ${myOnlineGroupCharacter ? 'æ›´æ¢' : 'è®¾ç½®'}è§’è‰²
                    </button>
                </div>
            </div>
            
            <div style="background:#fff; padding:16px; margin-bottom:10px;">
                <div style="font-size:14px; font-weight:500; margin-bottom:12px;">èŠå¤©èƒŒæ™¯å›¾</div>
                <div style="display:flex; flex-direction:column; gap:12px;">
                    <div style="display:flex; gap:8px;">
                        <button onclick="document.getElementById('online-group-bg-input').setAttribute('data-group-id', '${groupId}'); document.getElementById('online-group-bg-input').click()" style="flex:1; padding:8px 12px; background:#f0f0f0; border:none; border-radius:6px; font-size:13px; color:#666; cursor:pointer;">ä¸Šä¼ èƒŒæ™¯</button>
                        <button onclick="clearOnlineGroupBackground('${groupId}')" style="flex:1; padding:8px 12px; background:#f0f0f0; border:none; border-radius:6px; font-size:13px; color:#666; cursor:pointer;">æ¸…é™¤èƒŒæ™¯</button>
                    </div>
                    <div id="online-group-bg-preview" style="width:100%; height:120px; border-radius:8px; background:#f5f5f5; background-size:cover; background-position:center; border:1px solid #e8e8e8; display:flex; align-items:center; justify-content:center; color:#999; font-size:12px;">
                        æš‚æ— èƒŒæ™¯å›¾
                    </div>
                </div>
            </div>
            
            <div style="background:#fff; padding:16px;">
                <button onclick="inviteFriendToGroup('${groupId}')" style="width:100%; padding:14px; background:#f5f5f5; color:#333; border:none; border-radius:8px; font-size:15px; margin-bottom:10px;">é‚€è¯·å¥½å‹</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(page);
    
    // åŠ è½½å¹¶æ˜¾ç¤ºèƒŒæ™¯å›¾é¢„è§ˆ
    loadOnlineGroupBackgroundPreview(groupId);
}

// æ˜¾ç¤ºæ›´æ¢è§’è‰²å¼¹çª—
async function showChangeGroupCharacterModal(groupId) {
    const chars = await db.characters.toArray();
    const availableChars = chars.filter(c => c.type !== 'user' && c.type !== 'online_friend');
    
    const modal = document.createElement('div');
    modal.id = 'change-char-modal';
    modal.style.cssText = `position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:10000; display:flex; align-items:center; justify-content:center;`;
    
    modal.innerHTML = `
        <div style="background:#fff; border-radius:12px; padding:20px; width:80%; max-width:300px;">
            <h3 style="margin:0 0 16px 0; text-align:center;">é€‰æ‹©è§’è‰²</h3>
            <select id="change-char-select" style="width:100%; padding:12px; border:1px solid #ddd; border-radius:8px; margin-bottom:16px;">
                <option value="">ä¸ä½¿ç”¨è§’è‰²</option>
                ${availableChars.map(c => `<option value="${c.id}" ${myOnlineGroupCharacter?.name === c.name ? 'selected' : ''}>${c.name}</option>`).join('')}
            </select>
            <div style="display:flex; gap:10px;">
                <button onclick="this.closest('#change-char-modal').remove()" style="flex:1; padding:12px; background:#f0f0f0; color:#666; border:none; border-radius:8px;">å–æ¶ˆ</button>
                <button onclick="doChangeGroupCharacter('${groupId}')" style="flex:1; padding:12px; background:var(--ins-pink); color:#fff; border:none; border-radius:8px;">ç¡®å®š</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// æ‰§è¡Œæ›´æ¢è§’è‰²
async function doChangeGroupCharacter(groupId) {
    const charId = document.getElementById('change-char-select').value;
    
    let myChar = null;
    if (charId) {
        const char = await db.characters.get(parseInt(charId));
        if (char) {
            myChar = {
                name: char.name,
                avatar: char.avatar || '',
                desc: char.description?.substring(0, 200) || ''
            };
        }
    }
    
    const myWx = getMyOnlineWxAccount();
    onlineSocket.send(JSON.stringify({
        type: 'update_group_character',
        group_id: groupId,
        my_wx_account: myWx,
        character: myChar
    }));
    
    myOnlineGroupCharacter = myChar;
    document.getElementById('change-char-modal')?.remove();
    document.getElementById('online-group-info-page')?.remove();
    showOnlineGroupInfo(groupId);
}

// é‚€è¯·å¥½å‹åˆ°ç¾¤èŠ
async function inviteFriendToGroup(groupId) {
    const friends = await db.characters.where('type').equals('online_friend').toArray();
    
    if (friends.length === 0) {
        alert('æš‚æ— è”æœºå¥½å‹å¯é‚€è¯·');
        return;
    }
    
    const modal = document.createElement('div');
    modal.id = 'invite-friend-modal';
    modal.style.cssText = `position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:10000; display:flex; align-items:center; justify-content:center;`;
    
    modal.innerHTML = `
        <div style="background:#fff; border-radius:12px; padding:20px; width:80%; max-width:300px; max-height:60vh; display:flex; flex-direction:column;">
            <h3 style="margin:0 0 16px 0; text-align:center;">é‚€è¯·å¥½å‹</h3>
            <div style="flex:1; overflow-y:auto;">
                ${friends.map(f => `
                    <div onclick="doInviteFriend('${groupId}', '${f.onlineData?.wx_account}')" style="display:flex; align-items:center; padding:12px; border-bottom:1px solid #f5f5f5; cursor:pointer;">
                        <div style="width:40px; height:40px; border-radius:8px; background-image:url(${f.avatar}); background-size:cover; background-color:#e0e0e0; margin-right:12px;"></div>
                        <span>${f.name}</span>
                    </div>
                `).join('')}
            </div>
            <button onclick="this.closest('#invite-friend-modal').remove()" style="margin-top:12px; padding:12px; background:#f0f0f0; color:#666; border:none; border-radius:8px;">å–æ¶ˆ</button>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// æ‰§è¡Œé‚€è¯·å¥½å‹
function doInviteFriend(groupId, friendWx) {
    const myWx = getMyOnlineWxAccount();
    onlineSocket.send(JSON.stringify({
        type: 'invite_to_group',
        group_id: groupId,
        my_wx_account: myWx,
        invite_wx_account: friendWx
    }));
    
    document.getElementById('invite-friend-modal')?.remove();
    showToast('é‚€è¯·å·²å‘é€');
}

// è®¾ç½®è”æœºç¾¤èŠèƒŒæ™¯å›¾
async function setOnlineGroupBackground(input) {
    if (!input.files || !input.files[0]) return;
    
    const groupId = input.getAttribute('data-group-id') || currentOnlineGroupId;
    if (!groupId) {
        showToast('æ— æ³•è·å–ç¾¤èŠID');
        return;
    }
    
    const file = input.files[0];
    const reader = new FileReader();
    
    reader.onload = async function(e) {
        const base64 = e.target.result;
        const accountId = getCurrentAccountId();
        if (!accountId) return;
        
        try {
            // æŸ¥æ‰¾å¯¹åº”çš„æœ¬åœ°ç¾¤èŠè®°å½•
            const groups = await db.group_chats
                .where('ownerAccountId').equals(accountId)
                .filter(g => g.isOnlineGroup && g.onlineGroupId === groupId)
                .toArray();
            
            if (groups.length > 0) {
                const group = groups[0];
                group.chat_background = base64;
                await db.group_chats.put(group);
                
                // åº”ç”¨èƒŒæ™¯å›¾
                applyOnlineGroupBackground(groupId);
                
                // æ›´æ–°é¢„è§ˆ
                loadOnlineGroupBackgroundPreview(groupId);
                
                showToast('èƒŒæ™¯å›¾å·²è®¾ç½®');
            }
        } catch (e) {
            console.error('ä¿å­˜è”æœºç¾¤èŠèƒŒæ™¯å›¾å¤±è´¥:', e);
            showToast('ä¿å­˜å¤±è´¥');
        }
    };
    
    reader.readAsDataURL(file);
}

// æ¸…é™¤è”æœºç¾¤èŠèƒŒæ™¯å›¾
async function clearOnlineGroupBackground(groupId) {
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    try {
        // æŸ¥æ‰¾å¯¹åº”çš„æœ¬åœ°ç¾¤èŠè®°å½•
        const groups = await db.group_chats
            .where('ownerAccountId').equals(accountId)
            .filter(g => g.isOnlineGroup && g.onlineGroupId === groupId)
            .toArray();
        
        if (groups.length > 0) {
            const group = groups[0];
            group.chat_background = null;
            await db.group_chats.put(group);
            
            // åº”ç”¨èƒŒæ™¯å›¾ï¼ˆæ¸…é™¤ï¼‰
            applyOnlineGroupBackground(groupId);
            
            // æ›´æ–°é¢„è§ˆ
            loadOnlineGroupBackgroundPreview(groupId);
            
            showToast('èƒŒæ™¯å›¾å·²æ¸…é™¤');
        }
    } catch (e) {
        console.error('æ¸…é™¤è”æœºç¾¤èŠèƒŒæ™¯å›¾å¤±è´¥:', e);
        showToast('æ¸…é™¤å¤±è´¥');
    }
}

// åº”ç”¨è”æœºç¾¤èŠèƒŒæ™¯å›¾
async function applyOnlineGroupBackground(groupId) {
    const page = document.getElementById('online-group-chat-page');
    if (!page) return;
    
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    try {
        // æŸ¥æ‰¾å¯¹åº”çš„æœ¬åœ°ç¾¤èŠè®°å½•
        const groups = await db.group_chats
            .where('ownerAccountId').equals(accountId)
            .filter(g => g.isOnlineGroup && g.onlineGroupId === groupId)
            .toArray();
        
        if (groups.length > 0) {
            const group = groups[0];
            if (group.chat_background) {
                page.style.backgroundImage = `url(${group.chat_background})`;
                page.style.backgroundSize = 'cover';
                page.style.backgroundPosition = 'center';
                page.style.backgroundRepeat = 'no-repeat';
                page.style.backgroundAttachment = 'fixed';
            } else {
                page.style.backgroundImage = '';
                page.style.backgroundSize = '';
                page.style.backgroundPosition = '';
                page.style.backgroundRepeat = '';
                page.style.backgroundAttachment = '';
                page.style.backgroundColor = '#ffffff';
            }
        }
    } catch (e) {
        console.error('åº”ç”¨è”æœºç¾¤èŠèƒŒæ™¯å›¾å¤±è´¥:', e);
    }
}

// åŠ è½½è”æœºç¾¤èŠèƒŒæ™¯å›¾é¢„è§ˆ
async function loadOnlineGroupBackgroundPreview(groupId) {
    const preview = document.getElementById('online-group-bg-preview');
    if (!preview) return;
    
    const accountId = getCurrentAccountId();
    if (!accountId) return;
    
    try {
        // æŸ¥æ‰¾å¯¹åº”çš„æœ¬åœ°ç¾¤èŠè®°å½•
        const groups = await db.group_chats
            .where('ownerAccountId').equals(accountId)
            .filter(g => g.isOnlineGroup && g.onlineGroupId === groupId)
            .toArray();
        
        if (groups.length > 0) {
            const group = groups[0];
            if (group.chat_background) {
                preview.style.backgroundImage = `url(${group.chat_background})`;
                preview.innerHTML = '';
            } else {
                preview.style.backgroundImage = '';
                preview.innerHTML = 'æš‚æ— èƒŒæ™¯å›¾';
            }
        } else {
            preview.style.backgroundImage = '';
            preview.innerHTML = 'æš‚æ— èƒŒæ™¯å›¾';
        }
    } catch (e) {
        console.error('åŠ è½½è”æœºç¾¤èŠèƒŒæ™¯å›¾é¢„è§ˆå¤±è´¥:', e);
    }
}

// ==================== è”æœºç¾¤èŠåŠŸèƒ½ç»“æŸ ====================

// å°†è”æœºç›¸å…³å‡½æ•°æš´éœ²åˆ°å…¨å±€ä½œç”¨åŸŸ
window.toggleOnlineSettings = toggleOnlineSettings;
window.loadOnlineSettings = loadOnlineSettings;
window.saveOnlineSettings = saveOnlineSettings;
window.testOnlineConnection = testOnlineConnection;
window.connectToOnlineServer = connectToOnlineServer;
window.showOnlineLoginModal = showOnlineLoginModal;
window.showOnlineRegisterModal = showOnlineRegisterModal;
window.doOnlineLogin = doOnlineLogin;
window.doOnlineRegister = doOnlineRegister;
window.onlineLogout = onlineLogout;
window.showOnlineSearchModal = showOnlineSearchModal;
window.doOnlineSearch = doOnlineSearch;
window.sendOnlineFriendRequest = sendOnlineFriendRequest;
window.goOnlineWithCharacter = goOnlineWithCharacter;
window.goOfflineWithCharacter = goOfflineWithCharacter;
window.showOnlineStatusPage = showOnlineStatusPage;
window.hideOnlineStatusPage = hideOnlineStatusPage;
window.updateOnlineFeatureSection = updateOnlineFeatureSection;
window.refreshOnlineStatusPageContent = refreshOnlineStatusPageContent;
window.renderOnlineCharList = renderOnlineCharList;
window.updateOnlineConnectionStatus = updateOnlineConnectionStatus;
window.manualSyncOnline = manualSyncOnline;

// è”æœºç¾¤èŠå‡½æ•°
window.showCreateOnlineGroupModal = showCreateOnlineGroupModal;
window.doCreateOnlineGroup = doCreateOnlineGroup;
window.openOnlineGroup = openOnlineGroup;
window.hideOnlineGroupChat = hideOnlineGroupChat;
window.sendOnlineGroupMsg = sendOnlineGroupMsg;
window.letMyCharacterSpeak = letMyCharacterSpeak;
window.showOnlineGroupInfo = showOnlineGroupInfo;
window.showChangeGroupCharacterModal = showChangeGroupCharacterModal;
window.doChangeGroupCharacter = doChangeGroupCharacter;
window.inviteFriendToGroup = inviteFriendToGroup;
window.doInviteFriend = doInviteFriend;
window.onlineGroupVoiceInput = onlineGroupVoiceInput;
window.closeOnlineGroupVoiceModal = closeOnlineGroupVoiceModal;
window.startOnlineGroupVoiceRecord = startOnlineGroupVoiceRecord;
window.playOnlineGroupAudio = playOnlineGroupAudio;
window.receiveOnlineGroupTransfer = receiveOnlineGroupTransfer;
window.doJoinOnlineGroup = doJoinOnlineGroup;

// ============================================
// å¤´åƒåº“ç³»ç»Ÿ
// ============================================

let avatarLibraryMainTab = 'single'; // ä¸»åˆ†ç±»ï¼š'single' | 'couple'
let avatarLibraryCurrentTag = ''; // å½“å‰é€‰ä¸­çš„å°æ ‡ç­¾åï¼ˆç©º=å…¨éƒ¨ï¼‰
let avatarPreviewCurrentId = null; // å½“å‰é¢„è§ˆçš„å¤´åƒID
let couplePairingMode = false; // æƒ…å¤´é…å¯¹æ¨¡å¼
let couplePairingFirst = null; // é…å¯¹æ¨¡å¼ä¸‹é€‰ä¸­çš„ç¬¬ä¸€å¼ å¤´åƒID
let avatarBatchDeleteMode = false; // æ‰¹é‡åˆ é™¤æ¨¡å¼
let avatarBatchSelected = new Set(); // æ‰¹é‡é€‰ä¸­çš„å¤´åƒIDé›†åˆ

// æ‰“å¼€å¤´åƒåº“é¡µé¢
async function showAvatarLibraryPage() {
    const page = document.getElementById('avatar-library-page');
    if (page) {
        page.style.display = 'flex';
        avatarLibraryMainTab = 'single';
        avatarLibraryCurrentTag = '';
        updateMainTabUI();
        await loadSubTags();
        renderAvatarLibrary();
    }
}

function hideAvatarLibraryPage() {
    const page = document.getElementById('avatar-library-page');
    if (page) page.style.display = 'none';
    avatarBatchDeleteMode = false;
    avatarBatchSelected.clear();
}

// åˆ‡æ¢ä¸»åˆ†ç±»ï¼ˆå•äººå¤´åƒ / æƒ…å¤´ï¼‰
async function switchAvatarTab(tab) {
    avatarLibraryMainTab = tab;
    avatarLibraryCurrentTag = ''; // åˆ‡æ¢ä¸»Tabæ—¶é‡ç½®å­æ ‡ç­¾
    couplePairingMode = false; // é‡ç½®é…å¯¹æ¨¡å¼
    couplePairingFirst = null;
    avatarBatchDeleteMode = false; // é‡ç½®æ‰¹é‡åˆ é™¤æ¨¡å¼
    avatarBatchSelected.clear();
    updateMainTabUI();
    await loadSubTags();
    renderAvatarLibrary();
    updateBatchDeleteBar();
}

// æ›´æ–°ä¸»Tabçš„UIé«˜äº®
function updateMainTabUI() {
    const singleTab = document.getElementById('avatar-tab-single');
    const coupleTab = document.getElementById('avatar-tab-couple');
    const singleLine = document.getElementById('avatar-tab-single-line');
    const coupleLine = document.getElementById('avatar-tab-couple-line');
    
    if (avatarLibraryMainTab === 'single') {
        if (singleTab) { singleTab.style.color = '#262626'; singleTab.style.fontWeight = '600'; }
        if (coupleTab) { coupleTab.style.color = '#b0b0b0'; coupleTab.style.fontWeight = '500'; }
        if (singleLine) singleLine.style.width = '24px';
        if (coupleLine) coupleLine.style.width = '0';
    } else {
        if (coupleTab) { coupleTab.style.color = '#262626'; coupleTab.style.fontWeight = '600'; }
        if (singleTab) { singleTab.style.color = '#b0b0b0'; singleTab.style.fontWeight = '500'; }
        if (coupleLine) coupleLine.style.width = '24px';
        if (singleLine) singleLine.style.width = '0';
    }
}

// åŠ è½½å¹¶æ¸²æŸ“å½“å‰ä¸»åˆ†ç±»ä¸‹çš„å°æ ‡ç­¾
async function loadSubTags() {
    const container = document.getElementById('avatar-subtags-container');
    if (!container) return;
    
    let tags = [];
    try {
        // å…ˆæ¸…ç†æ—§çš„æ— parentCategoryè®°å½•ï¼ˆå…¼å®¹æ—§ç‰ˆï¼‰
        const allCats = await db.avatar_categories.toArray();
        for (const cat of allCats) {
            if (!cat.parentCategory) {
                // æ—§ç‰ˆæ•°æ®ï¼Œæ ¹æ®åå­—è‡ªåŠ¨åˆ†é…
                const pc = cat.name === 'æƒ…å¤´' ? 'couple' : 'single';
                await db.avatar_categories.update(cat.id, { parentCategory: pc });
            }
        }
        tags = await db.avatar_categories
            .where('parentCategory').equals(avatarLibraryMainTab)
            .sortBy('order');
    } catch (e) {
        console.error('[å¤´åƒåº“] åŠ è½½å­æ ‡ç­¾å¤±è´¥:', e);
        // é™çº§ï¼šæ‰‹åŠ¨ç­›é€‰
        try {
            const allCats = await db.avatar_categories.toArray();
            tags = allCats.filter(c => c.parentCategory === avatarLibraryMainTab)
                .sort((a, b) => (a.order || 0) - (b.order || 0));
        } catch (e2) {
            console.error('[å¤´åƒåº“] é™çº§åŠ è½½ä¹Ÿå¤±è´¥:', e2);
        }
    }
    
    let html = '';
    
    // "å…¨éƒ¨" æ ‡ç­¾
    const allActive = avatarLibraryCurrentTag === '';
    html += `<div onclick="selectAvatarSubTag('')" style="flex-shrink:0; padding:5px 14px; font-size:12px; 
        border-radius:14px; cursor:pointer; transition:all 0.2s; white-space:nowrap;
        background:${allActive ? '#262626' : '#f5f5f5'}; color:${allActive ? '#fff' : '#666'}; 
        font-weight:${allActive ? '600' : '400'};">å…¨éƒ¨</div>`;
    
    // ç”¨æˆ·æ·»åŠ çš„å°æ ‡ç­¾
    for (const tag of tags) {
        const isActive = avatarLibraryCurrentTag === tag.name;
        html += `<div onclick="selectAvatarSubTag('${tag.name.replace(/'/g, "\\'")}')" 
            oncontextmenu="event.preventDefault(); showSubTagMenu(event, ${tag.id}, '${tag.name.replace(/'/g, "\\'")}')"
            style="flex-shrink:0; padding:5px 14px; font-size:12px; border-radius:14px; cursor:pointer; 
            transition:all 0.2s; white-space:nowrap; user-select:none;
            background:${isActive ? '#262626' : '#f5f5f5'}; color:${isActive ? '#fff' : '#666'}; 
            font-weight:${isActive ? '600' : '400'};">${tag.name}</div>`;
    }
    
    // "+" æ·»åŠ æŒ‰é’®
    html += `<div onclick="addSubTagDialog()" style="flex-shrink:0; width:26px; height:26px; border-radius:50%; 
        background:#f5f5f5; display:flex; align-items:center; justify-content:center; cursor:pointer;">
        <svg viewBox="0 0 24 24" style="width:12px; height:12px; fill:none; stroke:#999; stroke-width:2.5;">
            <line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line>
        </svg>
    </div>`;
    
    container.innerHTML = html;
}

// é€‰ä¸­å­æ ‡ç­¾
function selectAvatarSubTag(tagName) {
    avatarLibraryCurrentTag = tagName;
    loadSubTags(); // æ›´æ–°é«˜äº®
    renderAvatarLibrary();
}

// æ·»åŠ å­æ ‡ç­¾å¼¹çª—
async function addSubTagDialog() {
    const name = prompt('è¯·è¾“å…¥æ ‡ç­¾åç§°ï¼š');
    if (!name || !name.trim()) return;
    
    const trimmed = name.trim();
    
    // æ£€æŸ¥åŒä¸»åˆ†ç±»ä¸‹æ˜¯å¦é‡å
    const existing = await db.avatar_categories
        .where('parentCategory').equals(avatarLibraryMainTab)
        .toArray();
    if (existing.find(t => t.name === trimmed)) {
        showToast('è¯¥æ ‡ç­¾å·²å­˜åœ¨');
        return;
    }
    
    const maxOrder = existing.length > 0 ? Math.max(...existing.map(t => t.order || 0)) + 1 : 0;
    
    await db.avatar_categories.add({
        name: trimmed,
        parentCategory: avatarLibraryMainTab,
        order: maxOrder,
        time: Date.now()
    });
    
    avatarLibraryCurrentTag = trimmed;
    await loadSubTags();
    renderAvatarLibrary();
    showToast(`å·²æ·»åŠ æ ‡ç­¾ã€Œ${trimmed}ã€`);
}

// å³é”®/é•¿æŒ‰å­æ ‡ç­¾èœå•
function showSubTagMenu(event, tagId, tagName) {
    const old = document.getElementById('avatar-subtag-menu');
    if (old) old.remove();
    
    const menu = document.createElement('div');
    menu.id = 'avatar-subtag-menu';
    menu.style.cssText = `position:fixed; z-index:99999; background:#fff; border-radius:10px; 
        box-shadow:0 4px 20px rgba(0,0,0,0.12); padding:4px 0; min-width:100px;`;
    
    const x = event.clientX || 100;
    const y = event.clientY || 100;
    menu.style.left = Math.min(x, window.innerWidth - 120) + 'px';
    menu.style.top = Math.min(y, window.innerHeight - 100) + 'px';
    
    menu.innerHTML = `
        <div onclick="renameSubTag(${tagId}, '${tagName.replace(/'/g, "\\'")}')" 
             style="padding:10px 16px; font-size:13px; color:#262626; cursor:pointer;"
             onmouseover="this.style.background='#f5f5f5'" onmouseout="this.style.background='#fff'">é‡å‘½å</div>
        <div onclick="deleteSubTag(${tagId}, '${tagName.replace(/'/g, "\\'")}')" 
             style="padding:10px 16px; font-size:13px; color:#ff3b30; cursor:pointer;"
             onmouseover="this.style.background='#f5f5f5'" onmouseout="this.style.background='#fff'">åˆ é™¤</div>
    `;
    
    document.body.appendChild(menu);
    const closeMenu = (e) => {
        if (!menu.contains(e.target)) { menu.remove(); document.removeEventListener('click', closeMenu); }
    };
    setTimeout(() => document.addEventListener('click', closeMenu), 50);
}

// é‡å‘½åå­æ ‡ç­¾
async function renameSubTag(tagId, oldName) {
    const old = document.getElementById('avatar-subtag-menu');
    if (old) old.remove();
    
    const newName = prompt('è¯·è¾“å…¥æ–°çš„æ ‡ç­¾åç§°ï¼š', oldName);
    if (!newName || !newName.trim() || newName.trim() === oldName) return;
    
    const trimmed = newName.trim();
    const siblings = await db.avatar_categories
        .where('parentCategory').equals(avatarLibraryMainTab).toArray();
    if (siblings.find(t => t.name === trimmed)) {
        showToast('è¯¥æ ‡ç­¾åå·²å­˜åœ¨');
        return;
    }
    
    await db.avatar_categories.update(tagId, { name: trimmed });
    
    // æ›´æ–°è¯¥æ ‡ç­¾ä¸‹å¤´åƒçš„tagå­—æ®µ
    const avatarsInTag = await db.avatar_library
        .where('tag').equals(oldName).toArray();
    for (const av of avatarsInTag) {
        if (av.category === avatarLibraryMainTab) {
            await db.avatar_library.update(av.id, { tag: trimmed });
        }
    }
    
    if (avatarLibraryCurrentTag === oldName) avatarLibraryCurrentTag = trimmed;
    await loadSubTags();
    renderAvatarLibrary();
    showToast(`å·²é‡å‘½åä¸ºã€Œ${trimmed}ã€`);
}

// åˆ é™¤å­æ ‡ç­¾
async function deleteSubTag(tagId, tagName) {
    const old = document.getElementById('avatar-subtag-menu');
    if (old) old.remove();
    
    // è¯¥æ ‡ç­¾ä¸‹çš„å¤´åƒä¸åˆ é™¤ï¼Œåªæ˜¯æŠŠå®ƒä»¬çš„tagæ¸…ç©º
    if (!confirm(`ç¡®å®šåˆ é™¤æ ‡ç­¾ã€Œ${tagName}ã€å—ï¼Ÿ\næ ‡ç­¾ä¸‹çš„å¤´åƒä¸ä¼šè¢«åˆ é™¤ï¼Œä¼šå˜ä¸ºæœªåˆ†ç±»ã€‚`)) return;
    
    await db.avatar_categories.delete(tagId);
    
    // æ¸…ç©ºè¯¥æ ‡ç­¾ä¸‹å¤´åƒçš„tag
    const avatarsInTag = await db.avatar_library.where('tag').equals(tagName).toArray();
    for (const av of avatarsInTag) {
        if (av.category === avatarLibraryMainTab) {
            await db.avatar_library.update(av.id, { tag: '' });
        }
    }
    
    if (avatarLibraryCurrentTag === tagName) avatarLibraryCurrentTag = '';
    await loadSubTags();
    renderAvatarLibrary();
    showToast(`å·²åˆ é™¤æ ‡ç­¾ã€Œ${tagName}ã€`);
}

// æ¸²æŸ“å¤´åƒåˆ—è¡¨
async function renderAvatarLibrary() {
    const content = document.getElementById('avatar-library-content');
    if (!content) return;
    
    let allInCategory = await db.avatar_library
        .where('category').equals(avatarLibraryMainTab)
        .toArray();
    
    // æŒ‰å­æ ‡ç­¾ç­›é€‰
    let avatars;
    if (avatarLibraryCurrentTag) {
        avatars = allInCategory.filter(a => a.tag === avatarLibraryCurrentTag);
    } else {
        avatars = allInCategory;
    }
    // æŒ‰æ—¶é—´å€’åº
    avatars.sort((a, b) => (b.time || 0) - (a.time || 0));
    
    if (!avatars || avatars.length === 0) {
        const tabName = avatarLibraryMainTab === 'single' ? 'å•äººå¤´åƒ' : 'æƒ…å¤´';
        content.innerHTML = `
            <div style="display:flex; flex-direction:column; align-items:center; justify-content:center; padding:80px 40px;">
                <svg viewBox="0 0 24 24" style="width:40px; height:40px; fill:none; stroke:#dbdbdb; stroke-width:1.2;">
                    <circle cx="12" cy="8" r="4"></circle>
                    <path d="M20 21a8 8 0 1 0-16 0"></path>
                </svg>
                <div style="font-size:14px; color:#8e8e8e; margin-top:20px;">æš‚æ— ${avatarLibraryCurrentTag || tabName}</div>
                <div style="font-size:12px; color:#c7c7c7; margin-top:6px;">ç‚¹å‡»å³ä¸Šè§’ + æ·»åŠ å¤´åƒ</div>
            </div>
        `;
        return;
    }
    
    if (avatarLibraryMainTab === 'couple') {
        // æƒ…å¤´ - æ‰‹åŠ¨é…å¯¹å±•ç¤º
        // åˆ†ç¦»å·²é…å¯¹å’Œæœªé…å¯¹
        const paired = {}; // pairId -> [av1, av2]
        const unpaired = [];
        
        for (const av of avatars) {
            if (av.pairId) {
                if (!paired[av.pairId]) paired[av.pairId] = [];
                paired[av.pairId].push(av);
            } else {
                unpaired.push(av);
            }
        }
        
        let html = '';
        
        // é…å¯¹æ“ä½œæ 
        html += `<div style="display:flex; align-items:center; justify-content:space-between; padding:12px 16px;">
            <div style="font-size:12px; color:#999;">${Object.keys(paired).length} å¯¹æƒ…å¤´ Â· ${unpaired.length} å¼ æœªé…å¯¹</div>
            <div style="display:flex; gap:8px;">
                <div onclick="toggleAvatarBatchDelete()" style="padding:5px 14px; font-size:12px; border-radius:14px; cursor:pointer;
                    background:${avatarBatchDeleteMode ? '#ff3b30' : '#f5f5f5'}; color:${avatarBatchDeleteMode ? '#fff' : '#666'}; 
                    font-weight:500; transition:all 0.2s;">
                    ${avatarBatchDeleteMode ? 'å–æ¶ˆ' : 'æ‰¹é‡åˆ é™¤'}
                </div>
                <div onclick="toggleCouplePairingMode()" style="padding:5px 14px; font-size:12px; border-radius:14px; cursor:pointer;
                    background:${couplePairingMode ? '#ff6b81' : '#f5f5f5'}; color:${couplePairingMode ? '#fff' : '#666'}; 
                    font-weight:500; transition:all 0.2s;">
                    ${couplePairingMode ? 'å®Œæˆé…å¯¹' : 'é…å¯¹'}
                </div>
            </div>
        </div>`;
        
        // é…å¯¹æ¨¡å¼æç¤º
        if (couplePairingMode) {
            html += `<div style="text-align:center; padding:6px 16px 12px; font-size:12px; color:#ff6b81;">
                ${couplePairingFirst ? 'å†é€‰ä¸€å¼ å®Œæˆé…å¯¹ ğŸ’•' : 'é€‰æ‹©ç¬¬ä¸€å¼ å¤´åƒ'}
            </div>`;
        }
        
        // æ‰¹é‡åˆ é™¤æ¨¡å¼æç¤º
        if (avatarBatchDeleteMode) {
            html += `<div style="text-align:center; padding:6px 16px 12px; font-size:12px; color:#ff3b30;">
                ç‚¹å‡»å¤´åƒé€‰æ‹©è¦åˆ é™¤çš„å›¾ç‰‡
            </div>`;
        }
        
        // å·²é…å¯¹çš„æƒ…å¤´ - ä¸¤å¯¹ä¸€è¡Œ
        const pairIds = Object.keys(paired);
        if (pairIds.length > 0) {
            html += `<div style="display:flex; flex-wrap:wrap; padding:4px 8px;">`;
            for (const pid of pairIds) {
                const pair = paired[pid];
                const av1 = pair[0];
                const av2 = pair[1];
                if (!av1) continue;
                const isBatch1 = avatarBatchDeleteMode && avatarBatchSelected.has(av1.id);
                const isBatch2 = av2 && avatarBatchDeleteMode && avatarBatchSelected.has(av2.id);
                const clickAction1 = avatarBatchDeleteMode ? `toggleBatchSelect(${av1.id})` : `showAvatarPreview(${av1.id})`;
                const clickAction2 = av2 ? (avatarBatchDeleteMode ? `toggleBatchSelect(${av2.id})` : `showAvatarPreview(${av2.id})`) : '';
                html += `
                    <div style="width:50%; box-sizing:border-box; padding:6px 4px;">
                        <div style="display:flex; align-items:center; justify-content:center; gap:0;">
                            <div onclick="${clickAction1}" style="width:60px; height:60px; border-radius:12px; overflow:hidden; cursor:pointer; border:1px solid #f0f0f0; position:relative; flex-shrink:0;">
                                <img src="${av1.url}" style="width:100%; height:100%; object-fit:cover; display:block; ${isBatch1 ? 'opacity:0.5;' : ''}" onerror="this.parentElement.style.background='#fafafa';">
                                ${isBatch1 ? `<div style="position:absolute; top:2px; right:2px; width:18px; height:18px; border-radius:50%; background:#ff3b30; display:flex; align-items:center; justify-content:center;">
                                    <svg viewBox="0 0 24 24" style="width:12px; height:12px; fill:none; stroke:#fff; stroke-width:3;"><polyline points="20 6 9 17 4 12"></polyline></svg>
                                </div>` : ''}
                            </div>
                            <div style="display:flex; flex-direction:column; align-items:center; padding:0 4px; flex-shrink:0;">
                                <svg viewBox="0 0 24 24" style="width:12px; height:12px; fill:#ff6b81; stroke:none;">
                                    <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
                                </svg>
                                ${!avatarBatchDeleteMode ? `<div onclick="unpairCouple('${pid}')" style="margin-top:3px; font-size:9px; color:#ccc; cursor:pointer;">æ‹†å¼€</div>` : ''}
                            </div>
                            ${av2 ? `
                            <div onclick="${clickAction2}" style="width:60px; height:60px; border-radius:12px; overflow:hidden; cursor:pointer; border:1px solid #f0f0f0; position:relative; flex-shrink:0;">
                                <img src="${av2.url}" style="width:100%; height:100%; object-fit:cover; display:block; ${isBatch2 ? 'opacity:0.5;' : ''}" onerror="this.parentElement.style.background='#fafafa';">
                                ${isBatch2 ? `<div style="position:absolute; top:2px; right:2px; width:18px; height:18px; border-radius:50%; background:#ff3b30; display:flex; align-items:center; justify-content:center;">
                                    <svg viewBox="0 0 24 24" style="width:12px; height:12px; fill:none; stroke:#fff; stroke-width:3;"><polyline points="20 6 9 17 4 12"></polyline></svg>
                                </div>` : ''}
                            </div>
                            ` : '<div style="width:60px; height:60px; flex-shrink:0;"></div>'}
                        </div>
                    </div>
                `;
            }
            html += `</div>`;
        }
        
        // æœªé…å¯¹çš„å¤´åƒï¼ˆç½‘æ ¼å±•ç¤ºï¼‰
        if (unpaired.length > 0) {
            if (pairIds.length > 0) {
                html += `<div style="padding:12px 16px 6px; font-size:12px; color:#b0b0b0;">æœªé…å¯¹</div>`;
            }
            const gridItems = unpaired.map(av => {
                const isSelected = couplePairingMode && couplePairingFirst === av.id;
                const isBatchSel = avatarBatchDeleteMode && avatarBatchSelected.has(av.id);
                let clickAction;
                if (avatarBatchDeleteMode) {
                    clickAction = `toggleBatchSelect(${av.id})`;
                } else if (couplePairingMode) {
                    clickAction = `selectCoupleAvatar(${av.id})`;
                } else {
                    clickAction = `showAvatarPreview(${av.id})`;
                }
                return `
                    <div onclick="${clickAction}" 
                         style="aspect-ratio:1; overflow:hidden; cursor:pointer; position:relative; 
                         ${isSelected ? 'outline:3px solid #ff6b81; outline-offset:-3px; border-radius:4px;' : ''}">
                        <img src="${av.url}" style="width:100%; height:100%; object-fit:cover; display:block; 
                             ${isSelected || isBatchSel ? 'opacity:0.5;' : 'transition:opacity 0.2s;'}" 
                             onerror="this.style.display='none'; this.parentElement.style.background='#fafafa';">
                        ${isSelected ? `<div style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); 
                            width:28px; height:28px; border-radius:50%; background:#ff6b81; display:flex; align-items:center; justify-content:center;">
                            <span style="color:#fff; font-size:14px;">1</span>
                        </div>` : ''}
                        ${isBatchSel ? `<div style="position:absolute; top:4px; right:4px; width:20px; height:20px; border-radius:50%; background:#ff3b30; display:flex; align-items:center; justify-content:center;">
                            <svg viewBox="0 0 24 24" style="width:12px; height:12px; fill:none; stroke:#fff; stroke-width:3;"><polyline points="20 6 9 17 4 12"></polyline></svg>
                        </div>` : ''}
                    </div>
                `;
            }).join('');
            html += `<div style="display:grid; grid-template-columns:repeat(3, 1fr); gap:1.5px;">${gridItems}</div>`;
        }
        
        // æ‰¹é‡æ¨¡å¼ä¸‹ç•™å‡ºåº•éƒ¨ç©ºé—´
        if (avatarBatchDeleteMode) {
            html += `<div style="height:60px;"></div>`;
        }
        
        content.innerHTML = html;
    } else {
        // å•äººå¤´åƒ - INSé£ä¸‰åˆ—ç½‘æ ¼
        let topBarHtml = '';
        if (avatars.length > 0) {
            topBarHtml = `<div style="display:flex; align-items:center; justify-content:flex-end; padding:10px 16px;">
                <div onclick="toggleAvatarBatchDelete()" style="padding:5px 14px; font-size:12px; border-radius:14px; cursor:pointer;
                    background:${avatarBatchDeleteMode ? '#ff3b30' : '#f5f5f5'}; color:${avatarBatchDeleteMode ? '#fff' : '#666'}; 
                    font-weight:500; transition:all 0.2s;">
                    ${avatarBatchDeleteMode ? 'å–æ¶ˆ' : 'æ‰¹é‡åˆ é™¤'}
                </div>
            </div>`;
            if (avatarBatchDeleteMode) {
                topBarHtml += `<div style="text-align:center; padding:0 16px 10px; font-size:12px; color:#ff3b30;">
                    ç‚¹å‡»å¤´åƒé€‰æ‹©è¦åˆ é™¤çš„å›¾ç‰‡
                </div>`;
            }
        }
        
        const gridHtml = avatars.map(av => {
            const isBatchSel = avatarBatchDeleteMode && avatarBatchSelected.has(av.id);
            const clickAction = avatarBatchDeleteMode ? `toggleBatchSelect(${av.id})` : `showAvatarPreview(${av.id})`;
            return `
                <div onclick="${clickAction}" style="aspect-ratio:1; overflow:hidden; cursor:pointer; position:relative;">
                    <img src="${av.url}" style="width:100%; height:100%; object-fit:cover; display:block; transition:opacity 0.2s; ${isBatchSel ? 'opacity:0.5;' : ''}" 
                         onmouseover="this.style.opacity='0.85'" onmouseout="this.style.opacity='${isBatchSel ? '0.5' : '1'}'" 
                         onerror="this.style.display='none'; this.parentElement.style.background='#fafafa';">
                    ${isBatchSel ? `<div style="position:absolute; top:4px; right:4px; width:20px; height:20px; border-radius:50%; background:#ff3b30; display:flex; align-items:center; justify-content:center;">
                        <svg viewBox="0 0 24 24" style="width:12px; height:12px; fill:none; stroke:#fff; stroke-width:3;"><polyline points="20 6 9 17 4 12"></polyline></svg>
                    </div>` : ''}
                </div>
            `;
        }).join('');
        
        let bottomPad = avatarBatchDeleteMode ? '<div style="height:60px;"></div>' : '';
        content.innerHTML = topBarHtml + `<div style="display:grid; grid-template-columns:repeat(3, 1fr); gap:1.5px;">${gridHtml}</div>` + bottomPad;
    }
}

function showAvatarImportModal() {
    const modal = document.getElementById('avatar-import-modal');
    if (modal) {
        modal.style.display = 'flex';
        const urlArea = document.getElementById('avatar-url-input-area');
        if (urlArea) urlArea.style.display = 'none';
        const urlInput = document.getElementById('avatar-url-input');
        if (urlInput) urlInput.value = '';
    }
}

function hideAvatarImportModal() {
    const modal = document.getElementById('avatar-import-modal');
    if (modal) modal.style.display = 'none';
}

function showAvatarUrlInput() {
    const urlArea = document.getElementById('avatar-url-input-area');
    if (urlArea) {
        urlArea.style.display = 'block';
        const input = document.getElementById('avatar-url-input');
        if (input) input.focus();
    }
}

// ä»ç›¸å†Œæ–‡ä»¶å¯¼å…¥å¤´åƒ
async function handleAvatarFileImport(input) {
    if (!input.files || input.files.length === 0) return;
    
    const files = Array.from(input.files);
    let count = 0;
    
    for (const file of files) {
        try {
            const dataUrl = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
            
            await db.avatar_library.add({
                url: dataUrl,
                category: avatarLibraryMainTab,
                tag: avatarLibraryCurrentTag || '',
                time: Date.now(),
                source: 'file',
                fileName: file.name
            });
            count++;
        } catch (e) {
            console.error('[å¤´åƒåº“] å¯¼å…¥æ–‡ä»¶å¤±è´¥:', e);
        }
    }
    
    input.value = '';
    
    if (count > 0) {
        showToast(`å·²æ·»åŠ  ${count} å¼ å¤´åƒ`);
        renderAvatarLibrary();
    }
}

// ä»URLå¯¼å…¥å¤´åƒï¼ˆæ”¯æŒå¤šè¡Œæ‰¹é‡ç²˜è´´ï¼‰
async function importAvatarFromUrl() {
    const input = document.getElementById('avatar-url-input');
    const rawText = input ? input.value.trim() : '';
    
    if (!rawText) {
        showToast('è¯·è¾“å…¥å›¾ç‰‡é“¾æ¥');
        return;
    }
    
    // æŒ‰æ¢è¡Œåˆ†å‰²ï¼Œæ”¯æŒå¤šç§æ¢è¡Œç¬¦
    const lines = rawText.split(/[\r\n]+/).map(l => l.trim()).filter(l => l.length > 0);
    
    // è‡ªåŠ¨è¯†åˆ«æœ‰æ•ˆURL
    const validUrls = [];
    for (const line of lines) {
        if (line.startsWith('http://') || line.startsWith('https://') || line.startsWith('data:')) {
            validUrls.push(line);
        }
    }
    
    if (validUrls.length === 0) {
        showToast('æœªè¯†åˆ«åˆ°æœ‰æ•ˆçš„å›¾ç‰‡é“¾æ¥');
        return;
    }
    
    let count = 0;
    for (const url of validUrls) {
        try {
            await db.avatar_library.add({
                url: url,
                category: avatarLibraryMainTab,
                tag: avatarLibraryCurrentTag || '',
                time: Date.now() + count, // ä¿è¯æ—¶é—´é€’å¢ï¼Œé¡ºåºæ­£ç¡®
                source: 'url'
            });
            count++;
        } catch (e) {
            console.error('[å¤´åƒåº“] URLå¯¼å…¥å¤±è´¥:', url, e);
        }
    }
    
    if (count > 0) {
        input.value = '';
        hideAvatarImportModal();
        showToast(`å·²å¯¼å…¥ ${count} å¼ å¤´åƒ`);
        renderAvatarLibrary();
    } else {
        showToast('å¯¼å…¥å¤±è´¥ï¼Œè¯·é‡è¯•');
    }
}

// é¢„è§ˆå¤´åƒ
async function showAvatarPreview(id) {
    const avatar = await db.avatar_library.get(id);
    if (!avatar) return;
    
    avatarPreviewCurrentId = id;
    
    const modal = document.getElementById('avatar-preview-modal');
    const img = document.getElementById('avatar-preview-img');
    
    if (modal && img) {
        img.src = avatar.url;
        modal.style.display = 'flex';
    }
}

function hideAvatarPreview() {
    const modal = document.getElementById('avatar-preview-modal');
    if (modal) modal.style.display = 'none';
    avatarPreviewCurrentId = null;
}

// è®¾ä¸ºå½“å‰è§’è‰²å¤´åƒ
async function useAvatarAsProfile() {
    if (!avatarPreviewCurrentId) return;
    
    const avatar = await db.avatar_library.get(avatarPreviewCurrentId);
    if (!avatar) return;
    
    if (!currentMyCharId) {
        showToast('è¯·å…ˆç™»å½•è´¦å·');
        return;
    }
    
    const myChar = await db.characters.get(parseInt(currentMyCharId));
    if (!myChar) {
        showToast('æœªæ‰¾åˆ°è§’è‰²ä¿¡æ¯');
        return;
    }
    
    myChar.avatar = avatar.url;
    await db.characters.put(myChar);
    
    hideAvatarPreview();
    showToast('å¤´åƒè®¾ç½®æˆåŠŸ');
}

// ä»å¤´åƒåº“åˆ é™¤
async function deleteAvatarFromLibrary() {
    if (!avatarPreviewCurrentId) return;
    
    if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™å¼ å¤´åƒå—ï¼Ÿ')) return;
    
    try {
        await db.avatar_library.delete(avatarPreviewCurrentId);
        hideAvatarPreview();
        showToast('å·²åˆ é™¤');
        renderAvatarLibrary();
    } catch (e) {
        console.error('[å¤´åƒåº“] åˆ é™¤å¤±è´¥:', e);
        showToast('åˆ é™¤å¤±è´¥');
    }
}

// ========== æ‰¹é‡åˆ é™¤åŠŸèƒ½ ==========

// åˆ‡æ¢æ‰¹é‡åˆ é™¤æ¨¡å¼
function toggleAvatarBatchDelete() {
    avatarBatchDeleteMode = !avatarBatchDeleteMode;
    avatarBatchSelected.clear();
    // é€€å‡ºé…å¯¹æ¨¡å¼
    couplePairingMode = false;
    couplePairingFirst = null;
    renderAvatarLibrary();
    updateBatchDeleteBar();
}

// æ‰¹é‡é€‰ä¸­/å–æ¶ˆé€‰ä¸­å¤´åƒ
function toggleBatchSelect(id) {
    if (avatarBatchSelected.has(id)) {
        avatarBatchSelected.delete(id);
    } else {
        avatarBatchSelected.add(id);
    }
    renderAvatarLibrary();
    updateBatchDeleteBar();
}

// æ‰¹é‡å…¨é€‰å½“å‰åˆ†ç±»çš„å¤´åƒ
async function batchSelectAll() {
    let allInCategory = await db.avatar_library
        .where('category').equals(avatarLibraryMainTab)
        .toArray();
    if (avatarLibraryCurrentTag) {
        allInCategory = allInCategory.filter(a => a.tag === avatarLibraryCurrentTag);
    }
    if (avatarBatchSelected.size === allInCategory.length) {
        // å·²å…¨é€‰ï¼Œå–æ¶ˆå…¨é€‰
        avatarBatchSelected.clear();
    } else {
        avatarBatchSelected.clear();
        for (const av of allInCategory) {
            avatarBatchSelected.add(av.id);
        }
    }
    renderAvatarLibrary();
    updateBatchDeleteBar();
}

// æ›´æ–°åº•éƒ¨æ‰¹é‡æ“ä½œæ 
function updateBatchDeleteBar() {
    const bar = document.getElementById('avatar-batch-bar');
    if (!bar) return;
    if (avatarBatchDeleteMode) {
        bar.style.display = 'flex';
        const count = avatarBatchSelected.size;
        bar.innerHTML = `
            <div onclick="batchSelectAll()" style="padding:8px 16px; font-size:13px; color:#007aff; cursor:pointer; font-weight:500;">
                å…¨é€‰
            </div>
            <div style="flex:1; text-align:center; font-size:13px; color:#666;">
                å·²é€‰ <span style="color:#ff3b30; font-weight:600;">${count}</span> å¼ 
            </div>
            <div onclick="executeBatchDelete()" style="padding:8px 16px; font-size:13px; color:${count > 0 ? '#ff3b30' : '#ccc'}; cursor:${count > 0 ? 'pointer' : 'default'}; font-weight:600;">
                åˆ é™¤
            </div>
        `;
    } else {
        bar.style.display = 'none';
        bar.innerHTML = '';
    }
}

// æ‰§è¡Œæ‰¹é‡åˆ é™¤
async function executeBatchDelete() {
    const count = avatarBatchSelected.size;
    if (count === 0) {
        showToast('è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„å¤´åƒ');
        return;
    }
    
    if (!confirm(`ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${count} å¼ å¤´åƒå—ï¼Ÿ`)) return;
    
    try {
        const ids = Array.from(avatarBatchSelected);
        for (const id of ids) {
            await db.avatar_library.delete(id);
        }
        avatarBatchSelected.clear();
        avatarBatchDeleteMode = false;
        updateBatchDeleteBar();
        renderAvatarLibrary();
        showToast(`å·²åˆ é™¤ ${count} å¼ å¤´åƒ`);
    } catch (e) {
        console.error('[å¤´åƒåº“] æ‰¹é‡åˆ é™¤å¤±è´¥:', e);
        showToast('åˆ é™¤å¤±è´¥');
    }
}

// åˆ‡æ¢é…å¯¹æ¨¡å¼
function toggleCouplePairingMode() {
    couplePairingMode = !couplePairingMode;
    couplePairingFirst = null;
    // é€€å‡ºæ‰¹é‡åˆ é™¤æ¨¡å¼
    avatarBatchDeleteMode = false;
    avatarBatchSelected.clear();
    updateBatchDeleteBar();
    renderAvatarLibrary();
}

// é…å¯¹æ¨¡å¼ä¸‹é€‰ä¸­å¤´åƒ
async function selectCoupleAvatar(id) {
    if (!couplePairingMode) return;
    
    if (couplePairingFirst === null) {
        // é€‰ä¸­ç¬¬ä¸€å¼ 
        couplePairingFirst = id;
        renderAvatarLibrary();
    } else if (couplePairingFirst === id) {
        // ç‚¹äº†åŒä¸€å¼ ï¼Œå–æ¶ˆé€‰ä¸­
        couplePairingFirst = null;
        renderAvatarLibrary();
    } else {
        // é€‰ä¸­ç¬¬äºŒå¼ ï¼Œå®Œæˆé…å¯¹
        const pairId = 'pair_' + Date.now();
        try {
            await db.avatar_library.update(couplePairingFirst, { pairId: pairId });
            await db.avatar_library.update(id, { pairId: pairId });
            couplePairingFirst = null;
            showToast('é…å¯¹æˆåŠŸ ğŸ’•');
            renderAvatarLibrary();
        } catch (e) {
            console.error('[å¤´åƒåº“] é…å¯¹å¤±è´¥:', e);
            showToast('é…å¯¹å¤±è´¥');
        }
    }
}

// å–æ¶ˆé…å¯¹ï¼ˆæ‹†å¼€ï¼‰
async function unpairCouple(pairId) {
    if (!confirm('ç¡®å®šè¦æ‹†å¼€è¿™å¯¹æƒ…å¤´å—ï¼Ÿ')) return;
    
    try {
        const paired = await db.avatar_library.toArray();
        const toUnpair = paired.filter(a => a.pairId === pairId);
        for (const av of toUnpair) {
            await db.avatar_library.update(av.id, { pairId: '' });
        }
        showToast('å·²æ‹†å¼€');
        renderAvatarLibrary();
    } catch (e) {
        console.error('[å¤´åƒåº“] å–æ¶ˆé…å¯¹å¤±è´¥:', e);
    }
}

// ============================================
// AIè‡ªä¸»æ¢å¤´åƒåŠŸèƒ½
// ============================================

// æ‰§è¡Œæ¢å¤´åƒï¼šä»å¤´åƒåº“éšæœºé€‰ä¸€å¼ å•äººå¤´åƒè®¾ä¸ºè§’è‰²å¤´åƒ
async function executeChangeAvatar(charId, accountId) {
    try {
        const singleAvatars = await db.avatar_library.where('category').equals('single').toArray();
        if (!singleAvatars || singleAvatars.length === 0) {
            console.log('[æ¢å¤´åƒ] å¤´åƒåº“ä¸­æ²¡æœ‰å•äººå¤´åƒ');
            return;
        }
        
        // è·å–è§’è‰²å½“å‰å¤´åƒ
        const char = await db.characters.get(charId);
        if (!char) return;
        
        const currentAvatarUrl = char.avatar || '';
        
        // ğŸ”¥ ä¿®å¤ï¼šè¿‡æ»¤æ‰æ— æ•ˆURLå’Œå½“å‰æ­£åœ¨ä½¿ç”¨çš„å¤´åƒï¼Œé¿å…"æ¢äº†ä½†æ²¡å˜"
        let availableAvatars = singleAvatars.filter(a => {
            if (!a.url || a.url.trim() === '') return false; // æ’é™¤ç©ºURL
            if (a.url === currentAvatarUrl) return false; // æ’é™¤å½“å‰å¤´åƒ
            return true;
        });
        
        // å¦‚æœè¿‡æ»¤åæ²¡æœ‰å¯é€‰çš„ï¼ˆæ¯”å¦‚åªæœ‰ä¸€å¼ ä¸”å°±æ˜¯å½“å‰å¤´åƒï¼‰ï¼Œç”¨å…¨éƒ¨
        if (availableAvatars.length === 0) {
            availableAvatars = singleAvatars.filter(a => a.url && a.url.trim() !== '');
            if (availableAvatars.length === 0) {
                console.log('[æ¢å¤´åƒ] å¤´åƒåº“ä¸­æ²¡æœ‰æœ‰æ•ˆçš„å¤´åƒURL');
                return;
            }
        }
        
        // éšæœºé€‰æ‹©ä¸€å¼ 
        const randomIndex = Math.floor(Math.random() * availableAvatars.length);
        const selectedAvatar = availableAvatars[randomIndex];
        
        console.log(`[æ¢å¤´åƒ] ${char.name} å‡†å¤‡æ¢å¤´åƒ, å¯é€‰: ${availableAvatars.length}å¼ , é€‰ä¸­ç¬¬${randomIndex + 1}å¼ `);
        
        // ğŸ”¥ ä¿®å¤ï¼šé‡æ–°è·å–æœ€æ–°çš„charï¼Œé˜²æ­¢å¹¶å‘ä¿®æ”¹è¦†ç›–
        const freshChar = await db.characters.get(charId);
        if (!freshChar) return;
        
        const oldAvatar = freshChar.avatar;
        freshChar.avatar = selectedAvatar.url;
        await db.characters.put(freshChar);
        
        console.log(`[æ¢å¤´åƒ] ${freshChar.name} æ¢äº†æ–°å¤´åƒ (æ—§: ${oldAvatar?.substring(0, 50)}... â†’ æ–°: ${selectedAvatar.url.substring(0, 50)}...)`);
        
        // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯åˆ°èŠå¤©è®°å½•
        const currentAccountId = accountId || getCurrentAccountId();
        let history = getChatHistory(freshChar, currentAccountId);
        history.push({
            role: 'system',
            content: `${freshChar.name} æ›´æ¢äº†å¤´åƒ`,
            time: Date.now(),
            type: 'avatar_change'
        });
        await setChatHistory(freshChar, currentAccountId, history);
        
        // ğŸ”¥ ä¿®å¤ï¼šåˆ·æ–°UI - ä¸è®ºæ˜¯å¦åœ¨å½“å‰èŠå¤©é¡µéƒ½åˆ·æ–°ç›¸å…³UI
        if (currentChatCharId === charId) {
            // é‡æ–°æ¸²æŸ“æ•´ä¸ªèŠå¤©é¡µé¢ï¼Œç¡®ä¿æ‰€æœ‰å¤´åƒç«‹å³æ›´æ–°
            const updatedChar = await db.characters.get(charId);
            if (updatedChar) {
                renderChatBody(updatedChar);
            }
            // æ›´æ–°èŠå¤©æ ‡é¢˜æ çš„å¤´åƒï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
            const chatHeaderAvatar = document.querySelector('#chat-page .chat-header .msg-avatar, #chat-page .chat-header img');
            if (chatHeaderAvatar) {
                if (chatHeaderAvatar.tagName === 'IMG') {
                    chatHeaderAvatar.src = selectedAvatar.url;
                } else {
                    chatHeaderAvatar.style.backgroundImage = `url(${selectedAvatar.url})`;
                }
            }
        }
        
        // ğŸ”¥ ä¿®å¤ï¼šåŒæ—¶åˆ·æ–°å¾®ä¿¡åˆ—è¡¨ä¸­çš„å¤´åƒæ˜¾ç¤º
        try {
            const wechatContent = document.getElementById('wechat-content');
            if (wechatContent && wechatContent.innerHTML) {
                // æ‰¾åˆ°å¯¹åº”è§’è‰²çš„å¤´åƒå…ƒç´ å¹¶æ›´æ–°
                const avatarEls = wechatContent.querySelectorAll(`[data-char-id="${charId}"] .msg-avatar, [onclick*="openChat(${charId})"] .msg-avatar`);
                avatarEls.forEach(el => {
                    el.style.backgroundImage = `url(${selectedAvatar.url})`;
                });
                // å¦‚æœæ‰¾ä¸åˆ°ç‰¹å®šçš„ï¼Œåˆ·æ–°æ•´ä¸ªåˆ—è¡¨
                if (avatarEls.length === 0) {
                    renderWechatList(wechatContent);
                }
            }
        } catch (uiErr) {
            console.warn('[æ¢å¤´åƒ] åˆ·æ–°å¾®ä¿¡åˆ—è¡¨å¤´åƒå¤±è´¥:', uiErr);
        }
        
        showToast(`${freshChar.name} æ¢äº†æ–°å¤´åƒ`);
    } catch (e) {
        console.error('[æ¢å¤´åƒ] æ‰§è¡Œå¤±è´¥:', e);
    }
}

// å‘é€æƒ…å¤´é‚€è¯·å¡ç‰‡
async function sendCoupleAvatarCard(charId, accountId) {
    try {
        // æŸ¥æ‰¾å·²é…å¯¹çš„æƒ…å¤´
        const coupleAvatars = await db.avatar_library.where('category').equals('couple').toArray();
        const paired = {};
        for (const av of coupleAvatars) {
            if (av.pairId) {
                if (!paired[av.pairId]) paired[av.pairId] = [];
                paired[av.pairId].push(av);
            }
        }
        
        // åªå–å®Œæ•´é…å¯¹çš„ï¼ˆæœ‰2å¼ çš„ï¼‰
        const completePairs = Object.keys(paired).filter(k => paired[k].length === 2);
        
        if (completePairs.length === 0) {
            console.log('[æƒ…å¤´é‚€è¯·] æ²¡æœ‰å·²é…å¯¹çš„æƒ…å¤´');
            return false;
        }
        
        // éšæœºé€‰ä¸€å¯¹
        const randomPairId = completePairs[Math.floor(Math.random() * completePairs.length)];
        const pair = paired[randomPairId];
        const av1 = pair[0];
        const av2 = pair[1];
        
        const char = await db.characters.get(charId);
        if (!char) return false;
        
        // æ„å»ºæƒ…å¤´é‚€è¯·å¡ç‰‡HTML - ç´§å‡‘INSç™½è‰²é£æ ¼
        const cardHtml = `<div style="width:220px;background:#fff;border-radius:12px;overflow:hidden;box-shadow:0 1px 4px rgba(0,0,0,0.06);font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;"><div style="display:flex;align-items:center;justify-content:center;gap:0;padding:14px 16px 10px;"><div style="width:72px;height:72px;border-radius:50%;overflow:hidden;flex-shrink:0;box-shadow:0 0 0 1px rgba(0,0,0,0.04);"><img src="${av1.url}" style="width:100%;height:100%;object-fit:cover;display:block;" onerror="this.style.display='none'"></div><div style="padding:0 8px;display:flex;align-items:center;"><svg viewBox="0 0 24 24" style="width:14px;height:14px;fill:#ff6b81;stroke:none;opacity:0.8;"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg></div><div style="width:72px;height:72px;border-radius:50%;overflow:hidden;flex-shrink:0;box-shadow:0 0 0 1px rgba(0,0,0,0.04);"><img src="${av2.url}" style="width:100%;height:100%;object-fit:cover;display:block;" onerror="this.style.display='none'"></div></div><div style="text-align:center;padding:0 16px 12px;font-size:12px;color:#8e8e8e;letter-spacing:0.3px;">ä¸€èµ·æ¢æƒ…å¤´å§</div><div class="couple-card-actions" style="display:flex;border-top:0.5px solid #efefef;"><div onclick="acceptCoupleAvatar(this,${av1.id},${av2.id},${charId})" style="flex:1;text-align:center;padding:10px;font-size:13px;font-weight:500;color:#262626;cursor:pointer;">æ¢</div><div style="width:0.5px;background:#efefef;"></div><div onclick="declineCoupleAvatar(this)" style="flex:1;text-align:center;padding:10px;font-size:13px;color:#c7c7c7;cursor:pointer;">ç®—äº†</div></div></div>`;
        
        // å­˜å‚¨åˆ°èŠå¤©å†å²
        const freshChar = await db.characters.get(charId);
        if (freshChar) {
            let history = getChatHistory(freshChar, accountId);
            const cardMsg = {
                role: 'char',
                content: `[couple_avatar_card]${cardHtml}`,
                time: Date.now()
            };
            history.push(cardMsg);
            await setChatHistory(freshChar, accountId, history);
            
            // æ¸²æŸ“UI
            if (currentChatCharId === charId) {
                renderChatBody(freshChar);
            } else {
                sendSystemNotification(freshChar.name, '[æƒ…å¤´é‚€è¯·]');
            }
        }
        
        return true;
    } catch (e) {
        console.error('[æƒ…å¤´é‚€è¯·] å‘é€å¤±è´¥:', e);
        return false;
    }
}

// æ¥å—æƒ…å¤´é‚€è¯· - ç”¨æˆ·å’Œè§’è‰²éƒ½æ¢ä¸Šæƒ…å¤´
async function acceptCoupleAvatar(btn, av1Id, av2Id, charId) {
    try {
        const av1 = await db.avatar_library.get(av1Id);
        const av2 = await db.avatar_library.get(av2Id);
        
        if (!av1 || !av2) {
            showToast('å¤´åƒæ•°æ®ä¸å­˜åœ¨');
            return;
        }
        
        // è§’è‰²æ¢ç¬¬ä¸€å¼ ï¼Œç”¨æˆ·æ¢ç¬¬äºŒå¼ ï¼ˆæˆ–åè¿‡æ¥éšæœºï¼‰
        const useFirst = Math.random() > 0.5;
        const charAvatar = useFirst ? av1.url : av2.url;
        const userAvatar = useFirst ? av2.url : av1.url;
        
        // æ›´æ–°è§’è‰²å¤´åƒ
        const char = await db.characters.get(charId);
        if (char) {
            char.avatar = charAvatar;
            await db.characters.put(char);
        }
        
        // æ›´æ–°ç”¨æˆ·å¤´åƒ
        if (currentMyCharId) {
            const myChar = await db.characters.get(parseInt(currentMyCharId));
            if (myChar) {
                myChar.avatar = userAvatar;
                await db.characters.put(myChar);
            }
        }
        
        // æ›´æ–°æŒ‰é’®UI
        const cardEl = btn.closest('.couple-card-actions');
        if (cardEl) {
            cardEl.innerHTML = `<div style="flex:1;text-align:center;padding:10px;font-size:12px;color:#8e8e8e;">å·²æ¢ä¸Š â™¡</div>`;
        }
        
        // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯åˆ°èŠå¤©è®°å½•
        const accountId = getCurrentAccountId();
        let history = getChatHistory(char, accountId);
        history.push({
            role: 'system',
            content: `ä½ å’Œ ${char.name} æ¢ä¸Šäº†æƒ…å¤´ ğŸ’•`,
            time: Date.now(),
            type: 'couple_avatar_accepted'
        });
        await setChatHistory(char, accountId, history);
        
        // å¦‚æœå½“å‰æ­£åœ¨æŸ¥çœ‹èŠå¤©ï¼Œåˆ·æ–°
        if (currentChatCharId === charId) {
            const freshChar = await db.characters.get(charId);
            if (freshChar) renderChatBody(freshChar);
        }
        
        showToast('å·²æ¢ä¸Šæƒ…å¤´ ğŸ’•');
    } catch (e) {
        console.error('[æƒ…å¤´é‚€è¯·] æ¥å—å¤±è´¥:', e);
        showToast('æ¢å¤´åƒå¤±è´¥');
    }
}

// æ‹’ç»æƒ…å¤´é‚€è¯·
function declineCoupleAvatar(btn) {
    const cardEl = btn.closest('.couple-card-actions');
    if (cardEl) {
        cardEl.innerHTML = `<div style="flex:1;text-align:center;padding:10px;font-size:12px;color:#c7c7c7;">å·²å©‰æ‹’</div>`;
    }
}

// è§’è‰²æ¢å›å•äººå¤´åƒï¼ˆä»æƒ…å¤´æ¢å›æ¥ï¼‰
async function executeRevertCoupleAvatar(charId, accountId) {
    try {
        const singleAvatars = await db.avatar_library.where('category').equals('single').toArray();
        if (!singleAvatars || singleAvatars.length === 0) {
            console.log('[æ¢å›å•äººå¤´åƒ] å¤´åƒåº“ä¸­æ²¡æœ‰å•äººå¤´åƒ');
            return;
        }
        
        // éšæœºé€‰æ‹©ä¸€å¼ å•äººå¤´åƒ
        const randomIndex = Math.floor(Math.random() * singleAvatars.length);
        const selectedAvatar = singleAvatars[randomIndex];
        
        // æ›´æ–°è§’è‰²å¤´åƒ
        const char = await db.characters.get(charId);
        if (!char) return;
        
        char.avatar = selectedAvatar.url;
        await db.characters.put(char);
        
        console.log(`[æ¢å›å•äººå¤´åƒ] ${char.name} æ¢å›äº†å•äººå¤´åƒ`);
        
        // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯åˆ°èŠå¤©è®°å½•
        let history = getChatHistory(char, accountId);
        history.push({
            role: 'system',
            content: `${char.name} æ¢å›äº†å•äººå¤´åƒ`,
            time: Date.now(),
            type: 'revert_couple_avatar'
        });
        await setChatHistory(char, accountId, history);
        
        // ç«‹å³åˆ·æ–°UI
        if (currentChatCharId === charId) {
            const freshChar = await db.characters.get(charId);
            if (freshChar) {
                renderChatBody(freshChar);
            }
        }
        
        showToast(`${char.name} æ¢å›äº†å•äººå¤´åƒ`);
    } catch (e) {
        console.error('[æ¢å›å•äººå¤´åƒ] æ‰§è¡Œå¤±è´¥:', e);
    }
}

// è§’è‰²ä½¿ç”¨ç”¨æˆ·å‘é€çš„å›¾ç‰‡ä½œä¸ºå¤´åƒ
// imageIndex: ç¬¬å‡ å¼ å›¾ç‰‡ï¼ˆä»æœ€è¿‘å¾€å‰æ•°ï¼Œ1=æœ€è¿‘çš„ï¼Œ2=å€’æ•°ç¬¬2å¼ ...ï¼‰
async function executeUseImageAsAvatar(charId, accountId, imageIndex) {
    try {
        const char = await db.characters.get(charId);
        if (!char) return;
        
        // ä»èŠå¤©è®°å½•ä¸­æ”¶é›†ç”¨æˆ·å‘é€çš„æ‰€æœ‰å›¾ç‰‡ï¼ˆä»æ–°åˆ°æ—§ï¼‰
        let history = getChatHistory(char, accountId);
        let userImages = [];
        
        for (let i = history.length - 1; i >= 0; i--) {
            const msg = history[i];
            if (msg.role === 'user' && msg.content && msg.content.startsWith('[img:')) {
                // æå–å›¾ç‰‡URL
                const imgUrl = msg.content.substring(5, msg.content.length - 1);
                userImages.push({
                    url: imgUrl,
                    index: i,
                    desc: msg.imageDescription || ''
                });
            }
        }
        
        if (userImages.length === 0) {
            console.log('[ä½¿ç”¨å›¾ç‰‡å¤´åƒ] æ²¡æœ‰æ‰¾åˆ°ç”¨æˆ·å‘é€çš„å›¾ç‰‡');
            return;
        }
        
        // é€‰æ‹©ç¬¬ imageIndex å¼ ï¼ˆé»˜è®¤ç¬¬1å¼  = æœ€è¿‘çš„ï¼‰
        const targetIdx = Math.max(0, Math.min((imageIndex || 1) - 1, userImages.length - 1));
        const selectedImage = userImages[targetIdx];
        
        console.log(`[ä½¿ç”¨å›¾ç‰‡å¤´åƒ] ç”¨æˆ·å…±å‘é€ ${userImages.length} å¼ å›¾ç‰‡ï¼Œé€‰æ‹©ç¬¬ ${targetIdx + 1} å¼ ${selectedImage.desc ? `ï¼ˆæè¿°: ${selectedImage.desc}ï¼‰` : ''}`);
        
        // æ›´æ–°è§’è‰²å¤´åƒ
        char.avatar = selectedImage.url;
        await db.characters.put(char);
        
        console.log(`[ä½¿ç”¨å›¾ç‰‡å¤´åƒ] ${char.name} ä½¿ç”¨äº†ç”¨æˆ·å‘é€çš„å›¾ç‰‡ä½œä¸ºå¤´åƒ`);
        
        // æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯åˆ°èŠå¤©è®°å½•
        history = getChatHistory(char, accountId); // é‡æ–°è·å–æœ€æ–°
        history.push({
            role: 'system',
            content: `${char.name} æŠŠä½ å‘çš„å›¾ç‰‡æ¢æˆäº†å¤´åƒ`,
            time: Date.now(),
            type: 'use_image_avatar'
        });
        await setChatHistory(char, accountId, history);
        
        // ç«‹å³åˆ·æ–°UI
        if (currentChatCharId === charId) {
            const freshChar = await db.characters.get(charId);
            if (freshChar) {
                renderChatBody(freshChar);
            }
        }
        
        showToast(`${char.name} æ¢ä¸Šäº†ä½ å‘çš„å›¾ç‰‡ä½œä¸ºå¤´åƒ`);
    } catch (e) {
        console.error('[ä½¿ç”¨å›¾ç‰‡å¤´åƒ] æ‰§è¡Œå¤±è´¥:', e);
    }
}

// æ³¨å†Œå…¨å±€å‡½æ•°
window.showAvatarLibraryPage = showAvatarLibraryPage;
window.hideAvatarLibraryPage = hideAvatarLibraryPage;
window.switchAvatarTab = switchAvatarTab;
window.showAvatarImportModal = showAvatarImportModal;
window.hideAvatarImportModal = hideAvatarImportModal;
window.showAvatarUrlInput = showAvatarUrlInput;
window.handleAvatarFileImport = handleAvatarFileImport;
window.importAvatarFromUrl = importAvatarFromUrl;
window.showAvatarPreview = showAvatarPreview;
window.hideAvatarPreview = hideAvatarPreview;
window.useAvatarAsProfile = useAvatarAsProfile;
window.deleteAvatarFromLibrary = deleteAvatarFromLibrary;
window.selectAvatarSubTag = selectAvatarSubTag;
window.addSubTagDialog = addSubTagDialog;
window.showSubTagMenu = showSubTagMenu;
window.renameSubTag = renameSubTag;
window.deleteSubTag = deleteSubTag;
window.toggleCouplePairingMode = toggleCouplePairingMode;
window.selectCoupleAvatar = selectCoupleAvatar;
window.unpairCouple = unpairCouple;
window.toggleAvatarBatchDelete = toggleAvatarBatchDelete;
window.toggleBatchSelect = toggleBatchSelect;
window.batchSelectAll = batchSelectAll;
window.executeBatchDelete = executeBatchDelete;
window.executeChangeAvatar = executeChangeAvatar;
window.sendCoupleAvatarCard = sendCoupleAvatarCard;
window.acceptCoupleAvatar = acceptCoupleAvatar;
window.declineCoupleAvatar = declineCoupleAvatar;
window.executeRevertCoupleAvatar = executeRevertCoupleAvatar;
window.executeUseImageAsAvatar = executeUseImageAsAvatar;

// ============================================
// é¥¿ç¾äº†å¤–å–ç³»ç»Ÿ
// ============================================

// é¥¿ç¾äº†æ•°æ®å­˜å‚¨
let emeiData = {
    myCoupons: [], // æˆ‘çš„ä¼˜æƒ åˆ¸
    couponClaimCount: 3, // ä»Šæ—¥å‰©ä½™é¢†å–æ¬¡æ•°
    lastClaimDate: null, // ä¸Šæ¬¡é¢†å–æ—¥æœŸ
    currentStore: null, // å½“å‰é€‰ä¸­çš„åº—é“º
    cart: [], // è´­ç‰©è½¦
    selectedRecipient: 'self', // é€‰ä¸­çš„æ”¶è´§äºº
    selectedCoupon: null, // é€‰ä¸­çš„ä¼˜æƒ åˆ¸
    selectedPaymentMethod: null // é€‰ä¸­çš„æ”¯ä»˜æ–¹å¼
};

// é»˜è®¤åº—é“ºæ•°æ®ï¼ˆçœŸå®ç¾å›¢é£æ ¼ï¼‰
const defaultStores = [
    {
        id: 1,
        name: 'è‚¯å¾·åŸº',
        description: 'ç‚¸é¸¡æ±‰å ¡ | é…é€åˆ°å®¶',
        avatar: 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22%23E4002B%22 width=%22100%22 height=%22100%22 rx=%2212%22/%3E%3Ctext x=%2250%22 y=%2265%22 font-size=%2240%22 text-anchor=%22middle%22 fill=%22%23fff%22 font-weight=%22bold%22%3EKFC%3C/text%3E%3C/svg%3E',
        sales: 5234,
        menu: [
            { id: 101, name: 'é¦™è¾£é¸¡è…¿å ¡', price: 18, image: 'ğŸ”' },
            { id: 102, name: 'åŸå‘³é¸¡å—', price: 12, image: 'ğŸ—' },
            { id: 103, name: 'è–¯æ¡ï¼ˆå¤§ï¼‰', price: 13, image: 'ğŸŸ' },
            { id: 104, name: 'è›‹æŒï¼ˆ2ä¸ªï¼‰', price: 10, image: 'ğŸ¥§' },
            { id: 105, name: 'å¯ä¹ï¼ˆå¤§ï¼‰', price: 9, image: 'ğŸ¥¤' },
            { id: 106, name: 'é¸¡ç±³èŠ±', price: 11, image: 'ğŸ¿' }
        ]
    },
    {
        id: 2,
        name: 'éº¦å½“åŠ³',
        description: 'æ±‰å ¡è–¯æ¡ | 24å°æ—¶è¥ä¸š',
        avatar: 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22%23FFC72C%22 width=%22100%22 height=%22100%22 rx=%2212%22/%3E%3Ctext x=%2250%22 y=%2265%22 font-size=%2235%22 text-anchor=%22middle%22 fill=%22%23DA020E%22 font-weight=%22bold%22%3EM%3C/text%3E%3C/svg%3E',
        sales: 4892,
        menu: [
            { id: 201, name: 'å·¨æ— éœ¸', price: 25, image: 'ğŸ”' },
            { id: 202, name: 'éº¦è¾£é¸¡è…¿å ¡', price: 19, image: 'ğŸ”' },
            { id: 203, name: 'éº¦ä¹é¸¡å—ï¼ˆ10å—ï¼‰', price: 20, image: 'ğŸ—' },
            { id: 204, name: 'è–¯æ¡ï¼ˆå¤§ï¼‰', price: 13, image: 'ğŸŸ' },
            { id: 205, name: 'éº¦æ—‹é£', price: 15, image: 'ğŸ¦' },
            { id: 206, name: 'æ¿çƒ§é¸¡è…¿å ¡', price: 22, image: 'ğŸ”' }
        ]
    },
    {
        id: 3,
        name: 'èœœé›ªå†°åŸ',
        description: 'å†°æ·‡æ·‹ä¸èŒ¶ | è¶…é«˜æ€§ä»·æ¯”',
        avatar: 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22%23E60012%22 width=%22100%22 height=%22100%22 rx=%2212%22/%3E%3Ctext x=%2250%22 y=%2245%22 font-size=%2228%22 text-anchor=%22middle%22 fill=%22%23fff%22%3EğŸ¦%3C/text%3E%3Ctext x=%2250%22 y=%2278%22 font-size=%2216%22 text-anchor=%22middle%22 fill=%22%23fff%22 font-weight=%22bold%22%3Eèœœé›ª%3C/text%3E%3C/svg%3E',
        sales: 8921,
        menu: [
            { id: 301, name: 'æŸ æª¬æ°´', price: 4, image: 'ğŸ‹' },
            { id: 302, name: 'å†°é²œæŸ æª¬èŒ¶', price: 5, image: 'ğŸµ' },
            { id: 303, name: 'æ‘‡æ‘‡å¥¶æ˜”', price: 6, image: 'ğŸ¥›' },
            { id: 304, name: 'å†°æ·‡æ·‹', price: 2, image: 'ğŸ¦' },
            { id: 305, name: 'æ£’æ‰“é²œæ©™', price: 6, image: 'ğŸŠ' },
            { id: 306, name: 'æ»¡æ¯ç™¾é¦™æœ', price: 7, image: 'ğŸ¥' },
            { id: 307, name: 'çç å¥¶èŒ¶', price: 7, image: 'ğŸ§‹' }
        ]
    },
    {
        id: 4,
        name: 'ç‘å¹¸å’–å•¡',
        description: 'ç²¾å“å’–å•¡ | æ–°ç”¨æˆ·é¦–æ¯å…è´¹',
        avatar: 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22%230A3A6B%22 width=%22100%22 height=%22100%22 rx=%2212%22/%3E%3Ctext x=%2250%22 y=%2245%22 font-size=%2230%22 text-anchor=%22middle%22 fill=%22%23fff%22%3Eâ˜•%3C/text%3E%3Ctext x=%2250%22 y=%2278%22 font-size=%2214%22 text-anchor=%22middle%22 fill=%22%2300AEEF%22 font-weight=%22bold%22%3Eluckin%3C/text%3E%3C/svg%3E',
        sales: 7653,
        menu: [
            { id: 401, name: 'ç”Ÿæ¤°æ‹¿é“', price: 18, image: 'â˜•' },
            { id: 402, name: 'ç¾å¼å’–å•¡', price: 12, image: 'â˜•' },
            { id: 403, name: 'æ‹¿é“', price: 15, image: 'â˜•' },
            { id: 404, name: 'æ‘©å¡', price: 18, image: 'â˜•' },
            { id: 405, name: 'ç”Ÿé…ªæ‹¿é“', price: 20, image: 'â˜•' },
            { id: 406, name: 'æ¤°äº‘æ‹¿é“', price: 19, image: 'â˜•' },
            { id: 407, name: 'æŠ¹èŒ¶æ‹¿é“', price: 16, image: 'ğŸµ' }
        ]
    },
    {
        id: 5,
        name: 'å¿…èƒœå®¢',
        description: 'æŠ«è¨æ„é¢ | èšé¤ä¹‹é€‰',
        avatar: 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22%23D4202C%22 width=%22100%22 height=%22100%22 rx=%2212%22/%3E%3Ctext x=%2250%22 y=%2245%22 font-size=%2232%22 text-anchor=%22middle%22 fill=%22%23fff%22%3EğŸ•%3C/text%3E%3Ctext x=%2250%22 y=%2278%22 font-size=%2212%22 text-anchor=%22middle%22 fill=%22%23fff%22 font-weight=%22bold%22%3EPizza Hut%3C/text%3E%3C/svg%3E',
        sales: 3421,
        menu: [
            { id: 501, name: 'è¶…çº§è‡³å°ŠæŠ«è¨ï¼ˆ9å¯¸ï¼‰', price: 68, image: 'ğŸ•' },
            { id: 502, name: 'é“ç›˜ç‰›è‚‰æŠ«è¨ï¼ˆ9å¯¸ï¼‰', price: 58, image: 'ğŸ•' },
            { id: 503, name: 'å¥¶æ²¹è˜‘è‡æ±¤', price: 18, image: 'ğŸ²' },
            { id: 504, name: 'æ„å¼è‚‰é…±é¢', price: 32, image: 'ğŸ' },
            { id: 505, name: 'çƒ¤é¸¡ç¿…ï¼ˆ6å—ï¼‰', price: 28, image: 'ğŸ—' },
            { id: 506, name: 'èŠå£«è›‹ç³•', price: 22, image: 'ğŸ°' }
        ]
    },
    {
        id: 6,
        name: 'æµ·åº•æå¤–é€',
        description: 'ç«é”…é£Ÿæ | åœ¨å®¶åƒç«é”…',
        avatar: 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22%23C8102E%22 width=%22100%22 height=%22100%22 rx=%2212%22/%3E%3Ctext x=%2250%22 y=%2245%22 font-size=%2228%22 text-anchor=%22middle%22 fill=%22%23fff%22%3EğŸ²%3C/text%3E%3Ctext x=%2250%22 y=%2278%22 font-size=%2216%22 text-anchor=%22middle%22 fill=%22%23fff%22 font-weight=%22bold%22%3Eæµ·åº•æ%3C/text%3E%3C/svg%3E',
        sales: 2876,
        menu: [
            { id: 601, name: 'ç•ªèŒ„é”…åº•', price: 38, image: 'ğŸ…' },
            { id: 602, name: 'éº»è¾£é”…åº•', price: 42, image: 'ğŸŒ¶ï¸' },
            { id: 603, name: 'è‚¥ç‰›å·', price: 36, image: 'ğŸ¥©' },
            { id: 604, name: 'è™¾æ»‘', price: 28, image: 'ğŸ¦' },
            { id: 605, name: 'æ¯›è‚š', price: 32, image: 'ğŸ¥“' },
            { id: 606, name: 'åœŸè±†ç‰‡', price: 12, image: 'ğŸ¥”' },
            { id: 607, name: 'è±†è…', price: 10, image: 'ğŸ«˜' }
        ]
    },
    {
        id: 7,
        name: 'æ²™å¿å°åƒ',
        description: 'è’¸é¥ºæ‹Œé¢ | å®æƒ ç®¡é¥±',
        avatar: 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22%23FF6B00%22 width=%22100%22 height=%22100%22 rx=%2212%22/%3E%3Ctext x=%2250%22 y=%2245%22 font-size=%2228%22 text-anchor=%22middle%22 fill=%22%23fff%22%3EğŸ¥Ÿ%3C/text%3E%3Ctext x=%2250%22 y=%2278%22 font-size=%2216%22 text-anchor=%22middle%22 fill=%22%23fff%22 font-weight=%22bold%22%3Eæ²™å¿%3C/text%3E%3C/svg%3E',
        sales: 6543,
        menu: [
            { id: 701, name: 'è’¸é¥ºï¼ˆä¸€ç¬¼ï¼‰', price: 6, image: 'ğŸ¥Ÿ' },
            { id: 702, name: 'æ‹Œé¢', price: 7, image: 'ğŸœ' },
            { id: 703, name: 'ç‚–ç½æ±¤', price: 8, image: 'ğŸ²' },
            { id: 704, name: 'æ‰é£Ÿï¼ˆé¦„é¥¨ï¼‰', price: 7, image: 'ğŸ¥Ÿ' },
            { id: 705, name: 'å¤è›‹', price: 2, image: 'ğŸ¥š' },
            { id: 706, name: 'é’èœ', price: 5, image: 'ğŸ¥¬' },
            { id: 707, name: 'å¤é¸¡è…¿', price: 8, image: 'ğŸ—' }
        ]
    },
    {
        id: 8,
        name: 'å…°å·æ‹‰é¢',
        description: 'æ‰‹å·¥æ‹‰é¢ | æ¸…çœŸç¾é£Ÿ',
        avatar: 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22%2300875A%22 width=%22100%22 height=%22100%22 rx=%2212%22/%3E%3Ctext x=%2250%22 y=%2245%22 font-size=%2228%22 text-anchor=%22middle%22 fill=%22%23fff%22%3EğŸœ%3C/text%3E%3Ctext x=%2250%22 y=%2278%22 font-size=%2216%22 text-anchor=%22middle%22 fill=%22%23fff%22 font-weight=%22bold%22%3Eæ‹‰é¢%3C/text%3E%3C/svg%3E',
        sales: 4321,
        menu: [
            { id: 801, name: 'ç‰›è‚‰é¢', price: 15, image: 'ğŸœ' },
            { id: 802, name: 'ç‰›è‚‰æ‹Œé¢', price: 16, image: 'ğŸ' },
            { id: 803, name: 'é¸¡è›‹é¢', price: 10, image: 'ğŸœ' },
            { id: 804, name: 'ç‰›è‚‰ç›–æµ‡é¥­', price: 18, image: 'ğŸ›' },
            { id: 805, name: 'å‡‰çš®', price: 8, image: 'ğŸ¥—' },
            { id: 806, name: 'çƒ¤ç¾Šè‚‰ä¸²ï¼ˆ5ä¸²ï¼‰', price: 15, image: 'ğŸ¢' }
        ]
    },
    {
        id: 9,
        name: 'æ˜Ÿå·´å…‹',
        description: 'å’–å•¡ç”œå“ | å“è´¨ä¹‹é€‰',
        avatar: 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22%2300704A%22 width=%22100%22 height=%22100%22 rx=%2212%22/%3E%3Ctext x=%2250%22 y=%2248%22 font-size=%2230%22 text-anchor=%22middle%22 fill=%22%23fff%22%3Eâ˜•%3C/text%3E%3Ctext x=%2250%22 y=%2278%22 font-size=%2211%22 text-anchor=%22middle%22 fill=%22%23fff%22 font-weight=%22bold%22%3ESTARBUCKS%3C/text%3E%3C/svg%3E',
        sales: 5678,
        menu: [
            { id: 901, name: 'ç„¦ç³–ç›å¥‡æœµï¼ˆå¤§æ¯ï¼‰', price: 38, image: 'â˜•' },
            { id: 902, name: 'æŠ¹èŒ¶æ˜Ÿå†°ä¹ï¼ˆå¤§æ¯ï¼‰', price: 39, image: 'ğŸµ' },
            { id: 903, name: 'ç¾å¼ï¼ˆå¤§æ¯ï¼‰', price: 28, image: 'â˜•' },
            { id: 904, name: 'æ‹¿é“ï¼ˆå¤§æ¯ï¼‰', price: 33, image: 'â˜•' },
            { id: 905, name: 'è”“è¶Šè“å¸åº·', price: 18, image: 'ğŸ§' },
            { id: 906, name: 'å·§å…‹åŠ›è›‹ç³•', price: 32, image: 'ğŸ°' }
        ]
    },
    {
        id: 10,
        name: 'å–œèŒ¶',
        description: 'æ–°å¼èŒ¶é¥® | çœŸèŒ¶çœŸæœ',
        avatar: 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22%23000000%22 width=%22100%22 height=%22100%22 rx=%2212%22/%3E%3Ctext x=%2250%22 y=%2245%22 font-size=%2228%22 text-anchor=%22middle%22 fill=%22%23fff%22%3EğŸ§‹%3C/text%3E%3Ctext x=%2250%22 y=%2278%22 font-size=%2216%22 text-anchor=%22middle%22 fill=%22%23fff%22 font-weight=%22bold%22%3EHEYTEA%3C/text%3E%3C/svg%3E',
        sales: 6234,
        menu: [
            { id: 1001, name: 'å¤šè‚‰è‘¡è„', price: 25, image: 'ğŸ‡' },
            { id: 1002, name: 'èŠèŠèŠ’èŠ’', price: 28, image: 'ğŸ¥­' },
            { id: 1003, name: 'çƒ¤é»‘ç³–æ³¢æ³¢ç‰›ä¹³', price: 22, image: 'ğŸ§‹' },
            { id: 1004, name: 'çº¯ç»¿å¦èŒ¶å', price: 15, image: 'ğŸµ' },
            { id: 1005, name: 'èŠèŠè“è“', price: 26, image: 'ğŸ“' },
            { id: 1006, name: 'å¤šè‚‰èŠ’èŠ’ç”˜éœ²', price: 27, image: 'ğŸ¥­' }
        ]
    },
    {
        id: 11,
        name: 'åè±å£«',
        description: 'ç‚¸é¸¡æ±‰å ¡ | å¹³ä»·è¥¿å¼',
        avatar: 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22%23FF4500%22 width=%22100%22 height=%22100%22 rx=%2212%22/%3E%3Ctext x=%2250%22 y=%2245%22 font-size=%2228%22 text-anchor=%22middle%22 fill=%22%23fff%22%3EğŸ”%3C/text%3E%3Ctext x=%2250%22 y=%2278%22 font-size=%2214%22 text-anchor=%22middle%22 fill=%22%23fff%22 font-weight=%22bold%22%3Eåè±å£«%3C/text%3E%3C/svg%3E',
        sales: 3987,
        menu: [
            { id: 1101, name: 'é¦™è¾£é¸¡è…¿å ¡', price: 10, image: 'ğŸ”' },
            { id: 1102, name: 'åŠ²è¾£é¸¡ç¿…ï¼ˆ4ä¸ªï¼‰', price: 12, image: 'ğŸ—' },
            { id: 1103, name: 'è–¯æ¡', price: 6, image: 'ğŸŸ' },
            { id: 1104, name: 'å¯ä¹', price: 4, image: 'ğŸ¥¤' },
            { id: 1105, name: 'è›‹æŒï¼ˆ2ä¸ªï¼‰', price: 6, image: 'ğŸ¥§' },
            { id: 1106, name: 'å…¨å®¶æ¡¶', price: 39, image: 'ğŸª£' }
        ]
    },
    {
        id: 12,
        name: 'æ¨å›½ç¦éº»è¾£çƒ«',
        description: 'éº»è¾£çƒ« | æŒ‰æ–¤ç§°é‡',
        avatar: 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22%23CC0000%22 width=%22100%22 height=%22100%22 rx=%2212%22/%3E%3Ctext x=%2250%22 y=%2245%22 font-size=%2228%22 text-anchor=%22middle%22 fill=%22%23fff%22%3EğŸŒ¶ï¸%3C/text%3E%3Ctext x=%2250%22 y=%2278%22 font-size=%2214%22 text-anchor=%22middle%22 fill=%22%23fff%22 font-weight=%22bold%22%3Eæ¨å›½ç¦%3C/text%3E%3C/svg%3E',
        sales: 5123,
        menu: [
            { id: 1201, name: 'éº»è¾£çƒ«ï¼ˆå°ä»½ï¼‰', price: 18, image: 'ğŸ²' },
            { id: 1202, name: 'éº»è¾£çƒ«ï¼ˆå¤§ä»½ï¼‰', price: 28, image: 'ğŸ²' },
            { id: 1203, name: 'è‚¥ç‰›å·åŠ æ–™', price: 8, image: 'ğŸ¥©' },
            { id: 1204, name: 'é±¼ä¸¸åŠ æ–™', price: 5, image: 'ğŸŸ' },
            { id: 1205, name: 'å®½ç²‰åŠ æ–™', price: 4, image: 'ğŸœ' },
            { id: 1206, name: 'è±†çš®åŠ æ–™', price: 3, image: 'ğŸ«˜' },
            { id: 1207, name: 'ç±³é¥­', price: 2, image: 'ğŸš' }
        ]
    }
];

// ç”¨æˆ·è‡ªå®šä¹‰åº—é“ºï¼ˆä»DexieåŠ è½½ï¼‰
let customStores = [];

// è·å–æ‰€æœ‰åº—é“ºï¼ˆé»˜è®¤ + è‡ªå®šä¹‰ï¼‰
function getAllEmeiStores() {
    return [...defaultStores, ...customStores];
}

// ä»DexieåŠ è½½ç”¨æˆ·è‡ªå®šä¹‰åº—é“º
async function loadCustomStores() {
    try {
        const saved = await db.dexiData.get('emei_custom_stores');
        if (saved && saved.value) {
            customStores = JSON.parse(saved.value);
            console.log(`[é¥¿ç¾äº†] åŠ è½½äº† ${customStores.length} ä¸ªè‡ªå®šä¹‰åº—é“º`);
        }
    } catch (e) {
        console.error('[é¥¿ç¾äº†] åŠ è½½è‡ªå®šä¹‰åº—é“ºå¤±è´¥:', e);
    }
}

// ä¿å­˜è‡ªå®šä¹‰åº—é“ºåˆ°Dexie
async function saveCustomStores() {
    try {
        await db.dexiData.put({ key: 'emei_custom_stores', value: JSON.stringify(customStores) });
        console.log(`[é¥¿ç¾äº†] ä¿å­˜äº† ${customStores.length} ä¸ªè‡ªå®šä¹‰åº—é“º`);
    } catch (e) {
        console.error('[é¥¿ç¾äº†] ä¿å­˜è‡ªå®šä¹‰åº—é“ºå¤±è´¥:', e);
    }
}

// æ˜¾ç¤ºæ·»åŠ åº—é“ºå¼¹çª—
function showAddStoreModal() {
    // ç”Ÿæˆå”¯ä¸€ID
    const newId = Date.now();
    
    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay';
    overlay.id = 'add-store-modal';
    overlay.style.display = 'flex';
    overlay.innerHTML = `
        <div class="modal-box" style="max-height: 85vh; overflow-y: auto; max-width: 380px;">
            <div style="font-size: 17px; font-weight: 600; text-align: center; margin-bottom: 20px;">æ·»åŠ è‡ªå®šä¹‰åº—é“º</div>
            
            <div style="margin-bottom: 14px;">
                <div style="font-size: 12px; color: #999; margin-bottom: 6px;">åº—é“ºåç§° *</div>
                <input type="text" id="add-store-name" placeholder="å¦‚ï¼šå°æ˜ç‚’é¥­" style="width: 100%; padding: 10px 14px; border: 1px solid #e5e5e5; border-radius: 10px; font-size: 14px; outline: none; box-sizing: border-box;">
            </div>
            
            <div style="margin-bottom: 14px;">
                <div style="font-size: 12px; color: #999; margin-bottom: 6px;">åº—é“ºæè¿°</div>
                <input type="text" id="add-store-desc" placeholder="å¦‚ï¼šå®¶å¸¸ç‚’èœ | å¥½åƒä¸è´µ" style="width: 100%; padding: 10px 14px; border: 1px solid #e5e5e5; border-radius: 10px; font-size: 14px; outline: none; box-sizing: border-box;">
            </div>
            
            <div style="margin-bottom: 14px;">
                <div style="font-size: 12px; color: #999; margin-bottom: 6px;">åº—é“ºå›¾æ ‡ (emoji)</div>
                <input type="text" id="add-store-emoji" placeholder="å¦‚ï¼šğŸ³" value="ğŸ½ï¸" style="width: 100%; padding: 10px 14px; border: 1px solid #e5e5e5; border-radius: 10px; font-size: 14px; outline: none; box-sizing: border-box;">
            </div>
            
            <div style="margin-bottom: 14px;">
                <div style="font-size: 12px; color: #999; margin-bottom: 6px;">ä¸»é¢˜è‰²</div>
                <input type="color" id="add-store-color" value="#FF6B9D" style="width: 100%; height: 40px; border: 1px solid #e5e5e5; border-radius: 10px; cursor: pointer; padding: 2px;">
            </div>
            
            <div style="margin-bottom: 14px;">
                <div style="font-size: 12px; color: #999; margin-bottom: 8px;">èœå•é¡¹ï¼ˆæ¯è¡Œä¸€ä¸ªï¼Œæ ¼å¼ï¼šèœå ä»·æ ¼ emojiï¼‰</div>
                <textarea id="add-store-menu" placeholder="å¦‚ï¼š&#10;è›‹ç‚’é¥­ 12 ğŸ³&#10;ç•ªèŒ„è›‹æ±¤ 8 ğŸ…&#10;çº¢çƒ§è‚‰ 22 ğŸ¥©&#10;å¯ä¹ 5 ğŸ¥¤" style="width: 100%; min-height: 140px; padding: 10px 14px; border: 1px solid #e5e5e5; border-radius: 10px; font-size: 13px; outline: none; resize: vertical; box-sizing: border-box; line-height: 1.8;"></textarea>
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 16px;">
                <button onclick="closeAddStoreModal()" style="flex: 1; padding: 12px; background: #f5f5f5; border: none; border-radius: 10px; font-size: 14px; color: #666; cursor: pointer;">å–æ¶ˆ</button>
                <button onclick="confirmAddStore()" style="flex: 1; padding: 12px; background: linear-gradient(135deg, #ff6b9d 0%, #ff8fab 100%); border: none; border-radius: 10px; font-size: 14px; color: #fff; font-weight: 600; cursor: pointer; box-shadow: 0 4px 12px rgba(255,107,157,0.3);">æ·»åŠ </button>
            </div>
        </div>
    `;
    document.body.appendChild(overlay);
}

// å…³é—­æ·»åŠ åº—é“ºå¼¹çª—
function closeAddStoreModal() {
    const modal = document.getElementById('add-store-modal');
    if (modal) modal.remove();
}

// ç¡®è®¤æ·»åŠ åº—é“º
async function confirmAddStore() {
    const name = document.getElementById('add-store-name')?.value?.trim();
    const desc = document.getElementById('add-store-desc')?.value?.trim() || 'è‡ªå®šä¹‰åº—é“º';
    const emoji = document.getElementById('add-store-emoji')?.value?.trim() || 'ğŸ½ï¸';
    const color = document.getElementById('add-store-color')?.value || '#FF6B9D';
    const menuText = document.getElementById('add-store-menu')?.value?.trim() || '';
    
    if (!name) {
        showToast('âŒ è¯·è¾“å…¥åº—é“ºåç§°');
        return;
    }
    
    // è§£æèœå•
    const menuItems = [];
    const baseId = Date.now();
    if (menuText) {
        const lines = menuText.split('\n').filter(l => l.trim());
        lines.forEach((line, idx) => {
            const parts = line.trim().split(/\s+/);
            if (parts.length >= 2) {
                const itemName = parts[0];
                const price = parseFloat(parts[1]) || 10;
                const itemEmoji = parts[2] || 'ğŸ½ï¸';
                menuItems.push({ id: baseId + idx, name: itemName, price: price, image: itemEmoji });
            } else if (parts.length === 1) {
                menuItems.push({ id: baseId + idx, name: parts[0], price: 10, image: 'ğŸ½ï¸' });
            }
        });
    }
    
    if (menuItems.length === 0) {
        // æ²¡æœ‰èœå•å°±ç»™ä¸€ä¸ªé»˜è®¤é¡¹
        menuItems.push({ id: baseId, name: 'æ‹›ç‰Œèœ', price: 15, image: emoji });
    }
    
    // å°†é¢œè‰²è½¬ä¸ºhexç¼–ç ç”¨äºSVG
    const colorEncoded = encodeURIComponent(color);
    const nameShort = name.length > 3 ? name.substring(0, 3) : name;
    const nameEncoded = encodeURIComponent(nameShort);
    const emojiEncoded = encodeURIComponent(emoji);
    
    const newStore = {
        id: baseId,
        name: name,
        description: desc,
        avatar: `data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22${colorEncoded}%22 width=%22100%22 height=%22100%22 rx=%2212%22/%3E%3Ctext x=%2250%22 y=%2245%22 font-size=%2228%22 text-anchor=%22middle%22 fill=%22%23fff%22%3E${emojiEncoded}%3C/text%3E%3Ctext x=%2250%22 y=%2278%22 font-size=%2214%22 text-anchor=%22middle%22 fill=%22%23fff%22 font-weight=%22bold%22%3E${nameEncoded}%3C/text%3E%3C/svg%3E`,
        sales: Math.floor(Math.random() * 3000) + 500,
        menu: menuItems,
        isCustom: true // æ ‡è®°ä¸ºç”¨æˆ·è‡ªå®šä¹‰
    };
    
    customStores.push(newStore);
    await saveCustomStores();
    
    closeAddStoreModal();
    renderStoreList();
    showToast('âœ… åº—é“ºæ·»åŠ æˆåŠŸ');
}

// åˆ é™¤è‡ªå®šä¹‰åº—é“º
async function deleteCustomStore(storeId) {
    if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªåº—é“ºå—ï¼Ÿ')) return;
    
    customStores = customStores.filter(s => s.id !== storeId);
    await saveCustomStores();
    renderStoreList();
    showToast('âœ… åº—é“ºå·²åˆ é™¤');
}

// ç¼–è¾‘è‡ªå®šä¹‰åº—é“ºèœå•ï¼ˆæ·»åŠ èœå“ï¼‰
function showAddMenuItemModal(storeId) {
    const store = customStores.find(s => s.id === storeId);
    if (!store) return;
    
    const itemName = prompt('èœå“åç§°ï¼š');
    if (!itemName) return;
    
    const itemPrice = parseFloat(prompt('ä»·æ ¼ï¼ˆå…ƒï¼‰ï¼š') || '10');
    const itemEmoji = prompt('å›¾æ ‡emojiï¼ˆå¯é€‰ï¼‰ï¼š') || 'ğŸ½ï¸';
    
    store.menu.push({
        id: Date.now(),
        name: itemName,
        price: itemPrice,
        image: itemEmoji
    });
    
    saveCustomStores();
    
    // å¦‚æœå½“å‰æ­£åœ¨æŸ¥çœ‹è¿™ä¸ªåº—é“ºï¼Œåˆ·æ–°èœå•
    if (emeiData.currentStore && emeiData.currentStore.id === storeId) {
        emeiData.currentStore = store;
        renderEmeiMenu();
    }
    
    showToast('âœ… èœå“å·²æ·»åŠ ');
}

// åˆ é™¤è‡ªå®šä¹‰åº—é“ºçš„èœå“
async function deleteCustomMenuItem(storeId, itemId) {
    const store = customStores.find(s => s.id === storeId);
    if (!store) return;
    
    store.menu = store.menu.filter(m => m.id !== itemId);
    await saveCustomStores();
    
    // å¦‚æœå½“å‰æ­£åœ¨æŸ¥çœ‹è¿™ä¸ªåº—é“ºï¼Œåˆ·æ–°èœå•
    if (emeiData.currentStore && emeiData.currentStore.id === storeId) {
        emeiData.currentStore = store;
        renderEmeiMenu();
    }
    showToast('âœ… èœå“å·²åˆ é™¤');
}

// æ˜¾ç¤ºé¥¿ç¾äº†é¡µé¢
async function showEmeiPage() {
    const page = document.getElementById('emei-page');
    
    if (page) {
        page.style.display = 'flex';
        page.offsetHeight;
        page.classList.add('active');
        
        // åŠ è½½è‡ªå®šä¹‰åº—é“º
        await loadCustomStores();
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡ç½®æ¯æ—¥é¢†å–æ¬¡æ•°
        resetDailyCouponCount();
        
        // æ¸²æŸ“é¡µé¢
        renderEmeiMain();
    }
}

// éšè—é¥¿ç¾äº†é¡µé¢
function hideEmeiPage() {
    const page = document.getElementById('emei-page');
    
    if (page) {
        page.classList.remove('active');
        setTimeout(() => {
            page.style.display = 'none';
        }, 350);
    }
    
    // è¿”å›ä¸»è§†å›¾
    const mainView = document.getElementById('emei-main-view');
    const storeView = document.getElementById('emei-store-detail-view');
    const checkoutView = document.getElementById('emei-checkout-view');
    
    if (mainView) mainView.style.display = 'block';
    if (storeView) storeView.style.display = 'none';
    if (checkoutView) checkoutView.style.display = 'none';
}

// é‡ç½®æ¯æ—¥ä¼˜æƒ åˆ¸é¢†å–æ¬¡æ•°
function resetDailyCouponCount() {
    const today = new Date().toDateString();
    if (emeiData.lastClaimDate !== today) {
        emeiData.couponClaimCount = 3;
        emeiData.lastClaimDate = today;
    }
    
    // æ›´æ–°æ˜¾ç¤º
    const countEl = document.getElementById('emei-coupon-count');
    if (countEl) countEl.innerText = emeiData.couponClaimCount;
}

// æ¸²æŸ“ä¸»é¡µ
function renderEmeiMain() {
    // æ›´æ–°ä¼˜æƒ åˆ¸é¢†å–æ¬¡æ•°
    resetDailyCouponCount();
    
    // æ¸²æŸ“å·²é¢†å–çš„ä¼˜æƒ åˆ¸
    renderMyCoupons();
    
    // æ¸²æŸ“åº—é“ºåˆ—è¡¨
    renderStoreList();
}

// æ¸²æŸ“å·²é¢†å–çš„ä¼˜æƒ åˆ¸
function renderMyCoupons() {
    const container = document.getElementById('emei-my-coupons');
    if (!container) return;
    
    if (emeiData.myCoupons.length === 0) {
        container.style.display = 'none';
        return;
    }
    
    container.style.display = 'block';
    container.innerHTML = `
        <div style="font-size: 12px; color: #666; margin-bottom: 8px;">æˆ‘çš„ä¼˜æƒ åˆ¸</div>
        <div style="display: flex; gap: 8px; overflow-x: auto;">
            ${emeiData.myCoupons.map(coupon => `
                <div style="flex-shrink: 0; padding: 8px 16px; background: linear-gradient(135deg, #fff 0%, #fff9fa 100%); border: 1px solid rgba(255,107,157,0.2); border-radius: 8px; display: flex; flex-direction: column; align-items: center;">
                    <div style="font-size: 16px; font-weight: 600; color: var(--ins-pink);">${coupon.threshold}å‡${coupon.amount}</div>
                    <div style="font-size: 10px; color: #999; margin-top: 2px;">æ»¡${coupon.threshold}å¯ç”¨</div>
                </div>
            `).join('')}
        </div>
    `;
}

// é¢†å–ä¼˜æƒ åˆ¸
function claimEmeiCoupon() {
    if (emeiData.couponClaimCount <= 0) {
        alert('ä»Šæ—¥é¢†å–æ¬¡æ•°å·²ç”¨å®Œï¼Œæ˜å¤©å†æ¥å§ï¼');
        return;
    }
    
    // éšæœºç”Ÿæˆä¼˜æƒ åˆ¸
    const random = Math.random();
    let coupon;
    
    if (random < 0.7) {
        // 70%æ¦‚ç‡ï¼šå°é¢ä¼˜æƒ åˆ¸ (20-5)
        coupon = { threshold: 20, amount: 5, type: 'discount', expireDate: getExpireDate(7) };
    } else if (random < 0.9) {
        // 20%æ¦‚ç‡ï¼šä¸­é¢ä¼˜æƒ åˆ¸ (30-15)
        coupon = { threshold: 30, amount: 15, type: 'discount', expireDate: getExpireDate(7) };
    } else {
        // 10%æ¦‚ç‡ï¼šå¤§é¢ä¼˜æƒ åˆ¸ (20-15)
        coupon = { threshold: 20, amount: 15, type: 'discount', expireDate: getExpireDate(7) };
    }
    
    emeiData.myCoupons.push(coupon);
    emeiData.couponClaimCount--;
    
    // æ›´æ–°æ˜¾ç¤º
    document.getElementById('emei-coupon-count').innerText = emeiData.couponClaimCount;
    renderMyCoupons();
    
    // æç¤º
    alert(`ğŸ‰ æ­å–œé¢†å– ${coupon.threshold}å‡${coupon.amount} ä¼˜æƒ åˆ¸ï¼`);
}

// è·å–è¿‡æœŸæ—¥æœŸ
function getExpireDate(days) {
    const date = new Date();
    date.setDate(date.getDate() + days);
    return date.toLocaleDateString();
}

// æ¸²æŸ“åº—é“ºåˆ—è¡¨
function renderStoreList() {
    const container = document.getElementById('emei-store-list');
    if (!container) return;
    
    const allStores = getAllEmeiStores();
    
    container.innerHTML = allStores.map(store => {
        const rating = store.isCustom ? (4 + Math.random() * 0.9).toFixed(1) : '4.8';
        const deleteBtn = store.isCustom ? `<div onclick="event.stopPropagation(); deleteCustomStore(${store.id})" style="position: absolute; top: 8px; right: 8px; width: 24px; height: 24px; background: rgba(0,0,0,0.04); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 14px; color: #ccc; cursor: pointer;" onmouseover="this.style.color='#ff6b6b'; this.style.background='rgba(255,0,0,0.06)'" onmouseout="this.style.color='#ccc'; this.style.background='rgba(0,0,0,0.04)'">âœ•</div>` : '';
        const customTag = store.isCustom ? `<span style="font-size: 10px; padding: 2px 6px; background: #fff0f5; color: var(--ins-pink); border-radius: 4px; margin-left: 6px;">è‡ªå®šä¹‰</span>` : '';
        
        return `
        <div onclick="openEmeiStore(${store.id})" style="position: relative; background: #fff; border-radius: 16px; padding: 16px; margin-bottom: 12px; box-shadow: 0 2px 12px rgba(0,0,0,0.04); cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 16px rgba(0,0,0,0.08)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 12px rgba(0,0,0,0.04)'">
            ${deleteBtn}
            <div style="display: flex; gap: 12px;">
                <div style="width: 80px; height: 80px; border-radius: 12px; background-image: url(${store.avatar}); background-size: cover; background-color: #f5f5f5; flex-shrink: 0;"></div>
                <div style="flex: 1;">
                    <div style="font-size: 16px; font-weight: 600; color: #333; margin-bottom: 4px;">${store.name}${customTag}</div>
                    <div style="font-size: 12px; color: #999; margin-bottom: 8px;">${store.description}</div>
                    <div style="display: flex; gap: 12px; font-size: 11px; color: #666;">
                        <span>â­ ${rating}</span>
                        <span>æœˆå”® ${store.sales}+</span>
                    </div>
                </div>
            </div>
        </div>`;
    }).join('') + `
    <div onclick="showAddStoreModal()" style="background: #fafafa; border: 2px dashed #e0e0e0; border-radius: 16px; padding: 24px; margin-bottom: 12px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px; transition: all 0.2s;" onmouseover="this.style.borderColor='var(--ins-pink)'; this.style.background='#fff5f7'" onmouseout="this.style.borderColor='#e0e0e0'; this.style.background='#fafafa'">
        <svg width="20" height="20" fill="none" stroke="var(--ins-pink)" stroke-width="2" viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
        <span style="font-size: 14px; color: #999; font-weight: 500;">æ·»åŠ è‡ªå®šä¹‰åº—é“º</span>
    </div>`;
}


// æ‰“å¼€åº—é“ºè¯¦æƒ…
async function openEmeiStore(storeId) {
    const store = getAllEmeiStores().find(s => s.id === storeId);
    if (!store) return;
    
    emeiData.currentStore = store;
    emeiData.cart = [];
    
    // åˆ‡æ¢è§†å›¾
    document.getElementById('emei-main-view').style.display = 'none';
    document.getElementById('emei-store-detail-view').style.display = 'flex';
    
    // æ¸²æŸ“åº—é“ºä¿¡æ¯
    document.getElementById('emei-store-name').innerText = store.name;
    document.getElementById('emei-store-title').innerText = store.name;
    document.getElementById('emei-store-desc').innerText = store.description;
    document.getElementById('emei-store-sales').innerText = store.sales + '+';
    document.getElementById('emei-store-avatar').style.backgroundImage = `url(${store.avatar})`;
    
    // æ¸²æŸ“èœå•
    renderEmeiMenu();
    
    // æ¸²æŸ“æ”¶è´§äººé€‰é¡¹
    await renderRecipientOptions();
    
    // æ›´æ–°è´­ç‰©è½¦
    updateEmeiCart();
}

// è¿”å›ä¸»é¡µ
function backToEmeiMain() {
    const mainView = document.getElementById('emei-main-view');
    const storeView = document.getElementById('emei-store-detail-view');
    const checkoutView = document.getElementById('emei-checkout-view');
    
    if (mainView) mainView.style.display = 'block';
    if (storeView) storeView.style.display = 'none';
    if (checkoutView) checkoutView.style.display = 'none';
    emeiData.cart = [];
}

// æ¸²æŸ“èœå•
function renderEmeiMenu() {
    const container = document.getElementById('emei-menu-list');
    if (!container || !emeiData.currentStore) return;
    
    const store = emeiData.currentStore;
    const isCustom = store.isCustom;
    
    container.innerHTML = store.menu.map(item => `
        <div style="display: flex; align-items: center; justify-content: space-between; padding: 16px; background: #fff; border-radius: 12px; margin-bottom: 12px; box-shadow: 0 1px 4px rgba(0,0,0,0.04);">
            <div style="display: flex; align-items: center; gap: 12px; flex: 1;">
                <div style="width: 60px; height: 60px; background: linear-gradient(135deg, #fff5f7 0%, #ffeef2 100%); border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 32px;">${item.image}</div>
                <div style="flex: 1;">
                    <div style="font-size: 14px; font-weight: 500; color: #333; margin-bottom: 4px;">${item.name}${isCustom ? `<span onclick="event.stopPropagation(); deleteCustomMenuItem(${store.id}, ${item.id})" style="margin-left: 6px; font-size: 11px; color: #ccc; cursor: pointer;" title="åˆ é™¤èœå“">âœ•</span>` : ''}</div>
                    <div style="font-size: 16px; font-weight: 600; color: var(--ins-pink);">Â¥${item.price}</div>
                </div>
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
                <div onclick="decreaseEmeiItem(${item.id})" style="width: 28px; height: 28px; border: 1px solid #e5e5e5; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 18px; color: #666;">-</div>
                <div id="emei-item-count-${item.id}" style="min-width: 20px; text-align: center; font-size: 14px; font-weight: 500;">0</div>
                <div onclick="increaseEmeiItem(${item.id})" style="width: 28px; height: 28px; background: var(--ins-pink); border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 18px; color: #fff;">+</div>
            </div>
        </div>
    `).join('') + (isCustom ? `
    <div onclick="showAddMenuItemModal(${store.id})" style="background: #fafafa; border: 2px dashed #e0e0e0; border-radius: 12px; padding: 16px; margin-bottom: 12px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 6px; transition: all 0.2s;" onmouseover="this.style.borderColor='var(--ins-pink)'; this.style.background='#fff5f7'" onmouseout="this.style.borderColor='#e0e0e0'; this.style.background='#fafafa'">
        <svg width="16" height="16" fill="none" stroke="var(--ins-pink)" stroke-width="2" viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
        <span style="font-size: 13px; color: #999;">æ·»åŠ èœå“</span>
    </div>` : '');
}

// æ¸²æŸ“æ”¶è´§äººé€‰é¡¹
async function renderRecipientOptions() {
    const select = document.getElementById('emei-recipient-select');
    if (!select) {
        console.warn('emei-recipient-select å…ƒç´ ä¸å­˜åœ¨');
        return;
    }
    
    try {
        // è·å–æ‰€æœ‰è§’è‰²
        const characters = await db.characters.toArray();
        console.log('æ•°æ®åº“ä¸­æ‰€æœ‰è§’è‰²:', characters.length);
        
        // è¿‡æ»¤æ‰ç³»ç»Ÿè§’è‰²å’Œåœ¨çº¿å¥½å‹ï¼Œåªæ˜¾ç¤ºå¯ä»¥é…é€çš„è§’è‰²
        const availableChars = characters.filter(c => {
            // æ’é™¤ç³»ç»Ÿè§’è‰²ã€åœ¨çº¿å¥½å‹ç­‰
            if (c.type === 'system' || c.type === 'online_friend') return false;
            // åªæ˜¾ç¤ºæœ‰åå­—çš„è§’è‰²
            if (!c.name || c.name.trim() === '') return false;
            return true;
        });
        
        console.log('å¯ç”¨è§’è‰²:', availableChars.length, availableChars.map(c => c.name));
        
        let html = '<option value="self">æˆ‘è‡ªå·±</option>';
        availableChars.forEach(char => {
            const safeName = (char.name || '').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
            html += `<option value="${char.id}">${safeName}</option>`;
        });
        
        select.innerHTML = html;
        select.value = emeiData.selectedRecipient;
        
        console.log('å·²åŠ è½½', availableChars.length, 'ä¸ªè§’è‰²åˆ°é…é€åˆ—è¡¨');
    } catch (err) {
        console.error('åŠ è½½è§’è‰²åˆ—è¡¨å¤±è´¥:', err);
        select.innerHTML = '<option value="self">æˆ‘è‡ªå·±</option>';
    }
}

// å¢åŠ å•†å“æ•°é‡
function increaseEmeiItem(itemId) {
    if (!emeiData.currentStore) return;
    
    const item = emeiData.currentStore.menu.find(m => m.id === itemId);
    if (!item) return;
    
    const cartItem = emeiData.cart.find(c => c.id === itemId);
    if (cartItem) {
        cartItem.count++;
    } else {
        emeiData.cart.push({ ...item, count: 1 });
    }
    
    updateEmeiCart();
}

// å‡å°‘å•†å“æ•°é‡
function decreaseEmeiItem(itemId) {
    const cartItem = emeiData.cart.find(c => c.id === itemId);
    if (!cartItem) return;
    
    cartItem.count--;
    if (cartItem.count <= 0) {
        emeiData.cart = emeiData.cart.filter(c => c.id !== itemId);
    }
    
    updateEmeiCart();
}

// æ›´æ–°è´­ç‰©è½¦æ˜¾ç¤º
function updateEmeiCart() {
    // æ›´æ–°æ•°é‡æ˜¾ç¤º
    if (emeiData.currentStore) {
        emeiData.currentStore.menu.forEach(item => {
            const countEl = document.getElementById(`emei-item-count-${item.id}`);
            if (countEl) {
                const cartItem = emeiData.cart.find(c => c.id === item.id);
                countEl.innerText = cartItem ? cartItem.count : 0;
            }
        });
    }
    
    // æ›´æ–°æ€»ä»·
    const total = emeiData.cart.reduce((sum, item) => sum + item.price * item.count, 0);
    const totalEl = document.getElementById('emei-total-price');
    if (totalEl) totalEl.innerText = total.toFixed(2);
}

// æ›´æ–°æ”¶è´§äºº
function updateEmeiRecipient(value) {
    emeiData.selectedRecipient = value;
}


// æ˜¾ç¤ºç»“ç®—é¡µé¢
async function showEmeiCheckout() {
    if (emeiData.cart.length === 0) {
        alert('è´­ç‰©è½¦æ˜¯ç©ºçš„ï¼Œå¿«å»é€‰ç‚¹åƒçš„å§ï¼');
        return;
    }
    
    const recipientSelect = document.getElementById('emei-recipient-select');
    emeiData.selectedRecipient = recipientSelect ? recipientSelect.value : 'self';
    
    // åˆ‡æ¢è§†å›¾
    document.getElementById('emei-store-detail-view').style.display = 'none';
    document.getElementById('emei-checkout-view').style.display = 'flex';
    
    // æ¸²æŸ“æ”¶è´§äººä¿¡æ¯
    await renderCheckoutRecipient();
    
    // æ¸²æŸ“è®¢å•è¯¦æƒ…
    renderCheckoutItems();
    
    // è®¡ç®—ä»·æ ¼
    calculateCheckoutPrice();
    
    // åŠ è½½é’±åŒ…ä½™é¢
    await loadEmeiWalletBalance();
}

// è¿”å›åº—é“ºé¡µé¢
function backToEmeiStore() {
    const storeView = document.getElementById('emei-store-detail-view');
    const checkoutView = document.getElementById('emei-checkout-view');
    
    if (storeView) storeView.style.display = 'flex';
    if (checkoutView) checkoutView.style.display = 'none';
}

// æ¸²æŸ“æ”¶è´§äººä¿¡æ¯
async function renderCheckoutRecipient() {
    const avatar = document.getElementById('emei-recipient-avatar');
    const name = document.getElementById('emei-recipient-name');
    
    if (emeiData.selectedRecipient === 'self') {
        name.innerText = 'æˆ‘è‡ªå·±';
        avatar.style.backgroundImage = 'url(https://api.dicebear.com/7.x/avataaars/svg?seed=self)';
    } else {
        const char = await db.characters.get(parseInt(emeiData.selectedRecipient));
        if (char) {
            name.innerText = char.name;
            avatar.style.backgroundImage = `url(${char.avatar})`;
            avatar.style.backgroundSize = 'cover';
        }
    }
}

// æ¸²æŸ“è®¢å•è¯¦æƒ…
function renderCheckoutItems() {
    const container = document.getElementById('emei-checkout-items');
    if (!container) return;
    
    container.innerHTML = emeiData.cart.map(item => `
        <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #f5f5f5;">
            <div style="flex: 1;">
                <span style="font-size: 14px; color: #333;">${item.name}</span>
                <span style="font-size: 12px; color: #999; margin-left: 8px;">x${item.count}</span>
            </div>
            <div style="font-size: 14px; color: #333;">Â¥${(item.price * item.count).toFixed(2)}</div>
        </div>
    `).join('');
}

// è®¡ç®—ä»·æ ¼
function calculateCheckoutPrice() {
    const subtotal = emeiData.cart.reduce((sum, item) => sum + item.price * item.count, 0);
    const delivery = 3;
    let discount = 0;
    
    // è®¡ç®—ä¼˜æƒ åˆ¸æŠ˜æ‰£
    if (emeiData.selectedCoupon) {
        if (subtotal >= emeiData.selectedCoupon.threshold) {
            discount = emeiData.selectedCoupon.amount;
        } else {
            emeiData.selectedCoupon = null;
            document.getElementById('emei-selected-coupon-text').innerText = 'æœªä½¿ç”¨';
        }
    }
    
    const total = Math.max(subtotal + delivery - discount, 0.01);
    
    // æ›´æ–°æ˜¾ç¤º
    document.getElementById('emei-checkout-subtotal').innerText = subtotal.toFixed(2);
    document.getElementById('emei-checkout-delivery').innerText = delivery.toFixed(2);
    document.getElementById('emei-checkout-total').innerText = total.toFixed(2);
    
    if (discount > 0) {
        document.getElementById('emei-checkout-discount').innerText = discount.toFixed(2);
        document.getElementById('emei-checkout-discount-row').style.display = 'flex';
    } else {
        document.getElementById('emei-checkout-discount-row').style.display = 'none';
    }
}

// é€‰æ‹©ä¼˜æƒ åˆ¸
function selectEmeiCoupon() {
    const modal = document.getElementById('emei-coupon-modal');
    const list = document.getElementById('emei-coupon-list');
    
    if (!modal || !list) return;
    
    const subtotal = emeiData.cart.reduce((sum, item) => sum + item.price * item.count, 0);
    
    if (emeiData.myCoupons.length === 0) {
        alert('æš‚æ— å¯ç”¨ä¼˜æƒ åˆ¸');
        return;
    }
    
    list.innerHTML = emeiData.myCoupons.map((coupon, index) => {
        const canUse = subtotal >= coupon.threshold;
        return `
            <div onclick="${canUse ? `useEmeiCoupon(${index})` : ''}" style="padding: 16px; background: ${canUse ? '#fff' : '#f5f5f5'}; border: 2px solid ${emeiData.selectedCoupon === coupon ? 'var(--ins-pink)' : '#e5e5e5'}; border-radius: 12px; margin-bottom: 12px; cursor: ${canUse ? 'pointer' : 'not-allowed'}; opacity: ${canUse ? '1' : '0.5'};">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div style="font-size: 18px; font-weight: 600; color: var(--ins-pink);">${coupon.threshold}å‡${coupon.amount}</div>
                        <div style="font-size: 12px; color: #999; margin-top: 4px;">æ»¡${coupon.threshold}å¯ç”¨ | æœ‰æ•ˆæœŸè‡³${coupon.expireDate}</div>
                    </div>
                    ${canUse ? `<svg width="20" height="20" fill="${emeiData.selectedCoupon === coupon ? 'var(--ins-pink)' : '#ccc'}" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/></svg>` : '<span style="font-size: 11px; color: #999;">ä¸å¯ç”¨</span>'}
                </div>
            </div>
        `;
    }).join('');
    
    modal.style.display = 'flex';
}

// ä½¿ç”¨ä¼˜æƒ åˆ¸
function useEmeiCoupon(index) {
    emeiData.selectedCoupon = emeiData.myCoupons[index];
    document.getElementById('emei-selected-coupon-text').innerText = `${emeiData.selectedCoupon.threshold}å‡${emeiData.selectedCoupon.amount}`;
    closeEmeiCouponModal();
    calculateCheckoutPrice();
}

// å…³é—­ä¼˜æƒ åˆ¸å¼¹çª—
function closeEmeiCouponModal() {
    const modal = document.getElementById('emei-coupon-modal');
    if (modal) modal.style.display = 'none';
}

// åŠ è½½é’±åŒ…ä½™é¢
async function loadEmeiWalletBalance() {
    const accountId = getCurrentAccountId();
    let balance = 0;
    
    try {
        // ğŸ”§ ä»å½“å‰ç™»å½•è§’è‰²çš„ identity.balance è·å–ä½™é¢
        if (accountId) {
            const myChar = await db.characters.get(parseInt(accountId));
            if (myChar && myChar.identity) {
                balance = parseFloat(myChar.identity.balance || 0);
            }
        }
    } catch (err) {
        console.error('åŠ è½½é’±åŒ…ä½™é¢å¤±è´¥:', err);
    }
    
    const balanceEl = document.getElementById('emei-wallet-balance');
    if (balanceEl) balanceEl.innerText = balance.toFixed(2);
    
    // åŠ è½½äº²å±å¡ä¿¡æ¯
    await loadFamilyCardInfo();
}

// åŠ è½½äº²å±å¡ä¿¡æ¯
async function loadFamilyCardInfo() {
    const info = document.getElementById('emei-family-card-info');
    if (!info) return;
    
    try {
        // ğŸ”§ ä½¿ç”¨å½“å‰è´¦å·è§’è‰²æ”¶åˆ°çš„äº²å±å¡
        const myCharId = parseInt(currentMyCharId);
        const myChar = myCharId ? await db.characters.get(myCharId) : null;
        const cards = myChar?.identity?.familyCardsReceived || [];
        
        if (cards.length > 0) {
            const card = cards[0];
            info.innerText = `æ¥è‡ª ${card.fromName}`;
        } else {
            info.innerText = 'æœªç»‘å®š';
        }
    } catch (err) {
        info.innerText = 'æœªç»‘å®š';
    }
}


// æ˜¾ç¤ºæ”¯ä»˜æ–¹å¼å¼¹çª—
async function showEmeiPaymentModal() {
    const modal = document.getElementById('emei-payment-modal');
    if (modal) {
        modal.style.display = 'flex';
        emeiData.selectedPaymentMethod = null;
        
        // æ¸…é™¤æ‰€æœ‰é€‰ä¸­çŠ¶æ€
        document.querySelectorAll('.emei-payment-option').forEach(opt => {
            opt.style.borderColor = '#f0f0f0';
        });
        document.querySelectorAll('input[name="emei-payment"]').forEach(input => {
            input.checked = false;
        });
        
        // ğŸ”§ è·å–å½“å‰è´¦å·çš„ä½™é¢ï¼ˆä»è§’è‰²çš„identity.balanceè·å–ï¼‰
        const accountId = getCurrentAccountId();
        let balance = 0;
        if (accountId) {
            const myChar = await db.characters.get(parseInt(accountId));
            if (myChar && myChar.identity) {
                balance = parseFloat(myChar.identity.balance || 0);
            }
        }
        const balanceEl = document.getElementById('emei-wallet-balance');
        if (balanceEl) balanceEl.textContent = balance.toFixed(2);
        
        // ğŸ”§ è·å–å½“å‰è´¦å·çš„äº²å±å¡
        const myCharId = parseInt(currentMyCharId);
        const myChar = myCharId ? await db.characters.get(myCharId) : null;
        const familyCards = myChar?.identity?.familyCardsReceived || [];
        const familyCardEl = document.getElementById('emei-family-card-info');
        if (familyCardEl) {
            if (familyCards.length > 0) {
                const card = familyCards[0]; // ä½¿ç”¨ç¬¬ä¸€å¼ äº²å±å¡
                familyCardEl.textContent = `æ¥è‡ª ${card.fromName}`;
            } else {
                familyCardEl.textContent = 'æœªç»‘å®š';
            }
        }
    }
}

// å…³é—­æ”¯ä»˜æ–¹å¼å¼¹çª—
function closeEmeiPaymentModal() {
    const modal = document.getElementById('emei-payment-modal');
    if (modal) modal.style.display = 'none';
}

// é€‰æ‹©æ”¯ä»˜æ–¹å¼
function selectEmeiPaymentMethod(method) {
    emeiData.selectedPaymentMethod = method;
    
    // æ›´æ–°é€‰ä¸­çŠ¶æ€
    document.querySelectorAll('.emei-payment-option').forEach(opt => {
        opt.style.borderColor = '#f0f0f0';
    });
    document.querySelectorAll('input[name="emei-payment"]').forEach(input => {
        input.checked = input.value === method;
        if (input.checked) {
            input.closest('.emei-payment-option').style.borderColor = 'var(--ins-pink)';
        }
    });
}

// ç¡®è®¤æ”¯ä»˜
async function confirmEmeiPayment() {
    if (!emeiData.selectedPaymentMethod) {
        alert('è¯·é€‰æ‹©æ”¯ä»˜æ–¹å¼');
        return;
    }
    
    const subtotal = emeiData.cart.reduce((sum, item) => sum + item.price * item.count, 0);
    const delivery = 3;
    const discount = emeiData.selectedCoupon ? emeiData.selectedCoupon.amount : 0;
    const total = subtotal + delivery - discount;
    
    closeEmeiPaymentModal();
    
    // æ ¹æ®ä¸åŒæ”¯ä»˜æ–¹å¼å¤„ç†
    if (emeiData.selectedPaymentMethod === 'wallet') {
        await payWithWallet(total);
    } else if (emeiData.selectedPaymentMethod === 'family') {
        await payWithFamilyCard(total);
    } else if (emeiData.selectedPaymentMethod === 'request') {
        await requestPayment(total);
    }
}

// é›¶é’±æ”¯ä»˜
async function payWithWallet(amount) {
    const accountId = getCurrentAccountId();
    if (!accountId) {
        alert('è¯·å…ˆç™»å½•è´¦å·');
        return;
    }
    
    // ğŸ”§ ä»å½“å‰ç™»å½•è§’è‰²çš„ identity.balance è·å–ä½™é¢
    const myChar = await db.characters.get(parseInt(accountId));
    if (!myChar) {
        alert('è´¦å·æ•°æ®å¼‚å¸¸');
        return;
    }
    
    if (!myChar.identity) myChar.identity = {};
    const balance = parseFloat(myChar.identity.balance || 0);
    
    if (balance < amount) {
        alert('ä½™é¢ä¸è¶³ï¼Œè¯·é€‰æ‹©å…¶ä»–æ”¯ä»˜æ–¹å¼');
        return;
    }
    
    // æ‰£æ¬¾
    myChar.identity.balance = (balance - amount).toFixed(2);
    await db.characters.put(myChar);
    
    // å‘é€è®¢å•å¡ç‰‡
    await sendEmeiOrderCard();
    
    alert('æ”¯ä»˜æˆåŠŸï¼');
    
    // ğŸ”§ å¦‚æœæ˜¯ç»™è‡ªå·±ç‚¹å•ï¼Œè¯¢é—®æ˜¯å¦åˆ†äº«ç»™å¥½å‹
    if (emeiData.selectedRecipient === 'self') {
        showShareOrderModal(amount);
    } else {
        hideEmeiPage();
    }
}

// äº²å±å¡æ”¯ä»˜
async function payWithFamilyCard(amount) {
    // ğŸ”§ ä½¿ç”¨å½“å‰è´¦å·è§’è‰²æ”¶åˆ°çš„äº²å±å¡
    const myCharId = parseInt(currentMyCharId);
    const myChar = myCharId ? await db.characters.get(myCharId) : null;
    const cards = myChar?.identity?.familyCardsReceived || [];
    
    if (cards.length === 0) {
        alert('æœªç»‘å®šäº²å±å¡ï¼Œè¯·å…ˆç»‘å®š');
        return;
    }
    
    // ä½¿ç”¨ç¬¬ä¸€å¼ äº²å±å¡
    const card = cards[0];
    
    // æ‰£æ¬¾é€»è¾‘ï¼ˆè¿™é‡Œç®€åŒ–å¤„ç†ï¼‰
    // å®é™…åº”è¯¥ä»å¡ä¸»è´¦æˆ·æ‰£æ¬¾
    
    // å‘é€è®¢å•å¡ç‰‡å’Œé€šçŸ¥
    await sendEmeiOrderCard();
    
    alert('æ”¯ä»˜æˆåŠŸï¼å·²ä½¿ç”¨äº²å±å¡æ”¯ä»˜');
    hideEmeiPage();
}

// ç”³è¯·ä»£ä»˜
async function requestPayment(amount) {
    // è·å–ä»£ä»˜å¯¹è±¡ï¼ˆå¯ä»¥é€‰æ‹©ä»»æ„è§’è‰²ï¼‰
    const allCharacters = await db.characters.toArray();
    const availableChars = allCharacters.filter(c => {
        if (c.type === 'system' || c.type === 'online_friend') return false;
        if (!c.name || c.name.trim() === '') return false;
        return true;
    });
    
    if (availableChars.length === 0) {
        alert('æ²¡æœ‰å¯é€‰æ‹©çš„ä»£ä»˜å¯¹è±¡');
        return;
    }
    
    // å¼¹å‡ºé€‰æ‹©ä»£ä»˜å¯¹è±¡çš„å¼¹çª—
    const modal = document.createElement('div');
    modal.id = 'emei-payment-request-modal';
    modal.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:10000; display:flex; align-items:center; justify-content:center;';
    
    modal.innerHTML = `
        <div style="background:#fff; border-radius:16px; padding:20px; width:80%; max-width:350px; max-height:60vh; display:flex; flex-direction:column;">
            <h3 style="margin:0 0 16px 0; text-align:center; font-size:16px; font-weight:600;">é€‰æ‹©ä»£ä»˜å¯¹è±¡</h3>
            <div style="flex:1; overflow-y:auto; margin-bottom:16px;">
                ${availableChars.map(char => `
                    <div onclick="selectPaymentRequestTarget(${char.id}, '${char.name.replace(/'/g, "\\'")}')" style="display:flex; align-items:center; padding:12px; border-bottom:1px solid #f5f5f5; cursor:pointer; transition:background 0.2s;" onmouseover="this.style.background='#f8f8f8'" onmouseout="this.style.background='#fff'">
                        <div style="width:40px; height:40px; border-radius:50%; background-image:url(${char.avatar || ''}); background-size:cover; background-color:#e0e0e0; margin-right:12px; flex-shrink:0;"></div>
                        <span style="font-size:14px; color:#333;">${char.name}</span>
                    </div>
                `).join('')}
            </div>
            <button onclick="this.closest('#emei-payment-request-modal').remove()" style="padding:12px; background:#f0f0f0; color:#666; border:none; border-radius:8px; font-size:14px; cursor:pointer;">å–æ¶ˆ</button>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// é€‰æ‹©ä»£ä»˜å¯¹è±¡
async function selectPaymentRequestTarget(charId, charName) {
    const modal = document.getElementById('emei-payment-request-modal');
    if (modal) modal.remove();
    
    const recipient = await db.characters.get(charId);
    if (!recipient) {
        alert('è§’è‰²ä¿¡æ¯ä¸å­˜åœ¨');
        return;
    }
    
    const subtotal = emeiData.cart.reduce((sum, item) => sum + item.price * item.count, 0);
    const delivery = 3;
    const discount = emeiData.selectedCoupon ? emeiData.selectedCoupon.amount : 0;
    const total = subtotal + delivery - discount;
    
    // å‘é€ä»£ä»˜è¯·æ±‚å¡ç‰‡åˆ°èŠå¤©
    await sendPaymentRequestCard(recipient, total);
    
    // è·å–æ”¶è´§äººä¿¡æ¯ç”¨äºæ˜¾ç¤º
    let recipientName = 'æˆ‘è‡ªå·±';
    if (emeiData.selectedRecipient !== 'self') {
        const recipientChar = await db.characters.get(parseInt(emeiData.selectedRecipient));
        if (recipientChar) recipientName = recipientChar.name;
    }
    
    alert(`å·²å‘ ${charName} å‘é€ä»£ä»˜è¯·æ±‚\nè®¢å•è¯¦æƒ…ï¼š${emeiData.currentStore.name}ï¼Œæ”¶è´§äººï¼š${recipientName}`);
    hideEmeiPage();
}

// å‘é€è®¢å•å¡ç‰‡åˆ°èŠå¤©
async function sendEmeiOrderCard() {
    // å¦‚æœæ˜¯ç»™è‡ªå·±ç‚¹å•ï¼Œä¸”æ²¡æœ‰æ‰“å¼€èŠå¤©ï¼Œä¸å‘é€å¡ç‰‡
    if (emeiData.selectedRecipient === 'self' && !currentChatCharId) {
        return;
    }
    
    const accountId = getCurrentAccountId();
    let chatCharId;
    
    // å¦‚æœæ˜¯ç»™è§’è‰²ç‚¹å•ï¼Œå‘é€åˆ°è¯¥è§’è‰²çš„èŠå¤©
    if (emeiData.selectedRecipient !== 'self') {
        chatCharId = parseInt(emeiData.selectedRecipient);
    } else {
        // ç»™è‡ªå·±ç‚¹å•ï¼Œå‘é€åˆ°å½“å‰æ‰“å¼€çš„èŠå¤©
        chatCharId = currentChatCharId;
    }
    
    if (!chatCharId) return;
    
    const char = await db.characters.get(chatCharId);
    if (!char) return;
    
    // æ„å»ºè®¢å•ä¿¡æ¯
    const orderInfo = {
        store: emeiData.currentStore.name,
        items: emeiData.cart.map(item => `${item.name} x${item.count}`).join('ã€'),
        total: (emeiData.cart.reduce((sum, item) => sum + item.price * item.count, 0) + 3 - (emeiData.selectedCoupon ? emeiData.selectedCoupon.amount : 0)).toFixed(2),
        recipient: emeiData.selectedRecipient === 'self' ? 'æˆ‘è‡ªå·±' : char.name
    };
    
    // ğŸ”§ å°ç¥¨é£æ ¼å¡ç‰‡
    const itemsHtml = emeiData.cart.map(item => `<div style="display:flex;justify-content:space-between;margin-bottom:6px;font-size:13px;"><span style="color:#333;font-weight:600;">${item.name} x${item.count}</span><span style="font-family:Arial,sans-serif;">Â¥${(item.price * item.count).toFixed(2)}</span></div>`).join('');
    const deliveryFee = 3;
    const couponAmount = emeiData.selectedCoupon ? emeiData.selectedCoupon.amount : 0;
    const cardHtml = `<div style="width:260px;background:#fff;padding:16px;box-shadow:0 4px 15px rgba(0,0,0,0.1);position:relative;font-family:'Courier New',Courier,monospace;box-sizing:border-box;"><div style="position:absolute;top:-5px;left:0;width:100%;height:10px;background:linear-gradient(135deg,transparent 5px,#fff 5px) 0 0,linear-gradient(225deg,transparent 5px,#fff 5px) 0 0;background-size:20px 20px;background-repeat:repeat-x;"></div><div style="position:absolute;bottom:-10px;left:0;width:100%;height:10px;background:linear-gradient(45deg,transparent 5px,#fff 5px) 0 0,linear-gradient(-45deg,transparent 5px,#fff 5px) 0 0;background-size:20px 20px;background-repeat:repeat-x;"></div><div style="text-align:center;font-weight:800;font-size:16px;color:#333;margin-bottom:5px;border-bottom:2px dashed #ddd;padding-bottom:12px;">${orderInfo.store} Â· è®¢å•è¯¦æƒ…</div><div style="margin:12px 0;font-size:13px;color:#555;">${itemsHtml}<div style="display:flex;justify-content:space-between;margin-bottom:6px;font-size:11px;color:#999;"><span>é…é€è´¹</span><span>Â¥${deliveryFee.toFixed(2)}</span></div>${couponAmount > 0 ? `<div style="display:flex;justify-content:space-between;margin-bottom:6px;font-size:11px;color:#ff6b6b;"><span>ä¼˜æƒ åˆ¸</span><span>-Â¥${couponAmount.toFixed(2)}</span></div>` : ''}</div><div style="border-top:1px dashed #ccc;margin:12px 0;"></div><div style="display:flex;justify-content:space-between;font-size:16px;font-weight:900;color:#000;margin-bottom:12px;"><span>åˆè®¡</span><span style="font-family:Arial,sans-serif;">Â¥${orderInfo.total}</span></div><div style="text-align:center;font-size:10px;color:#aaa;font-family:Arial,sans-serif;">${new Date().toLocaleString('zh-CN')}</div></div>`;
    
    // ğŸ”§ ä½¿ç”¨æŒ‰è´¦å·éš”ç¦»çš„èŠå¤©è®°å½•ï¼ˆaccountId å·²åœ¨å‡½æ•°å¼€å¤´å£°æ˜ï¼‰
    let history = getChatHistory(char, accountId);
    history.push({
        role: 'user',
        content: `[emei_order]${cardHtml}`,
        time: Date.now()
    });
    await setChatHistory(char, accountId, history);
    
    // å¦‚æœå½“å‰åœ¨è¯¥èŠå¤©çª—å£ï¼Œåˆ·æ–°æ˜¾ç¤º
    if (currentChatCharId === chatCharId) {
        renderChatBody(char);
    } else if (emeiData.selectedRecipient !== 'self') {
        // ç»™è§’è‰²ç‚¹å•ï¼Œå³ä½¿æ²¡æ‰“å¼€èŠå¤©çª—å£ä¹Ÿæç¤ºç”¨æˆ·
        alert(`è®¢å•å·²å‘é€ç»™ ${char.name}ï¼å¯ä»¥åœ¨èŠå¤©ä¸­æŸ¥çœ‹è®¢å•è¯¦æƒ…ã€‚`);
    }
}

// å‘é€ä»£ä»˜è¯·æ±‚å¡ç‰‡
async function sendPaymentRequestCard(recipient, amount) {
    if (!recipient) return;
    
    // è·å–æ”¶è´§äººä¿¡æ¯
    let recipientName = 'æˆ‘è‡ªå·±';
    if (emeiData.selectedRecipient !== 'self') {
        const recipientChar = await db.characters.get(parseInt(emeiData.selectedRecipient));
        if (recipientChar) recipientName = recipientChar.name;
    }
    
    // ğŸ”§ å°ç¥¨é£æ ¼ä»£ä»˜è¯·æ±‚å¡ç‰‡
    const storeName = emeiData.currentStore.name;
    const payItemsHtml = emeiData.cart.map(i => `<div style="display:flex;justify-content:space-between;margin-bottom:6px;font-size:13px;"><span style="color:#333;font-weight:600;">${i.name} x${i.count}</span><span style="font-family:Arial,sans-serif;">Â¥${(i.price * i.count).toFixed(2)}</span></div>`).join('');
    const cardHtml = `<div style="width:260px;background:#fff;padding:16px;box-shadow:0 4px 15px rgba(0,0,0,0.1);position:relative;font-family:'Courier New',Courier,monospace;box-sizing:border-box;"><div style="position:absolute;top:-5px;left:0;width:100%;height:10px;background:linear-gradient(135deg,transparent 5px,#fff 5px) 0 0,linear-gradient(225deg,transparent 5px,#fff 5px) 0 0;background-size:20px 20px;background-repeat:repeat-x;"></div><div style="position:absolute;bottom:-10px;left:0;width:100%;height:10px;background:linear-gradient(45deg,transparent 5px,#fff 5px) 0 0,linear-gradient(-45deg,transparent 5px,#fff 5px) 0 0;background-size:20px 20px;background-repeat:repeat-x;"></div><div style="text-align:center;font-weight:800;font-size:16px;color:#333;margin-bottom:5px;border-bottom:2px dashed #ddd;padding-bottom:12px;">${storeName} Â· ä»£ä»˜è¯·æ±‚</div><div style="text-align:center;font-size:12px;color:#888;margin:8px 0;">å¸®æˆ‘ä»˜ä¸€ä¸‹å¤–å–~</div><div style="margin:12px 0;font-size:13px;color:#555;">${payItemsHtml}</div><div style="border-top:1px dashed #ccc;margin:12px 0;"></div><div style="display:flex;justify-content:space-between;font-size:16px;font-weight:900;color:#000;margin-bottom:14px;"><span>åˆè®¡</span><span style="font-family:Arial,sans-serif;color:#ff4d4f;">Â¥${amount.toFixed(2)}</span></div><div onclick="handlePaymentRequest(this)" data-amount="${amount.toFixed(2)}" data-pay-type="char_pay" style="display:block;width:100%;padding:10px;background:#ff4d4f;color:white;text-align:center;border-radius:4px;font-family:sans-serif;font-weight:bold;letter-spacing:1px;cursor:pointer;box-sizing:border-box;">å¸®æˆ‘æ”¯ä»˜</div><div style="text-align:center;font-size:10px;color:#aaa;margin-top:12px;font-family:Arial,sans-serif;">${new Date().toLocaleString('zh-CN')}</div></div>`;
    
    // ğŸ”§ ä½¿ç”¨æŒ‰è´¦å·éš”ç¦»çš„èŠå¤©è®°å½•
    const accountId = getCurrentAccountId();
    let history = getChatHistory(recipient, accountId);
    history.push({
        role: 'user',
        content: `[payment_request]${cardHtml}`,
        time: Date.now()
    });
    await setChatHistory(recipient, accountId, history);
    
    if (currentChatCharId === recipient.id) {
        renderChatBody(recipient);
    }
}

// å¤„ç†ä»£ä»˜è¯·æ±‚
async function handlePaymentRequest(btn) {
    const payType = btn.getAttribute('data-pay-type');
    const amount = parseFloat(btn.getAttribute('data-amount') || 0);
    
    if (payType === 'user_pay') {
        // ç”¨æˆ·å¸®è§’è‰²æ”¯ä»˜å¤–å– â†’ æ‰£ç”¨æˆ·é’±åŒ…ä½™é¢
        const accountId = getCurrentAccountId();
        if (!accountId) {
            showToast('è¯·å…ˆç™»å½•è´¦å·');
            return;
        }
        
        const myChar = await db.characters.get(parseInt(accountId));
        if (!myChar) {
            showToast('è´¦å·æ•°æ®å¼‚å¸¸');
            return;
        }
        
        if (!myChar.identity) myChar.identity = {};
        const balance = parseFloat(myChar.identity.balance || 0);
        
        if (balance < amount) {
            showToast(`ä½™é¢ä¸è¶³ (å½“å‰: Â¥${balance.toFixed(2)})`);
            return;
        }
        
        // æ‰£æ¬¾
        myChar.identity.balance = (balance - amount).toFixed(2);
        await db.characters.put(myChar);
        
        // æ›´æ–°ä½™é¢æ˜¾ç¤º
        await updateBalancePageDisplay();
        await updateWalletBalanceDisplay();
        
        // è®°å½•è´¦å•ï¼ˆæ”¯å‡ºï¼‰
        await addTransaction('expense', amount, 'å¤–å–ä»£ä»˜', 'å¸®TAæ”¯ä»˜å¤–å–');
        
        // æ›´æ–°æŒ‰é’®çŠ¶æ€
        btn.innerText = 'å·²æ”¯ä»˜ Â¥' + amount.toFixed(2);
        btn.style.background = '#52c41a';
        btn.style.cursor = 'default';
        btn.onclick = null;
        
        showToast(`æ”¯ä»˜æˆåŠŸï¼å·²æ‰£æ¬¾ Â¥${amount.toFixed(2)}`);
    } else {
        // è§’è‰²å¸®ç”¨æˆ·æ”¯ä»˜å¤–å– â†’ ç›´æ¥æ˜¾ç¤ºå·²æ”¯ä»˜
        btn.innerText = 'å·²æ”¯ä»˜';
        btn.style.background = '#52c41a';
        btn.style.cursor = 'default';
        btn.onclick = null;
        
        showToast('å¯¹æ–¹å·²æ”¯ä»˜');
    }
}

// ğŸ”§ æ˜¾ç¤ºåˆ†äº«è®¢å•å¼¹çª—ï¼ˆç»™è‡ªå·±ç‚¹å•åå¯ä»¥åˆ†äº«ç»™å¥½å‹ï¼‰
async function showShareOrderModal(amount) {
    const allCharacters = await db.characters.toArray();
    const accountId = getCurrentAccountId();
    
    // è¿‡æ»¤å¯åˆ†äº«çš„è§’è‰²ï¼ˆæœ‰å¥½å‹å…³ç³»çš„è§’è‰²ï¼‰
    const availableChars = allCharacters.filter(c => {
        if (c.type === 'system' || c.type === 'user') return false;
        if (!c.name || c.name.trim() === '') return false;
        // æ£€æŸ¥æ˜¯å¦æ˜¯å¥½å‹
        const status = getFriendStatus(c, accountId);
        return status === 'friend';
    });
    
    if (availableChars.length === 0) {
        hideEmeiPage();
        return;
    }
    
    const modal = document.createElement('div');
    modal.id = 'emei-share-modal';
    modal.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:10000; display:flex; align-items:center; justify-content:center;';
    
    modal.innerHTML = `
        <div style="background:#fff; border-radius:16px; padding:20px; width:85%; max-width:350px; max-height:70vh; display:flex; flex-direction:column;">
            <h3 style="margin:0 0 8px 0; text-align:center; font-size:16px; font-weight:600;">åˆ†äº«è®¢å•ç»™å¥½å‹</h3>
            <p style="margin:0 0 16px 0; text-align:center; font-size:12px; color:#999;">é€‰æ‹©æƒ³è¦åˆ†äº«çš„å¥½å‹ï¼ˆå¯å¤šé€‰ï¼‰</p>
            <div id="share-char-list" style="flex:1; overflow-y:auto; margin-bottom:16px; max-height:300px;">
                ${availableChars.map(char => `
                    <label style="display:flex; align-items:center; padding:12px; border-bottom:1px solid #f5f5f5; cursor:pointer;">
                        <input type="checkbox" value="${char.id}" style="width:18px; height:18px; margin-right:12px; accent-color:var(--ins-pink);">
                        <div style="width:40px; height:40px; border-radius:50%; background-image:url(${char.avatar || ''}); background-size:cover; background-color:#e0e0e0; margin-right:12px; flex-shrink:0;"></div>
                        <span style="font-size:14px; color:#333;">${char.name}</span>
                    </label>
                `).join('')}
            </div>
            <div style="display:flex; gap:12px;">
                <button onclick="closeShareOrderModal()" style="flex:1; padding:12px; background:#f0f0f0; color:#666; border:none; border-radius:8px; font-size:14px; cursor:pointer;">è·³è¿‡</button>
                <button onclick="confirmShareOrder()" style="flex:1; padding:12px; background:var(--ins-pink); color:#fff; border:none; border-radius:8px; font-size:14px; cursor:pointer;">åˆ†äº«</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// å…³é—­åˆ†äº«å¼¹çª—
function closeShareOrderModal() {
    const modal = document.getElementById('emei-share-modal');
    if (modal) modal.remove();
    hideEmeiPage();
}

// ç¡®è®¤åˆ†äº«è®¢å•
async function confirmShareOrder() {
    const checkboxes = document.querySelectorAll('#share-char-list input[type="checkbox"]:checked');
    const selectedIds = Array.from(checkboxes).map(cb => parseInt(cb.value));
    
    if (selectedIds.length === 0) {
        closeShareOrderModal();
        return;
    }
    
    const accountId = getCurrentAccountId();
    
    // å‘æ¯ä¸ªé€‰ä¸­çš„å¥½å‹å‘é€åˆ†äº«å¡ç‰‡
    for (const charId of selectedIds) {
        await sendShareOrderCard(charId, accountId);
    }
    
    showToast(`å·²åˆ†äº«ç»™ ${selectedIds.length} ä½å¥½å‹`);
    closeShareOrderModal();
}

// å‘é€åˆ†äº«è®¢å•å¡ç‰‡
async function sendShareOrderCard(charId, accountId) {
    const char = await db.characters.get(charId);
    if (!char) return;
    
    const orderInfo = {
        store: emeiData.currentStore.name,
        items: emeiData.cart.map(item => `${item.name} x${item.count}`).join('ã€'),
        total: (emeiData.cart.reduce((sum, item) => sum + item.price * item.count, 0) + 3 - (emeiData.selectedCoupon ? emeiData.selectedCoupon.amount : 0)).toFixed(2)
    };
    
    // åˆ›å»ºå°ç¥¨é£æ ¼åˆ†äº«å¡ç‰‡HTML
    const shareItemsHtml = emeiData.cart.map(item => `<div style="display:flex;justify-content:space-between;margin-bottom:6px;font-size:13px;"><span style="color:#333;font-weight:600;">${item.name} x${item.count}</span><span style="font-family:Arial,sans-serif;">Â¥${(item.price * item.count).toFixed(2)}</span></div>`).join('');
    const cardHtml = `<div style="width:260px;background:#fff;padding:16px;box-shadow:0 4px 15px rgba(0,0,0,0.1);position:relative;font-family:'Courier New',Courier,monospace;box-sizing:border-box;"><div style="position:absolute;top:-5px;left:0;width:100%;height:10px;background:linear-gradient(135deg,transparent 5px,#fff 5px) 0 0,linear-gradient(225deg,transparent 5px,#fff 5px) 0 0;background-size:20px 20px;background-repeat:repeat-x;"></div><div style="position:absolute;bottom:-10px;left:0;width:100%;height:10px;background:linear-gradient(45deg,transparent 5px,#fff 5px) 0 0,linear-gradient(-45deg,transparent 5px,#fff 5px) 0 0;background-size:20px 20px;background-repeat:repeat-x;"></div><div style="text-align:center;font-weight:800;font-size:16px;color:#333;margin-bottom:5px;border-bottom:2px dashed #ddd;padding-bottom:12px;">ğŸ›µ ${orderInfo.store} Â· å¤–å–åˆ†äº«</div><div style="text-align:center;font-size:12px;color:#888;margin:8px 0;">æˆ‘åˆšç‚¹äº†å¤–å–ï¼Œåˆ†äº«ç»™ä½ çœ‹çœ‹~</div><div style="margin:12px 0;font-size:13px;color:#555;">${shareItemsHtml}</div><div style="border-top:1px dashed #ccc;margin:12px 0;"></div><div style="display:flex;justify-content:space-between;font-size:16px;font-weight:900;color:#000;margin-bottom:8px;"><span>åˆè®¡</span><span style="font-family:Arial,sans-serif;">Â¥${orderInfo.total}</span></div><div style="text-align:center;font-size:11px;color:#999;margin-top:8px;">ğŸ” ä¸€èµ·ç‚¹å¤–å–å‘€~</div></div>`;
    
    // æ·»åŠ åˆ°èŠå¤©è®°å½•
    let history = getChatHistory(char, accountId);
    history.push({
        role: 'user',
        content: `[emei_share]${cardHtml}`,
        time: Date.now()
    });
    await setChatHistory(char, accountId, history);
    
    // å¦‚æœå½“å‰åœ¨è¯¥èŠå¤©çª—å£ï¼Œåˆ·æ–°æ˜¾ç¤º
    if (currentChatCharId === charId) {
        renderChatBody(char);
    }
}

// æ³¨å†Œå…¨å±€å‡½æ•°
window.showEmeiPage = showEmeiPage;
window.hideEmeiPage = hideEmeiPage;
window.claimEmeiCoupon = claimEmeiCoupon;
window.openEmeiStore = openEmeiStore;
window.backToEmeiMain = backToEmeiMain;
window.increaseEmeiItem = increaseEmeiItem;
window.decreaseEmeiItem = decreaseEmeiItem;
window.updateEmeiRecipient = updateEmeiRecipient;
window.showEmeiCheckout = showEmeiCheckout;
window.backToEmeiStore = backToEmeiStore;
window.selectEmeiCoupon = selectEmeiCoupon;
window.useEmeiCoupon = useEmeiCoupon;
window.closeEmeiCouponModal = closeEmeiCouponModal;
window.showEmeiPaymentModal = showEmeiPaymentModal;
window.closeEmeiPaymentModal = closeEmeiPaymentModal;
window.selectEmeiPaymentMethod = selectEmeiPaymentMethod;
window.confirmEmeiPayment = confirmEmeiPayment;
window.handlePaymentRequest = handlePaymentRequest;
window.selectPaymentRequestTarget = selectPaymentRequestTarget;
window.showShareOrderModal = showShareOrderModal;
window.closeShareOrderModal = closeShareOrderModal;
window.confirmShareOrder = confirmShareOrder;

// ==================== é—²é±¼App Logic ====================

const xianyuDb = new Dexie('XianyuDB_Internal');

xianyuDb.version(3).stores({
    goods: '++id, title, price, category, collected, viewCount, wantCount, createdAt, userId, sold, bought, originalPrice, sellerId',
    collections: '++id, goodsId, goodsTitle, goodsPrice, goodsCategory, collectedAt, userId',
    messages: '++id, goodsId, content, sender, createdAt, userId, senderId, role',
    chatSessions: '++id, goodsId, lastMessage, updatedAt, userId',
    users: '++id, username, avatar, createdAt, userId, role, blockedUsers',
    orders: '++id, goodsId, goodsTitle, goodsPrice, type, createdAt, userId',
    characters: '++id, userId, role, personality, worldView, createdAt'
});

// ç‰ˆæœ¬4ï¼šæ¸…é™¤æ—§çš„é»˜è®¤å•†å“æ•°æ®
xianyuDb.version(4).stores({
    goods: '++id, title, price, category, collected, viewCount, wantCount, createdAt, userId, sold, bought, originalPrice, sellerId',
    collections: '++id, goodsId, goodsTitle, goodsPrice, goodsCategory, collectedAt, userId',
    messages: '++id, goodsId, content, sender, createdAt, userId, senderId, role',
    chatSessions: '++id, goodsId, lastMessage, updatedAt, userId',
    users: '++id, username, avatar, createdAt, userId, role, blockedUsers',
    orders: '++id, goodsId, goodsTitle, goodsPrice, type, createdAt, userId',
    characters: '++id, userId, role, personality, worldView, createdAt'
}).upgrade(tx => {
    // æ¸…é™¤æ—§ç‰ˆæœ¬çš„é»˜è®¤å•†å“ã€è®¢å•ã€ç”¨æˆ·æ•°æ®
    tx.table('goods').clear();
    tx.table('orders').clear();
    tx.table('users').clear();
    tx.table('collections').clear();
    tx.table('messages').clear();
    tx.table('chatSessions').clear();
    tx.table('characters').clear();
});

// é—²é±¼å½“å‰è´¦å·IDï¼ˆä»WeChatè´¦å·é€‰æ‹©ä¸­è·å–ï¼Œç”¨äºæ•°æ®éš”ç¦»ï¼‰
let XY_CURRENT_USER_ID = null;
window.xianyuCurrentAccountId = null;
window.xianyuCurrentAccountName = '';

const XianyuAppState = {
    currentPage: 'xyHomePage',
    currentTab: 'xy-tab-home',
    currentGoods: null,
    pageHistory: [],
    
    navigateTo(pageId, tabId = null, addToHistory = true) {
        document.querySelectorAll('#xianyuAppPage .xy-page').forEach(page => {
            page.classList.remove('active');
        });
        
        const targetPage = document.getElementById(pageId);
        if (targetPage) {
            targetPage.classList.add('active');
            this.currentPage = pageId;
            
            if (addToHistory && pageId !== 'xyHomePage' && !this.pageHistory.includes(pageId)) {
                this.pageHistory.push(pageId);
            }
        }
        
        // èŠå¤©é¡µå’Œè¯¦æƒ…é¡µéšè—åº•éƒ¨å¯¼èˆªæ 
        const tabBar = document.querySelector('#xyMainContent .xy-tab-bar');
        if (tabBar) {
            const hideTabPages = ['xyChatPage', 'xyDetailPage'];
            tabBar.style.display = hideTabPages.includes(pageId) ? 'none' : 'flex';
        }
        
        if (tabId) {
            this.updateTabBar(tabId);
        } else {
            const tabMap = {
                'xyHomePage': 'xy-tab-home',
                'xyDetailPage': 'xy-tab-home',
                'xyMessageListPage': 'xy-tab-message',
                'xyChatPage': 'xy-tab-message',
                'xyMyPage': 'xy-tab-mine',
                'xyMyGoodsPage': 'xy-tab-mine',
                'xyMySoldPage': 'xy-tab-mine',
                'xyMyBoughtPage': 'xy-tab-mine',
                'xyMyCollectionsPage': 'xy-tab-mine'
            };
            this.updateTabBar(tabMap[pageId] || 'xy-tab-home');
        }
        
        if (pageId === 'xyHomePage') {
            xianyuLoadGoods();
        } else if (pageId === 'xyChatPage' && this.currentGoods) {
            xianyuLoadChatMessages(this.currentGoods.id);
        } else if (pageId === 'xyMessageListPage') {
            xianyuLoadMessageList();
        } else if (pageId === 'xyMyPage') {
            xianyuLoadMyPageData();
        } else if (pageId === 'xyMyGoodsPage') {
            xianyuLoadMyGoods();
        } else if (pageId === 'xyMySoldPage') {
            xianyuLoadMySold();
        } else if (pageId === 'xyMyBoughtPage') {
            xianyuLoadMyBought();
        } else if (pageId === 'xyMyCollectionsPage') {
            xianyuLoadMyCollections();
        }
    },
    
    updateTabBar(tabId) {
        document.querySelectorAll('#xianyuAppPage .xy-tab-item').forEach(tab => {
            tab.classList.remove('active');
        });
        
        const targetTab = document.getElementById(tabId);
        if (targetTab) {
            targetTab.classList.add('active');
            this.currentTab = tabId;
        }
    },
    
    goBack() {
        if (this.pageHistory.length > 0) {
            this.pageHistory.pop();
            if (this.pageHistory.length > 0) {
                const previousPage = this.pageHistory[this.pageHistory.length - 1];
                this.navigateTo(previousPage, null, false);
            } else {
                this.navigateTo('xyHomePage', 'xy-tab-home', false);
            }
        } else {
            this.navigateTo('xyHomePage', 'xy-tab-home', false);
        }
    },
    
    goBackToMyPage() {
        this.navigateTo('xyMyPage', 'xy-tab-mine', false);
    },
    
    switchTab(pageId, tabId) {
        this.navigateTo(pageId, tabId, false);
    }
};

async function xianyuInitializeUser() {
    if (!XY_CURRENT_USER_ID) return;
    // æ£€æŸ¥å½“å‰è´¦å·æ˜¯å¦å·²æœ‰é—²é±¼ç”¨æˆ·è®°å½•
    const existingUser = await xianyuDb.users.get(XY_CURRENT_USER_ID);
    if (!existingUser) {
        // ä»WeChatè§’è‰²è·å–è´¦å·ä¿¡æ¯
        let username = window.xianyuCurrentAccountName || 'ç”¨æˆ·';
        let avatar = 'fa-user';
        try {
            const accountChar = await db.characters.get(XY_CURRENT_USER_ID);
            if (accountChar) {
                username = accountChar.nick || accountChar.name || 'ç”¨æˆ·';
            }
        } catch(e) {}
        await xianyuDb.users.add({
            id: XY_CURRENT_USER_ID,
            username: username,
            avatar: avatar,
            createdAt: new Date()
        });
    }
    xianyuLoadUserInfo();
}

async function xianyuLoadUserInfo() {
    if (!XY_CURRENT_USER_ID) return;
    const user = await xianyuDb.users.get(XY_CURRENT_USER_ID);
    if (user) {
        const nameEl = document.getElementById('xyUserName');
        const avatarEl = document.getElementById('xyUserAvatar');
        if (nameEl) nameEl.textContent = user.username;
        if (avatarEl) {
            // å°è¯•æ˜¾ç¤ºWeChatè´¦å·å¤´åƒ
            try {
                const accountChar = await db.characters.get(XY_CURRENT_USER_ID);
                if (accountChar && accountChar.avatar) {
                    avatarEl.innerHTML = `<img src="${accountChar.avatar}" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">`;
                } else {
                    avatarEl.innerHTML = `<i class="fa ${user.avatar}"></i>`;
                }
            } catch(e) {
                avatarEl.innerHTML = `<i class="fa ${user.avatar}"></i>`;
            }
        }
    }
    await xianyuUpdateMyPageStats();
}

async function xianyuUpdateMyPageStats() {
    if (!XY_CURRENT_USER_ID) return;
    const myGoodsCount = await xianyuDb.goods.where('userId').equals(XY_CURRENT_USER_ID).count();
    const el1 = document.getElementById('xyMyGoodsCount');
    if (el1) el1.textContent = myGoodsCount;
    
    const mySoldCount = await xianyuDb.goods.where('userId').equals(XY_CURRENT_USER_ID).filter(g => g.sold === 1).count();
    const el2 = document.getElementById('xyMySoldCount');
    if (el2) el2.textContent = mySoldCount;
    
    const myBoughtCount = await xianyuDb.orders.where('userId').equals(XY_CURRENT_USER_ID).filter(o => o.type === 'buy').count();
    const el3 = document.getElementById('xyMyBoughtCount');
    if (el3) el3.textContent = myBoughtCount;
}

function xianyuShowDataStatus(message) {
    const statusEl = document.getElementById('xyDataStatus');
    if (!statusEl) return;
    statusEl.textContent = message;
    statusEl.style.display = 'block';
    setTimeout(() => {
        statusEl.style.display = 'none';
    }, 2000);
}

async function xianyuInitializeDefaultGoods() {
    // ä¸å†åˆå§‹åŒ–é»˜è®¤å•†å“ï¼Œå•†å“ç”±ç”¨æˆ·è‡ªè¡Œå‘å¸ƒæˆ–AIç”Ÿæˆ
}

// ç»Ÿä¸€ç”Ÿæˆå•†å“å¡ç‰‡HTML
function xianyuGoodsCardHTML(goodsItem, extraBadge = '') {
    const sellerDisplay = goodsItem.sellerName || 'åŒ¿åå–å®¶';
    return `
        <div class="xy-goods-img"><i class="fa fa-image"></i></div>
        <div class="xy-goods-info">
            <div class="xy-goods-title">${goodsItem.title}</div>
            <div class="xy-goods-price">Â¥${goodsItem.price}${extraBadge}</div>
            <div class="xy-goods-seller-row">
                <span class="xy-goods-seller-name"><i class="fa fa-user" style="margin-right:3px;font-size:10px;"></i>${sellerDisplay}</span>
                <span class="xy-goods-category-tag">${goodsItem.category}</span>
            </div>
        </div>
    `;
}

async function xianyuLoadGoods(category = null) {
    const container = document.getElementById('xyGoodsListContainer');
    if (!container) return;
    let goods;
    if (category) {
        goods = await xianyuDb.goods.where('category').equals(category).toArray();
    } else {
        goods = await xianyuDb.goods.toArray();
    }
    goods.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
    container.innerHTML = '';
    if (goods.length === 0) {
        container.innerHTML = '<div style="text-align: center; padding: 50px; color: #ccc;">æš‚æ— å•†å“ï¼Œå¿«å»å‘å¸ƒå§ï¼</div>';
        return;
    }
    goods.forEach(goodsItem => {
        const item = document.createElement('div');
        item.className = 'xy-goods-item';
        item.onclick = () => xianyuGoToDetail(goodsItem.id);
        item.innerHTML = xianyuGoodsCardHTML(goodsItem);
        container.appendChild(item);
    });
}

async function xianyuLoadMyGoods() {
    const container = document.getElementById('xyMyGoodsListContainer');
    if (!container) return;
    const goods = await xianyuDb.goods.where('userId').equals(XY_CURRENT_USER_ID).toArray();
    goods.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
    container.innerHTML = '';
    if (goods.length === 0) {
        container.innerHTML = `
            <div class="xy-empty-state">
                <div class="xy-empty-icon"><i class="fa fa-box-open"></i></div>
                <div class="xy-empty-text">ä½ è¿˜æ²¡æœ‰å‘å¸ƒè¿‡å•†å“</div>
                <button onclick="xianyuShowPublishDialog()" style="margin-top: 15px; padding: 8px 20px; background-color: #e89ab0; color: white; border: none; border-radius: 5px; cursor: pointer;">å»å‘å¸ƒ</button>
            </div>
        `;
        return;
    }
    goods.forEach(goodsItem => {
        const item = document.createElement('div');
        item.className = 'xy-goods-item';
        item.onclick = () => xianyuGoToDetail(goodsItem.id);
        const soldBadge = goodsItem.sold ? '<span style="font-size: 10px; color: #ff6666; margin-left: 5px;">å·²å”®å‡º</span>' : '';
        item.innerHTML = xianyuGoodsCardHTML(goodsItem, ` ${soldBadge}`);
        container.appendChild(item);
    });
}

async function xianyuLoadMySold() {
    const container = document.getElementById('xyMySoldListContainer');
    if (!container) return;
    const goods = await xianyuDb.goods.where('userId').equals(XY_CURRENT_USER_ID).filter(g => g.sold === 1).toArray();
    container.innerHTML = '';
    if (goods.length === 0) {
        container.innerHTML = `
            <div class="xy-empty-state">
                <div class="xy-empty-icon"><i class="fa fa-shopping-bag"></i></div>
                <div class="xy-empty-text">ä½ è¿˜æ²¡æœ‰å–å‡ºè¿‡å•†å“</div>
            </div>
        `;
        return;
    }
    goods.forEach(goodsItem => {
        const item = document.createElement('div');
        item.className = 'xy-goods-item';
        item.onclick = () => xianyuGoToDetail(goodsItem.id);
        item.innerHTML = xianyuGoodsCardHTML(goodsItem);
        container.appendChild(item);
    });
}

async function xianyuLoadMyBought() {
    const container = document.getElementById('xyMyBoughtListContainer');
    if (!container) return;
    const orders = await xianyuDb.orders.where('userId').equals(XY_CURRENT_USER_ID).filter(o => o.type === 'buy').toArray();
    container.innerHTML = '';
    if (orders.length === 0) {
        container.innerHTML = `
            <div class="xy-empty-state">
                <div class="xy-empty-icon"><i class="fa fa-shopping-cart"></i></div>
                <div class="xy-empty-text">ä½ è¿˜æ²¡æœ‰ä¹°åˆ°è¿‡å•†å“</div>
            </div>
        `;
        return;
    }
    for (const order of orders) {
        const goodsItem = await xianyuDb.goods.get(order.goodsId);
        if (goodsItem) {
            const item = document.createElement('div');
            item.className = 'xy-goods-item';
            item.onclick = () => xianyuGoToDetail(goodsItem.id);
            item.innerHTML = xianyuGoodsCardHTML(goodsItem);
            container.appendChild(item);
        }
    }
}

async function xianyuLoadMyCollections() {
    const container = document.getElementById('xyMyCollectionsListContainer');
    if (!container) return;
    const collections = await xianyuDb.collections.where('userId').equals(XY_CURRENT_USER_ID).toArray();
    container.innerHTML = '';
    if (collections.length === 0) {
        container.innerHTML = `
            <div class="xy-empty-state">
                <div class="xy-empty-icon"><i class="fa fa-star"></i></div>
                <div class="xy-empty-text">ä½ è¿˜æ²¡æœ‰æ”¶è—è¿‡å•†å“</div>
            </div>
        `;
        return;
    }
    for (const collection of collections) {
        const goodsItem = await xianyuDb.goods.get(collection.goodsId);
        if (goodsItem) {
            const item = document.createElement('div');
            item.className = 'xy-goods-item';
            item.onclick = () => xianyuGoToDetail(goodsItem.id);
            item.innerHTML = xianyuGoodsCardHTML(goodsItem);
            container.appendChild(item);
        }
    }
}

async function xianyuLoadMyPageData() {
    await xianyuUpdateMyPageStats();
}

async function xianyuLoadMessageList() {
    const container = document.getElementById('xyChatListContent');
    if (!container) return;
    container.innerHTML = '';
    
    const sessions = await xianyuDb.chatSessions.toArray();
    
    if (sessions.length === 0) {
        container.innerHTML = '<div style="text-align: center; padding: 50px; color: #ccc;">æš‚æ— æ¶ˆæ¯</div>';
        return;
    }
    
    sessions.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
    
    for (const session of sessions) {
        const goods = await xianyuDb.goods.get(session.goodsId);
        if (!goods) continue;
        
        const lastMessage = await xianyuDb.messages.where('goodsId').equals(session.goodsId).sortBy('createdAt');
        const lastMsg = lastMessage[lastMessage.length - 1];
        let senderName = 'æœªçŸ¥ç”¨æˆ·';
        
        if (lastMsg) {
            if (lastMsg.sender === 'buyer' || (lastMsg.userId !== XY_CURRENT_USER_ID && lastMsg.role === 'buyer')) {
                const buyer = await xianyuDb.users.where('userId').equals(lastMsg.senderId).first();
                senderName = buyer ? buyer.username : lastMsg.senderId;
            } else if (lastMsg.sender === 'seller' || lastMsg.role === 'seller') {
                const seller = await xianyuDb.users.get(goods.userId);
                senderName = seller ? seller.username : lastMsg.senderId;
            }
        }
        
        const time = new Date(session.updatedAt);
        const timeStr = `${time.getMonth() + 1}/${time.getDate()} ${time.getHours().toString().padStart(2, '0')}:${time.getMinutes().toString().padStart(2, '0')}`;
        
        const item = document.createElement('div');
        item.className = 'xy-msg-list-item';
        item.style.cursor = 'pointer';
        item.onclick = () => {
            XianyuAppState.currentGoods = goods;
            xianyuGoToChat();
        };
        
        item.innerHTML = `
            <div class="xy-msg-avatar" style="background-color: #e89ab0; color: white;">
                <i class="fa fa-user"></i>
            </div>
            <div class="xy-msg-info">
                <div class="xy-msg-top">
                    <div class="xy-msg-name">${goods.title} - ${senderName}</div>
                    <div class="xy-msg-time">${timeStr}</div>
                </div>
                <div class="xy-msg-content">${session.lastMessage || 'æš‚æ— æ¶ˆæ¯'}</div>
            </div>
        `;
        
        container.appendChild(item);
    }
}

async function xianyuSearchGoods(keyword) {
    const container = document.getElementById('xyGoodsListContainer');
    if (!container) return;
    const allGoods = await xianyuDb.goods.toArray();
    const filteredGoods = allGoods.filter(goodsItem => 
        goodsItem.title.toLowerCase().includes(keyword.toLowerCase()) ||
        goodsItem.category.toLowerCase().includes(keyword.toLowerCase()) ||
        (goodsItem.description && goodsItem.description.toLowerCase().includes(keyword.toLowerCase()))
    );
    container.innerHTML = '';
    if (filteredGoods.length === 0) {
        container.innerHTML = '<div style="text-align: center; padding: 50px; color: #ccc;">æœªæ‰¾åˆ°ç›¸å…³å•†å“</div>';
        return;
    }
    filteredGoods.forEach(goodsItem => {
        const item = document.createElement('div');
        item.className = 'xy-goods-item';
        item.onclick = () => xianyuGoToDetail(goodsItem.id);
        item.innerHTML = xianyuGoodsCardHTML(goodsItem);
        container.appendChild(item);
    });
}

async function xianyuGoToDetail(goodsId) {
    const goods = await xianyuDb.goods.get(goodsId);
    if (!goods) return;
    
    goods.viewCount = (goods.viewCount || 0) + 1;
    await xianyuDb.goods.update(goodsId, { viewCount: goods.viewCount });
    
    document.getElementById('xyDetailTitle').textContent = goods.title;
    document.getElementById('xyDetailPrice').textContent = `Â¥${goods.price}`;
    document.getElementById('xyDetailPostage').textContent = goods.postage || 'åŒ…é‚®';
    document.getElementById('xyDetailMeta').textContent = `æƒ³è¦${goods.wantCount || 0} | æµè§ˆ${goods.viewCount || 0}`;
    document.getElementById('xyDetailMeta1Key').textContent = goods.metaKey || 'ç±»åˆ«';
    document.getElementById('xyDetailMeta1Val').textContent = goods.metaVal || goods.category;
    document.getElementById('xyDetailDescTitle').textContent = goods.title;
    document.getElementById('xyDetailDescContent').textContent = goods.description;
    document.getElementById('xyDetailTipsTitle').textContent = 'å°è´´å£«';
    document.getElementById('xyDetailTipsContent').textContent = goods.tips || 'æ¸©é¦¨æç¤ºå†…å®¹';
    
    // æ˜¾ç¤ºå–å®¶åå­—
    const sellerNameEl = document.querySelector('#xyDetailPage .xy-seller-name');
    if (sellerNameEl) {
        const sellerDisplay = goods.sellerName || 'åŒ¿åå–å®¶';
        sellerNameEl.innerHTML = `${sellerDisplay} <span class="xy-credit-tag">å–å®¶ä¿¡ç”¨æå¥½</span>`;
    }
    // æ˜¾ç¤ºå–å®¶å¤´åƒ
    const sellerAvatarEl = document.querySelector('#xyDetailPage .xy-seller-avatar');
    if (sellerAvatarEl) {
        if (goods.sellerAvatar && goods.sellerAvatar.startsWith('http')) {
            sellerAvatarEl.innerHTML = `<img src="${goods.sellerAvatar}" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">`;
        } else {
            sellerAvatarEl.innerHTML = `<i class="fa ${goods.sellerAvatar || 'fa-user'}"></i>`;
        }
    }
    
    if (goods.category === 'ç¾å¦†' || goods.category === 'å¥³è£…') {
        document.getElementById('xySellerLocation').textContent = '7å°æ—¶å‰å‰æ¥è¿‡ | æ³‰å·';
        document.getElementById('xySellerService').textContent = '230+å·²æœåŠ¡(æ¬¡) | 2å¹´æœåŠ¡ç»éªŒ';
    } else {
        document.getElementById('xySellerLocation').textContent = 'åˆšåˆšæ¥è¿‡ | æ²³åŒ—Â·å¼ å®¶å£';
        document.getElementById('xySellerService').textContent = '83+å·²æœåŠ¡(æ¬¡) | 1å¹´æœåŠ¡ç»éªŒ';
    }
    
    xianyuUpdateCollectButton(goodsId);
    XianyuAppState.currentGoods = goods;
    XianyuAppState.navigateTo('xyDetailPage');
}

async function xianyuUpdateCollectButton(goodsId) {
    const collectBtn = document.getElementById('xyCollectBtn');
    const detailCollectBtn = document.getElementById('xyDetailCollectBtn');
    if (!collectBtn || !detailCollectBtn) return;
    
    const collection = await xianyuDb.collections.where('goodsId').equals(goodsId).filter(c => c.userId === XY_CURRENT_USER_ID).first();
    
    if (collection) {
        collectBtn.innerHTML = '<i class="fa fa-star"></i> å·²æ”¶è—';
        detailCollectBtn.className = 'fa fa-star';
        detailCollectBtn.title = 'å–æ¶ˆæ”¶è—';
    } else {
        collectBtn.innerHTML = '<i class="fa fa-star-o"></i> æ”¶è—';
        detailCollectBtn.className = 'fa fa-star-o';
        detailCollectBtn.title = 'æ”¶è—';
    }
}

async function xianyuToggleCollect(goodsId) {
    const goods = await xianyuDb.goods.get(goodsId);
    if (!goods) return;
    
    const collection = await xianyuDb.collections.where('goodsId').equals(goodsId).filter(c => c.userId === XY_CURRENT_USER_ID).first();
    
    if (collection) {
        await xianyuDb.collections.delete(collection.id);
        xianyuShowDataStatus('å·²å–æ¶ˆæ”¶è—');
    } else {
        await xianyuDb.collections.add({
            goodsId: goodsId,
            goodsTitle: goods.title,
            goodsPrice: goods.price,
            goodsCategory: goods.category,
            userId: XY_CURRENT_USER_ID,
            collectedAt: new Date()
        });
        xianyuShowDataStatus('å·²æ”¶è—');
    }
    xianyuUpdateCollectButton(goodsId);
    await xianyuUpdateMyPageStats();
}

async function xianyuLoadChatMessages(goodsId) {
    const container = document.getElementById('xyChatContent');
    if (!container) return;
    const messages = await xianyuDb.messages.where('goodsId').equals(goodsId).toArray();
    
    messages.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
    
    container.innerHTML = '';
    if (messages.length > 0) {
        messages.forEach(msg => {
            const messageDiv = document.createElement('div');
            const isUser = msg.sender === 'user' || (msg.userId === XY_CURRENT_USER_ID && msg.sender !== 'seller' && msg.sender !== 'buyer');
            const isSystem = msg.sender === 'system';
            
            messageDiv.className = `xy-message-item ${isUser ? 'xy-message-user' : isSystem ? 'xy-message-system' : 'xy-message-seller'}`;
            
            const time = new Date(msg.createdAt);
            const timeStr = `${time.getHours().toString().padStart(2, '0')}:${time.getMinutes().toString().padStart(2, '0')}`;
            
            let senderName = '';
            if (!isUser && !isSystem) {
                const goodsData = XianyuAppState.currentGoods;
                const displayName = (goodsData && goodsData.sellerName) ? goodsData.sellerName : (msg.senderId || 'å–å®¶');
                senderName = `<div style="font-size: 11px; color: #999; margin-bottom: 3px;">${displayName}</div>`;
            }
            
            messageDiv.innerHTML = `
                ${senderName}
                <div class="xy-message-bubble">${msg.content}</div>
                <div class="xy-message-time">${timeStr}</div>
            `;
            container.appendChild(messageDiv);
        });
    } else {
        container.innerHTML = '<div style="text-align: center; padding: 50px; color: #ccc;">è¿˜æ²¡æœ‰æ¶ˆæ¯ï¼Œå¼€å§‹èŠå¤©å§ï¼</div>';
    }
    
    container.scrollTop = container.scrollHeight;
}

// è·å–é—²é±¼çš„APIé…ç½®ï¼ˆä½¿ç”¨é¡¹ç›®çš„db.dexiDataï¼‰
async function getXianyuApiConfig() {
    const urlItem = await db.dexiData.get('aiBaseUrl');
    const keyItem = await db.dexiData.get('aiApiKey');
    const modelItem = await db.dexiData.get('aiCurrentModel');
    const tempItem = await db.dexiData.get('aiTemperature');

    let baseUrl = urlItem?.value || 'https://api.openai.com/v1';
    if (baseUrl.endsWith('/')) baseUrl = baseUrl.slice(0, -1);
    if (!baseUrl.includes('/v1')) {
        baseUrl += '/v1';
    }
    const apiUrl = baseUrl + '/chat/completions';

    return {
        apiUrl: apiUrl,
        apiKey: keyItem?.value || '',
        model: modelItem?.value || 'gpt-3.5-turbo',
        temperature: parseFloat(tempItem?.value) || 0.8
    };
}

async function xianyuSendMessage() {
    const input = document.getElementById('xyChatInput');
    if (!input) return;
    const content = input.value.trim();
    if (!content || !XianyuAppState.currentGoods) return;
    
    const goods = XianyuAppState.currentGoods;
    const seller = await xianyuDb.users.get(goods.userId);
    const currentUser = await xianyuDb.users.get(XY_CURRENT_USER_ID);
    const currentUserId = currentUser ? (currentUser.userId || `user_${XY_CURRENT_USER_ID}`) : `user_${XY_CURRENT_USER_ID}`;
    
    if (seller && seller.blockedUsers && seller.blockedUsers.includes(currentUserId)) {
        alert('æ‚¨å·²è¢«å–å®¶æ‹‰é»‘ï¼Œæ— æ³•å‘é€æ¶ˆæ¯');
        return;
    }
    
    await xianyuDb.messages.add({
        goodsId: goods.id,
        content: content,
        sender: 'user',
        userId: XY_CURRENT_USER_ID,
        senderId: XY_CURRENT_USER_ID,
        role: 'buyer',
        createdAt: new Date()
    });
    
    const existingSession = await xianyuDb.chatSessions.where('goodsId').equals(goods.id).first();
    if (existingSession) {
        await xianyuDb.chatSessions.update(existingSession.id, {
            lastMessage: content,
            updatedAt: new Date()
        });
    } else {
        await xianyuDb.chatSessions.add({
            goodsId: goods.id,
            lastMessage: content,
            updatedAt: new Date(),
            userId: XY_CURRENT_USER_ID
        });
    }
    
    input.value = '';
    xianyuLoadChatMessages(goods.id);
    
    if (XianyuAppState.currentPage === 'xyMessageListPage') {
        xianyuLoadMessageList();
    }
}

// æ¥æ”¶å›å¤æŒ‰é’® - æ‰‹åŠ¨è§¦å‘AIå›å¤
async function xianyuReceiveReply() {
    const goods = XianyuAppState.currentGoods;
    if (!goods) {
        alert('å½“å‰æ²¡æœ‰å•†å“ä¿¡æ¯');
        return;
    }
    
    // è·å–æœ€åä¸€æ¡ç”¨æˆ·æ¶ˆæ¯ä½œä¸ºä¸Šä¸‹æ–‡
    const messages = await xianyuDb.messages
        .where('goodsId').equals(goods.id)
        .toArray();
    
    const userMessages = messages.filter(m => m.sender === 'user');
    const lastUserMessage = userMessages.length > 0 ? userMessages[userMessages.length - 1].content : 'ä½ å¥½';
    
    // æŒ‰é’®loadingçŠ¶æ€
    const btn = document.querySelector('.xy-chat-receive-btn');
    if (btn) {
        btn.classList.add('loading');
        btn.textContent = 'ç­‰å¾…å›å¤...';
    }
    
    try {
        await xianyuGenerateAIResponse(goods.id, lastUserMessage, goods);
    } catch (e) {
        console.error('æ¥æ”¶å›å¤å¤±è´¥:', e);
        alert('æ¥æ”¶å›å¤å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
        if (btn) {
            btn.classList.remove('loading');
            btn.textContent = 'æ¥æ”¶å›å¤';
        }
    }
}

async function xianyuGenerateAIResponse(goodsId, userMessage, goods) {
    try {
        const config = await getXianyuApiConfig();
        const worldView = localStorage.getItem('xyWorldView') || '';
        
        if (!config.apiKey) {
            xianyuDefaultResponse(goodsId, userMessage, goods);
            return;
        }
        
        const seller = await xianyuDb.users.get(goods.userId);
        const sellerId = seller ? seller.userId : `seller_${goods.userId}`;
        const sellerName = goods.sellerName || 'å–å®¶';
        
        // å°è¯•ä»db.charactersä¸­æŸ¥æ‰¾åŒåè§’è‰²ï¼Œè·å–äººè®¾
        let sellerPersonality = '';
        try {
            const allChars = await db.characters.toArray();
            const matchedChar = allChars.find(c => 
                (c.nick === sellerName || c.name === sellerName) && c.type !== 'user'
            );
            if (matchedChar) {
                sellerPersonality = `\nã€ä½ çš„è§’è‰²äººè®¾ã€‘\nåå­—ï¼š${matchedChar.name}${matchedChar.nick ? `\næ˜µç§°ï¼š${matchedChar.nick}` : ''}${matchedChar.description ? `\nè®¾å®šï¼š${matchedChar.description}` : ''}`;
            }
        } catch(e) { console.log('è·å–è§’è‰²äººè®¾å¤±è´¥:', e); }
        
        // è·å–èŠå¤©å†å²ä½œä¸ºä¸Šä¸‹æ–‡
        const allMessages = await xianyuDb.messages
            .where('goodsId').equals(goodsId)
            .toArray();
        allMessages.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
        
        // æ„å»ºå¯¹è¯å†å²
        const chatHistory = allMessages.slice(-10).map(m => {
            return m.sender === 'user' ? `ä¹°å®¶ï¼š${m.content}` : `${sellerName}ï¼š${m.content}`;
        }).join('\n');
        
        // è·å–ä¹°å®¶åå­—
        const buyerName = window.xianyuCurrentAccountName || 'ä¹°å®¶';
        
        const systemPrompt = `ä½ æ˜¯é—²é±¼å–å®¶"${sellerName}"ï¼Œæ­£åœ¨å’Œä¹°å®¶"${buyerName}"èŠå¤©ã€‚${worldView ? `ä¸–ç•Œè§‚ï¼š${worldView}ã€‚` : ''}
å•†å“ä¿¡æ¯ï¼š${goods.title}ï¼Œå½“å‰ä»·æ ¼ï¼šÂ¥${goods.price}ã€‚
${sellerPersonality}

è¯·ä»¥"${sellerName}"çš„èº«ä»½å’Œè¯­æ°”å›å¤ã€‚å¦‚æœä½ æœ‰è§’è‰²äººè®¾ï¼Œå¿…é¡»ä¸¥æ ¼æŒ‰ç…§äººè®¾çš„æ€§æ ¼æ¥å›å¤ã€‚
ä½ å¯èƒ½ä¼šä¹Ÿå¯èƒ½ä¸ä¼šæ„è¯†åˆ°ä¹°å®¶æ˜¯è°ï¼Œè¿™å–å†³äºä½ çš„åˆ¤æ–­ã€‚`;

        const userPrompt = `ä»¥ä¸‹æ˜¯èŠå¤©è®°å½•ï¼š
${chatHistory}

å›å¤è§„åˆ™ï¼š
1. å¦‚æœä¹°å®¶ç ä»·ï¼Œä½ ä¸ä¸€å®šè¦åŒæ„ã€‚æ‹’ç»æ—¶ä¸è¦æåˆ°å…·ä½“ä»·æ ¼æ•°å­—
2. å¦‚æœä½ ä¸»åŠ¨åŒæ„é™ä»·ï¼Œç”¨è¿™ä¸ªç‰¹æ®Šæ ¼å¼æ ‡è®°æ–°ä»·æ ¼ï¼šã€æ”¹ä»·:æ•°å­—ã€‘ï¼Œä¾‹å¦‚ã€æ”¹ä»·:85ã€‘
3. å¦‚æœä¸åŒæ„é™ä»·ï¼Œå°±æ­£å¸¸æ‹’ç»ï¼Œç»å¯¹ä¸è¦å‡ºç°ã€æ”¹ä»·:ã€‘æ ‡è®°
4. å›å¤è¦è‡ªç„¶ã€å£è¯­åŒ–ï¼Œç¬¦åˆä½ çš„äººè®¾
5. ä½ å¯ä»¥åˆ†å¤šæ¡æ¶ˆæ¯å›å¤ï¼Œæ¯æ¡æ¶ˆæ¯ç”¨ ||| åˆ†éš”ã€‚æ¯”å¦‚"ä½ å¥½|||è¿™ä¸ªè¿˜åœ¨çš„|||è¦çš„è¯æ‹ä¸‹å§"
6. æ¯æ¡æ¶ˆæ¯è¦çŸ­å°ç²¾æ‚ï¼ŒåƒçœŸå®èŠå¤©ä¸€æ ·

è¯·åªå›å¤æ¶ˆæ¯å†…å®¹ï¼Œä¸è¦åŠ ä»»ä½•å‰ç¼€ã€‚`;
        
        const response = await fetch(config.apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${config.apiKey}`
            },
            body: JSON.stringify({
                model: config.model,
                messages: [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: userPrompt }
                ],
                temperature: config.temperature
            })
        });
        
        if (!response.ok) {
            throw new Error('APIè°ƒç”¨å¤±è´¥');
        }
        
        const data = await response.json();
        const aiResponse = data.choices[0].message.content.trim();
        
        // åªåœ¨AIæ˜ç¡®æ ‡è®°ã€æ”¹ä»·:æ•°å­—ã€‘æ—¶æ‰æ”¹ä»·
        const priceMatch = aiResponse.match(/ã€æ”¹ä»·[:ï¼š](\d+(?:\.\d+)?)ã€‘/);
        if (priceMatch) {
            const newPrice = parseFloat(priceMatch[1]);
            if (newPrice < goods.price && newPrice > 0) {
                await xianyuDb.goods.update(goodsId, { 
                    price: newPrice,
                    originalPrice: goods.originalPrice || goods.price
                });
                XianyuAppState.currentGoods.price = newPrice;
                const priceEl1 = document.getElementById('xyChatGoodsPrice');
                const priceEl2 = document.getElementById('xyDetailPrice');
                if (priceEl1) priceEl1.textContent = `Â¥${newPrice}`;
                if (priceEl2) priceEl2.textContent = `Â¥${newPrice}`;
            }
        }
        
        // æ¸…ç†å›å¤ä¸­çš„ç‰¹æ®Šæ ‡è®°
        const cleanResponse = aiResponse.replace(/ã€æ”¹ä»·[:ï¼š]\d+(?:\.\d+)?ã€‘/g, '').trim();
        
        // å°†å›å¤æŒ‰ ||| åˆ†éš”ä¸ºå¤šæ¡æ¶ˆæ¯ï¼Œé€æ¡å‘é€
        const messageParts = cleanResponse.split('|||').map(s => s.trim()).filter(s => s.length > 0);
        
        if (messageParts.length === 0) {
            messageParts.push(cleanResponse || 'å—¯å—¯');
        }
        
        // é€æ¡å‘é€æ¶ˆæ¯ï¼Œæ¯æ¡ä¹‹é—´æœ‰å»¶è¿Ÿ
        for (let i = 0; i < messageParts.length; i++) {
            const msgContent = messageParts[i];
            
            if (i > 0) {
                // éé¦–æ¡æ¶ˆæ¯ï¼Œç­‰å¾…ä¸€æ®µæ—¶é—´æ¨¡æ‹Ÿæ‰“å­—
                await new Promise(resolve => setTimeout(resolve, 600 + Math.random() * 800));
            }
            
            await xianyuDb.messages.add({
                goodsId: goodsId,
                content: msgContent,
                sender: 'seller',
                userId: goods.userId,
                senderId: sellerId,
                role: 'seller',
                createdAt: new Date()
            });
            
            // æ›´æ–°ä¼šè¯
            const existingSession = await xianyuDb.chatSessions.where('goodsId').equals(goodsId).first();
            if (existingSession) {
                await xianyuDb.chatSessions.update(existingSession.id, {
                    lastMessage: msgContent,
                    updatedAt: new Date()
                });
            } else {
                await xianyuDb.chatSessions.add({
                    goodsId: goodsId,
                    lastMessage: msgContent,
                    updatedAt: new Date(),
                    userId: XY_CURRENT_USER_ID
                });
            }
            
            // æ¯æ¡æ¶ˆæ¯å‘é€åç«‹å³åˆ·æ–°èŠå¤©ç•Œé¢
            xianyuLoadChatMessages(goodsId);
        }
        
        if (XianyuAppState.currentPage === 'xyMessageListPage') {
            xianyuLoadMessageList();
        }
    } catch (error) {
        console.error('AIå›å¤ç”Ÿæˆå¤±è´¥:', error);
        xianyuDefaultResponse(goodsId, userMessage, goods);
    }
}

async function xianyuDefaultResponse(goodsId, userMessage, goods) {
    const lowerMessage = userMessage.toLowerCase();
    let responses = [];
    
    if (lowerMessage.includes('ä¾¿å®œ') || lowerMessage.includes('é™ä»·') || lowerMessage.includes('ç ä»·')) {
        // é»˜è®¤å›å¤ä¸æ”¹ä»·ï¼Œåªæ˜¯å£å¤´å›åº”
        responses = ['è¿™ä¸ªä»·æ ¼å·²ç»å¾ˆå®æƒ äº†', 'ä¸å¥½æ„æ€ï¼Œä¸å¤ªèƒ½é™äº†'];
    } else if (lowerMessage.includes('åŒ…é‚®') || lowerMessage.includes('è¿è´¹')) {
        responses = ['åŒ…é‚®çš„ï¼Œæ”¾å¿ƒè´­ä¹°ï½'];
    } else if (lowerMessage.includes('è´¨é‡') || lowerMessage.includes('æ–°æ—§')) {
        responses = ['è´¨é‡å¾ˆå¥½çš„', 'å‡ ä¹å…¨æ–°ï¼Œå¯ä»¥æ”¾å¿ƒ'];
    } else {
        const defaultReplies = [
            ['æ‚¨å¥½ï¼Œæœ‰ä»€ä¹ˆå¯ä»¥å¸®æ‚¨çš„ï¼Ÿ'],
            ['åœ¨çš„', 'è¿™ä¸ªå•†å“è¿˜æœ‰å“¦'],
            ['æ„Ÿå…´è¶£çš„è¯å¯ä»¥ç›´æ¥æ‹ä¸‹å“¦'],
            ['æœ‰ç°è´§', 'ä»Šå¤©å¯ä»¥å‘è´§']
        ];
        responses = defaultReplies[Math.floor(Math.random() * defaultReplies.length)];
    }
    
    const seller = await xianyuDb.users.get(goods.userId);
    const sellerId = seller ? seller.userId : `seller_${goods.userId}`;
    
    for (let i = 0; i < responses.length; i++) {
        if (i > 0) {
            await new Promise(resolve => setTimeout(resolve, 500 + Math.random() * 500));
        }
        
        await xianyuDb.messages.add({
            goodsId: goodsId,
            content: responses[i],
            sender: 'seller',
            userId: goods.userId,
            senderId: sellerId,
            role: 'seller',
            createdAt: new Date()
        });
        
        const existingSession = await xianyuDb.chatSessions.where('goodsId').equals(goodsId).first();
        if (existingSession) {
            await xianyuDb.chatSessions.update(existingSession.id, {
                lastMessage: responses[i],
                updatedAt: new Date()
            });
        } else {
            await xianyuDb.chatSessions.add({
                goodsId: goodsId,
                lastMessage: responses[i],
                updatedAt: new Date(),
                userId: XY_CURRENT_USER_ID
            });
        }
        
        xianyuLoadChatMessages(goodsId);
    }
    
    if (XianyuAppState.currentPage === 'xyMessageListPage') {
        xianyuLoadMessageList();
    }
}

function xianyuSendQuickMessage(content) {
    const input = document.getElementById('xyChatInput');
    if (input) input.value = content;
    xianyuSendMessage();
}

async function xianyuPublishGoods() {
    const title = document.getElementById('xyPublishTitle').value;
    const price = document.getElementById('xyPublishPrice').value;
    const category = document.getElementById('xyPublishCategory').value;
    const description = document.getElementById('xyPublishDesc').value;
    
    if (!title || !price) {
        alert('è¯·å¡«å†™æ ‡é¢˜å’Œä»·æ ¼');
        return;
    }
    
    // è·å–å½“å‰è´¦å·åå­—ä½œä¸ºå–å®¶å
    let mySellerName = window.xianyuCurrentAccountName || 'æˆ‘';
    try {
        const accountChar = await db.characters.get(XY_CURRENT_USER_ID);
        if (accountChar) mySellerName = accountChar.nick || accountChar.name || mySellerName;
    } catch(e) {}
    
    const newGoods = {
        title: title,
        price: parseFloat(price),
        category: category,
        description: description || 'å•†å“æè¿°',
        sellerName: mySellerName,
        tips: 'å…·ä½“è¯·ç§èŠå’¨è¯¢',
        postage: 'åŒ…é‚®',
        metaKey: 'ç±»åˆ«',
        metaVal: category,
        viewCount: 0,
        wantCount: 0,
        collected: false,
        userId: XY_CURRENT_USER_ID,
        sellerId: `seller_${XY_CURRENT_USER_ID}`,
        originalPrice: parseFloat(price),
        sold: 0,
        bought: 0,
        createdAt: new Date()
    };
    
    const goodsId = await xianyuDb.goods.add(newGoods);
    xianyuHidePublishDialog();
    xianyuLoadGoods();
    xianyuShowDataStatus('å•†å“å‘å¸ƒæˆåŠŸ');
    await xianyuUpdateMyPageStats();
    
    setTimeout(() => {
        xianyuGenerateBuyerMessage(goodsId, newGoods);
    }, 2000);
}

async function xianyuGenerateBuyerMessage(goodsId, goods) {
    try {
        const config = await getXianyuApiConfig();
        const worldView = localStorage.getItem('xyWorldView') || '';
        
        const buyerId = `buyer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        await xianyuDb.characters.add({
            userId: buyerId,
            role: 'buyer',
            personality: 'æ™®é€šä¹°å®¶',
            worldView: worldView,
            createdAt: new Date()
        });
        
        const buyerUserId = await xianyuDb.users.add({
            username: `ä¹°å®¶${Math.random().toString(36).substr(2, 6)}`,
            avatar: 'fa-user',
            userId: buyerId,
            role: 'buyer',
            blockedUsers: [],
            createdAt: new Date()
        });
        
        let buyerMessage = '';
        
        if (config.apiUrl && config.apiKey) {
            const prompt = `ä½ æ˜¯ä¸€ä¸ªé—²é±¼ä¹°å®¶ï¼Œçœ‹åˆ°å•†å“"${goods.title}"ï¼Œä»·æ ¼Â¥${goods.price}ã€‚${worldView ? `ä¸–ç•Œè§‚ï¼š${worldView}` : ''}

è¯·ç”Ÿæˆä¸€æ¡ä¹°å®¶ç§ä¿¡ï¼Œå¯ä»¥æ˜¯ï¼š
1. è¯¢é—®å•†å“è¯¦æƒ…
2. ç ä»·
3. è¯¢é—®å‘è´§æ—¶é—´
4. å…¶ä»–åˆç†çš„é—®é¢˜

è¯·åªå›å¤æ¶ˆæ¯å†…å®¹ï¼Œè¦è‡ªç„¶ã€ç¬¦åˆé—²é±¼ä¹°å®¶çš„è¯­æ°”ã€‚`;
            
            try {
                const response = await fetch(config.apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${config.apiKey}`
                    },
                    body: JSON.stringify({
                        model: config.model,
                        messages: [
                            { role: 'system', content: 'ä½ æ˜¯ä¸€ä¸ªé—²é±¼ä¹°å®¶ï¼Œæ­£åœ¨è¯¢é—®å•†å“ä¿¡æ¯ã€‚' },
                            { role: 'user', content: prompt }
                        ],
                        temperature: config.temperature
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    buyerMessage = data.choices[0].message.content.trim();
                }
            } catch (e) {
                console.error('ç”Ÿæˆä¹°å®¶æ¶ˆæ¯APIå¤±è´¥:', e);
            }
        }
        
        if (!buyerMessage) {
            const messages = [
                `ä½ å¥½ï¼Œè¿™ä¸ª${goods.title}è¿˜åœ¨å—ï¼Ÿ`,
                `å¯ä»¥ä¾¿å®œç‚¹å—ï¼Ÿ`,
                `è¿™ä¸ªå•†å“åŒ…é‚®å—ï¼Ÿ`,
                `ä»€ä¹ˆæ—¶å€™å¯ä»¥å‘è´§ï¼Ÿ`,
                `å•†å“æ˜¯å…¨æ–°çš„å—ï¼Ÿ`
            ];
            buyerMessage = messages[Math.floor(Math.random() * messages.length)];
        }
        
        await xianyuDb.messages.add({
            goodsId: goodsId,
            content: buyerMessage,
            sender: 'buyer',
            userId: buyerUserId,
            senderId: buyerId,
            role: 'buyer',
            createdAt: new Date()
        });
        
        const existingSession = await xianyuDb.chatSessions.where('goodsId').equals(goodsId).first();
        if (existingSession) {
            await xianyuDb.chatSessions.update(existingSession.id, {
                lastMessage: buyerMessage,
                updatedAt: new Date()
            });
        } else {
            await xianyuDb.chatSessions.add({
                goodsId: goodsId,
                lastMessage: buyerMessage,
                updatedAt: new Date(),
                userId: XY_CURRENT_USER_ID
            });
        }
        
        xianyuShowDataStatus('æœ‰ä¹°å®¶æ¥ç§ä¿¡äº†ï¼');
        
        if (XianyuAppState.currentPage === 'xyMessageListPage') {
            xianyuLoadMessageList();
        }
    } catch (error) {
        console.error('ç”Ÿæˆä¹°å®¶æ¶ˆæ¯å¤±è´¥:', error);
    }
}

function xianyuShowMyGoods() { XianyuAppState.navigateTo('xyMyGoodsPage'); }
function xianyuShowMySold() { XianyuAppState.navigateTo('xyMySoldPage'); }
function xianyuShowMyBought() { XianyuAppState.navigateTo('xyMyBoughtPage'); }
function xianyuShowMyCollections() { XianyuAppState.navigateTo('xyMyCollectionsPage'); }
function xianyuShowMyChats() { alert('æˆ‘çš„èŠå¤©åŠŸèƒ½å¾…å¼€å‘'); }
function xianyuShowMyOrders() { alert('æˆ‘çš„è®¢å•åŠŸèƒ½å¾…å¼€å‘'); }
function xianyuShowMyWallet() { alert('æˆ‘çš„é’±åŒ…åŠŸèƒ½å¾…å¼€å‘'); }
function xianyuShowDataManagement() { xianyuShowSettingsDialog(); }

async function xianyuExportData() {
    const allData = {
        goods: await xianyuDb.goods.toArray(),
        collections: await xianyuDb.collections.toArray(),
        messages: await xianyuDb.messages.toArray(),
        users: await xianyuDb.users.toArray(),
        orders: await xianyuDb.orders.toArray(),
        exportDate: new Date().toISOString()
    };
    const dataStr = JSON.stringify(allData, null, 2);
    const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
    const exportFileDefaultName = 'xianyu_data.json';
    const linkElement = document.createElement('a');
    linkElement.setAttribute('href', dataUri);
    linkElement.setAttribute('download', exportFileDefaultName);
    linkElement.click();
    xianyuShowDataStatus('æ•°æ®å·²å¯¼å‡º');
}

function xianyuImportData() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = async (e) => {
        const file = e.target.files[0];
        const reader = new FileReader();
        reader.onload = async (event) => {
            try {
                const data = JSON.parse(event.target.result);
                await xianyuDb.goods.clear();
                await xianyuDb.collections.clear();
                await xianyuDb.messages.clear();
                await xianyuDb.users.clear();
                await xianyuDb.orders.clear();
                if (data.goods) await xianyuDb.goods.bulkAdd(data.goods);
                if (data.collections) await xianyuDb.collections.bulkAdd(data.collections);
                if (data.messages) await xianyuDb.messages.bulkAdd(data.messages);
                if (data.users) await xianyuDb.users.bulkAdd(data.users);
                if (data.orders) await xianyuDb.orders.bulkAdd(data.orders);
                xianyuShowDataStatus('æ•°æ®å¯¼å…¥æˆåŠŸ');
                xianyuLoadGoods();
                xianyuLoadUserInfo();
                xianyuHideSettingsDialog();
            } catch (error) {
                alert('æ•°æ®å¯¼å…¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼');
            }
        };
        reader.readAsText(file);
    };
    input.click();
}

async function xianyuClearAllData() {
    if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æ•°æ®å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ï¼')) {
        await xianyuDb.goods.clear();
        await xianyuDb.collections.clear();
        await xianyuDb.messages.clear();
        await xianyuDb.orders.clear();
        xianyuShowDataStatus('æ•°æ®å·²æ¸…ç©º');
        xianyuLoadGoods();
        xianyuLoadUserInfo();
        xianyuHideSettingsDialog();
    }
}

async function xianyuResetToDefault() {
    if (confirm('ç¡®å®šè¦æ¸…ç©ºå¹¶é‡ç½®æ•°æ®å—ï¼Ÿå½“å‰æ•°æ®å°†ä¼šè¢«æ¸…ç©ºï¼')) {
        await xianyuDb.goods.clear();
        await xianyuDb.collections.clear();
        await xianyuDb.messages.clear();
        await xianyuDb.orders.clear();
        await xianyuDb.users.clear();
        await xianyuInitializeUser();
        xianyuShowDataStatus('æ•°æ®å·²é‡ç½®');
        xianyuLoadGoods();
        xianyuLoadUserInfo();
        xianyuHideSettingsDialog();
    }
}

function xianyuShowGenerateDialog() {
    const dialog = document.getElementById('xyGenerateDialog');
    if (!dialog) return;
    const savedWorldView = localStorage.getItem('xyWorldView') || '';
    const input = document.getElementById('xyWorldViewInput');
    if (input) input.value = savedWorldView;
    dialog.style.display = 'flex';
}

function xianyuHideGenerateDialog() {
    const el = document.getElementById('xyGenerateDialog');
    if (el) el.style.display = 'none';
}

async function xianyuGenerateGoods() {
    const worldViewInput = document.getElementById('xyWorldViewInput');
    const worldView = worldViewInput ? worldViewInput.value.trim() : '';
    
    const config = await getXianyuApiConfig();
    
    if (!config.apiKey) {
        alert('è¯·å…ˆåœ¨æ¡Œé¢è®¾ç½®ä¸­é…ç½®APIå¯†é’¥');
        return;
    }
    
    if (worldView) {
        localStorage.setItem('xyWorldView', worldView);
    }
    
    xianyuShowDataStatus('æ­£åœ¨ç”Ÿæˆå•†å“...');
    
    try {
        // è·å–éuserç±»å‹çš„è§’è‰²ï¼Œç”¨äºéšæœºåˆ†é…ä¸ºå–å®¶ï¼ˆæ’é™¤æ‰€æœ‰ç”¨æˆ·è´¦å·ï¼‰
        let allCharacters = [];
        try {
            const allChars = await db.characters.toArray();
            allCharacters = allChars.filter(c => c.type !== 'user');
        } catch(e) { console.error('è·å–è§’è‰²åˆ—è¡¨å¤±è´¥:', e); }
        
        // æ„å»ºè§’è‰²åå•æç¤º
        let characterHint = '';
        if (allCharacters.length > 0) {
            const charNames = allCharacters.map(c => c.nick || c.name).filter(Boolean);
            if (charNames.length > 0) {
                characterHint = `\n\nå¯ç”¨çš„å–å®¶è§’è‰²åå•ï¼š${charNames.join('ã€')}ã€‚å¯ä»¥ä»è¿™äº›è§’è‰²ä¸­éšæœºé€‰æ‹©ä½œä¸ºå–å®¶ï¼Œä¹Ÿå¯ä»¥è‡ªåˆ›ä¸€äº›æœ‰ä¸ªæ€§çš„å–å®¶åå­—ï¼Œä¸¤è€…æ··æ­ã€‚æ¯ä¸ªè§’è‰²å¯ä»¥å–å¤šä¸ªå•†å“ï¼Œè¦ç¬¦åˆè§’è‰²çš„æ€§æ ¼å’Œèº«ä»½ã€‚`;
            }
        }
        
        const prompt = `è¯·ç”Ÿæˆè‡³å°‘10ä¸ªé—²é±¼å•†å“ä¿¡æ¯ã€‚${worldView ? `ä¸–ç•Œè§‚ï¼š${worldView}ã€‚è¯·æ ¹æ®è¿™ä¸ªä¸–ç•Œè§‚ç”Ÿæˆç¬¦åˆçš„å•†å“ã€‚` : ''}${characterHint}

æ¯ä¸ªå•†å“éœ€è¦åŒ…å«ï¼š
- title: å•†å“æ ‡é¢˜ï¼ˆç®€çŸ­å¸å¼•äººï¼ŒåƒçœŸå®é—²é±¼ç”¨æˆ·å‘çš„ï¼‰
- price: ä»·æ ¼ï¼ˆåˆç†èŒƒå›´ï¼Œæ•°å­—ï¼‰
- category: ç±»åˆ«ï¼ˆå¥³è£…/ç¾å¦†/æ•°ç /å›¾ä¹¦/å…¶ä»–ï¼‰
- description: å•†å“æè¿°ï¼ˆç®€çŸ­ï¼‰
- sellerName: å–å®¶åå­—ï¼ˆä»è§’è‰²åå•ä¸­é€‰æ‹©ï¼Œæˆ–è‡ªåˆ›ä¸€ä¸ªæœ‰ä¸ªæ€§çš„åå­—ï¼Œéšæœºæ··æ­ï¼Œä¸è¦å‡ºç°"ç”¨æˆ·"äºŒå­—ï¼‰

è¯·ä»¥JSONæ ¼å¼è¿”å›ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
[
  {"title": "å•†å“æ ‡é¢˜", "price": ä»·æ ¼æ•°å­—, "category": "ç±»åˆ«", "description": "å•†å“æè¿°", "sellerName": "å–å®¶åå­—"},
  ...
]

è‡³å°‘ç”Ÿæˆ10ä¸ªå•†å“ã€‚`;
        
        const response = await fetch(config.apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${config.apiKey}`
            },
            body: JSON.stringify({
                model: config.model,
                messages: [
                    { role: 'system', content: 'ä½ æ˜¯ä¸€ä¸ªå•†å“ç”ŸæˆåŠ©æ‰‹ï¼Œä¸“é—¨ç”Ÿæˆé—²é±¼å•†å“ä¿¡æ¯ã€‚æ¯ä¸ªå•†å“éƒ½å¿…é¡»æœ‰ä¸€ä¸ªå–å®¶åå­—ã€‚' },
                    { role: 'user', content: prompt }
                ],
                temperature: config.temperature
            })
        });
        
        if (!response.ok) {
            throw new Error('APIè°ƒç”¨å¤±è´¥');
        }
        
        const data = await response.json();
        let goodsList = [];
        
        try {
            const content = data.choices[0].message.content.trim();
            const jsonMatch = content.match(/\[[\s\S]*\]/);
            if (jsonMatch) {
                goodsList = JSON.parse(jsonMatch[0]);
            } else {
                throw new Error('æ— æ³•è§£æJSON');
            }
        } catch (parseError) {
            console.error('è§£æå¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å•†å“:', parseError);
            goodsList = xianyuGenerateDefaultGoods(worldView);
        }
        
        if (goodsList.length < 10) {
            const defaultGoods = xianyuGenerateDefaultGoods(worldView);
            goodsList = goodsList.concat(defaultGoods.slice(0, 10 - goodsList.length));
        }
        
        for (const item of goodsList.slice(0, Math.max(10, goodsList.length))) {
            const sellerName = item.sellerName || `ç”¨æˆ·${Math.random().toString(36).substr(2, 6)}`;
            const sellerId = `seller_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            
            // æŸ¥æ‰¾æ˜¯å¦æœ‰åŒ¹é…çš„è§’è‰²
            let sellerAvatar = 'fa-user';
            let matchedChar = null;
            if (allCharacters.length > 0) {
                matchedChar = allCharacters.find(c => 
                    (c.nick && c.nick === sellerName) || (c.name && c.name === sellerName)
                );
            }
            if (matchedChar && matchedChar.avatar) {
                sellerAvatar = matchedChar.avatar;
            }
            
            await xianyuDb.characters.add({
                userId: sellerId,
                role: 'seller',
                personality: sellerName,
                worldView: worldView,
                createdAt: new Date()
            });
            
            const sellerUserId = await xianyuDb.users.add({
                username: sellerName,
                avatar: sellerAvatar,
                userId: sellerId,
                role: 'seller',
                blockedUsers: [],
                createdAt: new Date()
            });
            
            await xianyuDb.goods.add({
                title: item.title || 'å•†å“æ ‡é¢˜',
                price: item.price || Math.floor(Math.random() * 500) + 10,
                category: item.category || 'å…¶ä»–',
                description: item.description || 'å•†å“æè¿°',
                sellerName: sellerName,
                sellerAvatar: sellerAvatar,
                tips: 'å…·ä½“è¯·ç§èŠå’¨è¯¢',
                postage: 'åŒ…é‚®',
                metaKey: 'ç±»åˆ«',
                metaVal: item.category || 'å…¶ä»–',
                viewCount: Math.floor(Math.random() * 100),
                wantCount: Math.floor(Math.random() * 10),
                collected: false,
                userId: sellerUserId,
                sellerId: sellerId,
                originalPrice: item.price || Math.floor(Math.random() * 500) + 10,
                sold: 0,
                bought: 0,
                createdAt: new Date()
            });
        }
        
        xianyuHideGenerateDialog();
        xianyuLoadGoods();
        xianyuShowDataStatus(`æˆåŠŸç”Ÿæˆ${Math.max(10, goodsList.length)}ä¸ªå•†å“ï¼`);
    } catch (error) {
        console.error('ç”Ÿæˆå•†å“å¤±è´¥:', error);
        alert('ç”Ÿæˆå•†å“å¤±è´¥ï¼Œè¯·æ£€æŸ¥APIè®¾ç½®');
    }
}

function xianyuGenerateDefaultGoods(worldView) {
    const categories = ['å¥³è£…', 'ç¾å¦†', 'æ•°ç ', 'å›¾ä¹¦', 'å…¶ä»–'];
    const defaultNames = ['å°ç”œç”œ', 'é—²ç½®è¾¾äºº', 'äºŒæ‰‹å°ç‹å­', 'æ¸…ä»“å°‘å¥³', 'å®è—å–å®¶', 'æ‚è´§é“ºè€æ¿', 'ç”œèœœå°é“º', 'æ–‡è‰ºé’å¹´', 'æ•°ç æ§', 'æ—¶å°šè¾£å¦ˆ'];
    const goods = [];
    
    for (let i = 0; i < 10; i++) {
        const category = categories[Math.floor(Math.random() * categories.length)];
        goods.push({
            title: `${category}å•†å“${i + 1}`,
            price: Math.floor(Math.random() * 500) + 10,
            category: category,
            description: `è¿™æ˜¯ä¸€ä¸ª${category}å•†å“ï¼Œ${worldView ? `ç¬¦åˆ${worldView}ä¸–ç•Œè§‚` : 'è´¨é‡å¾ˆå¥½'}`,
            sellerName: defaultNames[i % defaultNames.length]
        });
    }
    
    return goods;
}

function xianyuShowPublishDialog() { 
    const el = document.getElementById('xyPublishDialog');
    if (el) el.style.display = 'flex'; 
}
function xianyuHidePublishDialog() {
    const el = document.getElementById('xyPublishDialog');
    if (el) el.style.display = 'none';
    const t = document.getElementById('xyPublishTitle');
    const p = document.getElementById('xyPublishPrice');
    const d = document.getElementById('xyPublishDesc');
    if (t) t.value = '';
    if (p) p.value = '';
    if (d) d.value = '';
}
function xianyuShowSettings() { xianyuShowSettingsDialog(); }
function xianyuShowSettingsDialog() { 
    const el = document.getElementById('xySettingsDialog');
    if (el) el.style.display = 'flex'; 
}
function xianyuHideSettingsDialog() { 
    const el = document.getElementById('xySettingsDialog');
    if (el) el.style.display = 'none'; 
}

function xianyuEditProfile() {
    xianyuDb.users.get(XY_CURRENT_USER_ID).then(user => {
        if (user) {
            const nameEl = document.getElementById('xyEditUserName');
            const avatarEl = document.getElementById('xyEditUserAvatar');
            if (nameEl) nameEl.value = user.username;
            if (avatarEl) avatarEl.value = user.avatar;
        }
    });
    const el = document.getElementById('xyEditProfileDialog');
    if (el) el.style.display = 'flex';
}

function xianyuHideEditProfileDialog() { 
    const el = document.getElementById('xyEditProfileDialog');
    if (el) el.style.display = 'none'; 
}

async function xianyuSaveProfile() {
    const nameEl = document.getElementById('xyEditUserName');
    const avatarEl = document.getElementById('xyEditUserAvatar');
    const username = nameEl ? nameEl.value : '';
    const avatar = avatarEl ? avatarEl.value : 'fa-user';
    if (!username.trim()) {
        alert('è¯·è¾“å…¥ç”¨æˆ·å');
        return;
    }
    await xianyuDb.users.update(XY_CURRENT_USER_ID, {
        username: username,
        avatar: avatar
    });
    xianyuHideEditProfileDialog();
    xianyuLoadUserInfo();
    xianyuShowDataStatus('èµ„æ–™å·²æ›´æ–°');
}

function xianyuFilterByCategory(category) { xianyuLoadGoods(category); }
function xianyuShowAllGoods() { xianyuLoadGoods(); }
function xianyuSwitchTab(pageId, tabId) { XianyuAppState.switchTab(pageId, tabId); }
function xianyuGoBack() { XianyuAppState.goBack(); }
function xianyuGoBackToMyPage() { XianyuAppState.goBackToMyPage(); }

async function xianyuGoToChat() {
    if (XianyuAppState.currentGoods) {
        const goods = XianyuAppState.currentGoods;
        const priceEl = document.getElementById('xyChatGoodsPrice');
        const descEl = document.getElementById('xyChatGoodsDesc');
        const locEl = document.getElementById('xyChatGoodsLocation');
        if (priceEl) priceEl.textContent = `Â¥${goods.price}`;
        if (descEl) descEl.textContent = goods.postage || 'åŒ…é‚®';
        if (locEl) locEl.textContent = goods.metaVal || 'æœªçŸ¥åœ°åŒº';
        
        const seller = await xianyuDb.users.get(goods.userId);
        const sellerName = goods.sellerName || (seller ? seller.username : 'å–å®¶');
        const roleTag = goods.userId === XY_CURRENT_USER_ID ? 'ä¹°å®¶' : 'å–å®¶';
        const headerEl = document.getElementById('xyChatHeaderName');
        if (headerEl) headerEl.innerHTML = `${sellerName} <span class="xy-credit-tag">${roleTag}</span>`;
        
        XianyuAppState.navigateTo('xyChatPage');
    } else {
        alert('è¯·å…ˆé€‰æ‹©å•†å“');
    }
}

function xianyuBuyNow() {
    if (XianyuAppState.currentGoods) {
        if (confirm(`ç¡®å®šè´­ä¹°å•†å“ï¼š${XianyuAppState.currentGoods.title} ä»·æ ¼ï¼šÂ¥${XianyuAppState.currentGoods.price}ï¼Ÿ`)) {
            xianyuDb.goods.update(XianyuAppState.currentGoods.id, { sold: 1 });
            xianyuDb.orders.add({
                goodsId: XianyuAppState.currentGoods.id,
                goodsTitle: XianyuAppState.currentGoods.title,
                goodsPrice: XianyuAppState.currentGoods.price,
                type: 'buy',
                userId: XY_CURRENT_USER_ID,
                createdAt: new Date()
            });
            xianyuShowDataStatus('è´­ä¹°æˆåŠŸï¼');
            alert('è´­ä¹°æˆåŠŸï¼');
            xianyuUpdateMyPageStats();
        }
    }
}

function xianyuBuyFromChat() { xianyuBuyNow(); }

function xianyuShowChatMenu() {
    const menu = document.getElementById('xyChatMenu');
    if (menu) menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
}

document.addEventListener('click', (e) => {
    const menu = document.getElementById('xyChatMenu');
    if (menu && !menu.contains(e.target) && !e.target.closest('.fa-ellipsis-v')) {
        menu.style.display = 'none';
    }
});

function xianyuShowPriceEditDialog() {
    const goods = XianyuAppState.currentGoods;
    if (!goods) return;
    
    const newPrice = prompt(`å½“å‰ä»·æ ¼ï¼šÂ¥${goods.price}\nè¯·è¾“å…¥æ–°ä»·æ ¼ï¼š`, goods.price);
    if (newPrice && !isNaN(newPrice) && parseFloat(newPrice) > 0) {
        xianyuUpdatePrice(goods.id, parseFloat(newPrice));
    }
    const menu = document.getElementById('xyChatMenu');
    if (menu) menu.style.display = 'none';
}

async function xianyuUpdatePrice(goodsId, newPrice) {
    const goods = await xianyuDb.goods.get(goodsId);
    if (!goods) return;
    
    await xianyuDb.goods.update(goodsId, {
        price: newPrice,
        originalPrice: goods.originalPrice || goods.price
    });
    
    XianyuAppState.currentGoods.price = newPrice;
    const priceEl1 = document.getElementById('xyChatGoodsPrice');
    const priceEl2 = document.getElementById('xyDetailPrice');
    if (priceEl1) priceEl1.textContent = `Â¥${newPrice}`;
    if (priceEl2) priceEl2.textContent = `Â¥${newPrice}`;
    
    const seller = await xianyuDb.users.get(goods.userId);
    const sellerId = seller ? seller.userId : `seller_${goods.userId}`;
    
    await xianyuDb.messages.add({
        goodsId: goodsId,
        content: `ä»·æ ¼å·²æ›´æ–°ä¸ºÂ¥${newPrice}`,
        sender: 'seller',
        userId: goods.userId,
        senderId: sellerId,
        role: 'seller',
        createdAt: new Date()
    });
    
    xianyuLoadChatMessages(goodsId);
    xianyuShowDataStatus('ä»·æ ¼å·²æ›´æ–°');
}

async function xianyuBlockUser() {
    const goods = XianyuAppState.currentGoods;
    if (!goods) return;
    
    const isUserAsSeller = goods.userId === XY_CURRENT_USER_ID;
    let targetUserId = null;
    let targetSenderId = null;
    
    if (isUserAsSeller) {
        const buyerMessage = await xianyuDb.messages.where('goodsId').equals(goods.id).filter(m => m.sender !== 'user' && m.role === 'buyer').first();
        if (buyerMessage) {
            targetUserId = buyerMessage.userId;
            targetSenderId = buyerMessage.senderId;
        }
    } else {
        const seller = await xianyuDb.users.get(goods.userId);
        targetUserId = goods.userId;
        targetSenderId = seller ? seller.userId : `seller_${goods.userId}`;
    }
    
    if (!targetUserId) {
        alert('æ— æ³•ç¡®å®šè¦æ‹‰é»‘çš„ç”¨æˆ·');
        const menu = document.getElementById('xyChatMenu');
        if (menu) menu.style.display = 'none';
        return;
    }
    
    if (confirm('ç¡®å®šè¦æ‹‰é»‘è¯¥ç”¨æˆ·å—ï¼Ÿ')) {
        const currentUser = await xianyuDb.users.get(XY_CURRENT_USER_ID);
        if (!currentUser) {
            alert('ç”¨æˆ·ä¿¡æ¯ä¸å­˜åœ¨');
            const menu = document.getElementById('xyChatMenu');
            if (menu) menu.style.display = 'none';
            return;
        }
        
        const blockedUsers = currentUser.blockedUsers || [];
        
        if (!blockedUsers.includes(targetSenderId)) {
            blockedUsers.push(targetSenderId);
            await xianyuDb.users.update(XY_CURRENT_USER_ID, {
                blockedUsers: blockedUsers
            });
            
            xianyuShowDataStatus('å·²æ‹‰é»‘è¯¥ç”¨æˆ·');
            
            await xianyuDb.messages.add({
                goodsId: goods.id,
                content: 'æ‚¨å·²è¢«æ‹‰é»‘',
                sender: 'system',
                userId: XY_CURRENT_USER_ID,
                senderId: `system_${XY_CURRENT_USER_ID}`,
                role: 'system',
                createdAt: new Date()
            });
            
            xianyuLoadChatMessages(goods.id);
        } else {
            xianyuShowDataStatus('è¯¥ç”¨æˆ·å·²è¢«æ‹‰é»‘');
        }
    }
    
    const menu = document.getElementById('xyChatMenu');
    if (menu) menu.style.display = 'none';
}

// é—²é±¼åˆå§‹åŒ– - ä»…ç»‘å®šäº‹ä»¶ï¼Œæ•°æ®åˆå§‹åŒ–åœ¨é€‰æ‹©è´¦å·åè¿›è¡Œ
document.addEventListener('DOMContentLoaded', async () => {
    try {
        await xianyuDb.open();
        
        const searchInput = document.getElementById('xySearchInput');
        if (searchInput) {
            searchInput.addEventListener('input', (e) => {
                if (e.target.value.trim()) {
                    xianyuSearchGoods(e.target.value.trim());
                } else {
                    xianyuLoadGoods();
                }
            });
        }
        
        const collectBtn = document.getElementById('xyCollectBtn');
        if (collectBtn) {
            collectBtn.addEventListener('click', function() {
                if (XianyuAppState.currentGoods) {
                    xianyuToggleCollect(XianyuAppState.currentGoods.id);
                }
            });
        }
        
        const detailCollectBtn = document.getElementById('xyDetailCollectBtn');
        if (detailCollectBtn) {
            detailCollectBtn.addEventListener('click', function() {
                if (XianyuAppState.currentGoods) {
                    xianyuToggleCollect(XianyuAppState.currentGoods.id);
                }
            });
        }
        
        console.log('[é—²é±¼] äº‹ä»¶ç»‘å®šå®Œæˆï¼Œç­‰å¾…è´¦å·é€‰æ‹©');
    } catch (error) {
        console.error('[é—²é±¼] åˆå§‹åŒ–å¤±è´¥:', error);
    }
});

// é—²é±¼è´¦å·é€‰æ‹©ç›¸å…³å‡½æ•°
function openXianyuApp() {
    document.getElementById('xianyuAppPage').classList.add('active');
    // é‡ç½®åˆ°è´¦å·é€‰æ‹©é¡µé¢
    document.getElementById('xySelectAccountPage').style.display = 'flex';
    document.getElementById('xyMainContent').style.display = 'none';
    XY_CURRENT_USER_ID = null;
    window.xianyuCurrentAccountId = null;
    window.xianyuCurrentAccountName = '';
    // åŠ è½½è´¦å·åˆ—è¡¨
    loadXianyuAccountList();
}

function closeXianyuApp() {
    document.getElementById('xianyuAppPage').classList.remove('active');
    XY_CURRENT_USER_ID = null;
    window.xianyuCurrentAccountId = null;
    window.xianyuCurrentAccountName = '';
}

// é€€å‡ºé—²é±¼ä¸»ç•Œé¢ï¼Œå›åˆ°è´¦å·é€‰æ‹©
function exitXianyuToSelect() {
    document.getElementById('xyMainContent').style.display = 'none';
    document.getElementById('xySelectAccountPage').style.display = 'flex';
    
    // é‡ç½®é¡µé¢çŠ¶æ€
    document.querySelectorAll('#xianyuAppPage .xy-page').forEach(page => {
        page.classList.remove('active');
    });
    const homePage = document.getElementById('xyHomePage');
    if (homePage) homePage.classList.add('active');
    
    // é‡ç½®TabçŠ¶æ€
    document.querySelectorAll('#xianyuAppPage .xy-tab-item').forEach(tab => {
        tab.classList.remove('active');
    });
    const homeTab = document.getElementById('xy-tab-home');
    if (homeTab) homeTab.classList.add('active');
    
    // é‡ç½®XianyuAppState
    XianyuAppState.currentPage = 'xyHomePage';
    XianyuAppState.currentTab = 'xy-tab-home';
    XianyuAppState.pageHistory = ['xyHomePage'];
    XianyuAppState.currentGoods = null;
    
    // æ¸…é™¤å…¨å±€çŠ¶æ€
    XY_CURRENT_USER_ID = null;
    window.xianyuCurrentAccountId = null;
    window.xianyuCurrentAccountName = '';
    
    loadXianyuAccountList();
}

// åŠ è½½å¾®ä¿¡è´¦å·åˆ—è¡¨
async function loadXianyuAccountList() {
    const accounts = await db.characters.where('type').equals('user').toArray();
    const listContainer = document.getElementById('xyAccountList');
    listContainer.innerHTML = '';
    
    if (accounts.length === 0) {
        listContainer.innerHTML = '<div class="xy-select-empty">æš‚æ— å¾®ä¿¡è´¦å·<div class="empty-hint">è¯·å…ˆåˆ›å»º User æ¡£æ¡ˆå¹¶æ³¨å†Œå¾®ä¿¡</div></div>';
        return;
    }
    
    accounts.forEach(account => {
        const item = document.createElement('div');
        item.className = 'xy-account-item';
        item.onclick = () => selectXianyuAccount(account.id, account.name);
        
        const avatarHtml = account.avatar 
            ? `<img src="${account.avatar}" alt="">` 
            : account.name.charAt(0);
        
        item.innerHTML = `
            <div class="xy-account-avatar">${avatarHtml}</div>
            <div class="xy-account-info">
                <div class="xy-account-name">${account.name}</div>
                <div class="xy-account-desc">${account.identity?.phone || account.identity?.wechat_id || 'WeChatç”¨æˆ·'}</div>
            </div>
            <div class="xy-account-arrow">â€º</div>
        `;
        
        listContainer.appendChild(item);
    });
}

// é€‰æ‹©å¾®ä¿¡è´¦å· â†’ ç›´æ¥è¿›å…¥é—²é±¼ä¸»ç•Œé¢
async function selectXianyuAccount(accountId, accountName) {
    XY_CURRENT_USER_ID = accountId;
    window.xianyuCurrentAccountId = accountId;
    window.xianyuCurrentAccountName = accountName;
    
    // è¿›å…¥ä¸»ç•Œé¢
    await enterXianyuMainPage();
}

// è¿›å…¥é—²é±¼ä¸»ç•Œé¢
async function enterXianyuMainPage() {
    document.getElementById('xySelectAccountPage').style.display = 'none';
    document.getElementById('xyMainContent').style.display = 'block';
    
    // æ›´æ–°"æˆ‘çš„"é¡µé¢çš„ç”¨æˆ·ä¿¡æ¯ä¸ºå½“å‰è´¦å·
    if (window.xianyuCurrentAccountId) {
        try {
            const accountChar = await db.characters.get(window.xianyuCurrentAccountId);
            if (accountChar) {
                const accountName = accountChar.nick || accountChar.name || 'ç”¨æˆ·';
                const accountAvatar = accountChar.avatar || '';
                
                const nameEl = document.getElementById('xyUserName');
                const avatarEl = document.getElementById('xyUserAvatar');
                if (nameEl) nameEl.textContent = accountName;
                if (avatarEl) {
                    if (accountAvatar) {
                        avatarEl.innerHTML = `<img src="${accountAvatar}" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">`;
                    } else {
                        avatarEl.innerHTML = `<span style="font-size:24px;color:#e89ab0;">${accountName.charAt(0)}</span>`;
                    }
                }
            }
        } catch(e) {
            console.error('[é—²é±¼] åŠ è½½è´¦å·ä¿¡æ¯å¤±è´¥:', e);
        }
    }
    
    // åˆå§‹åŒ–å½“å‰è´¦å·çš„æ•°æ®
    try {
        await xianyuDb.open().catch(() => {});
        await xianyuInitializeUser();
        await xianyuInitializeDefaultGoods();
        await xianyuLoadGoods();
        
        XianyuAppState.pageHistory = ['xyHomePage'];
        console.log('[é—²é±¼] è´¦å·', window.xianyuCurrentAccountName, 'åˆå§‹åŒ–å®Œæˆ');
    } catch (error) {
        console.error('[é—²é±¼] åˆå§‹åŒ–å¤±è´¥:', error);
    }
}

// ==================== icity æ—¥è®°åº”ç”¨ ====================

// icity å½“å‰é€‰ä¸­çš„è´¦å·IDå’Œè§’è‰²ä¿¡æ¯
window.icityCurrentAccountId = null;
window.icityCurrentAccountName = '';

function openIcityApp() {
    document.getElementById('icityAppPage').classList.add('active');
    // é‡ç½®åˆ°è´¦å·é€‰æ‹©é¡µé¢
    document.getElementById('icitySelectAccountPage').style.display = 'flex';
    document.getElementById('icityMainContent').style.display = 'none';
    window.icityCurrentAccountId = null;
    window.icityCurrentAccountName = '';
    window.icitySelectedRole = null;
    // åŠ è½½è´¦å·åˆ—è¡¨
    loadIcityAccountList();
}

function closeIcityApp() {
    document.getElementById('icityAppPage').classList.remove('active');
    window.icityCurrentAccountId = null;
    window.icityCurrentAccountName = '';
    window.icitySelectedRole = null;
}

// é€€å‡ºicityä¸»ç•Œé¢ï¼Œå›åˆ°è´¦å·é€‰æ‹©
function exitIcityToSelect() {
    document.getElementById('icityMainContent').style.display = 'none';
    document.getElementById('icitySelectAccountPage').style.display = 'flex';
    
    // é‡ç½®é¡µé¢çŠ¶æ€ï¼šç¡®ä¿ä¸‹æ¬¡è¿›å…¥æ—¶ä»åˆ—è¡¨é¡µå¼€å§‹
    const listPage = document.getElementById('icityListPage');
    const detailPage = document.getElementById('icityDetailPage');
    const publishPage = document.getElementById('icityPublishPage');
    const myPage = document.getElementById('icityMyPage');
    if (listPage) listPage.classList.add('active');
    if (detailPage) detailPage.classList.remove('active');
    if (publishPage) publishPage.classList.remove('active');
    if (myPage) myPage.classList.remove('active');
    
    // é‡ç½®TabçŠ¶æ€
    const tabDiary = document.getElementById('icityTabDiary');
    const tabMy = document.getElementById('icityTabMy');
    if (tabDiary) tabDiary.classList.add('active');
    if (tabMy) tabMy.classList.remove('active');
    
    // æ¸…é™¤å…¨å±€çŠ¶æ€
    window.icityCurrentAccountId = null;
    window.icityCurrentAccountName = '';
    window.icityCurrentAccountAvatar = '';
    window.icitySelectedRole = null;
    window.icityInitialized = false;
    
    loadIcityAccountList();
}

// åŠ è½½å¾®ä¿¡è´¦å·åˆ—è¡¨ï¼ˆuserç±»å‹çš„è§’è‰²ï¼‰
async function loadIcityAccountList() {
    const accounts = await db.characters.where('type').equals('user').toArray();
    const listContainer = document.getElementById('icityAccountList');
    listContainer.innerHTML = '';
    
    if (accounts.length === 0) {
        listContainer.innerHTML = '<div class="icity-select-empty">æš‚æ— å¾®ä¿¡è´¦å·<div class="empty-hint">è¯·å…ˆåˆ›å»º User æ¡£æ¡ˆå¹¶æ³¨å†Œå¾®ä¿¡</div></div>';
        return;
    }
    
    accounts.forEach(account => {
        const item = document.createElement('div');
        item.className = 'icity-account-item';
        item.onclick = () => selectIcityAccount(account.id, account.name);
        
        const avatarHtml = account.avatar 
            ? `<img src="${account.avatar}" alt="">` 
            : account.name.charAt(0);
        
        item.innerHTML = `
            <div class="icity-account-avatar">${avatarHtml}</div>
            <div class="icity-account-info">
                <div class="icity-account-name">${account.name}</div>
                <div class="icity-account-desc">${account.identity?.phone || account.identity?.wechat_id || 'WeChatç”¨æˆ·'}</div>
            </div>
            <div class="icity-account-arrow">â€º</div>
        `;
        
        listContainer.appendChild(item);
    });
}

// é€‰æ‹©å¾®ä¿¡è´¦å· â†’ ç›´æ¥è¿›å…¥æ—¥è®°ä¸»ç•Œé¢
async function selectIcityAccount(accountId, accountName) {
    window.icityCurrentAccountId = accountId;
    window.icityCurrentAccountName = accountName;
    window.icitySelectedRole = null;
    
    // ç›´æ¥è¿›å…¥ä¸»ç•Œé¢
    await enterIcityMainPage();
}

// è¿›å…¥ icity ä¸»ç•Œé¢
async function enterIcityMainPage() {
    document.getElementById('icitySelectAccountPage').style.display = 'none';
    document.getElementById('icityMainContent').style.display = '';
    
    // æ›´æ–°é¡µé¢æ ‡é¢˜æ˜¾ç¤ºå½“å‰è´¦å·
    const pageTitle = document.querySelector('#icityListPage .page-title');
    if (pageTitle && window.icityCurrentAccountName) {
        pageTitle.textContent = `${window.icityCurrentAccountName} Â· æ—¥è®°`;
    }
    
    // æ›´æ–°"æˆ‘çš„"é¡µé¢çš„ç”¨æˆ·ä¿¡æ¯ä¸ºå½“å‰è´¦å·
    if (window.icityCurrentAccountId) {
        try {
            const accountChar = await db.characters.get(window.icityCurrentAccountId);
            if (accountChar) {
                const accountName = accountChar.nick || accountChar.name || 'user';
                const accountWechatId = accountChar.identity?.wechat_id || accountChar.name || 'user';
                const accountAvatar = accountChar.avatar || '';
                
                // æ›´æ–°"æˆ‘çš„"é¡µé¢å¤´åƒã€åå­—ã€ID
                const profileName = document.querySelector('#icityMyPage .profile-name');
                const profileId = document.querySelector('#icityMyPage .profile-id');
                const profileAvatar = document.querySelector('#icityMyPage .profile-avatar');
                if (profileName) profileName.textContent = accountName;
                if (profileId) profileId.textContent = `@${accountWechatId}`;
                if (profileAvatar) {
                    if (accountAvatar) {
                        profileAvatar.style.backgroundImage = `url(${accountAvatar})`;
                        profileAvatar.style.backgroundSize = 'cover';
                        profileAvatar.style.backgroundPosition = 'center';
                        profileAvatar.textContent = '';
                    } else {
                        // æ²¡æœ‰å¤´åƒæ—¶æ¸…é™¤æ—§å¤´åƒï¼Œæ˜¾ç¤ºåå­—é¦–å­—
                        profileAvatar.style.backgroundImage = '';
                        profileAvatar.textContent = accountName.charAt(0);
                    }
                }
                
                // æ›´æ–°"æˆ‘çš„"é¡µé¢æ ‡é¢˜
                const myPageTitle = document.querySelector('#icityMyPage .page-title');
                if (myPageTitle) myPageTitle.textContent = `${accountName} Â· æˆ‘çš„`;
                
                // æ›´æ–°è¯¦æƒ…é¡µå¤´åƒå’Œåå­—
                const detailAvatar = document.querySelector('#icityDetailPage .detail-avatar, #icityDetailPage .avatar');
                const detailUserName = document.querySelector('#icityDetailPage .user-name');
                const detailUserId = document.querySelector('#icityDetailPage .user-id');
                if (detailAvatar && accountAvatar) {
                    detailAvatar.src = accountAvatar;
                }
                
                // ä¿å­˜åˆ°å…¨å±€ï¼Œæ–¹ä¾¿å…¶ä»–åœ°æ–¹ä½¿ç”¨
                window.icityCurrentAccountAvatar = accountAvatar;
                window.icityCurrentAccountName = accountName;
            }
        } catch(e) { console.warn(e); }
    }
    
    // åˆå§‹åŒ–æˆ–åˆ·æ–° icity åŠŸèƒ½
    if (!window.icityInitialized) {
        initIcityApp();
        window.icityInitialized = true;
    } else {
        // é‡æ–°åŠ è½½å½“å‰è´¦å·çš„æ—¥è®°
        loadIcityDiariesFromStorage().catch(console.error);
        updateIcityMyDiaryList();
    }
}

function initIcityApp() {
    // DOMå…ƒç´ è·å–
    const listPage = document.getElementById('icityListPage');
    const detailPage = document.getElementById('icityDetailPage');
    const publishPage = document.getElementById('icityPublishPage');
    const myPage = document.getElementById('icityMyPage');
    const detailBackBtn = document.getElementById('icityDetailBackBtn');
    const detailContent = document.getElementById('icityDetailContent');
    const detailTime = document.getElementById('icityDetailTime');
    const tabPublishBtn = document.getElementById('icityTabPublishBtn');
    const publishCloseBtn = document.getElementById('icityPublishCloseBtn');
    const publishSubmit = document.getElementById('icityPublishSubmit');
    const tabDiary = document.getElementById('icityTabDiary');
    const tabMy = document.getElementById('icityTabMy');
    const myTabDiary = document.getElementById('icityMyTabDiary');
    const myTabPublishBtn = document.getElementById('icityMyTabPublishBtn');
    const myTabMy = document.getElementById('icityMyTabMy');
    const commentInput = document.querySelector('#icityContent .comment-input');
    const sendBtn = document.getElementById('icitySendBtn');
    const likeBtn = document.getElementById('icityLikeBtn');
    const profileEdit = document.getElementById('icityProfileEdit');

    // 1. æ—¥è®°åˆ—è¡¨ -> è¯¦æƒ…é¡µï¼ˆä½¿ç”¨äº‹ä»¶å§”æ‰˜ï¼Œå› ä¸ºåˆ—è¡¨æ˜¯åŠ¨æ€çš„ï¼‰
    const diaryList = document.getElementById('icityDiaryList');
    if (diaryList) {
        diaryList.addEventListener('click', (e) => {
            const diaryItem = e.target.closest('.diary-item');
            if (diaryItem) {
                detailPage.dataset.fromPage = 'list';
                listPage.classList.remove('active');
                detailPage.classList.add('active');
                renderDiaryContentWithAnnotations(diaryItem.dataset.id, diaryItem.dataset.content).catch(console.error);
                detailTime.textContent = diaryItem.dataset.time;
                detailPage.dataset.currentDiaryId = diaryItem.dataset.id;
                detailPage.dataset.isUserPublished = diaryItem.dataset.isUserPublished;
                const roleName = diaryItem.querySelector('.user-name')?.textContent || 'user';
                const wechatId = diaryItem.querySelector('.user-id')?.textContent?.replace('@', '') || 'user';
                const avatarImg = diaryItem.querySelector('.avatar');
                const avatarUrl = avatarImg?.src || '';
                document.querySelector('#icityDetailPage .page-title').textContent = `${roleName} Â· æ—¥è®°`;
                const detailAvatar = document.querySelector('#icityDetailPage .detail-avatar');
                const detailUsername = document.querySelector('#icityDetailPage .detail-username');
                const detailUserid = document.querySelector('#icityDetailPage .detail-userid');
                if (detailAvatar) {
                    if (avatarUrl && !avatarUrl.includes('data:image/svg')) {
                        detailAvatar.style.backgroundImage = `url(${avatarUrl})`;
                        detailAvatar.style.backgroundSize = 'cover';
                        detailAvatar.style.backgroundPosition = 'center';
                    } else {
                        detailAvatar.style.backgroundImage = '';
                        detailAvatar.textContent = roleName.charAt(0);
                    }
                }
                if (detailUsername) detailUsername.textContent = roleName;
                if (detailUserid) detailUserid.textContent = `@${wechatId}`;
            }
        });
    }

    // 2. æˆ‘çš„æ—¥è®°åˆ—è¡¨ -> è¯¦æƒ…é¡µ
    const myDiaryList = document.querySelector('#icityMyPage .my-diary-list');
    if (myDiaryList) {
        myDiaryList.addEventListener('click', (e) => {
            const myDiaryItem = e.target.closest('.my-diary-item');
            if (myDiaryItem) {
                detailPage.dataset.fromPage = 'my';
                const diaryId = myDiaryItem.dataset.id;
                const diaryItem = document.querySelector(`#icityDiaryList .diary-item[data-id="${diaryId}"]`);
                myPage.classList.remove('active');
                detailPage.classList.add('active');
                renderDiaryContentWithAnnotations(myDiaryItem.dataset.id, myDiaryItem.dataset.content).catch(console.error);
                detailTime.textContent = myDiaryItem.dataset.time;
                detailPage.dataset.currentDiaryId = myDiaryItem.dataset.id;
                detailPage.dataset.isUserPublished = myDiaryItem.dataset.isUserPublished;
                if (diaryItem) {
                    const roleName = diaryItem.querySelector('.user-name')?.textContent || 'user';
                    const wechatId = diaryItem.querySelector('.user-id')?.textContent?.replace('@', '') || 'user';
                    const avatarImg = diaryItem.querySelector('.avatar');
                    const avatarUrl = avatarImg?.src || '';
                    document.querySelector('#icityDetailPage .page-title').textContent = `${roleName} Â· æ—¥è®°`;
                    const detailAvatar = document.querySelector('#icityDetailPage .detail-avatar');
                    const detailUsername = document.querySelector('#icityDetailPage .detail-username');
                    const detailUserid = document.querySelector('#icityDetailPage .detail-userid');
                    if (detailAvatar) {
                        if (avatarUrl && !avatarUrl.includes('data:image/svg')) {
                            detailAvatar.style.backgroundImage = `url(${avatarUrl})`;
                            detailAvatar.style.backgroundSize = 'cover';
                            detailAvatar.style.backgroundPosition = 'center';
                        } else {
                            detailAvatar.style.backgroundImage = '';
                            detailAvatar.textContent = roleName.charAt(0);
                        }
                    }
                    if (detailUsername) detailUsername.textContent = roleName;
                    if (detailUserid) detailUserid.textContent = `@${wechatId}`;
                }
            }
        });
    }

    // 3. è¯¦æƒ…é¡µ -> åˆ—è¡¨é¡µ/æˆ‘çš„é¡µ
    if (detailBackBtn) detailBackBtn.addEventListener('click', () => {
        detailPage.classList.remove('active');
        if (detailPage.dataset.fromPage === 'my') {
            myPage.classList.add('active');
        } else {
            listPage.classList.add('active');
        }
    });

    // 4. åˆ—è¡¨é¡µåº•éƒ¨Tabåˆ‡æ¢
    if (tabDiary) tabDiary.addEventListener('click', () => {
        listPage.classList.add('active');
        myPage.classList.remove('active');
        tabDiary.classList.add('active');
        if (tabMy) tabMy.classList.remove('active');
        if (myTabDiary) myTabDiary.classList.add('active');
        if (myTabMy) myTabMy.classList.remove('active');
    });

    if (tabMy) tabMy.addEventListener('click', () => {
        listPage.classList.remove('active');
        myPage.classList.add('active');
        if (tabDiary) tabDiary.classList.remove('active');
        tabMy.classList.add('active');
        if (myTabDiary) myTabDiary.classList.remove('active');
        if (myTabMy) myTabMy.classList.add('active');
    });

    // 5. æˆ‘çš„é¡µé¢åº•éƒ¨Tabåˆ‡æ¢
    if (myTabDiary) myTabDiary.addEventListener('click', () => {
        myPage.classList.remove('active');
        listPage.classList.add('active');
        myTabDiary.classList.add('active');
        if (myTabMy) myTabMy.classList.remove('active');
        if (tabDiary) tabDiary.classList.add('active');
        if (tabMy) tabMy.classList.remove('active');
    });

    if (myTabMy) myTabMy.addEventListener('click', () => {
        listPage.classList.remove('active');
        myPage.classList.add('active');
        if (myTabDiary) myTabDiary.classList.remove('active');
        myTabMy.classList.add('active');
        if (tabDiary) tabDiary.classList.remove('active');
        if (tabMy) tabMy.classList.add('active');
    });

    // 6. å‘å¸ƒæŒ‰é’®ç‚¹å‡»
    if (tabPublishBtn) tabPublishBtn.addEventListener('click', () => {
        listPage.classList.remove('active');
        publishPage.classList.add('active');
    });

    if (myTabPublishBtn) myTabPublishBtn.addEventListener('click', () => {
        myPage.classList.remove('active');
        publishPage.classList.add('active');
    });

    // 7. å…³é—­å‘å¸ƒé¡µ
    if (publishCloseBtn) publishCloseBtn.addEventListener('click', () => {
        publishPage.classList.remove('active');
        if (listPage.classList.contains('active')) {
            listPage.classList.add('active');
        } else {
            myPage.classList.add('active');
        }
    });

    // 8. å‘å¸ƒæ—¥è®°åŠŸèƒ½
    if (publishSubmit) publishSubmit.addEventListener('click', async () => {
        const title = document.getElementById('icityTitleInput').value;
        const content = document.getElementById('icityContentInput').value.trim();
        if (content === '') {
            alert('è¯·è¾“å…¥æ—¥è®°å†…å®¹ï½');
            return;
        }
        
        // è·å–å½“å‰è´¦å·ä¿¡æ¯
        let userName = 'user';
        let userWechatId = 'user';
        let userAvatar = '';
        if (window.icityCurrentAccountId) {
            try {
                const accountChar = await db.characters.get(window.icityCurrentAccountId);
                if (accountChar) {
                    userName = accountChar.nick || accountChar.name || 'user';
                    userWechatId = accountChar.identity?.wechat_id || accountChar.name || 'user';
                    userAvatar = accountChar.avatar || '';
                }
            } catch(e) {
                console.warn('è·å–è´¦å·ä¿¡æ¯å¤±è´¥:', e);
            }
        }
        const currentPersona = JSON.parse(localStorage.getItem('currentMyPersona') || 'null');
        if (!window.icityCurrentAccountId && currentPersona) {
            userName = currentPersona.nickname || userName;
            userWechatId = currentPersona.wechatId || userWechatId;
            userAvatar = currentPersona.avatarUrl || userAvatar;
        }
        
        const today = new Date();
        const dateStr = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
        const timeStr = `${String(today.getHours()).padStart(2, '0')}:${String(today.getMinutes()).padStart(2, '0')}`;
        
        const diaryId = Date.now();
        const fullContent = title ? `${title}\n\n${content}` : content;
        
        addIcityDiary({
            id: diaryId,
            content: fullContent,
            time: `${dateStr} ${timeStr}`,
            roleName: userName,
            role: {
                name: userName,
                realName: currentPersona?.realName || userName,
                wechatId: userWechatId,
                friend: {
                    avatar: userAvatar
                }
            },
            isUserPublished: true
        });
        
        document.getElementById('icityTitleInput').value = '';
        document.getElementById('icityContentInput').value = '';
        publishPage.classList.remove('active');
        listPage.classList.add('active');
        showIcityGenerateStatus('æ—¥è®°å‘å¸ƒæˆåŠŸï¼', 'success');
    });

    // 9. è¯„è®ºå‘é€åŠŸèƒ½
    if (sendBtn) sendBtn.addEventListener('click', () => {
        const comment = commentInput ? commentInput.value.trim() : '';
        if (comment === '') {
            alert('è¯·è¾“å…¥è¯„è®ºå†…å®¹ï½');
            return;
        }
        alert(`è¯„è®ºå‘é€æˆåŠŸï¼š${comment}`);
        if (commentInput) commentInput.value = '';
    });

    // 10. è¯¦æƒ…é¡µç‚¹èµäº¤äº’
    let isLiked = false;
    if (likeBtn) likeBtn.addEventListener('click', () => {
        isLiked = !isLiked;
        if (isLiked) {
            likeBtn.style.color = '#ff4d6d';
            likeBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5 22 12.28 18.6 15.36 13.45 20.04L12 21.35z"/></svg> å·²å–œæ¬¢';
        } else {
            likeBtn.style.color = '#999';
            likeBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M16.5 3c-1.74 0-3.41.81-4.5 2.09C10.91 3.81 9.24 3 7.5 3 4.42 3 2 5.42 2 8.5c0 3.78 3.4 6.86 8.55 11.54L12 21.35l1.45-1.32C18.6 15.36 22 12.28 22 8.5 22 5.42 19.58 3 16.5 3zM12.1 18.55l-.1.1-.1-.1C7.14 14.24 4 11.39 4 8.5 4 6.5 5.5 5 7.5 5c1.54 0 3.04.99 3.57 2.36h1.87C13.46 5.99 14.96 5 16.5 5c2 0 3.5 1.5 3.5 3.5 0 2.89-3.14 5.74-7.9 10.05z"/></svg> å–œæ¬¢';
        }
    });

    // 11. æˆ‘çš„é¡µé¢ç¼–è¾‘èµ„æ–™ç‚¹å‡»
    if (profileEdit) {
        profileEdit.addEventListener('click', () => {
            openIcityEditProfileModal();
        });
    }
    
    // 12. åˆ é™¤æ—¥è®°æŒ‰é’®ç‚¹å‡»
    const deleteBtn = document.getElementById('icityDeleteBtn');
    if (deleteBtn) {
        deleteBtn.addEventListener('click', async () => {
            const diaryId = detailPage.dataset.currentDiaryId;
            if (!diaryId) {
                alert('æ— æ³•è·å–æ—¥è®°ID');
                return;
            }
            
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ç¯‡æ—¥è®°å—ï¼Ÿåˆ é™¤åæ— æ³•æ¢å¤ï¼')) {
                try {
                    await icityDb.diaries.delete(parseInt(diaryId));
                    await icityDb.annotations.where('diaryId').equals(parseInt(diaryId)).delete();
                    
                    const diaryItem = document.querySelector(`#icityDiaryList .diary-item[data-id="${diaryId}"]`);
                    if (diaryItem) diaryItem.remove();
                    
                    const myDiaryItem2 = document.querySelector(`.my-diary-item[data-id="${diaryId}"]`);
                    if (myDiaryItem2) myDiaryItem2.remove();
                    
                    updateIcityMyDiaryList();
                    
                    const remainingDiaries = document.querySelectorAll('#icityDiaryList .diary-item');
                    if (remainingDiaries.length === 0) {
                        document.getElementById('icityDiaryList').innerHTML = '<div style="text-align: center; padding: 40px 20px; color: #999; font-size: 14px;">è¿˜æ²¡æœ‰æ—¥è®°<br><div style="font-size: 12px; margin-top: 8px; color: #ccc;">ç‚¹å‡»å³ä¸Šè§’å‘å¸ƒæˆ–ç”Ÿæˆæ—¥è®°</div></div>';
                    }
                    
                    showIcityGenerateStatus('æ—¥è®°å·²åˆ é™¤', 'success');
                    
                    detailPage.classList.remove('active');
                    if (detailPage.dataset.fromPage === 'my') {
                        myPage.classList.add('active');
                    } else {
                        listPage.classList.add('active');
                    }
                } catch (error) {
                    console.error('åˆ é™¤æ—¥è®°å¤±è´¥:', error);
                    showIcityGenerateStatus('åˆ é™¤å¤±è´¥: ' + error.message, 'error');
                }
            }
        });
    }

    // ä»DexieåŠ è½½æ—¥è®°
    loadIcityDiariesFromStorage().catch(console.error);
    
    // åˆå§‹åŒ–"æˆ‘çš„æ—¥è®°"åˆ—è¡¨
    updateIcityMyDiaryList();
    
    // åˆå§‹åŒ–æ–‡æœ¬æ ‡æ³¨åŠŸèƒ½
    initIcityAnnotation();

    // 13. è§’è‰²é€‰æ‹©æŒ‰é’®ç‚¹å‡»
    const selectRoleBtn = document.getElementById('icitySelectRoleBtn');
    if (selectRoleBtn) selectRoleBtn.addEventListener('click', () => {
        openIcityRoleModal();
    });

    // 14. ç”Ÿæˆæ—¥è®°æŒ‰é’®ç‚¹å‡»
    const generateBtn = document.getElementById('icityGenerateBtn');
    if (generateBtn) generateBtn.addEventListener('click', () => {
        generateIcityDiary();
    });
}

// icity è§’è‰²é€‰æ‹©æ¨¡æ€æ¡†ï¼ˆåœ¨appå†…åˆ‡æ¢è§’è‰²ï¼ŒæŒ‰è´¦å·è¿‡æ»¤å¥½å‹ï¼‰
async function openIcityRoleModal() {
    // ä»æ•°æ®åº“è·å–è§’è‰²åˆ—è¡¨ï¼ŒæŒ‰å½“å‰è´¦å·è¿‡æ»¤å¥½å‹ï¼ˆæ’é™¤è”æœºå¥½å‹ï¼‰
    const allChars = await db.characters.toArray();
    const currentAccountId = window.icityCurrentAccountId;
    const friends = allChars.filter(c => {
        if (c.type === 'user') return false;
        if (c.isOnlineFriend === true) return false; // æ’é™¤è”æœºå¥½å‹
        if (currentAccountId) {
            const status = getFriendStatus(c, currentAccountId);
            return status === 'friend';
        }
        return c.type === 'char' || c.type === 'npc';
    });
    const roleList = document.getElementById('icityRoleList');
    
    if (friends.length === 0) {
        roleList.innerHTML = '<div style="text-align: center; padding: 40px 20px; color: #999; font-size: 14px;">è¿˜æ²¡æœ‰åˆ›å»ºè§’è‰²<br><div style="font-size: 12px; margin-top: 8px; color: #ccc;">è¯·å…ˆåˆ›å»ºè§’è‰²</div></div>';
    } else {
        roleList.innerHTML = '';
        friends.forEach((friend, index) => {
            const roleItem = document.createElement('div');
            roleItem.className = 'icity-role-item';
            roleItem.setAttribute('data-index', index);
            
            const friendName = friend.nick || friend.name;
            const friendPersona = friend.description || friend.personality || 'æš‚æ— è¯¦ç»†äººè®¾';
            
            const prompt = `ä½ æ˜¯ä¸€ä¸ªçœŸå®çš„äººï¼Œåå­—å«${friendName}ã€‚${friendPersona}`;
            
            roleItem.setAttribute('data-role', friendName);
            roleItem.setAttribute('data-prompt', prompt);
            roleItem.setAttribute('data-name', friend.name);
            
            roleItem.innerHTML = `
                <div style="display: flex; align-items: center; gap: 12px;">
                    ${friend.avatar ? `<img src="${friend.avatar}" style="width: 40px; height: 40px; border-radius: 50%; object-fit: cover;" alt="">` : `<div style="width: 40px; height: 40px; border-radius: 50%; background: #eee; display: flex; align-items: center; justify-content: center; color: #999; font-size: 16px;">${friendName.charAt(0)}</div>`}
                    <div style="flex: 1;">
                        <div class="icity-role-name">${friendName}</div>
                        <div class="icity-role-desc">${friendPersona.length > 50 ? friendPersona.substring(0, 50) + '...' : friendPersona}</div>
                    </div>
                </div>
            `;
            
            roleItem.addEventListener('click', () => {
                document.querySelectorAll('.icity-role-item').forEach(r => r.classList.remove('selected'));
                roleItem.classList.add('selected');
                window.icitySelectedRole = {
                    name: friendName,
                    realName: friendName,
                    wechatId: friend.id || friendName.toLowerCase().replace(/\s/g, ''),
                    prompt: prompt,
                    persona: friendPersona,
                    friend: friend
                };
                setTimeout(() => {
                    closeIcityRoleModal();
                }, 300);
            });
            
            roleList.appendChild(roleItem);
        });
    }
    
    document.getElementById('icityRoleModal').style.display = 'flex';
}

function closeIcityRoleModal() {
    document.getElementById('icityRoleModal').style.display = 'none';
}

// æ‰“å¼€ç¼–è¾‘èµ„æ–™æ¨¡æ€æ¡†
async function openIcityEditProfileModal() {
    const modal = document.getElementById('icityEditProfileModal');
    
    let nickname = '';
    let wechatId = '';
    if (window.icityCurrentAccountId) {
        try {
            const accountChar = await db.characters.get(window.icityCurrentAccountId);
            if (accountChar) {
                nickname = accountChar.nick || accountChar.name || '';
                wechatId = accountChar.identity?.wechat_id || '';
            }
        } catch(e) { console.warn(e); }
    } else {
        const currentPersona = JSON.parse(localStorage.getItem('currentMyPersona') || 'null');
        nickname = currentPersona?.nickname || '';
        wechatId = currentPersona?.wechatId || '';
    }
    
    document.getElementById('icityEditUsername').value = nickname;
    document.getElementById('icityEditWechatId').value = wechatId;
    
    modal.style.display = 'flex';
}

function closeIcityEditProfileModal() {
    document.getElementById('icityEditProfileModal').style.display = 'none';
}

function saveIcityProfile() {
    const username = document.getElementById('icityEditUsername').value.trim();
    const wechatId = document.getElementById('icityEditWechatId').value.trim();
    
    if (!username) {
        alert('è¯·è¾“å…¥ç”¨æˆ·å');
        return;
    }
    
    if (!wechatId) {
        alert('è¯·è¾“å…¥å¾®ä¿¡ID');
        return;
    }
    
    const currentPersona = JSON.parse(localStorage.getItem('currentMyPersona') || '{}');
    currentPersona.nickname = username;
    currentPersona.wechatId = wechatId;
    localStorage.setItem('currentMyPersona', JSON.stringify(currentPersona));
    
    const profileName = document.querySelector('#icityMyPage .profile-name');
    const profileId = document.querySelector('#icityMyPage .profile-id');
    if (profileName) profileName.textContent = username;
    if (profileId) profileId.textContent = `@${wechatId}`;
    
    closeIcityEditProfileModal();
    showIcityGenerateStatus('èµ„æ–™ä¿å­˜æˆåŠŸï¼', 'success');
}

// æ˜¾ç¤ºç”Ÿæˆè¿›åº¦æç¤º
function showIcityGenerateStatus(message, type = 'info') {
    const oldToast = document.getElementById('icityGenerateToast');
    if (oldToast) oldToast.remove();
    
    const toast = document.createElement('div');
    toast.id = 'icityGenerateToast';
    toast.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: ${type === 'error' ? '#ff4d4f' : type === 'success' ? '#52c41a' : 'rgba(0,0,0,0.8)'};
        color: white;
        padding: 20px 30px;
        border-radius: 10px;
        z-index: 10002;
        font-size: 14px;
        max-width: 300px;
        text-align: center;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    `;
    toast.textContent = message;
    document.body.appendChild(toast);
    
    if (type === 'success' || type === 'error') {
        setTimeout(() => {
            toast.remove();
        }, 3000);
    }
}

// è·å–AI APIé…ç½®ï¼ˆä»Dexieï¼‰
async function getIcityApiConfig() {
    const urlItem = await db.dexiData.get('aiBaseUrl');
    const keyItem = await db.dexiData.get('aiApiKey');
    const modelItem = await db.dexiData.get('aiCurrentModel');
    const tempItem = await db.dexiData.get('aiTemperature');
    
    let baseUrl = (urlItem?.value || 'https://api.openai.com/v1').trim();
    if (baseUrl.endsWith('/')) baseUrl = baseUrl.slice(0, -1);
    if (!baseUrl.includes('/v1')) baseUrl += '/v1';
    const apiUrl = baseUrl + '/chat/completions';
    
    return {
        apiUrl: apiUrl,
        apiKey: keyItem?.value || '',
        model: modelItem?.value || 'gpt-3.5-turbo',
        temperature: parseFloat(tempItem?.value) || 0.8
    };
}

// ç”Ÿæˆ icity æ—¥è®°
async function generateIcityDiary() {
    if (!window.icitySelectedRole) {
        showIcityGenerateStatus('è¯·å…ˆé€‰æ‹©è§’è‰²', 'error');
        openIcityRoleModal();
        return;
    }

    const config = await getIcityApiConfig();

    if (!config.apiKey) {
        showIcityGenerateStatus('è¯·å…ˆåœ¨è®¾ç½®ä¸­é…ç½® API å¯†é’¥', 'error');
        return;
    }

    const generateBtn = document.getElementById('icityGenerateBtn');
    const originalHTML = generateBtn.innerHTML;
    generateBtn.innerHTML = '<svg class="icon-svg" viewBox="0 0 24 24"><path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/></svg>';
    generateBtn.style.pointerEvents = 'none';
    showIcityGenerateStatus('æ­£åœ¨ç”Ÿæˆæ—¥è®°å¹¶å¤„ç†ä»»åŠ¡...', 'info');

    try {
        const today = new Date();
        const dateStr = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
        const timeStr = `${String(today.getHours()).padStart(2, '0')}:${String(today.getMinutes()).padStart(2, '0')}`;

        // è·å–èŠå¤©è®°å½•
        let recentChatHistory = '';
        try {
            const friendChar = window.icitySelectedRole.friend;
            if (friendChar) {
                const accountId = typeof getCurrentAccountId === 'function' ? getCurrentAccountId() : null;
                const chatHistory = typeof getChatHistory === 'function' ? getChatHistory(friendChar, accountId) : [];
                if (chatHistory && chatHistory.length > 0) {
                    const recentMessages = chatHistory.slice(-10).map(msg => {
                        const sender = msg.isSelf ? 'æˆ‘' : (friendChar.nick || friendChar.name);
                        return `${sender}: ${msg.content || msg.text || ''}`;
                    }).join('\n');
                    if (recentMessages) {
                        recentChatHistory = `\n\næœ€è¿‘çš„èŠå¤©è®°å½•ï¼š\n${recentMessages}`;
                    }
                }
            }
        } catch (e) {
            console.warn('è·å–èŠå¤©è®°å½•å¤±è´¥:', e);
        }
        
        // æ”¶é›†ä»»åŠ¡ä¿¡æ¯
        let myLastDiaryWithAnnotations = null;
        let myLastDiaryId = null; // ä¿å­˜ä¸Šä¸€ç¯‡AIæ—¥è®°çš„IDï¼Œç”¨äºåç»­ä¿å­˜å›å¤
        let userRecentDiary = null;
        
        try {
            const currentAccountId = window.icityCurrentAccountId || 0;
            let allDiaries;
            if (currentAccountId) {
                allDiaries = await icityDb.diaries.where('accountId').equals(currentAccountId).reverse().sortBy('createdAt');
                allDiaries = allDiaries.slice(0, 10);
            } else {
                allDiaries = await icityDb.diaries.orderBy('createdAt').reverse().limit(10).toArray();
            }
            
            const myLastDiary = allDiaries.find(d => d.isUserPublished === 0 || d.isUserPublished === false);
            if (myLastDiary) {
                myLastDiaryId = myLastDiary.id; // è®°ä½è¿™ä¸ªIDï¼Œåé¢è¦ç”¨
                // åŒæ—¶ç”¨æ•°å­—å’Œå­—ç¬¦ä¸²æŸ¥è¯¢æ ‡æ³¨
                const annotations = await getIcityAnnotations(myLastDiary.id);
                const userAnnotations = annotations.filter(ann => !ann.isAI && !ann.isReply);
                if (userAnnotations.length > 0) {
                    myLastDiaryWithAnnotations = {
                        content: myLastDiary.content,
                        annotations: userAnnotations
                    };
                }
            }
            
            userRecentDiary = allDiaries.find(d => d.isUserPublished === 1 || d.isUserPublished === true);
        } catch (e) {
            console.warn('è·å–æ—¥è®°æ•°æ®å¤±è´¥:', e);
        }

        const roleName = window.icitySelectedRole.name || window.icitySelectedRole.realName || 'è§’è‰²';
        const rolePersona = window.icitySelectedRole.persona || '';

        // æ„å»ºè‡ªç„¶çš„ system prompt
        const systemPrompt = `ä½ ç°åœ¨æ˜¯${roleName}ï¼Œä¸€ä¸ªçœŸå®å­˜åœ¨çš„äººã€‚ä»¥ä¸‹æ˜¯å…³äºä½ çš„ä¿¡æ¯ï¼š
${rolePersona}

ä½ æ­£åœ¨å†™è‡ªå·±çš„ç§äººæ—¥è®°ã€‚è¦æ±‚ï¼š
- å®Œå…¨ä»¥${roleName}çš„ç¬¬ä¸€äººç§°è§†è§’ä¹¦å†™ï¼ŒåƒçœŸäººåœ¨æ‰‹æœºå¤‡å¿˜å½•é‡Œéšæ‰‹å†™çš„æ—¥è®°
- è¯­æ°”è‡ªç„¶éšæ„ï¼Œå¯ä»¥æœ‰å£è¯­åŒ–è¡¨è¾¾ã€è¯­æ°”è¯ã€çœç•¥å·ã€æ„Ÿå¹å·
- ä¸è¦å†™å¾—åƒä½œæ–‡æˆ–æ–‡å­¦ä½œå“ï¼Œè¦åƒçœŸäººçš„ç¢ç¢å¿µã€æµæ°´è´¦ã€å¿ƒæƒ…è®°å½•
- å¯ä»¥å†™ä»Šå¤©å‘ç”Ÿçš„å°äº‹ã€çªç„¶æƒ³åˆ°çš„äº‹ã€å¯¹æŸä»¶äº‹çš„åæ§½ã€çº ç»“ã€å¼€å¿ƒã€éš¾è¿‡ç­‰ç­‰
- å†…å®¹è¦æœ‰ç»†èŠ‚å’Œç”»é¢æ„Ÿï¼Œæ¯”å¦‚å…·ä½“åƒäº†ä»€ä¹ˆã€çœ‹åˆ°äº†ä»€ä¹ˆã€å’Œè°è¯´äº†ä»€ä¹ˆè¯
- å¯ä»¥æœ‰å‰åè·³è·ƒã€æƒ³åˆ°å“ªå†™åˆ°å“ªçš„æ„Ÿè§‰ï¼Œä¸éœ€è¦ä¸¥æ ¼çš„é€»è¾‘ç»“æ„
- å¯ä»¥å¤¹æ‚ä¸€äº›å†…å¿ƒç‹¬ç™½ã€è‡ªé—®è‡ªç­”
- å­—æ•°åœ¨800-2000å­—å·¦å³ï¼Œä¸è¦å¤ªçŸ­ä¹Ÿä¸è¦åˆ»æ„å‡‘å­—æ•°`;

        // æ„å»º user prompt
        let userPromptParts = [];
        
        userPromptParts.push(`è¯·ä»¥${roleName}çš„èº«ä»½å†™ä¸€ç¯‡ä»Šå¤©çš„æ—¥è®°ã€‚`);
        
        if (recentChatHistory) {
            userPromptParts.push(`\nå‚è€ƒæœ€è¿‘å’Œåˆ«äººçš„èŠå¤©å†…å®¹ï¼Œå¯ä»¥åœ¨æ—¥è®°é‡Œè‡ªç„¶åœ°æåˆ°ç›¸å…³çš„äº‹ï¼ˆä¸è¦ç…§æ¬èŠå¤©è®°å½•ï¼Œç”¨æ—¥è®°çš„å£å»å»å†™æ„Ÿå—å’Œæƒ³æ³•ï¼‰ï¼š${recentChatHistory}`);
        }

        // æ ‡æ³¨ä»»åŠ¡
        let hasExtraTasks = false;
        if (myLastDiaryWithAnnotations || userRecentDiary) {
            hasExtraTasks = true;
            userPromptParts.push(`\né™¤äº†æ—¥è®°ä¹‹å¤–ï¼Œè¿˜æœ‰é¢å¤–ä»»åŠ¡ï¼š`);
            if (myLastDiaryWithAnnotations) {
                userPromptParts.push(`- ç”¨æˆ·å¯¹ä½ ä¸Šä¸€ç¯‡æ—¥è®°è¿›è¡Œäº†æ ‡æ³¨è¯„è®ºï¼Œè¯·ä»¥${roleName}çš„å£å»å¯¹æ¯æ¡ç»™å‡ºç®€çŸ­å›åº”ï¼ˆåƒæœ‹å‹ä¹‹é—´å›å¤ç•™è¨€ä¸€æ ·è‡ªç„¶ï¼Œ15-30å­—ï¼‰ï¼š`);
                myLastDiaryWithAnnotations.annotations.forEach(ann => {
                    userPromptParts.push(`  Â· æ ‡æ³¨å†…å®¹ï¼š"${ann.text}" â†’ ç”¨æˆ·è¯„è®ºï¼š${ann.comment}`);
                });
            }
            if (userRecentDiary) {
                userPromptParts.push(`- ç”¨æˆ·å†™äº†ä¸€ç¯‡æ—¥è®°ï¼Œè¯·ä»¥${roleName}çš„å£å»å¯¹å…¶ä¸­2-4å¤„å†…å®¹è¿›è¡Œæ ‡æ³¨è¯„è®ºï¼ˆåƒæœ‹å‹åœ¨æ—è¾¹å†™æ‰¹æ³¨ä¸€æ ·ï¼ŒçœŸå®è‡ªç„¶ï¼Œ15-40å­—ï¼‰ï¼š`);
                userPromptParts.push(`  ç”¨æˆ·çš„æ—¥è®°å†…å®¹ï¼š${userRecentDiary.content.substring(0, 1500)}`);
            }
        }

        userPromptParts.push(`\nè¯·ä¸¥æ ¼æŒ‰ä»¥ä¸‹JSONæ ¼å¼è¾“å‡ºï¼Œä¸è¦è¾“å‡ºå…¶ä»–ä»»ä½•å†…å®¹ï¼š
{
  "diary": "æ—¥è®°æ­£æ–‡ï¼ˆçº¯æ–‡æœ¬ï¼Œç”¨\\næ¢è¡Œï¼‰",
  "repliesToUserAnnotations": ${myLastDiaryWithAnnotations ? '[{"text": "ä½ æ—¥è®°ä¸­è¢«æ ‡æ³¨çš„åŸæ–‡ç‰‡æ®µ", "comment": "ä½ çš„å›åº”"}]' : '[]'},
  "annotationsForUserDiary": ${userRecentDiary ? '[{"text": "ç”¨æˆ·æ—¥è®°ä¸­çš„åŸæ–‡ç‰‡æ®µ", "comment": "ä½ çš„æ ‡æ³¨è¯„è®º"}]' : '[]'}
}`);

        const userPrompt = userPromptParts.join('\n');

        const response = await fetch(config.apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${config.apiKey}` },
            body: JSON.stringify({
                model: config.model,
                messages: [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: userPrompt }
                ],
                temperature: config.temperature || 0.9,
                max_tokens: 8000
            })
        });

        if (!response.ok) throw new Error(`APIè¯·æ±‚å¤±è´¥: ${response.status}`);

        const data = await response.json();
        const responseContent = data.choices?.[0]?.message?.content?.trim() || '';
        
        let jsonStr = responseContent;
        if (jsonStr.startsWith('```json')) {
            jsonStr = jsonStr.replace(/^```json\s*/, '').replace(/\s*```$/, '');
        } else if (jsonStr.startsWith('```')) {
            jsonStr = jsonStr.replace(/^```\s*/, '').replace(/\s*```$/, '');
        }
        
        const parsed = JSON.parse(jsonStr);
        const diaryContent = parsed.diary || '';
        const replies = parsed.repliesToUserAnnotations || [];
        const annotationsFromAI = parsed.annotationsForUserDiary || [];
        
        console.log('[icityç”Ÿæˆ] æ—¥è®°é•¿åº¦:', diaryContent.length, 'å›å¤æ ‡æ³¨æ•°:', replies.length, 'æ ‡æ³¨ç”¨æˆ·æ—¥è®°æ•°:', annotationsFromAI.length);
        console.log('[icityç”Ÿæˆ] myLastDiaryId:', myLastDiaryId, 'myLastDiaryWithAnnotations:', !!myLastDiaryWithAnnotations, 'userRecentDiary:', !!userRecentDiary);
        
        if (!diaryContent || diaryContent.length < 50) throw new Error('ç”Ÿæˆçš„æ—¥è®°å†…å®¹è¿‡çŸ­');
        
        const diaryId = Date.now();
        addIcityDiary({
            id: diaryId,
            content: diaryContent,
            time: `${dateStr} ${timeStr}`,
            roleName: window.icitySelectedRole.name || window.icitySelectedRole.realName || 'user',
            role: window.icitySelectedRole,
            isUserPublished: false
        });
        
        // ä¿å­˜å¯¹æˆ‘ä¸Šä¸€ç¯‡æ—¥è®°çš„å›å¤æ ‡æ³¨ï¼ˆä½¿ç”¨ä¹‹å‰è®°ä½çš„myLastDiaryIdï¼Œä¸å†é‡æ–°æŸ¥è¯¢ï¼‰
        if (replies.length > 0 && myLastDiaryWithAnnotations && myLastDiaryId) {
            console.log('[icity] ä¿å­˜å›å¤æ ‡æ³¨åˆ°æ—¥è®°ID:', myLastDiaryId, 'å›å¤æ•°é‡:', replies.length);
            const replyAnnotations = replies.map((reply, idx) => ({
                id: Date.now() + idx + 1000,
                diaryId: myLastDiaryId,
                text: reply.text,
                comment: reply.comment,
                createdAt: new Date().toISOString(),
                isAI: true,
                aiRole: window.icitySelectedRole.name,
                isReply: true,
                accountId: window.icityCurrentAccountId || 0
            }));
            for (const ann of replyAnnotations) {
                await icityDb.annotations.put(ann);
            }
        }
        
        // ä¿å­˜å¯¹ç”¨æˆ·æ—¥è®°çš„æ ‡æ³¨
        if (annotationsFromAI.length > 0 && userRecentDiary) {
            const annotationsToSave = annotationsFromAI.map((ann, idx) => ({
                id: Date.now() + idx + 2000,
                diaryId: userRecentDiary.id,
                text: ann.text,
                comment: ann.comment,
                createdAt: new Date().toISOString(),
                isAI: true,
                aiRole: window.icitySelectedRole.name,
                accountId: window.icityCurrentAccountId || 0
            }));
            for (const ann of annotationsToSave) {
                await icityDb.annotations.put(ann);
            }
        }
        
        showIcityGenerateStatus(`å®Œæˆï¼${replies.length > 0 ? `å›å¤äº†${replies.length}æ¡æ ‡æ³¨ï¼Œ` : ''}${annotationsFromAI.length > 0 ? `æ ‡æ³¨äº†ä½ çš„æ—¥è®°${annotationsFromAI.length}å¤„` : ''}`, 'success');
        
    } catch (error) {
        console.error('ç”Ÿæˆå¤±è´¥:', error);
        showIcityGenerateStatus(`ç”Ÿæˆå¤±è´¥ï¼š${error.message}`, 'error');
    } finally {
        generateBtn.innerHTML = originalHTML;
        generateBtn.style.pointerEvents = 'auto';
    }
}

// æ·»åŠ æ—¥è®°åˆ°åˆ—è¡¨
function addIcityDiary(diary) {
    const diaryList = document.getElementById('icityDiaryList');
    const date = new Date(diary.time);
    const monthNames = ['1æœˆ', '2æœˆ', '3æœˆ', '4æœˆ', '5æœˆ', '6æœˆ', '7æœˆ', '8æœˆ', '9æœˆ', '10æœˆ', '11æœˆ', '12æœˆ'];
    const weekDays = ['æ˜ŸæœŸæ—¥', 'æ˜ŸæœŸä¸€', 'æ˜ŸæœŸäºŒ', 'æ˜ŸæœŸä¸‰', 'æ˜ŸæœŸå››', 'æ˜ŸæœŸäº”', 'æ˜ŸæœŸå…­'];
    const dateStr = `${monthNames[date.getMonth()]}${date.getDate()}æ—¥ Â· ${weekDays[date.getDay()]} ${date.getFullYear()}`;
    const timeStr = diary.time.split(' ')[1] || '00:00';
    
    const role = diary.role || window.icitySelectedRole || {};
    const avatarUrl = role.friend?.avatar || `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='40'%3E%3Crect width='40' height='40' fill='%23ddd'/%3E%3Ccircle cx='20' cy='20' r='15' fill='%23ccc'/%3E%3C/svg%3E`;
    const wechatId = role.wechatId || role.friend?.id || 'user';
    const roleName = diary.roleName || role.name || role.realName || 'user';
    
    const preview = diary.content.replace(/\n/g, ' ').substring(0, 50) + (diary.content.length > 50 ? '...' : '');

    const diaryItem = document.createElement('div');
    diaryItem.className = 'diary-item';
    diaryItem.setAttribute('data-id', diary.id);
    diaryItem.setAttribute('data-content', diary.content);
    diaryItem.setAttribute('data-time', diary.time);
    diaryItem.setAttribute('data-role-name', roleName);
    diaryItem.setAttribute('data-wechat-id', wechatId);
    diaryItem.setAttribute('data-avatar-url', avatarUrl);
    diaryItem.setAttribute('data-is-user-published', diary.isUserPublished ? 'true' : 'false');
    
    diaryItem.innerHTML = `
        <div class="diary-header">
            <div class="user-info">
                <img src="${avatarUrl}" alt="å¤´åƒ" class="avatar" style="border-radius: 50%; object-fit: cover;">
                <div class="user-name-box">
                    <div class="user-name">${roleName}</div>
                    <div class="user-id">@${wechatId}</div>
                </div>
            </div>
            <div class="diary-date">${dateStr}</div>
        </div>
        <div class="diary-content">${preview}</div>
        <div class="diary-actions">
            <div class="action-item">
                <svg viewBox="0 0 24 24"><path d="M16.5 3c-1.74 0-3.41.81-4.5 2.09C10.91 3.81 9.24 3 7.5 3 4.42 3 2 5.42 2 8.5c0 3.78 3.4 6.86 8.55 11.54L12 21.35l1.45-1.32C18.6 15.36 22 12.28 22 8.5 22 5.42 19.58 3 16.5 3zM12.1 18.55l-.1.1-.1-.1C7.14 14.24 4 11.39 4 8.5 4 6.5 5.5 5 7.5 5c1.54 0 3.04.99 3.57 2.36h1.87C13.46 5.99 14.96 5 16.5 5c2 0 3.5 1.5 3.5 3.5 0 2.89-3.14 5.74-7.9 10.05z"/></svg>
                0
            </div>
            <div class="action-item">
                <svg viewBox="0 0 24 24"><path d="M21.99 4c0-1.1-.89-2-2-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4-.01-18zM18 14H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z"/></svg>
                0
            </div>
            <div class="action-item">
                <svg viewBox="0 0 24 24"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm.5-13H11v6l5.25 3.15.75-1.23-4.5-2.67z"/></svg>
                ${timeStr}
            </div>
            <div class="more-btn">
                <svg viewBox="0 0 24 24"><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/></svg>
            </div>
        </div>
    `;

    const firstChild = diaryList.firstElementChild;
    if (firstChild && firstChild.style && firstChild.style.textAlign === 'center') {
        diaryList.innerHTML = '';
    }
    
    if (diaryList.firstChild) {
        diaryList.insertBefore(diaryItem, diaryList.firstChild);
    } else {
        diaryList.appendChild(diaryItem);
    }

    updateIcityMyDiaryList();
    
    saveIcityDiaryToDexie(diary.id, {
        content: diary.content,
        time: diary.time,
        roleName: roleName,
        wechatId: wechatId,
        avatarUrl: avatarUrl,
        isUserPublished: diary.isUserPublished ? 1 : 0,
        createdAt: new Date().toISOString(),
        accountId: window.icityCurrentAccountId || 0
    });
}

// ä¿å­˜å•ä¸ªæ—¥è®°åˆ°Dexie
async function saveIcityDiaryToDexie(diaryId, diaryData) {
    try {
        await icityDb.diaries.put({
            id: diaryId,
            accountId: window.icityCurrentAccountId || 0,
            ...diaryData
        });
    } catch (error) {
        console.error('ä¿å­˜æ—¥è®°åˆ°Dexieå¤±è´¥:', error);
    }
}

// ä»DexieåŠ è½½æ‰€æœ‰æ—¥è®°ï¼ˆæŒ‰accountIdè¿‡æ»¤ï¼‰
async function loadIcityDiariesFromStorage() {
    const diaryList = document.getElementById('icityDiaryList');
    if (!diaryList) return;
    
    const currentAccountId = window.icityCurrentAccountId || 0;
    
    try {
        const savedDiaries = localStorage.getItem('icity_diaries');
        if (savedDiaries) {
            try {
                const diaries = JSON.parse(savedDiaries);
                for (const diary of diaries) {
                    await icityDb.diaries.put({
                        id: diary.id,
                        content: diary.content,
                        time: diary.time,
                        roleName: diary.roleName || 'user',
                        wechatId: diary.wechatId || 'user',
                        avatarUrl: diary.avatarUrl || '',
                        isUserPublished: diary.isUserPublished ? 1 : 0,
                        createdAt: new Date().toISOString(),
                        accountId: currentAccountId
                    });
                }
                localStorage.removeItem('icity_diaries');
            } catch (e) {
                console.error('è¿ç§»localStorageæ•°æ®å¤±è´¥:', e);
            }
        }
        
        // æŒ‰ accountId è¿‡æ»¤æ—¥è®°
        let diaries;
        if (currentAccountId) {
            diaries = (await icityDb.diaries.where('accountId').equals(currentAccountId).reverse().toArray());
        } else {
            diaries = await icityDb.diaries.orderBy('id').reverse().toArray();
        }
        
        if (diaries.length === 0) {
            diaryList.innerHTML = '<div style="text-align: center; padding: 40px 20px; color: #999; font-size: 14px;">è¿˜æ²¡æœ‰æ—¥è®°<br><div style="font-size: 12px; margin-top: 8px; color: #ccc;">ç‚¹å‡»å³ä¸Šè§’å‘å¸ƒæˆ–ç”Ÿæˆæ—¥è®°</div></div>';
            return;
        }
        
        diaryList.innerHTML = '';
        
        diaries.sort((a, b) => {
            const timeA = new Date(a.time.replace(/-/g, '/'));
            const timeB = new Date(b.time.replace(/-/g, '/'));
            return timeB - timeA;
        });
        
        diaries.forEach(diary => {
            const diaryItem = document.createElement('div');
            diaryItem.className = 'diary-item';
            diaryItem.setAttribute('data-id', diary.id);
            diaryItem.setAttribute('data-content', diary.content);
            diaryItem.setAttribute('data-time', diary.time);
            diaryItem.setAttribute('data-role-name', diary.roleName || 'user');
            diaryItem.setAttribute('data-wechat-id', diary.wechatId || 'user');
            diaryItem.setAttribute('data-avatar-url', diary.avatarUrl || '');
            diaryItem.setAttribute('data-is-user-published', diary.isUserPublished ? 'true' : 'false');
            
            const date = new Date(diary.time.replace(/-/g, '/'));
            const monthNames = ['1æœˆ', '2æœˆ', '3æœˆ', '4æœˆ', '5æœˆ', '6æœˆ', '7æœˆ', '8æœˆ', '9æœˆ', '10æœˆ', '11æœˆ', '12æœˆ'];
            const weekDays = ['æ˜ŸæœŸæ—¥', 'æ˜ŸæœŸä¸€', 'æ˜ŸæœŸäºŒ', 'æ˜ŸæœŸä¸‰', 'æ˜ŸæœŸå››', 'æ˜ŸæœŸäº”', 'æ˜ŸæœŸå…­'];
            const dateStr = `${monthNames[date.getMonth()]}${date.getDate()}æ—¥ Â· ${weekDays[date.getDay()]} ${date.getFullYear()}`;
            const timeStr = diary.time.split(' ')[1] || '00:00';
            const preview = diary.content.replace(/\n/g, ' ').substring(0, 50) + (diary.content.length > 50 ? '...' : '');
            
            diaryItem.innerHTML = `
                <div class="diary-header">
                    <div class="user-info">
                        <img src="${diary.avatarUrl || ''}" alt="å¤´åƒ" class="avatar" style="border-radius: 50%; object-fit: cover;">
                        <div class="user-name-box">
                            <div class="user-name">${diary.roleName || 'user'}</div>
                            <div class="user-id">@${diary.wechatId || 'user'}</div>
                        </div>
                    </div>
                    <div class="diary-date">${dateStr}</div>
                </div>
                <div class="diary-content">${preview}</div>
                <div class="diary-actions">
                    <div class="action-item">
                        <svg viewBox="0 0 24 24"><path d="M16.5 3c-1.74 0-3.41.81-4.5 2.09C10.91 3.81 9.24 3 7.5 3 4.42 3 2 5.42 2 8.5c0 3.78 3.4 6.86 8.55 11.54L12 21.35l1.45-1.32C18.6 15.36 22 12.28 22 8.5 22 5.42 19.58 3 16.5 3zM12.1 18.55l-.1.1-.1-.1C7.14 14.24 4 11.39 4 8.5 4 6.5 5.5 5 7.5 5c1.54 0 3.04.99 3.57 2.36h1.87C13.46 5.99 14.96 5 16.5 5c2 0 3.5 1.5 3.5 3.5 0 2.89-3.14 5.74-7.9 10.05z"/></svg>
                        0
                    </div>
                    <div class="action-item">
                        <svg viewBox="0 0 24 24"><path d="M21.99 4c0-1.1-.89-2-2-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4-.01-18zM18 14H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z"/></svg>
                        0
                    </div>
                    <div class="action-item">
                        <svg viewBox="0 0 24 24"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm.5-13H11v6l5.25 3.15.75-1.23-4.5-2.67z"/></svg>
                        ${timeStr}
                    </div>
                    <div class="more-btn">
                        <svg viewBox="0 0 24 24"><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/></svg>
                    </div>
                </div>
            `;
            
            diaryList.appendChild(diaryItem);
        });
        
        updateIcityMyDiaryList();
    } catch (error) {
        console.error('åŠ è½½æ—¥è®°å¤±è´¥:', error);
        diaryList.innerHTML = '<div style="text-align: center; padding: 40px 20px; color: #999; font-size: 14px;">åŠ è½½æ—¥è®°å¤±è´¥</div>';
    }
}

// æ›´æ–°"æˆ‘çš„æ—¥è®°"åˆ—è¡¨
function updateIcityMyDiaryList() {
    const allDiaryItems = document.querySelectorAll('#icityContent .diary-item');
    const userPublishedItems = Array.from(allDiaryItems).filter(item => 
        item.dataset.isUserPublished === 'true'
    );
    const myDiaryList = document.querySelector('#icityMyPage .my-diary-list');
    
    if (!myDiaryList) return;
    
    myDiaryList.innerHTML = '';
    
    if (userPublishedItems.length === 0) {
        myDiaryList.innerHTML = '<div style="text-align: center; padding: 40px 20px; color: #999; font-size: 14px;">è¿˜æ²¡æœ‰æ—¥è®°<br><div style="font-size: 12px; margin-top: 8px; color: #ccc;">åœ¨å‘å¸ƒé¡µé¢å‘å¸ƒæ—¥è®°åæ‰ä¼šæ˜¾ç¤ºåœ¨è¿™é‡Œ</div></div>';
    } else {
        userPublishedItems.forEach(item => {
            const myDiaryItem = document.createElement('div');
            myDiaryItem.className = 'my-diary-item';
            myDiaryItem.setAttribute('data-id', item.dataset.id);
            myDiaryItem.setAttribute('data-content', item.dataset.content);
            myDiaryItem.setAttribute('data-time', item.dataset.time);
            myDiaryItem.setAttribute('data-role-name', item.dataset.roleName || '');
            myDiaryItem.setAttribute('data-wechat-id', item.dataset.wechatId || '');
            myDiaryItem.setAttribute('data-avatar-url', item.dataset.avatarUrl || '');
            
            const preview = item.dataset.content.replace(/\n/g, ' ').substring(0, 100) + (item.dataset.content.length > 100 ? '...' : '');
            
            myDiaryItem.innerHTML = `
                <div class="my-diary-time">${item.dataset.time}</div>
                <div class="my-diary-content">${preview}</div>
            `;
            
            myDiaryList.appendChild(myDiaryItem);
        });
    }

    const statElement = document.querySelector('#icityMyPage .my-diary-stat');
    if (statElement) {
        statElement.textContent = `æˆ‘çš„æ—¥è®°ï¼ˆ${userPublishedItems.length}ç¯‡ï¼‰`;
    }
}

// ==================== icity æ–‡æœ¬æ ‡æ³¨åŠŸèƒ½ ====================

function initIcityAnnotation() {
    const detailPage = document.getElementById('icityDetailPage');
    if (!detailPage) return;

    let selectionTimer = null;
    
    // ç»Ÿä¸€çš„é€‰åŒºæ£€æŸ¥å‡½æ•°
    function checkAndShowAnnotation() {
        if (selectionTimer) clearTimeout(selectionTimer);
        selectionTimer = setTimeout(() => {
            const selection = window.getSelection();
            if (!selection || selection.rangeCount === 0) return;
            const text = selection.toString().trim();
            if (text.length === 0) return;
            
            const detailContent = document.getElementById('icityDetailContent');
            if (!detailContent) return;
            
            const range = selection.getRangeAt(0);
            if (detailContent.contains(range.commonAncestorContainer) || 
                detailContent.contains(range.startContainer) ||
                detailContent.contains(selection.anchorNode)) {
                showAnnotationPopup(range, text);
            }
        }, 300);
    }
    
    // æ–¹å¼1ï¼šselectionchangeï¼ˆæ¡Œé¢æµè§ˆå™¨ï¼‰
    document.addEventListener('selectionchange', checkAndShowAnnotation);
    
    // æ–¹å¼2ï¼šmouseupï¼ˆé¼ æ ‡æ‹–é€‰é‡Šæ”¾æ—¶æ£€æŸ¥ï¼‰
    document.addEventListener('mouseup', function(e) {
        const detailContent = document.getElementById('icityDetailContent');
        if (detailContent && (detailContent.contains(e.target) || detailContent === e.target)) {
            setTimeout(checkAndShowAnnotation, 50);
        }
    });
    
    // æ–¹å¼3ï¼štouchendï¼ˆè§¦å±é•¿æŒ‰é€‰æ‹©é‡Šæ”¾æ—¶æ£€æŸ¥ï¼‰
    document.addEventListener('touchend', function(e) {
        const detailContent = document.getElementById('icityDetailContent');
        if (detailContent && (detailContent.contains(e.target) || detailContent === e.target)) {
            // è§¦å±é€‰æ‹©éœ€è¦æ›´é•¿çš„å»¶è¿Ÿï¼Œç­‰å¾…ç³»ç»Ÿé€‰åŒºç¨³å®š
            setTimeout(checkAndShowAnnotation, 500);
        }
    });
    
    // ç‚¹å‡»å¤–éƒ¨å…³é—­å¼¹çª—
    document.addEventListener('mousedown', function(e) {
        const popup = document.getElementById('icityAnnotationPopup');
        const detailContent = document.getElementById('icityDetailContent');
        if (popup && !popup.contains(e.target) && 
            !e.target.closest('.annotation-highlight') &&
            !(detailContent && detailContent.contains(e.target))) {
            closeAnnotationPopup();
        }
    });
    
    // è§¦å±ç‚¹å‡»å¤–éƒ¨å…³é—­å¼¹çª—
    document.addEventListener('touchstart', function(e) {
        const popup = document.getElementById('icityAnnotationPopup');
        if (!popup) return;
        if (popup.contains(e.target)) return;
        if (e.target.closest && e.target.closest('.annotation-highlight')) return;
        const detailContent = document.getElementById('icityDetailContent');
        if (detailContent && detailContent.contains(e.target)) return;
        closeAnnotationPopup();
    }, { passive: true });
}

function showAnnotationPopup(range, selectedText) {
    const oldPopup = document.getElementById('icityAnnotationPopup');
    if (oldPopup) oldPopup.remove();
    
    const popup = document.createElement('div');
    popup.id = 'icityAnnotationPopup';
    popup.className = 'icity-annotation-popup';
    popup.dataset.selectedText = selectedText;
    
    popup.innerHTML = `
        <div class="annotation-text">å·²é€‰æ‹©ï¼š${selectedText.length > 30 ? selectedText.substring(0, 30) + '...' : selectedText}</div>
        <textarea class="annotation-input" id="icityAnnotationInput" placeholder="æ·»åŠ æ ‡æ³¨è¯„è®º..."></textarea>
        <div class="annotation-buttons">
            <button class="annotation-btn annotation-btn-cancel" onclick="closeAnnotationPopup()">å–æ¶ˆ</button>
            <button class="annotation-btn annotation-btn-save" onclick="saveIcityAnnotation()">ä¿å­˜</button>
        </div>
    `;
    
    document.body.appendChild(popup);
    
    let rect;
    if (range instanceof Range) {
        rect = range.getBoundingClientRect();
    } else if (range && range.target) {
        rect = range.target.getBoundingClientRect();
    } else {
        return;
    }

    popup.style.left = (rect.left + rect.width / 2 - 150) + 'px';
    popup.style.top = (rect.bottom + 10) + 'px';
    
    const popupRect = popup.getBoundingClientRect();
    if (popupRect.left < 10) popup.style.left = '10px';
    if (popupRect.right > window.innerWidth - 10) popup.style.left = (window.innerWidth - popupRect.width - 10) + 'px';
    
    if (popupRect.bottom > window.innerHeight - 10) {
        popup.style.top = (rect.top - popupRect.height - 10) + 'px';
    }
    
    setTimeout(() => {
        document.getElementById('icityAnnotationInput')?.focus();
    }, 100);
}

function closeAnnotationPopup() {
    const popup = document.getElementById('icityAnnotationPopup');
    if (popup) popup.remove();
    window.getSelection().removeAllRanges();
}

async function saveIcityAnnotation() {
    const input = document.getElementById('icityAnnotationInput');
    const comment = input?.value.trim() || '';
    const detailContentEl = document.getElementById('icityDetailContent');
    const diaryId = detailContentEl?.dataset.diaryId;
    const popup = document.getElementById('icityAnnotationPopup');
    
    if (!diaryId) {
        closeAnnotationPopup();
        return;
    }
    
    let selectedText = popup?.dataset.selectedText;
    
    if (!selectedText) {
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            selectedText = selection.toString().trim();
        }
    }
    
    if (!selectedText) {
        closeAnnotationPopup();
        return;
    }
    
    showIcityGenerateStatus('æ­£åœ¨ä¿å­˜æ ‡æ³¨...', 'info');
    
    try {
        const annotations = await getIcityAnnotations(diaryId);
        const annotation = {
            id: Date.now(),
            text: selectedText,
            comment: comment,
            createdAt: new Date().toISOString(),
            isAI: false
        };
        
        annotations.push(annotation);
        await saveIcityAnnotations(diaryId, annotations);
        
        const originalContent = detailContentEl.dataset.originalContent || detailContentEl.textContent;
        await renderDiaryContentWithAnnotations(diaryId, originalContent);
        
        closeAnnotationPopup();
        showIcityGenerateStatus('æ ‡æ³¨å·²ä¿å­˜', 'success');
    } catch (error) {
        console.error('ä¿å­˜æ ‡æ³¨å¤±è´¥:', error);
        showIcityGenerateStatus('ä¿å­˜æ ‡æ³¨å¤±è´¥: ' + error.message, 'error');
        closeAnnotationPopup();
    }
}

// è·å–æ ‡æ³¨æ•°æ®ï¼ˆä»Dexieï¼‰- åŒæ—¶æŸ¥è¯¢æ•°å­—å’Œå­—ç¬¦ä¸²ç±»å‹çš„diaryId
async function getIcityAnnotations(diaryId) {
    try {
        const key = `icity_annotations_${diaryId}`;
        const numId = parseInt(diaryId);
        const strId = String(diaryId);
        
        const oldData = localStorage.getItem(key);
        if (oldData) {
            try {
                const annotations = JSON.parse(oldData);
                for (const ann of annotations) {
                    await icityDb.annotations.put({
                        id: ann.id,
                        diaryId: numId || strId,
                        text: ann.text,
                        comment: ann.comment || '',
                        createdAt: ann.createdAt || new Date().toISOString(),
                        accountId: window.icityCurrentAccountId || 0
                    });
                }
                localStorage.removeItem(key);
            } catch (e) {
                console.error('è¿ç§»æ ‡æ³¨æ•°æ®å¤±è´¥:', e);
            }
        }
        
        // åŒæ—¶æŸ¥æ•°å­—IDå’Œå­—ç¬¦ä¸²IDï¼Œè§£å†³ç±»å‹ä¸åŒ¹é…é—®é¢˜
        let annotations = [];
        try {
            const byNum = numId ? await icityDb.annotations.where('diaryId').equals(numId).toArray() : [];
            const byStr = await icityDb.annotations.where('diaryId').equals(strId).toArray();
            // åˆå¹¶å»é‡
            const idSet = new Set();
            for (const ann of [...byNum, ...byStr]) {
                if (!idSet.has(ann.id)) {
                    idSet.add(ann.id);
                    annotations.push(ann);
                }
            }
        } catch (e) {
            annotations = await icityDb.annotations.where('diaryId').equals(diaryId).toArray();
        }
        return annotations;
    } catch (error) {
        console.error('è·å–æ ‡æ³¨å¤±è´¥:', error);
        return [];
    }
}

// ä¿å­˜æ ‡æ³¨æ•°æ®ï¼ˆåˆ°Dexieï¼‰- ç»Ÿä¸€ä½¿ç”¨æ•°å­—ç±»å‹diaryId
async function saveIcityAnnotations(diaryId, annotations) {
    try {
        const numId = parseInt(diaryId);
        const strId = String(diaryId);
        // åˆ é™¤æ•°å­—å’Œå­—ç¬¦ä¸²ç±»å‹çš„æ—§æ ‡æ³¨
        await icityDb.annotations.where('diaryId').equals(numId || strId).delete();
        if (numId) {
            await icityDb.annotations.where('diaryId').equals(strId).delete();
        }
        for (const ann of annotations) {
            await icityDb.annotations.put({
                id: ann.id,
                diaryId: numId || diaryId,
                text: ann.text,
                comment: ann.comment || '',
                createdAt: ann.createdAt || new Date().toISOString(),
                isAI: ann.isAI || false,
                aiRole: ann.aiRole || '',
                isReply: ann.isReply || false,
                accountId: window.icityCurrentAccountId || 0
            });
        }
    } catch (error) {
        console.error('ä¿å­˜æ ‡æ³¨å¤±è´¥:', error);
    }
}

// æ¸²æŸ“å¸¦æ ‡æ³¨çš„æ—¥è®°å†…å®¹
async function renderDiaryContentWithAnnotations(diaryId, content) {
    const detailContentEl = document.getElementById('icityDetailContent');
    if (!detailContentEl) return;
    
    detailContentEl.dataset.diaryId = diaryId;
    detailContentEl.dataset.originalContent = content;
    
    const annotations = await getIcityAnnotations(diaryId);
    const annotationsArray = Array.isArray(annotations) ? annotations : [];
    
    if (annotationsArray.length === 0) {
        detailContentEl.textContent = content;
    } else {
        // åœ¨åŸå§‹çº¯æ–‡æœ¬ä¸Šå®šä½æ¯ä¸ªæ ‡æ³¨çš„ä½ç½®
        let segments = [];
        for (const ann of annotationsArray) {
            if (!ann.text) continue;
            const idx = content.indexOf(ann.text);
            if (idx !== -1) {
                segments.push({
                    start: idx,
                    end: idx + ann.text.length,
                    ann: ann
                });
            }
        }
        
        // æŒ‰ä½ç½®æ’åº
        segments.sort((a, b) => a.start - b.start);
        
        // å»é™¤é‡å çš„æ ‡æ³¨ï¼ˆä¿ç•™å…ˆå‡ºç°çš„ï¼‰
        let filtered = [];
        let lastEnd = 0;
        for (const seg of segments) {
            if (seg.start >= lastEnd) {
                filtered.push(seg);
                lastEnd = seg.end;
            }
        }
        
        // ä¸€æ¬¡æ€§æ„å»ºHTMLï¼Œä¸åšå¤šè½®å­—ç¬¦ä¸²æ›¿æ¢
        let html = '';
        let pos = 0;
        for (const seg of filtered) {
            // æ·»åŠ æ ‡æ³¨å‰çš„æ™®é€šæ–‡æœ¬
            if (seg.start > pos) {
                html += icityEscapeHtml(content.substring(pos, seg.start));
            }
            // æ·»åŠ é«˜äº®æ ‡æ³¨ï¼ˆç”¨ icityEscapeAttr è½¬ä¹‰å±æ€§å€¼ï¼Œé˜²æ­¢å¼•å·ç ´åHTMLï¼‰
            html += `<span class="annotation-highlight" data-annotation-id="${seg.ann.id}" title="${icityEscapeAttr(seg.ann.comment || 'æ— è¯„è®º')}">${icityEscapeHtml(seg.ann.text)}</span>`;
            pos = seg.end;
        }
        // æ·»åŠ æœ€åå‰©ä½™çš„æ–‡æœ¬
        if (pos < content.length) {
            html += icityEscapeHtml(content.substring(pos));
        }
        
        detailContentEl.innerHTML = html;
        
        detailContentEl.querySelectorAll('.annotation-highlight').forEach(highlight => {
            highlight.addEventListener('click', function(e) {
                e.stopPropagation();
                const annId = this.dataset.annotationId;
                const annotation = annotationsArray.find(a => a.id == annId);
                if (annotation) {
                    showIcityAnnotationTooltip(e, annotation);
                }
            });
        });
    }
    
    await updateIcityAnnotationList(diaryId);
}

// æ›´æ–°æ ‡æ³¨åˆ—è¡¨
async function updateIcityAnnotationList(diaryId) {
    const annotationList = document.getElementById('icityAnnotationList');
    if (!annotationList) return;
    
    const annotations = await getIcityAnnotations(diaryId);
    
    if (annotations.length === 0) {
        annotationList.style.display = 'none';
    } else {
        annotationList.style.display = 'block';
        annotationList.innerHTML = '';
        
        annotations.forEach(ann => {
            const item = document.createElement('div');
            item.className = 'icity-annotation-item';
            const roleTag = ann.isAI ? `<span style="color: #e67e22; font-size: 11px; font-weight: bold;">[${ann.aiRole || 'AI'}${ann.isReply ? ' å›å¤' : ' æ ‡æ³¨'}]</span> ` : '';
            item.innerHTML = `
                <div class="annotation-quote">"${icityEscapeHtml(ann.text)}"</div>
                <div class="annotation-comment">${roleTag}${icityEscapeHtml(ann.comment || 'æ— è¯„è®º')}</div>
                <div style="font-size: 11px; color: #999; margin-top: 6px;">${new Date(ann.createdAt).toLocaleString('zh-CN')}</div>
            `;
            annotationList.appendChild(item);
        });
    }
}

// æ˜¾ç¤ºæ ‡æ³¨æç¤º
function showIcityAnnotationTooltip(event, annotation) {
    const oldTooltip = document.getElementById('icityAnnotationTooltip');
    if (oldTooltip) oldTooltip.remove();
    
    const tooltip = document.createElement('div');
    tooltip.id = 'icityAnnotationTooltip';
    tooltip.className = 'icity-annotation-tooltip';
    tooltip.textContent = annotation.comment || 'æ— è¯„è®º';
    
    document.body.appendChild(tooltip);
    
    const rect = event.target.getBoundingClientRect();
    tooltip.style.left = (rect.left + rect.width / 2 - tooltip.offsetWidth / 2) + 'px';
    tooltip.style.top = (rect.top - tooltip.offsetHeight - 8) + 'px';
    
    setTimeout(() => {
        tooltip.remove();
    }, 3000);
}

// icity HTMLè½¬ä¹‰ï¼ˆä½¿ç”¨ä¸åŒåç§°é¿å…å†²çªï¼‰
function icityEscapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// è½¬ä¹‰HTMLå±æ€§å€¼ï¼ˆåŒ…æ‹¬å¼•å·ï¼‰
function icityEscapeAttr(text) {
    return String(text || '').replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

// æš´éœ² icity å…¨å±€å‡½æ•°
window.openIcityApp = openIcityApp;
window.closeIcityApp = closeIcityApp;
window.exitIcityToSelect = exitIcityToSelect;
window.openIcityRoleModal = openIcityRoleModal;
window.closeIcityRoleModal = closeIcityRoleModal;
window.openIcityEditProfileModal = openIcityEditProfileModal;
window.closeIcityEditProfileModal = closeIcityEditProfileModal;
window.saveIcityProfile = saveIcityProfile;
window.closeAnnotationPopup = closeAnnotationPopup;
window.saveIcityAnnotation = saveIcityAnnotation;
